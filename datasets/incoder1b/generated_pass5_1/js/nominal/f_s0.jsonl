{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "gc": "<|endoftext|>/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const len = numbers.length;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n"}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "gc": "<|endoftext|>/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  const paren_group_strings = [];\n  paren_groups.forEach((group) => {\n    const paren_group_string = '';\n    group.forEach((char) => {\n      if (char === ')') {\n        paren_group_string += ')';\n      } else {\n        paren_group_string += char;\n      }\n    });\n    paren_group_strings.push(paren_group_string);\n  });\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return the string that has the\n  smallest number of parentheses within it.\n  >>> smallestParens('( ) (( )) (( )( ))')\n  '()'\n  */\nconst smallestParens = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  let paren_group_string = '';\n  let smallest_paren_count = 0;\n  paren_groups.forEach((group) => {\n    const paren_group_string = '';\n    group.forEach((char) => {\n      if (char === ')') {\n        paren_group_string += ')';\n      } else {\n        paren_group_string += char;\n      }\n    });\n    if (paren_group_string!== '') {\n      smallest_paren_count = Math.min(smallest_paren_count, paren_group_string.length);\n    }\n    paren_group_string += ')';\n  });\n  return paren_group_string.substring(0, smallest_paren_count);\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return the string that has the\n  largest number of parentheses within it.\n  >>> largestParens('( ) (( )) (( )( ))')\n  '()'\n  */\nconst largestParens = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  let paren_group_string = '';\n  let largestParen_count = 0;\n  paren_groups.forEach((group) => {\n    const paren_group_string = '';\n    group.forEach((char) => {\n      if (char === ')') {\n        paren_group_string += ')';\n      } else {\n        paren_group_string += char;\n      }\n    });\n    if (paren_group_string!== '') {\n      largestParen_count = Math.max(largestParen_count, paren_group_string.length);\n    }\n    paren_group_string += ')';\n  });\n  return paren_group_string.substring(0, largestParen_count);\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return the string that has the\n  largest number of parentheses within it.\n  >>> largestParens('( ) (( )) (( )( ))')\n  '()'\n  */\nconst largestParensIgnoreSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  let paren_group_string = '';\n  let largestParen_count = 0;\n  paren_groups.forEach((group) => {\n    const paren_group_string = '';\n    group.forEach((char) => {\n      if (char === ')') {\n        paren_group_string += ')';\n      } else {\n        paren_group_string += char;\n      }\n    });\n    if (paren_group_string!== '') {\n      largestParen_count = Math.max(largestParen_count, paren_group_string.length);\n    }\n    paren_group_string += ')';\n  });\n  return paren_group_string.substring(0, largestParen_count);\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return the string that has the\n  smallest number of parentheses within it.\n  >>> smallestParensIgnoreSpaces('( ) (( )) (( )( ))')\n  '()'\n  */\nconst smallestParensIgnoreSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  let paren_group_string = '';\n  let smallest_paren_count = 0;\n  paren_groups.forEach((group) => {\n    const paren_group_string = '';\n    group.forEach((char) => {\n      if (char === ')') {\n        paren_group_string += ')';\n      } else {\n        paren_group_string += char;\n      }\n    });\n    if (paren_group_string!== '') {\n      smallest_paren_count = Math.min(smallest_paren_count, paren_group_string.length);\n    }\n    paren_group_string += ')';\n  });\n  return paren_group_string.substring(0, smallest_paren_count);\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return the string that has the\n  largest number of parentheses within it.\n  >>> largestParensIgnoreSpaces('( ) (( )) (( )( ))')\n  '()'\n  */\nconst largestParensIgnoreSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  let paren_group_string = '';\n  let largestParen_count = 0;\n  paren_groups.forEach((group) => {\n    const paren_group_string = '';\n    group.forEach((char) => {\n      if (char === ')') {\n        paren_group_string += ')';\n      } else {\n        paren_group_string += char;\n      }\n    });\n    if (paren_group_string!== '') {\n      largestParen_count = Math.max(largestParen_count, paren_group_string.length);\n    }\n    paren_group_string += ')';\n  });\n  return paren_group_string.substring(0, largestParen_count);\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return the string that has the\n  smallest number of parentheses within it.\n  >>> smallestParensIgnoreSpaces('( ) (( )) (( )( ))')\n  '()'\n  */\nconst smallestParensIgnoreSpacesIgnoreSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  let paren_group_string = '';\n  let smallest_paren_count = 0;\n  paren_groups.forEach((group) => {\n    const paren_group_string = '';\n    group.forEach((char) => {\n      if (char === ')') {\n        paren_group_string += ')';\n      } else {\n        paren_group_string += char;\n      }\n    });\n    if (paren_group_string!== '') {\n      smallest_paren_count = Math.min(smallest_paren_count, paren_group_string.length);\n    }\n    paren_group_string += ')';\n  });\n  return paren_group_string.substring(0, smallest_paren_count);\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return the string that has the\n  largest number of parentheses within it.\n  >>> largestParensIgnoreSpacesIgnoreSpaces('( ) (( )) (( )( ))')\n  '()'\n  */\nconst largestParensIgnoreSpacesIgnoreSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  let paren_group_string = '';\n  let largestParen_count = 0;\n  paren_groups.forEach((group) => {\n    const paren_group_string = '';\n    group.forEach((char) => {\n      if (char"}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "gc": "<|endoftext|>/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  const decimalPart = decimal + '';\n  return `${decimalPart}${remainder}`;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateInteger = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  const decimalPart = decimal + '';\n  return `${decimalPart}${remainder}`;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part and the decimal part.\n  >>> truncateNumber(3.5)\n  (3, 5)\n  */\nconst truncateDecimal = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  const decimalPart = decimal + '';\n  return `${decimalPart}${remainder}`;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part and the remainder of the number.\n  >>> truncateNumber(3.5)\n  (3, 5)\n  */\nconst truncateRemainder = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  const decimalPart = decimal + '';\n  return `${decimalPart}${remainder}`;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part and the remainder of the number as a string.\n  >>> truncateNumber(3.5)\n  (3, 5)\n  */\nconst truncateRemainderAsString = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  const decimalPart = decimal + '';\n  return `${decimalPart}${remainder}`;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part and the remainder of the number as a string.\n  >>> truncateNumber(3.5)\n  (3, 5)\n  */\nconst truncateRemainderAsStringWithDecimal = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  const decimalPart = decimal + '';\n  return `${decimalPart}${remainder}`;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part and the remainder of the number as a string.\n  >>> truncateNumber(3.5)\n  (3, 5)\n  */\nconst truncateRemainderAsStringWithDecimalAndRemainder = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  const decimalPart = decimal + '';\n  return `${decimalPart}${remainder}`;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part and the remainder of the number as a string.\n  >>> truncateNumber(3.5)\n  (3, 5)\n  */\nconst truncateRemainderAsStringWithDecimalAndRemainderAsString = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  const decimalPart = decimal + '';\n  return `${decimalPart}${remainder}`;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part and the remainder of the number as a string.\n  >>> truncateNumber(3.5)\n  (3, 5)\n  */\nconst truncateRemainderAsStringWithDecimalAndRemainderAsStringWithDecimal = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  const decimalPart = decimal + '';\n  return `${decimalPart}${remainder}`;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part and the remainder of the number as a string.\n  >>> truncateNumber(3.5)\n  (3, 5)\n  */\nconst truncateRemainderAsStringWithDecimalAndRemainderAsStringWithDecimalAndRemainder = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  const decimalPart = decimal + '';\n  return `${decimalPart}${remainder}`;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part and the remainder of the number as a string.\n  >>> truncateNumber(3.5)\n  (3, 5)\n  */\nconst truncateRemainderAsStringWithDecimalAndRemainderAsStringWithDecimalAndRemainderAsString = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  const decimalPart = decimal + '';\n  return `${decimalPart}${remainder}`;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part and the remainder of the number as a string.\n  >>> truncateNumber(3.5)\n  (3, 5)\n  */\nconst truncateRemainderAsStringWithDecimalAndRemainderAsStringWithDecimalAndRemainderAsStringWithDecimal = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  const decimalPart = decimal + '';\n  return `${decimalPart}${remainder}`;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part and the remainder of the number as a string.\n  >>> truncateNumber(3.5)\n  (3, 5)\n  */\nconst truncateRemainderAsStringWithDecimalAndRemainderAsStringWithDecimalAndRemainderAsStringWithDecimalAndRemainder = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  const decimalPart = decimal + '';\n  return `${decimalPart}${remainder}`;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part and the remainder of the number as a string.\n  >>> truncateNumber(3.5)\n  (3, 5)\n  */\nconst truncateRemainderAsStringWithDecimalAndRemainderAsStringWithDecimalAndRemainder"}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "gc": "<|endoftext|>/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 10, 10])\n  false\n  >>> belowZero([10, -10, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 10, 10])\n  false\n  >>> belowZero([10, -10, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 10, 10])\n  false\n  >>> belowZero([10, -10, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 10, 10])\n  false\n  >>> belowZero([10, -10, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 10, 10])\n  false\n  >>> belowZero([10, -10, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 10, 10])\n  false\n  >>> belowZero([10, -10, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 10, 10])\n  false\n  >>> belowZero([10, -10, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 10, 10])\n  false\n  >>> belowZero([10, -10, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 10, 10])\n  false\n  >>> belowZero([10, -10, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 10, 10])\n  false\n  >>> belowZero([10, -10, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 10, 10])\n  false\n  >>> belowZero([10, -10, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([10, 10, 10])\n  false\n  >>> belowZero([10, -10, 10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts "}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "gc": "<|endoftext|>/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => Math.pow(number - mean, 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/**\n  Given a list of numbers, calculate Mean Squared Deviation\n  around the mean of this dataset.\n  Mean Squared Deviation is the average squared difference between each\n  element and a centerpoint (mean in this case):\n  MSD = average | x - x_mean |^2\n  >>> meanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst meanSquaredDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => Math.pow(number - mean, 2));\n  return mean(deviations);\n};\n\n/**\n  Given a list of numbers, calculate Root Mean Squared Deviation\n  around the mean of this dataset.\n  Root Mean Squared Deviation is the square root of the mean squared deviation\n  around the mean of this dataset:\n  RMSE = sqrt(mean(deviations)) / mean(numbers)\n  >>> rootMeanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst rootMeanSquaredDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => Math.pow(number - mean, 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/**\n  Given a list of numbers, calculate Mean Squared Logarithmic Deviation\n  around the mean of this dataset.\n  Mean Squared Logarithmic Deviation is the average of the logarithms of\n  each element and a centerpoint (mean in this case):\n  MSL = average | log(x - x_mean)\n  >>> meanSquaredLogarithmicDeviation([1.0, 2.0, 3.0, 4.0])\n  2.718281828459045\n  */\nconst meanSquaredLogarithmicDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => Math.log(number - mean));\n  return mean(deviations);\n};\n\n/**\n  Given a list of numbers, calculate Mean Squared Exponential Deviation\n  around the mean of this dataset.\n  Mean Squared Exponential Deviation is the average of the exponentials of\n  each element and a centerpoint (mean in this case):\n  MSE = average | exp(x - x_mean)\n  >>> meanSquaredExponentialDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst meanSquaredExponentialDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => Math.exp(number - mean));\n  return mean(deviations);\n};\n\n/**\n  Given a list of numbers, calculate Mean Absolute Percentage Deviation\n  around the mean of this dataset.\n  Mean Absolute Percentage Deviation is the average of the percentages\n  of each element and a centerpoint (mean in this case):\n  MAP = average | x / x_mean\n  >>> meanAbsolutePercentageDeviation([1.0, 2.0, 3.0, 4.0])\n  0.5\n  */\nconst meanAbsolutePercentageDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => number / mean);\n  return mean(deviations);\n};\n\n/**\n  Given a list of numbers, calculate Mean Absolute Percentage Deviation\n  around the mean of this dataset.\n  Mean Absolute Percentage Deviation is the average of the percentages\n  of each element and a centerpoint (mean in this case):\n  MAP = average | x / x_mean\n  >>> meanAbsolutePercentageDeviation([1.0, 2.0, 3.0, 4.0])\n  0.5\n  */\nconst meanAbsolutePercentageDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => number / mean);\n  return mean(deviations);\n};\n\n/**\n  Given a list of numbers, calculate Mean Squared Percentage Deviation\n  around the mean of this dataset.\n  Mean Squared Percentage Deviation is the average of the percentages\n  of each element and a centerpoint (mean in this case):\n  MSD = average | x / x_mean^2\n  >>> meanSquaredPercentageDeviation([1.0, 2.0, 3.0, 4.0])\n  2.718281828459045\n  */\nconst meanSquaredPercentageDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => number / mean);\n  return mean(deviations);\n};\n\n/**\n  Given a list of numbers, calculate Root Mean Squared Percentage Deviation\n  around the mean of this dataset.\n  Root Mean Squared Percentage Deviation is the square root of the mean squared percentage\n  deviation around the mean of this dataset:\n  RMSE = sqrt(mean(deviations)) / mean(numbers)\n  >>> rootMeanSquaredPercentageDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst rootMeanSquaredPercentageDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => number / mean);\n  return Math.sqrt(mean(deviations));\n};\n\n/**\n  Given a list of numbers, calculate Mean Squared Logarithmic Percentage Deviation\n  around the mean of this dataset.\n  Mean Squared Logarithmic Percentage Deviation is the average of the logarithms\n  of each element and a centerpoint (mean in this case):\n  MSL = average | log(x / x_mean)\n  >>> meanSquaredLogarithmicPercentageDeviation([1.0, 2.0, 3.0, 4.0])\n  2.718281828459045\n  */\nconst meanSquaredLogarithmicPercentageDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => Math.log(number / mean));\n  return mean(deviations);\n};\n\n/**\n  Given a list of numbers, calculate Mean Squared Exponential Percentage Deviation\n  around the mean of this dataset.\n  Mean Squared Exponential Percentage Deviation is the average of the exponentials\n  of each element and a centerpoint (mean in this case):\n  MSE = average | exp(x / x_mean)\n  >>> meanSquaredExponentialPercentageDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst meanSquaredExponentialPercentageDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => Math.exp(number / mean));\n  return mean(deviations);\n};\n\n/**\n  Given a list of numbers, calculate Mean Absolute Percentage Deviation\n  around the mean of this dataset.\n  Mean Absolute Percentage Deviation is the average of the percentages\n  of each element and a centerpoint (mean in this case):\n  MAP = average | x / x_mean\n  >>> meanAbsolutePercentageDeviation([1.0, 2.0, 3.0, 4.0])\n  0.5\n  */\nconst meanAbsolutePercentageDeviation = (number"}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "gc": "<|endoftext|>/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  while (i < numbers.length) {\n    if (i === 0 || numbers[i - 1] + delimeter > numbers[i]) {\n      result.push(numbers[i])\n    }\n    result.push(numbers[i])\n    i++\n  }\n  return result\n}\n\n/**\n * Split a list into two lists based on a predicate.\n *\n * Splitting an empty list returns [[], []], while a non-empty list returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n *\n * Splitting a non-empty list returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n *\n * Splitting a list that contains a single element returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n *\n * Splitting a list that contains more than one element returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n */\nconst split = (list, predicate) => {\n  if (list === []) {\n    return [[], []]\n  }\n  if (list === null || list === undefined) {\n    return [list, list]\n  }\n  if (list.length === 1) {\n    return [list, list]\n  }\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (predicate(list[i])) {\n      result.push(list.slice(0, i))\n      list.splice(i, 1)\n      i++\n    } else {\n      result.push(list.slice(0, i))\n      list.splice(i, 1)\n    }\n  }\n  return result\n}\n\n/**\n * Split a list into two lists based on a predicate.\n *\n * Splitting an empty list returns [[], []], while a non-empty list returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n *\n * Splitting a non-empty list returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n *\n * Splitting a list that contains a single element returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n *\n * Splitting a list that contains more than one element returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n */\nconst splitWith = (list, predicate) => {\n  if (list === []) {\n    return [[], []]\n  }\n  if (list === null || list === undefined) {\n    return [list, list]\n  }\n  if (list.length === 1) {\n    return [list, list]\n  }\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (predicate(list[i])) {\n      result.push(list.slice(0, i))\n      list.splice(i, 1)\n      i++\n    } else {\n      result.push(list.slice(0, i))\n      list.splice(i, 1)\n    }\n  }\n  return result\n}\n\n/**\n * Split a list into two lists based on a predicate.\n *\n * Splitting an empty list returns [[], []], while a non-empty list returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n *\n * Splitting a non-empty list returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n *\n * Splitting a list that contains more than one element returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n */\nconst splitWithout = (list, predicate) => {\n  if (list === []) {\n    return [[], []]\n  }\n  if (list === null || list === undefined) {\n    return [list, list]\n  }\n  if (list.length === 1) {\n    return [list, list]\n  }\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (predicate(list[i])) {\n      result.push(list.slice(0, i))\n      list.splice(i, 1)\n      i++\n    } else {\n      result.push(list.slice(0, i))\n      list.splice(i, 1)\n    }\n  }\n  return result\n}\n\n/**\n * Split a list into two lists based on a predicate.\n *\n * Splitting an empty list returns [[], []], while a non-empty list returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n *\n * Splitting a non-empty list returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n *\n * Splitting a list that contains more than one element returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n */\nconst splitWithout = (list, predicate) => {\n  if (list === []) {\n    return [[], []]\n  }\n  if (list === null || list === undefined) {\n    return [list, list]\n  }\n  if (list.length === 1) {\n    return [list, list]\n  }\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (predicate(list[i])) {\n      result.push(list.slice(0, i))\n      list.splice(i, 1)\n      i++\n    } else {\n      result.push(list.slice(0, i))\n      list.splice(i, 1)\n    }\n  }\n  return result\n}\n\n/**\n * Split a list into two lists based on a predicate.\n *\n * Splitting an empty list returns [[], []], while a non-empty list returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n *\n * Splitting a non-empty list returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n *\n * Splitting a list that contains more than one element returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n */\nconst splitWithout = (list, predicate) => {\n  if (list === []) {\n    return [[], []]\n  }\n  if (list === null || list === undefined) {\n    return [list, list]\n  }\n  if (list.length === 1) {\n    return [list, list]\n  }\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (predicate(list[i])) {\n      result.push(list.slice(0, i))\n      list.splice(i, 1)\n      i++\n    } else {\n      result.push(list.slice(0, i))\n      list.splice(i, 1)\n    }\n  }\n  return result\n}\n\n/**\n * Split a list into two lists based on a predicate.\n *\n * Splitting an empty list returns [[], []], while a non-empty list returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n *\n * Splitting a non-empty list returns [[a], [b], [c]], where `a` and `b` are\n * the first two elements of the split list, and `c` is the third element.\n *\n * Splitting a list that contains more than one element returns [[a], [b"}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "gc": "<|endoftext|>/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_count = 0;\n  const paren_"}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  return strings.filter(string =>!string.indexOf(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstringNot = (strings, substring) => {\n  return strings.filter(string =>!string.indexOf(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterByNotSubstringNot = (strings, substring) => {\n  return strings.filter(string =>!string.indexOf(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstringNotContains = (strings, substring) => {\n  return strings.filter(string =>!string.indexOf(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterByNotSubstringNotContains = (strings, substring) => {\n  return strings.filter(string =>!string.indexOf(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstringNotContainsOnly = (strings, substring) => {\n  return strings.filter(string =>!string.indexOf(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterByNotSubstringNotContainsOnly = (strings, substring) => {\n  return strings.filter(string =>!string.indexOf(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstringContains = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring)!== -1);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterByNotSubstringContains = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring)!== -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstringContainsOnly = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterByNotSubstringContainsOnly = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstringContainsOnlyContains = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring)!== -1);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterByNotSubstringContainsOnlyContains = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring)!== -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstringContainsOnlyContainsOnly = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstringContainsOnlyContainsOnlyContainsOnly = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstringContainsOnlyContainsOnlyContainsOnlyContainsOnly = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstringContainsOnlyContainsOnlyContainsOnlyContainsOnlyContainsOnlyContainsOnly = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstringContainsOnlyContainsOnlyContainsOnlyContainsOnlyContainsOnlyContainsOnlyContainsOnlyContainsOnly = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filterBySubstringContainsOnlyContainsOnlyContainsOnlyContainsOnlyContainsOnlyContainsOnlyContainsOnlyContainsOnlyContainsOnlyContainsOnlyContainsOnlyContainsOnlyContainsOnlyContainsOnlyContains"}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  if (numbers.length === 0) {\n    return (0, 1);\n  }\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase = (str) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('');\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase2 = (str, char) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('')\n   .split(char)\n   .map(c => c.toLowerCase());\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase3 = (str, char) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('')\n   .split(char)\n   .map(c => c.toLowerCase());\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase4 = (str, char) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('')\n   .split(char)\n   .map(c => c.toLowerCase());\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase5 = (str, char) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('')\n   .split(char)\n   .map(c => c.toLowerCase());\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase6 = (str, char) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('')\n   .split(char)\n   .map(c => c.toLowerCase());\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase7 = (str, char) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('')\n   .split(char)\n   .map(c => c.toLowerCase());\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase8 = (str, char) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('')\n   .split(char)\n   .map(c => c.toLowerCase());\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase9 = (str, char) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('')\n   .split(char)\n   .map(c => c.toLowerCase());\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase10 = (str, char) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('')\n   .split(char)\n   .map(c => c.toLowerCase());\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase11 = (str, char) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('')\n   .split(char)\n   .map(c => c.toLowerCase());\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase12 = (str, char) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('')\n   .split(char)\n   .map(c => c.toLowerCase());\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase13 = (str, char) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('')\n   .split(char)\n   .map(c => c.toLowerCase());\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase14 = (str, char) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('')\n   .split(char)\n   .map(c => c.toLowerCase());\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase15 = (str, char) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('')\n   .split(char)\n   .map(c => c.toLowerCase());\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase16 = (str, char) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('')\n   .split(char)\n   .map(c => c.toLowerCase());\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase17 = (str, char) => {\n  return str\n   .split('')\n   .map(c => c.toUpperCase())\n   .join('')\n   .split(char)\n   .map(c => c.toLowerCase());\n};\n\n/* Given a string, return a tuple consisting of a lowercase and uppercase version of that string.\n  >>> toTitleCase('hello world')\n  ('Hello', 'HELLO')\n  */\nconst toTitleCase18"}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "gc": "<|endoftext|>/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let max = 0;\n  let maxIndex = 0;\n  let maxValue = 0;\n  let maxIndexValue = 0;\n  let maxIndexValue2 = 0;\n  let maxIndexValue3 = 0;\n  let maxIndexValue4 = 0;\n  let maxIndexValue5 = 0;\n  let maxIndexValue6 = 0;\n  let maxIndexValue7 = 0;\n  let maxIndexValue8 = 0;\n  let maxIndexValue9 = 0;\n  let maxIndexValue10 = 0;\n  let maxIndexValue11 = 0;\n  let maxIndexValue12 = 0;\n  let maxIndexValue13 = 0;\n  let maxIndexValue14 = 0;\n  let maxIndexValue15 = 0;\n  let maxIndexValue16 = 0;\n  let maxIndexValue17 = 0;\n  let maxIndexValue18 = 0;\n  let maxIndexValue19 = 0;\n  let maxIndexValue20 = 0;\n  let maxIndexValue21 = 0;\n  let maxIndexValue22 = 0;\n  let maxIndexValue23 = 0;\n  let maxIndexValue24 = 0;\n  let maxIndexValue25 = 0;\n  let maxIndexValue26 = 0;\n  let maxIndexValue27 = 0;\n  let maxIndexValue28 = 0;\n  let maxIndexValue29 = 0;\n  let maxIndexValue30 = 0;\n  let maxIndexValue31 = 0;\n  let maxIndexValue32 = 0;\n  let maxIndexValue33 = 0;\n  let maxIndexValue34 = 0;\n  let maxIndexValue35 = 0;\n  let maxIndexValue36 = 0;\n  let maxIndexValue37 = 0;\n  let maxIndexValue38 = 0;\n  let maxIndexValue39 = 0;\n  let maxIndexValue40 = 0;\n  let maxIndexValue41 = 0;\n  let maxIndexValue42 = 0;\n  let maxIndexValue43 = 0;\n  let maxIndexValue44 = 0;\n  let maxIndexValue45 = 0;\n  let maxIndexValue46 = 0;\n  let maxIndexValue47 = 0;\n  let maxIndexValue48 = 0;\n  let maxIndexValue49 = 0;\n  let maxIndexValue50 = 0;\n  let maxIndexValue51 = 0;\n  let maxIndexValue52 = 0;\n  let maxIndexValue53 = 0;\n  let maxIndexValue54 = 0;\n  let maxIndexValue55 = 0;\n  let maxIndexValue56 = 0;\n  let maxIndexValue57 = 0;\n  let maxIndexValue58 = 0;\n  let maxIndexValue59 = 0;\n  let maxIndexValue60 = 0;\n  let maxIndexValue61 = 0;\n  let maxIndexValue62 = 0;\n  let maxIndexValue63 = 0;\n  let maxIndexValue64 = 0;\n  let maxIndexValue65 = 0;\n  let maxIndexValue66 = 0;\n  let maxIndexValue67 = 0;\n  let maxIndexValue68 = 0;\n  let maxIndexValue69 = 0;\n  let maxIndexValue70 = 0;\n  let maxIndexValue71 = 0;\n  let maxIndexValue72 = 0;\n  let maxIndexValue73 = 0;\n  let maxIndexValue74 = 0;\n  let maxIndexValue75 = 0;\n  let maxIndexValue76 = 0;\n  let maxIndexValue77 = 0;\n  let maxIndexValue78 = 0;\n  let maxIndexValue79 = 0;\n  let maxIndexValue80 = 0;\n  let maxIndexValue81 = 0;\n  let maxIndexValue82 = 0;\n  let maxIndexValue83 = 0;\n  let maxIndexValue84 = 0;\n  let maxIndexValue85 = 0;\n  let maxIndexValue86 = 0;\n  let maxIndexValue87 = 0;\n  let maxIndexValue88 = 0;\n  let maxIndexValue89 = 0;\n  let maxIndexValue90 = 0;\n  let maxIndexValue91 = 0;\n  let maxIndexValue92 = 0;\n  let maxIndexValue93 = 0;\n  let maxIndexValue94 = 0;\n  let maxIndexValue95 = 0;\n  let maxIndexValue96 = 0;\n  let maxIndexValue97 = 0;\n  let maxIndexValue98 = 0;\n  let maxIndexValue99 = 0;\n  let maxIndexValue100 = 0;\n  let maxIndexValue101 = 0;\n  let maxIndexValue102 = 0;\n  let maxIndexValue103 = 0;\n  let maxIndexValue104 = 0;\n  let maxIndexValue105 = 0;\n  let maxIndexValue106 = 0;\n  let maxIndexValue107 = 0;\n  let maxIndexValue108 = 0;\n  let maxIndexValue109 = 0;\n  let maxIndexValue110 = 0;\n  let maxIndexValue111 = 0;\n  let maxIndexValue112 = 0;\n  let maxIndexValue113 = 0;\n  let maxIndexValue114 = 0;\n  let maxIndexValue115 = 0;\n  let maxIndexValue116 = 0;\n  let maxIndexValue117 = 0;\n  let maxIndexValue118 = 0;\n  let maxIndexValue119 = 0;\n  let maxIndexValue120 = 0;\n  let maxIndexValue121 = 0;\n  let maxIndexValue122 = 0;\n  let maxIndexValue123 = 0;\n  let maxIndexValue124 = 0;\n  let maxIndexValue125 = 0;\n  let maxIndexValue126 = 0;\n  let maxIndexValue127 = 0;\n  let maxIndexValue128 = 0;\n  let maxIndexValue129 = 0;\n  let maxIndexValue130 = 0;\n  let maxIndexValue131 = 0;\n  let maxIndexValue132 = 0;\n  let maxIndexValue133 = 0;\n  let maxIndexValue134 = 0;\n  let maxIndexValue135 = 0;\n  let maxIndexValue136 = 0;\n  let maxIndexValue137 = 0;\n  let maxIndexValue138 = 0;\n  let maxIndexValue139 = 0;\n  let maxIndexValue140 = 0;\n  let maxIndexValue141 = 0;\n  let maxIndexValue142 = 0;\n  let maxIndexValue143 = 0;\n  let maxIndexValue144 = 0;\n  let maxIndexValue145 = 0;\n  let maxIndexValue146 = 0;\n  let maxIndexValue147 = 0;\n  let maxIndexValue148 = 0;\n  let maxIndexValue149 = 0;\n  let maxIndexValue150 = 0;\n  let maxIndexValue151 = 0;\n  let maxIndexValue152 = 0;\n  let maxIndexValue153 = 0;\n  let maxIndexValue154 = 0;\n  let maxIndexValue155 = 0;\n  let maxIndexValue156 = 0;\n  let maxIndexValue157 = 0;\n  let maxIndexValue158 = 0;\n  let maxIndexValue159 = 0;\n  let maxIndexValue160 = 0;\n  let maxIndexValue161 = 0;\n  let maxIndexValue162 = 0;\n  let maxIndexValue163 = 0;\n  let maxIndexValue164 = 0;\n  let maxIndexValue165 = 0;\n  let maxIndexValue166 = 0;\n  let maxIndexValue167 = 0;\n  let maxIndexValue168 = 0;\n  let maxIndexValue169 = 0;\n  let maxIndexValue170 = 0;\n  let maxIndexValue171 = 0;\n  let maxIndexValue172 = 0;\n  let maxIndexValue173 = 0;\n  let maxIndexValue174 = 0;\n  let maxIndexValue175 = 0;\n  let maxIndexValue176 = 0;\n  let maxIndexValue177 = 0;\n  let maxIndexValue178 = 0;\n  let maxIndexValue179 = 0;\n  let maxIndexValue180 = 0;\n  let maxIndexValue181 = 0;\n  let maxIndexValue182 = 0;\n  let maxIndexValue183 = 0;\n  let maxIndexValue184 = 0;\n  let maxIndexValue185 = 0;\n  let maxIndexValue186 = 0;\n  let maxIndexValue187 = 0;\n  let maxIndexValue188 = 0;\n  let maxIndexValue189 = 0;\n  let maxIndexValue190 = 0;\n  let maxIndexValue191 = 0;\n  let maxIndexValue192 = 0;\n  let maxIndexValue193 = 0;\n  let maxIndexValue194 = 0;\n  let maxIndexValue195 = 0;\n  let maxIndexValue196 = 0;\n  let maxIndexValue197 = 0;\n  let maxIndexValue198 = 0;\n  let maxIndexValue199 = 0;\n  let maxIndexValue200 = 0;\n  let maxIndexValue201 = 0;\n  let maxIndexValue202 = 0;\n  let maxIndexValue203 = 0;\n  let maxIndexValue204 = 0;\n  let maxIndexValue205 = 0;\n  let maxIndexValue206 = 0;\n  let maxIndexValue207 = 0;\n  let maxIndexValue208 = 0;\n  let maxIndexValue209 = 0;\n  let maxIndexValue210 = 0;\n  let maxIndexValue211 = 0;\n  let "}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "gc": "<|endoftext|>/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let palindrome = '';\n  let palindromeLength = 0;\n  let palindromePrefix = string;\n  let palindromeSuffix = string;\n  let palindromePrefixLength = string.length;\n  let palindromeSuffixLength = string.length;\n\n  /* Find longest palindrome that begins with a supplied string */\n  while (true) {\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = palindromePrefix.length + palindromeSuffix.length;\n    }\n\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = palindromePrefix.length + palindromeSuffix.length;\n    }\n\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = palindromePrefix.length + palindromeSuffix.length;\n    }\n\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = palindromePrefix.length + palindromeSuffix.length;\n    }\n\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = palindromePrefix.length + palindromeSuffix.length;\n    }\n\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = palindromePrefix.length + palindromeSuffix.length;\n    }\n\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = palindromePrefix.length + palindromeSuffix.length;\n    }\n\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = palindromePrefix.length + palindromeSuffix.length;\n    }\n\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = palindromePrefix.length + palindromeSuffix.length;\n    }\n\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = palindromePrefix.length + palindromeSuffix.length;\n    }\n\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = palindromePrefix.length + palindromeSuffix.length;\n    }\n\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = palindromePrefix.length + palindromeSuffix.length;\n    }\n\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = palindromePrefix.length + palindromeSuffix.length;\n    }\n\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = palindromePrefix.length + palindromeSuffix.length;\n    }\n\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = palindromePrefix.length + palindromeSuffix.length;\n    }\n\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = palindromePrefix.length + palindromeSuffix.length;\n    }\n\n    /* Find longest palindrome that begins with a supplied string */\n    if (palindromeLength < palindromePrefixLength + palindromeSuffixLength) {\n      palindrome = palindromePrefix + palindromeSuffix;\n      palindromeLength = p"}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "gc": "<|endoftext|>/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary AND on two strings.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary OR on two strings.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary NOT on two strings.\n  >>> stringNot('010', '110')\n  '110'\n  */\nconst stringNot = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += ~a[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary AND on two strings.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary OR on two strings.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary NOT on two strings.\n  >>> stringNot('010', '110')\n  '110'\n  */\nconst stringNot = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += ~a[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary AND on two strings.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary OR on two strings.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary NOT on two strings.\n  >>> stringNot('010', '110')\n  '110'\n  */\nconst stringNot = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += ~a[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary AND on two strings.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary OR on two strings.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary NOT on two strings.\n  >>> stringNot('010', '110')\n  '110'\n  */\nconst stringNot = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += ~a[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary AND on two strings.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary OR on two strings.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary NOT on two strings.\n  >>> stringNot('010', '110')\n  '110'\n  */\nconst stringNot = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += ~a[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary AND on two strings.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary OR on two strings.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary NOT on two strings.\n  >>> stringNot('010', '110')\n  '110'\n  */\nconst stringNot = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += ~a[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/**\n  Perform binary AND on two strings.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAn"}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "gc": "<|endoftext|>/* Out of list of strings, return the longest one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  const longestString = strings[0]\n  let longestLength = 0\n  for (let i = 1; i < strings.length; i++) {\n    const currentString = strings[i]\n    if (currentString.length > longestLength) {\n      longestLength = currentString.length\n      longestString = currentString\n    }\n  }\n  return longestString\n}\n\n/**\n * Returns a new string with every character replaced by its ASCII representation\n * except the character '\\0' which gets replaced by its ASCII representation '\\\\0'\n * and all other characters are replaced by their ASCII representation '\\\\x{hex}'\n * where 'hex' is a valid hexadecimal digit.\n * >>> escape('abc')\n * 'abc'\n * >>> escape('\\\\x{abc}')\n * 'abc'\n * >>> escape('\\\\x{abc}\\\\0')\n * 'abc\\\\0'\n * >>> escape('\\\\x{abc}\\\\0\\\\0')\n * 'abc\\\\0\\\\0'\n * >>> escape('\\\\x{abc}\\\\0\\\\0\\\\0')\n * 'abc\\\\0\\\\0\\\\0'\n * >>> escape('\\\\x{abc}\\\\0\\\\0\\\\0\\\\0')\n * 'abc\\\\0\\\\0\\\\0\\\\0\\\\0'\n * >>> escape('\\\\x{abc}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0')\n * 'abc\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0'\n * >>> escape('\\\\x{abc}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0"}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest common divisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "gc": "<|endoftext|>/* Return a greatest common divisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a % b === 0) {\n    return a\n  }\n  return b\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomInt = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntBetween = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntBetweenInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntBetweenInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntBetweenInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntBetweenInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntBetweenInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntBetweenInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntBetweenInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntBetweenInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntBetweenInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntBetweenInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, 100)\n  2\n  >>> randomInt(1, 100)\n  3\n  */\nconst randomIntInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between min and max\n * >>> randomInt(1, 100)\n  1\n  >>> randomInt(1, "}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "gc": "<|endoftext|>/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix.slice(0, -1));\n    currentPrefix = currentPrefix.slice(-1);\n  }\n  return prefixes;\n};\n\n/**\n * Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffixes('abc')\n  ['c', 'ba', 'abc']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix.slice(0, -1));\n    currentSuffix = currentSuffix.slice(-1);\n  }\n  return suffixes;\n};\n\n/**\n * Return list of all common prefixes from shortest to longest of the input string\n  >>> allCommonPrefixes('abc')\n  ['a', 'b', 'c']\n  */\nconst allCommonPrefixes = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    if (prefixes.indexOf(currentPrefix) === -1) {\n      prefixes.push(currentPrefix);\n    }\n    currentPrefix = currentPrefix.slice(-1);\n  }\n  return prefixes;\n};\n\n/**\n * Return list of all common suffixes from shortest to longest of the input string\n  >>> allCommonSuffixes('abc')\n  ['c', 'ba', 'abc']\n  */\nconst allCommonSuffixes = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    if (suffixes.indexOf(currentSuffix) === -1) {\n      suffixes.push(currentSuffix);\n    }\n    currentSuffix = currentSuffix.slice(-1);\n  }\n  return suffixes;\n};\n\n/**\n * Return list of all common substrings from shortest to longest of the input string\n  >>> allCommonSubstrings('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allCommonSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    if (substrings.indexOf(currentSubstring) === -1) {\n      substrings.push(currentSubstring);\n    }\n    currentSubstring = currentSubstring.slice(-1);\n  }\n  return substrings;\n};\n\n/**\n * Return list of all common substrings from shortest to longest of the input string\n  >>> allCommonSubstrings('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allCommonSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    if (substrings.indexOf(currentSubstring) === -1) {\n      substrings.push(currentSubstring);\n    }\n    currentSubstring = currentSubstring.slice(-1);\n  }\n  return substrings;\n};\n\n/**\n * Return list of all common substrings from shortest to longest of the input string\n  >>> allCommonSubstrings('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allCommonSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    if (substrings.indexOf(currentSubstring) === -1) {\n      substrings.push(currentSubstring);\n    }\n    currentSubstring = currentSubstring.slice(-1);\n  }\n  return substrings;\n};\n\n/**\n * Return list of all common substrings from shortest to longest of the input string\n  >>> allCommonSubstrings('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allCommonSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    if (substrings.indexOf(currentSubstring) === -1) {\n      substrings.push(currentSubstring);\n    }\n    currentSubstring = currentSubstring.slice(-1);\n  }\n  return substrings;\n};\n\n/**\n * Return list of all common substrings from shortest to longest of the input string\n  >>> allCommonSubstrings('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allCommonSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    if (substrings.indexOf(currentSubstring) === -1) {\n      substrings.push(currentSubstring);\n    }\n    currentSubstring = currentSubstring.slice(-1);\n  }\n  return substrings;\n};\n\n/**\n * Return list of all common substrings from shortest to longest of the input string\n  >>> allCommonSubstrings('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allCommonSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    if (substrings.indexOf(currentSubstring) === -1) {\n      substrings.push(currentSubstring);\n    }\n    currentSubstring = currentSubstring.slice(-1);\n  }\n  return substrings;\n};\n\n/**\n * Return list of all common substrings from shortest to longest of the input string\n  >>> allCommonSubstrings('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allCommonSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    if (substrings.indexOf(currentSubstring) === -1) {\n      substrings.push(currentSubstring);\n    }\n    currentSubstring = currentSubstring.slice(-1);\n  }\n  return substrings;\n};\n\n/**\n * Return list of all common substrings from shortest to longest of the input string\n  >>> allCommonSubstrings('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allCommonSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    if (substrings.indexOf(currentSubstring) === -1) {\n      substrings.push(currentSubstring);\n    }\n    currentSubstring = currentSubstring.slice(-1);\n  }\n  return substrings;\n};\n\n/**\n * Return list of all common substrings from shortest to longest of the input string\n  >>> allCommonSubstrings('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allCommonSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    if (substrings.indexOf(currentSubstring) === -1) {\n      substrings.push(currentSubstring);\n    }\n    currentSubstring = currentSubstring.slice(-1);\n  }\n  return substrings;\n};\n\n/**\n * Return list of all common substrings from shortest to longest of the input string\n  >>> allCommonSubstrings('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allCommonSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    if (substrings.indexOf(currentSubstring) === -1) {\n      substrings.push(currentSubstring);\n    }\n    currentSubstring = currentSubstring.slice(-1);\n  }\n  return substrings;\n};\n\n/**\n * Return list of all common substrings from shortest to longest of the input string\n  >>> allCommonSubstrings('abc')\n  ['abc', 'ab', 'abc']\n  */\nconst allCommonSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    if (substrings.indexOf(currentSubstring) === -1) {\n      substrings.push(currentSubstring);\n    }\n    currentSubstring = currentSubstring.slice(-1);\n  }\n  return substrings;\n};\n\n/**\n * Return list of all common substrings from shortest to longest of the input string\n  >>> allCommonSubstrings('abc')\n  ['"}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "gc": "<|endoftext|>/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += '0';\n  }\n  return s;\n};\n\n/**\n  Returns a string containing a number formatted as a currency string.\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n  >>> formatCurrency(123.456, {symbol: '$', decimals: 2})\n  '$123.46'\n"}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "gc": "<|endoftext|>/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i).toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find the longest common subsequence (LCS) of a given string.\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  'abc'\n  >>> longestCommonSubsequence('abcde')\n  '"}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "gc": "<|endoftext|>/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const notes_lengths = notes.map((note) => parseInt(note, 10));\n  const notes_beats = notes_lengths.map((length) => length / 4);\n  return notes_beats;\n};\n\n// Given a string, return list of integers corresponding to how many beats does each not last.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n\n// >>> parseNotLast('o o|.| o| o|.|.|.| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n// >>> parseNotLast('o o|.| o| o|.|.|.|.| o o|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|."}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "gc": "<|endoftext|>/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let index = string.indexOf(substring);\n  while (index >= 0) {\n    count++;\n    index = string.indexOf(substring, index + substring.length);\n  }\n  return count;\n};\n\n/**\n * Returns a new string made from all the characters of the given string.\n * If the given string contains no characters, an empty string is returned.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n * If the given string contains multiple characters, each character is returned\n * in turn.\n"}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "gc": "<|endoftext|>/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numbersByLetter = numbers.split('').map((letter) => Number(letter));\n  const sortedNumbers = numbersByLetter.sort((a, b) => a - b);\n  return sortedNumbers.join('');\n};\n\n/**\n  Given a string, return a new string where all spaces are replaced with\n  underscores.\n  >>> replaceAll(' ', '_', 'Hello World')\n  'hello_world'\n  */\nconst replaceAll = (str, search, replace) => {\n  return str.replace(new RegExp(search, 'g'), replace);\n};\n\n/**\n  Given a string, return a new string where all spaces are replaced with\n  underscores and all non-alphanumeric characters are replaced with underscores.\n  >>> replaceAll(' ', '_', 'Hello World')\n  'hello_world'\n  */\nconst replaceAllNonAlphaNumeric = (str) => {\n  return str.replace(/[^a-zA-Z0-9]/g, '_');\n};\n\n/**\n  Given a string, return a new string where all spaces are replaced with\n  underscores and all non-alphanumeric characters are replaced with underscores\n  and all non-alphanumeric characters are replaced with underscores.\n  >>> replaceAllNonAlphaNumeric(' ', '_')\n  '_hello_world'\n  */\nconst replaceAllNonAlphaNumericAndSpaces = (str) => {\n  return str.replace(/[^a-zA-Z0-9 ]/g, '_');\n};\n\n/**\n  Given a string, return a new string where all spaces are replaced with\n  underscores and all non-alphanumeric characters are replaced with underscores\n  and all non-alphanumeric characters are replaced with underscores.\n  >>> replaceAllNonAlphaNumericAndSpaces(' ', '_')\n  '_hello_world'\n  */\nconst replaceAllNonAlphaNumericAndSpacesAndSpaces = (str) => {\n  return str.replace(/[^a-zA-Z0-9 ]/g, '_');\n};\n\n/**\n  Given a string, return a new string where all spaces are replaced with\n  underscores and all non-alphanumeric characters are replaced with underscores\n  and all non-alphanumeric characters are replaced with underscores.\n  >>> replaceAllNonAlphaNumericAndSpacesAndSpaces(' ', '_')\n  '_hello_world'\n  */\nconst replaceAllNonAlphaNumericAndSpacesAndSpacesAndSpaces = (str) => {\n  return str.replace(/[^a-zA-Z0-9 ]/g, '_');\n};\n\n/**\n  Given a string, return a new string where all spaces are replaced with\n  underscores and all non-alphanumeric characters are replaced with underscores\n  and all non-alphanumeric characters are replaced with underscores.\n  >>> replaceAllNonAlphaNumericAndSpacesAndSpacesAndSpaces(' ', '_')\n  '_hello_world'\n  */\nconst replaceAllNonAlphaNumericAndSpacesAndSpacesAndSpacesAndSpaces = (str) => {\n  return str.replace(/[^a-zA-Z0-9 ]/g, '_');\n};\n\n/**\n  Given a string, return a new string where all spaces are replaced with\n  underscores and all non-alphanumeric characters are replaced with underscores\n  and all non-alphanumeric characters are replaced with underscores.\n  >>> replaceAllNonAlphaNumericAndSpacesAndSpacesAndSpacesAndSpaces(' ', '_')\n  '_hello_world'\n  */\nconst replaceAllNonAlphaNumericAndSpacesAndSpacesAndSpacesAndSpacesAndSpaces = (str) => {\n  return str.replace(/[^a-zA-Z0-9 ]/g, '_');\n};\n\n/**\n  Given a string, return a new string where all spaces are replaced with\n  underscores and all non-alphanumeric characters are replaced with underscores\n  and all non-alphanumeric characters are replaced with underscores.\n  >>> replaceAllNonAlphaNumericAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpaces(' ', '_')\n  '_hello_world'\n  */\nconst replaceAllNonAlphaNumericAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpaces = (str) => {\n  return str.replace(/[^a-zA-Z0-9 ]/g, '_');\n};\n\n/**\n  Given a string, return a new string where all spaces are replaced with\n  underscores and all non-alphanumeric characters are replaced with underscores\n  and all non-alphanumeric characters are replaced with underscores.\n  >>> replaceAllNonAlphaNumericAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpaces"}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "gc": "<|endoftext|>/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const minDistance = Number.MAX_VALUE;\n  const closestElements = [];\n\n  numbers.forEach((number) => {\n    const distance = Math.abs(number - numbers[numbers.length - 1]);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElements = [number];\n    }\n  });\n\n  return closestElements;\n};\n\n/* Given a string, return all possible permutations of its characters, in order.\n  >>> permutationOf('hello')\n  ['hello', 'ello', 'ehllo', 'helllo', 'hEllo', 'eHllo', 'eHell', 'Hell', 'HeLl', 'HellO', 'HeLLo', 'HeLLo', 'HeLlO', 'HeLLoO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLlO', 'HeLl"}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "gc": "<|endoftext|>/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const [min, max] = numbers.reduce((acc, curr) => {\n    return [Math.min(acc, curr), Math.max(acc, curr)]\n  }, [Number.MAX_VALUE, Number.MIN_VALUE])\n  return numbers.map((n) => n * max / min)\n}\n\n/**\n * Given a list of numbers (of at least two elements), return a list of\n * numbers scaled so that each element in the list will be in the range [0, 1]\n * >>> scaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst scaleToUnit = (numbers) => {\n  const [min, max] = numbers.reduce((acc, curr) => {\n    return [Math.min(acc, curr), Math.max(acc, curr)]\n  }, [Number.MAX_VALUE, Number.MIN_VALUE])\n  return numbers.map((n) => n * max / min)\n}\n\n/**\n * Given a list of numbers (of at least two elements), return a list of\n * numbers scaled so that each element in the list will be in the range [0, 1]\n * >>> scaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst scaleToUnitWithRange = (numbers) => {\n  const [min, max] = numbers.reduce((acc, curr) => {\n    return [Math.min(acc, curr), Math.max(acc, curr)]\n  }, [Number.MAX_VALUE, Number.MIN_VALUE])\n  return numbers.map((n) => n * max / min + 0.5)\n}\n\n/**\n * Given a list of numbers (of at least two elements), return a list of\n * numbers scaled so that each element in the list will be in the range [0, 1]\n * >>> scaleToUnitWithRange([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst scaleToUnitWithRangeAndRange = (numbers) => {\n  const [min, max] = numbers.reduce((acc, curr) => {\n    return [Math.min(acc, curr), Math.max(acc, curr)]\n  }, [Number.MAX_VALUE, Number.MIN_VALUE])\n  return numbers.map((n) => n * max / min + 0.5)\n}\n\n/**\n * Given a list of numbers (of at least two elements), return a list of\n * numbers scaled so that each element in the list will be in the range [0, 1]\n * >>> scaleToUnitWithRangeAndRange([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst scaleToUnitWithRangeAndRangeAndRange = (numbers) => {\n  const [min, max] = numbers.reduce((acc, curr) => {\n    return [Math.min(acc, curr), Math.max(acc, curr)]\n  }, [Number.MAX_VALUE, Number.MIN_VALUE])\n  return numbers.map((n) => n * max / min + 0.5)\n}\n\n/**\n * Given a list of numbers (of at least two elements), return a list of\n * numbers scaled so that each element in the list will be in the range [0, 1]\n * >>> scaleToUnitWithRangeAndRangeAndRange([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst scaleToUnitWithRangeAndRangeAndRange = (numbers) => {\n  const [min, max] = numbers.reduce((acc, curr) => {\n    return [Math.min(acc, curr), Math.max(acc, curr)]\n  }, [Number.MAX_VALUE, Number.MIN_VALUE])\n  return numbers.map((n) => n * max / min + 0.5)\n}\n\n/**\n * Given a list of numbers (of at least two elements), return a list of\n * numbers scaled so that each element in the list will be in the range [0, 1]\n * >>> scaleToUnitWithRangeAndRangeAndRange([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst scaleToUnitWithRangeAndRangeAndRangeAndRange = (numbers) => {\n  const [min, max] = numbers.reduce((acc, curr) => {\n    return [Math.min(acc, curr), Math.max(acc, curr)]\n  }, [Number.MAX_VALUE, Number.MIN_VALUE])\n  return numbers.map((n) => n * max / min + 0.5)\n}\n\n/**\n * Given a list of numbers (of at least two elements), return a list of\n * numbers scaled so that each element in the list will be in the range [0, 1]\n * >>> scaleToUnitWithRangeAndRangeAndRangeAndRange([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst scaleToUnitWithRangeAndRangeAndRangeAndRangeAndRange = (numbers) => {\n  const [min, max] = numbers.reduce((acc, curr) => {\n    return [Math.min(acc, curr), Math.max(acc, curr)]\n  }, [Number.MAX_VALUE, Number.MIN_VALUE])\n  return numbers.map((n) => n * max / min + 0.5)\n}\n\n/**\n * Given a list of numbers (of at least two elements), return a list of\n * numbers scaled so that each element in the list will be in the range [0, 1]\n * >>> scaleToUnitWithRangeAndRangeAndRangeAndRangeAndRange([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst scaleToUnitWithRangeAndRangeAndRangeAndRangeAndRangeAndRange = (numbers) => {\n  const [min, max] = numbers.reduce((acc, curr) => {\n    return [Math.min(acc, curr), Math.max(acc, curr)]\n  }, [Number.MAX_VALUE, Number.MIN_VALUE])\n  return numbers.map((n) => n * max / min + 0.5)\n}\n\n/**\n * Given a list of numbers (of at least two elements), return a list of\n * numbers scaled so that each element in the list will be in the range [0, 1]\n * >>> scaleToUnitWithRangeAndRangeAndRangeAndRangeAndRangeAndRange([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst scaleToUnitWithRangeAndRangeAndRangeAndRangeAndRangeAndRangeAndRange = (numbers) => {\n  const [min, max] = numbers.reduce((acc, curr) => {\n    return [Math.min(acc, curr), Math.max(acc, curr)]\n  }, [Number.MAX_VALUE, Number.MIN_VALUE])\n  return numbers.map((n) => n * max / min + 0.5)\n}\n\n/**\n * Given a list of numbers (of at least two elements), return a list of\n * numbers scaled so that each element in the list will be in the range [0, 1]\n * >>> scaleToUnitWithRangeAndRangeAndRangeAndRangeAndRangeAndRangeAndRange([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst scaleToUnitWithRangeAndRangeAndRangeAndRangeAndRangeAndRangeAndRangeAndRange = (numbers) => {\n  const [min, max] = numbers.reduce((acc, curr) => {\n    return [Math.min(acc, curr), Math.max(acc, curr)]\n  }, [Number.MAX_VALUE, Number.MIN_VALUE])\n  return numbers.map((n) => n * max / min + 0.5)\n}\n\n/**\n * Given a list of numbers (of at least two elements), return a list of\n * numbers scaled so that each element in the list will be in the range [0, 1]\n * >>> scaleToUnitWithRangeAndRangeAndRangeAndRangeAndRangeAndRangeAndRangeAndRange([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst scaleToUnitWithRangeAndRangeAndRangeAndRangeAndRangeAndRangeAndRangeAndRangeAndRange = (numbers) => {\n  const [min, max] = numbers.reduce((acc, curr) => {\n    return [Math.min(acc, curr), Math.max(acc, curr)]\n  }, [Number.MAX_VALUE, Number.MIN_VALUE])\n  return numbers.map((n) => n * max / min "}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "gc": "<|endoftext|>/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filter given list of any python values only for floats\n  >>> filterFloats(['a', 3.14, 5])\n  [5]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3.14]\n  */\nconst filterFloats = (values) => {\n  return values.filter(value => typeof value === 'number' && isFinite(value));\n};\n\n/**\n * Filter given list of any python values only for strings\n  >>> filterStrings(['a', 3.14, 5])\n  [5]\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterStrings = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given list of any python values only for booleans\n  >>> filterBooleans(['a', 3.14, 5])\n  [5]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean');\n};\n\n/**\n * Filter given list of any python values only for None\n  >>> filterNone([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterNone = (values) => {\n  return values.filter(value => value === null);\n};\n\n/**\n * Filter given list of any python values only for empty lists\n  >>> filterEmptyList([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyList = (values) => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty dictionaries\n  >>> filterEmptyDict([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyDict = (values) => {\n  return values.filter(value => value === {});\n};\n\n/**\n * Filter given list of any python values only for empty strings\n  >>> filterEmptyString([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyString = (values) => {\n  return values.filter(value => value === '');\n};\n\n/**\n * Filter given list of any python values only for empty arrays\n  >>> filterEmptyArray([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyArray = (values) => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty objects\n  >>> filterEmptyObject([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyObject = (values) => {\n  return values.filter(value => value === {});\n};\n\n/**\n * Filter given list of any python values only for empty functions\n  >>> filterEmptyFunction([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyFunction = (values) => {\n  return values.filter(value => value === Function);\n};\n\n/**\n * Filter given list of any python values only for empty classes\n  >>> filterEmptyClass([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyClass = (values) => {\n  return values.filter(value => value === Object);\n};\n\n/**\n * Filter given list of any python values only for empty numbers\n  >>> filterEmptyNumber([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyNumber = (values) => {\n  return values.filter(value => value === Number);\n};\n\n/**\n * Filter given list of any python values only for empty strings\n  >>> filterEmptyString(['a', 3.14, 5])\n  [5, 3.14, 1]\n  */\nconst filterEmptyString = (values) => {\n  return values.filter(value => value === '');\n};\n\n/**\n * Filter given list of any python values only for empty arrays\n  >>> filterEmptyArray([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyArray = (values) => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty objects\n  >>> filterEmptyObject([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyObject = (values) => {\n  return values.filter(value => value === {});\n};\n\n/**\n * Filter given list of any python values only for empty functions\n  >>> filterEmptyFunction([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyFunction = (values) => {\n  return values.filter(value => value === Function);\n};\n\n/**\n * Filter given list of any python values only for empty classes\n  >>> filterEmptyClass([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyClass = (values) => {\n  return values.filter(value => value === Object);\n};\n\n/**\n * Filter given list of any python values only for empty numbers\n  >>> filterEmptyNumber([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyNumber = (values) => {\n  return values.filter(value => value === Number);\n};\n\n/**\n * Filter given list of any python values only for empty strings\n  >>> filterEmptyString(['a', 3.14, 5])\n  [5, 3.14, 1]\n  */\nconst filterEmptyString = (values) => {\n  return values.filter(value => value === '');\n};\n\n/**\n * Filter given list of any python values only for empty arrays\n  >>> filterEmptyArray([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyArray = (values) => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty objects\n  >>> filterEmptyObject([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyObject = (values) => {\n  return values.filter(value => value === {});\n};\n\n/**\n * Filter given list of any python values only for empty functions\n  >>> filterEmptyFunction([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyFunction = (values) => {\n  return values.filter(value => value === Function);\n};\n\n/**\n * Filter given list of any python values only for empty classes\n  >>> filterEmptyClass([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyClass = (values) => {\n  return values.filter(value => value === Object);\n};\n\n/**\n * Filter given list of any python values only for empty numbers\n  >>> filterEmptyNumber([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc', {}, []]\n  */\nconst filterEmptyNumber = (values) => {\n  return values.filter(value => value === Number);\n};\n\n/**\n * Filter given list of any python values only for empty strings\n  >>> filterEmptyString(['a', 3.14, 5])\n  [5, 3.14, 1]\n  */\nconst filterEmptyString = (values) => {\n  return values.filter(value => value === '');\n};\n\n/**\n * Filter given list of any python values only for empty arrays\n  >>> filterEmptyArray([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, '"}
{"task_id": "JavaScript/23", "prompt": "/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "gc": "<|endoftext|>/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'b')\n  false\n  */\nconst startsWith = (string, prefix) => {\n  return string.indexOf(prefix) === 0\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'b')\n  false\n  */\nconst startsWithIgnoreCase = (string, prefix) => {\n  return string.indexOf(prefix) === 0 && string[0].toUpperCase() === prefix[0].toUpperCase()\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWithIgnoreCase = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1 && string[0].toUpperCase() === suffix[0].toUpperCase()\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWithIgnoreCase('abc', 'a')\n  true\n  >>> startsWithIgnoreCase('abc', 'b')\n  false\n  */\nconst startsWithIgnoreCaseIgnoreCase = (string, prefix) => {\n  return string.indexOf(prefix) === 0 && string[0].toUpperCase() === prefix[0].toUpperCase() && string[0].toLowerCase() === prefix[0].toLowerCase()\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWithIgnoreCase('abc', 'b')\n  true\n  >>> endsWithIgnoreCase('abc', 'a')\n  false\n  */\nconst endsWithIgnoreCaseIgnoreCase = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1 && string[0].toUpperCase() === suffix[0].toUpperCase() && string[0].toLowerCase() === suffix[0].toLowerCase()\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWithIgnoreCaseIgnoreCase('abc', 'a')\n  true\n  >>> startsWithIgnoreCaseIgnoreCase('abc', 'b')\n  false\n  */\nconst startsWithIgnoreCaseIgnoreCaseIgnoreCase = (string, prefix) => {\n  return string.indexOf(prefix) === 0 && string[0].toUpperCase() === prefix[0].toUpperCase() && string[0].toLowerCase() === prefix[0].toLowerCase() && string[0].toUpperCase() === prefix[1].toUpperCase()\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWithIgnoreCaseIgnoreCase('abc', 'b')\n  true\n  >>> endsWithIgnoreCaseIgnoreCase('abc', 'a')\n  false\n  */\nconst endsWithIgnoreCaseIgnoreCaseIgnoreCase = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1 && string[0].toUpperCase() === suffix[0].toUpperCase() && string[0].toLowerCase() === suffix[0].toLowerCase() && string[0].toUpperCase() === suffix[1].toUpperCase()\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWithIgnoreCaseIgnoreCaseIgnoreCase('abc', 'a')\n  true\n  >>> startsWithIgnoreCaseIgnoreCaseIgnoreCase('abc', 'b')\n  false\n  */\nconst startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (string, prefix) => {\n  return string.indexOf(prefix) === 0 && string[0].toUpperCase() === prefix[0].toUpperCase() && string[0].toLowerCase() === prefix[0].toLowerCase() && string[0].toUpperCase() === prefix[1].toUpperCase() && string[0].toLowerCase() === prefix[2].toLowerCase()\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'b')\n  true\n  >>> endsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'a')\n  false\n  */\nconst endsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1 && string[0].toUpperCase() === suffix[0].toUpperCase() && string[0].toLowerCase() === suffix[0].toLowerCase() && string[0].toUpperCase() === suffix[1].toUpperCase() && string[0].toLowerCase() === suffix[2].toLowerCase()\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'a')\n  true\n  >>> startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'b')\n  false\n  */\nconst startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (string, prefix) => {\n  return string.indexOf(prefix) === 0 && string[0].toUpperCase() === prefix[0].toUpperCase() && string[0].toLowerCase() === prefix[0].toLowerCase() && string[0].toUpperCase() === prefix[1].toUpperCase() && string[0].toLowerCase() === prefix[2].toLowerCase() && string[0].toUpperCase() === prefix[3].toLowerCase()\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'b')\n  true\n  >>> endsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'a')\n  false\n  */\nconst endsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1 && string[0].toUpperCase() === suffix[0].toUpperCase() && string[0].toLowerCase() === suffix[0].toLowerCase() && string[0].toUpperCase() === suffix[1].toUpperCase() && string[0].toLowerCase() === suffix[2].toLowerCase() && string[0].toUpperCase() === suffix[3].toLowerCase()\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'a')\n  true\n  >>> startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'b')\n  false\n  */\nconst startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (string, prefix) => {\n  return string.indexOf(prefix) === 0 && string[0].toUpperCase() === prefix[0].toUpperCase() && string[0].toLowerCase() === prefix[0].toLowerCase() && string[0].toUpperCase() === prefix[1].toUpperCase() && string[0].toLowerCase() === prefix[2].toLowerCase() && string[0].toUpperCase() === prefix[3].toLowerCase() && string[0].toLowerCase() === prefix[4].toLowerCase()\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'b')\n  true\n  >>> endsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'a')\n  false\n  */\nconst endsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1 && string[0].toUpperCase() === suffix[0].toUpperCase() && string[0].toLowerCase() === suffix[0].toLowerCase() && string[0].toUpperCase() === suffix[1].toUpperCase() && string[0].toLowerCase() === suffix[2].toLowerCase() && string[0].toUpperCase() === suffix[3].toLowerCase() && string[0].toLowerCase() === suffix[4].toLowerCase()\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'a')\n  true\n  >>> startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase('abc', 'b')\n  false\n  */\nconst startsWithIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCaseIgnoreCase = (string, prefix) => {\n  return string.indexOf(prefix) === 0 && string[0].toUpperCase() === prefix[0].toUpperCase() && string[0].toLowerCase() === prefix[0].toLowerCase() && string[0].toUpperCase() === prefix[1].toUpperCase() && string[0].toLowerCase() === prefix[2].toLowerCase"}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "gc": "<|endoftext|>/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor *= 10;\n  }\n  return divisor;\n};\n\n/**\n * Given a number, return true if it is a prime number, false otherwise.\n * Prime numbers are composite numbers, meaning they contain only positive integers greater than 1.\n * A prime number is a natural number that has no positive divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than 1 and itself.\n * A prime number is a natural number that has no divisors other than "}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "gc": "<|endoftext|>/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize2 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize3 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize4 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize5 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize6 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize7 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize8 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize9 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize10 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize11 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize12 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize13 = (n) => {\n  let factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor"}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "gc": "<|endoftext|>/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const seen = new Set();\n  return numbers.filter((number) => {\n    if (seen.has(number)) {\n      return false;\n    }\n    seen.add(number);\n    return true;\n  });\n};\n\n// Given a string, return a string where all characters have been replaced by the\n// corresponding ASCII character in the range [32, 126].\nconst replaceCharacters = (string) => {\n  const chars = string.split('');\n  let newString = '';\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char >= 32 && char <= 126) {\n      newString += String.fromCharCode(char);\n    }\n  }\n  return newString;\n};\n\n// Given a string, return a string where all characters have been replaced by the\n// corresponding ASCII character in the range [32, 126].\nconst replaceCharactersWithUnicode = (string) => {\n  const chars = string.split('');\n  let newString = '';\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char >= 32 && char <= 126) {\n      newString += String.fromCharCode(char);\n    }\n  }\n  return newString.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '');\n};\n\n// Given a string, return a string where all characters have been replaced by the\n// corresponding ASCII character in the range [32, 126].\nconst replaceCharactersWithUnicodeAndNewline = (string) => {\n  const chars = string.split('');\n  let newString = '';\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char >= 32 && char <= 126) {\n      newString += String.fromCharCode(char);\n    }\n  }\n  return newString.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n').replace(\n    /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n'\n  );\n};\n\n// Given a string, return a string where all characters have been replaced by the\n// corresponding ASCII character in the range [32, 126].\nconst replaceCharactersWithUnicodeAndNewlineAndNewline = (string) => {\n  const chars = string.split('');\n  let newString = '';\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char >= 32 && char <= 126) {\n      newString += String.fromCharCode(char);\n    }\n  }\n  return newString.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n').replace(\n    /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n'\n  ).replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n');\n};\n\n// Given a string, return a string where all characters have been replaced by the\n// corresponding ASCII character in the range [32, 126].\nconst replaceCharactersWithUnicodeAndNewlineAndNewlineAndNewline = (\n  string\n) => {\n  const chars = string.split('');\n  let newString = '';\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char >= 32 && char <= 126) {\n      newString += String.fromCharCode(char);\n    }\n  }\n  return newString.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n').replace(\n    /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n'\n  ).replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n').replace(\n    /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n'\n  );\n};\n\n// Given a string, return a string where all characters have been replaced by the\n// corresponding ASCII character in the range [32, 126].\nconst replaceCharactersWithUnicodeAndNewlineAndNewlineAndNewlineAndNewline = (\n  string\n) => {\n  const chars = string.split('');\n  let newString = '';\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char >= 32 && char <= 126) {\n      newString += String.fromCharCode(char);\n    }\n  }\n  return newString.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n').replace(\n    /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n'\n  ).replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n').replace(\n    /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n'\n  ).replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n');\n};\n\n// Given a string, return a string where all characters have been replaced by the\n// corresponding ASCII character in the range [32, 126].\nconst replaceCharactersWithUnicodeAndNewlineAndNewlineAndNewlineAndNewline = (\n  string\n) => {\n  const chars = string.split('');\n  let newString = '';\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char >= 32 && char <= 126) {\n      newString += String.fromCharCode(char);\n    }\n  }\n  return newString.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n').replace(\n    /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n'\n  ).replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n').replace(\n    /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n'\n  ).replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n').replace(\n    /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n'\n  );\n};\n\n// Given a string, return a string where all characters have been replaced by the\n// corresponding ASCII character in the range [32, 126].\nconst replaceCharactersWithUnicodeAndNewlineAndNewlineAndNewlineAndNewline = (\n  string\n) => {\n  const chars = string.split('');\n  let newString = '';\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char >= 32 && char <= 126) {\n      newString += String.fromCharCode(char);\n    }\n  }\n  return newString.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n').replace(\n    /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n'\n  ).replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n').replace(\n    /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n'\n  ).replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n').replace(\n    /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '\\n'\n  );\n};\n\n// Given a string, return a string where all characters have been replaced by the\n// corresponding ASCII character in the range [32, 126].\nconst replaceCharactersWithUnicodeAndNewlineAndNewlineAndNewlineAndNewlineAndNewline = (\n  string\n) => {\n  const chars = string.split('');\n  let newString = '';\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char >= 32 && char <= 126) {\n      newString += String.fromCharCode(char);\n    }\n  }\n  return newString.replace(/["}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "gc": "<|endoftext|>/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().split('')\n   .map(c => c.toUpperCase())\n   .join('');\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter('Hello')\n  'H'\n  */\nconst firstLetter = (string) => {\n  return string[0] === string[0].toLowerCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetter('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toLowerCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toUpperCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toUpperCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toUpperCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toUpperCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toUpperCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toUpperCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toUpperCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toUpperCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toUpperCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toUpperCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toUpperCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toUpperCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toUpperCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toUpperCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toUpperCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst firstLetterOr = (string) => {\n  return string[0] === string[0].toUpperCase()? string.substr(1) : string;\n};\n\n/* Given a string, return the first letter of the string if it is a lowercase letter, otherwise return the\n  first letter of the string if it is uppercase letter, otherwise return the first letter of the string.\n  >>> firstLetter(firstLetterOr('Hello'))\n  'H'\n  */\nconst "}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "gc": "<|endoftext|>/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, curr) => acc += curr, \"\");\n};\n\n/**\n * Convert string to camel case\n * >>> camelCase('hello_world')\n  'helloWorld'\n  */\nconst camelCase = (string) => {\n  return string.replace(/([A-Z])/g,'$1').replace(/_/g,'')\n   .replace(/^./, (_) => '')\n   .toUpperCase();\n};\n\n/**\n * Convert string to dash case\n * >>> dashCase('hello_world')\n  'hello-world'\n  */\nconst dashCase = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2')\n   .replace(/([A-Z])([A-Z])/g, '$1-$2')\n   .replace(/([a-z])([a-z])/g, '$1-$2')\n   .replace(/([A-Z])([A-Z])/g, '$1-$2')\n   .replace(/([a-z])([A-Z])/g, '$1-$2')\n   .replace(/([A-Z])([A-Z])/g, '$1-$2');\n};\n\n/**\n * Convert string to underscore case\n * >>> underscoreCase('hello_world')\n  'hello_world'\n  */\nconst underscoreCase = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([a-z])([a-z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([a-z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2');\n};\n\n/**\n * Convert string to pascal case\n * >>> pascalCase('hello_world')\n  'HelloWorld'\n  */\nconst pascalCase = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase();\n  });\n};\n\n/**\n * Convert string to snake case\n * >>> snakeCase('hello_world')\n  'helloWorld'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toLowerCase();\n  });\n};\n\n/**\n * Convert string to title-case string\n * >>> titleCase('hello_world')\n  'Hello World'\n  */\nconst titleCase = (string) => {\n  return string.replace(/\\w\\S*/g, function(txt) {\n    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n  });\n};\n\n/**\n * Convert string to upper-case string\n * >>> upperCase('hello_world')\n  'HELLO WORLD'\n  */\nconst upperCase = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase();\n  });\n};\n\n/**\n * Convert string to lower-case string\n * >>> lowerCase('hello_world')\n  'hello_world'\n  */\nconst lowerCase = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toLowerCase();\n  });\n};\n\n/**\n * Convert string to camel case with first letter capitalized\n * >>> camelCaseFirst('hello_world')\n  'HelloWorld'\n  */\nconst camelCaseFirst = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase();\n  });\n};\n\n/**\n * Convert string to dash case with first letter capitalized\n * >>> dashCaseFirst('hello_world')\n  'hello-world'\n  */\nconst dashCaseFirst = (string) => {\n  return string.replace(/([a-z])/g, function($0, $1) {\n    return $1.toUpperCase();\n  });\n};\n\n/**\n * Convert string to underscore case with first letter capitalized\n * >>> underscoreCaseFirst('hello_world')\n  'hello_world'\n  */\nconst underscoreCaseFirst = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toLowerCase();\n  });\n};\n\n/**\n * Convert string to pascal case with first letter capitalized\n * >>> pascalCaseFirst('hello_world')\n  'HelloWorld'\n  */\nconst pascalCaseFirst = (string) => {\n  return string.replace(/([a-z])/g, function($0, $1) {\n    return $1.toLowerCase();\n  });\n};\n\n/**\n * Convert string to snake case with first letter capitalized\n * >>> snakeCaseFirst('hello_world')\n  'hello_world'\n  */\nconst snakeCaseFirst = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toLowerCase();\n  });\n};\n\n/**\n * Convert string to title-case string with first letter capitalized\n * >>> titleCaseFirst('hello_world')\n  'Hello World'\n  */\nconst titleCaseFirst = (string) => {\n  return string.replace(/\\w\\S*/g, function(txt) {\n    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n  });\n};\n\n/**\n * Convert string to upper-case string with first letter capitalized\n * >>> upperCaseFirst('hello_world')\n  'HELLO WORLD'\n  */\nconst upperCaseFirst = (string) => {\n  return string.replace(/([a-z])/g, function($0, $1) {\n    return $1.toUpperCase();\n  });\n};\n\n/**\n * Convert string to lower-case string with first letter capitalized\n * >>> lowerCaseFirst('hello_world')\n  'hello_world'\n  */\nconst lowerCaseFirst = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toLowerCase();\n  });\n};\n\n/**\n * Convert string to camel case with first letter capitalized\n * >>> camelCaseFirst('hello_world')\n  'HelloWorld'\n  */\nconst camelCaseFirst = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toUpperCase();\n  });\n};\n\n/**\n * Convert string to dash case with first letter capitalized\n * >>> dashCaseFirst('hello_world')\n  'hello-world'\n  */\nconst dashCaseFirst = (string) => {\n  return string.replace(/([a-z])/g, function($0, $1) {\n    return $1.toUpperCase();\n  });\n};\n\n/**\n * Convert string to underscore case with first letter capitalized\n * >>> underscoreCaseFirst('hello_world')\n  'hello_world'\n  */\nconst underscoreCaseFirst = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toLowerCase();\n  });\n};\n\n/**\n * Convert string to pascal case with first letter capitalized\n * >>> pascalCaseFirst('hello_world')\n  'HelloWorld'\n  */\nconst pascalCaseFirst = (string) => {\n  return string.replace(/([a-z])/g, function($0, $1) {\n    return $1.toLowerCase();\n  });\n};\n\n/**\n * Convert string to snake case with first letter capitalized\n * >>> snakeCaseFirst('hello_world')\n  'hello_world'\n  */\nconst snakeCaseFirst = (string) => {\n  return string.replace(/([A-Z])/g, function($0, $1) {\n    return $1.toLowerCase();\n  });\n};\n\n/**\n * Convert string to title-case string with first letter capitalized\n * >>> titleCaseFirst('hello_world')\n  'Hello World'\n  */\nconst titleCaseFirst = (string) => {\n  return string.replace(/"}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only keeping those that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only keeping those that do not start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefixNot = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only keeping those that do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffixNot = (strings, suffix) => {\n  return strings.filter(string =>!string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only keeping those that do not start with a given prefix and end with a given suffix.\n  >>> filterByPrefixNot('abc', 'a')\n  []\n  >>> filterByPrefixNot('abc', 'bcd')\n  ['abc']\n  >>> filterByPrefixNot('abc', 'cde')\n  ['abc', 'cde']\n  >>> filterByPrefixNot('abc', 'array')\n  []\n  >>> filterByPrefixNot('abc', 'ab')\n  []\n  >>> filterByPrefixNot('abc', 'abd')\n  []\n  >>> filterByPrefixNot('abc', 'abe')\n  []\n  >>> filterByPrefixNot('abc', 'abf')\n  []\n  >>> filterByPrefixNot('abc', 'abg')\n  []\n  >>> filterByPrefixNot('abc', 'abh')\n  []\n  >>> filterByPrefixNot('abc', 'abi')\n  []\n  >>> filterByPrefixNot('abc', 'abj')\n  []\n  >>> filterByPrefixNot('abc', 'abk')\n  []\n  >>> filterByPrefixNot('abc', 'abl')\n  []\n  >>> filterByPrefixNot('abc', 'abm')\n  []\n  >>> filterByPrefixNot('abc', 'abn')\n  []\n  >>> filterByPrefixNot('abc', 'abo')\n  []\n  >>> filterByPrefixNot('abc', 'abp')\n  []\n  >>> filterByPrefixNot('abc', 'abq')\n  []\n  >>> filterByPrefixNot('abc', 'abr')\n  []\n  >>> filterByPrefixNot('abc', 'abs')\n  []\n  >>> filterByPrefixNot('abc', 'abt')\n  []\n  >>> filterByPrefixNot('abc', 'abu')\n  []\n  >>> filterByPrefixNot('abc', 'abv')\n  []\n  >>> filterByPrefixNot('abc', 'abw')\n  []\n  >>> filterByPrefixNot('abc', 'abx')\n  []\n  >>> filterByPrefixNot('abc', 'aby')\n  []\n  >>> filterByPrefixNot('abc', 'abz')\n  []\n  >>> filterByPrefixNot('abc', 'ac')\n  []\n  >>> filterByPrefixNot('abc', 'acb')\n  []\n  >>> filterByPrefixNot('abc', 'acc')\n  []\n  >>> filterByPrefixNot('abc', 'acd')\n  []\n  >>> filterByPrefixNot('abc', 'ace')\n  []\n  >>> filterByPrefixNot('abc', 'acf')\n  []\n  >>> filterByPrefixNot('abc', 'acg')\n  []\n  >>> filterByPrefixNot('abc', 'ach')\n  []\n  >>> filterByPrefixNot('abc', 'aci')\n  []\n  >>> filterByPrefixNot('abc', 'acj')\n  []\n  >>> filterByPrefixNot('abc', 'ack')\n  []\n  >>> filterByPrefixNot('abc', 'acl')\n  []\n  >>> filterByPrefixNot('abc', 'acm')\n  []\n  >>> filterByPrefixNot('abc', 'acn')\n  []\n  >>> filterByPrefixNot('abc', 'aco')\n  []\n  >>> filterByPrefixNot('abc', 'acp')\n  []\n  >>> filterByPrefixNot('abc', 'acq')\n  []\n  >>> filterByPrefixNot('abc', 'acr')\n  []\n  >>> filterByPrefixNot('abc', 'acs')\n  []\n  >>> filterByPrefixNot('abc', 'act')\n  []\n  >>> filterByPrefixNot('abc', 'acu')\n  []\n  >>> filterByPrefixNot('abc', 'acv')\n  []\n  >>> filterByPrefixNot('abc', 'acw')\n  []\n  >>> filterByPrefixNot('abc', 'acx')\n  []\n  >>> filterByPrefixNot('abc', 'acy')\n  []\n  >>> filterByPrefixNot('abc', 'acz')\n  []\n  >>> filterByPrefixNot('abc', 'ad')\n  []\n  >>> filterByPrefixNot('abc', 'adb')\n  []\n  >>> filterByPrefixNot('abc', 'adc')\n  []\n  >>> filterByPrefixNot('abc', 'ade')\n  []\n  >>> filterByPrefixNot('abc', 'adf')\n  []\n  >>> filterByPrefixNot('abc', 'adg')\n  []\n  >>> filterByPrefixNot('abc', 'adh')\n  []\n  >>> filterByPrefixNot('abc', 'adi')\n  []\n  >>> filterByPrefixNot('abc', 'adj')\n  []\n  >>> filterByPrefixNot('abc', 'adk')\n  []\n  >>> filterByPrefixNot('abc', 'adl')\n  []\n  >>> filterByPrefixNot('abc', 'adm')\n  []\n  >>> filterByPrefixNot('abc', 'adn')\n  []\n  >>> filterByPrefixNot('abc', 'ado')\n  []\n  >>> filterByPrefixNot('abc', 'adp')\n  []\n  >>> filterByPrefixNot('abc', 'adq')\n  []\n  >>> filterByPrefixNot('abc', 'adr')\n  []\n  >>> filterByPrefixNot('abc', 'ads')\n  []\n  >>> filterByPrefixNot('abc', 'adt')\n  []\n  >>> filterByPrefixNot('abc', 'adu')\n  []\n  >>> filterByPrefixNot('abc', 'adv')\n  []\n  >>> filterByPrefixNot('abc', 'adw')\n  []\n  >>> "}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "gc": "<|endoftext|>/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] >= 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only negative numbers in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only numbers in the list that are divisible by 5.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible5 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 5 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only numbers in the list that are divisible by 7.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible7 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 7 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only numbers in the list that are divisible by 9.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible9 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 9 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only numbers in the list that are divisible by 11.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible11 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 11 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only numbers in the list that are divisible by 13.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible13 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 13 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only numbers in the list that are divisible by 15.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible15 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 15 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only numbers in the list that are divisible by 17.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible17 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 17 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only numbers in the list that are divisible by 19.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible19 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 19 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only numbers in the list that are divisible by 23.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible23 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 23 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only numbers in the list that are divisible by 25.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible25 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 25 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only numbers in the list that are divisible by 29.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible29 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 29 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only numbers in the list that are divisible by 31.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible31 = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 31 === 0) {\n      result.push(l[i])\n    }\n  }\n  return result\n}\n\n/*Return only numbers in the list that are divisible by 35.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, "}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "gc": "<|endoftext|>/*Return true if a given number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Given a number, return its prime factors.\n  >>> factors(5)\n  [2, 3]\n  >>> factors(6)\n  []\n  >>> factors(7)\n  []\n  >>> factors(8)\n  []\n  >>> factors(9)\n  [2, 3]\n  >>> factors(10)\n  [2, 3]\n  >>> factors(11)\n  [2, 3]\n  >>> factors(12)\n  [2, 3, 5]\n  >>> factors(13)\n  [2, 3, 5]\n  >>> factors(14)\n  [2, 3, 5]\n  >>> factors(15)\n  [2, 3, 5]\n  >>> factors(16)\n  [2, 3, 5]\n  >>> factors(17)\n  [2, 3, 5]\n  >>> factors(18)\n  [2, 3, 5]\n  >>> factors(19)\n  [2, 3, 5]\n  >>> factors(20)\n  [2, 3, 5]\n  >>> factors(21)\n  [2, 3, 5]\n  >>> factors(22)\n  [2, 3, 5]\n  >>> factors(23)\n  [2, 3, 5]\n  >>> factors(24)\n  [2, 3, 5]\n  >>> factors(25)\n  [2, 3, 5]\n  >>> factors(26)\n  [2, 3, 5]\n  >>> factors(27)\n  [2, 3, 5]\n  >>> factors(28)\n  [2, 3, 5]\n  >>> factors(29)\n  [2, 3, 5]\n  >>> factors(30)\n  [2, 3, 5]\n  >>> factors(31)\n  [2, 3, 5]\n  >>> factors(32)\n  [2, 3, 5]\n  >>> factors(33)\n  [2, 3, 5]\n  >>> factors(34)\n  [2, 3, 5]\n  >>> factors(35)\n  [2, 3, 5]\n  >>> factors(36)\n  [2, 3, 5]\n  >>> factors(37)\n  [2, 3, 5]\n  >>> factors(38)\n  [2, 3, 5]\n  >>> factors(39)\n  [2, 3, 5]\n  >>> factors(40)\n  [2, 3, 5]\n  >>> factors(41)\n  [2, 3, 5]\n  >>> factors(42)\n  [2, 3, 5]\n  >>> factors(43)\n  [2, 3, 5]\n  >>> factors(44)\n  [2, 3, 5]\n  >>> factors(45)\n  [2, 3, 5]\n  >>> factors(46)\n  [2, 3, 5]\n  >>> factors(47)\n  [2, 3, 5]\n  >>> factors(48)\n  [2, 3, 5]\n  >>> factors(49)\n  [2, 3, 5]\n  >>> factors(50)\n  [2, 3, 5]\n  >>> factors(51)\n  [2, 3, 5]\n  >>> factors(52)\n  [2, 3, 5]\n  >>> factors(53)\n  [2, 3, 5]\n  >>> factors(54)\n  [2, 3, 5]\n  >>> factors(55)\n  [2, 3, 5]\n  >>> factors(56)\n  [2, 3, 5]\n  >>> factors(57)\n  [2, 3, 5]\n  >>> factors(58)\n  [2, 3, 5]\n  >>> factors(59)\n  [2, 3, 5]\n  >>> factors(60)\n  [2, 3, 5]\n  >>> factors(61)\n  [2, 3, 5]\n  >>> factors(62)\n  [2, 3, 5]\n  >>> factors(63)\n  [2, 3, 5]\n  >>> factors(64)\n  [2, 3, 5]\n  >>> factors(65)\n  [2, 3, 5]\n  >>> factors(66)\n  [2, 3, 5]\n  >>> factors(67)\n  [2, 3, 5]\n  >>> factors(68)\n  [2, 3, 5]\n  >>> factors(69)\n  [2, 3, 5]\n  >>> factors(70)\n  [2, 3, 5]\n  >>> factors(71)\n  [2, 3, 5]\n  >>> factors(72)\n  [2, 3, 5]\n  >>> factors(73)\n  [2, 3, 5]\n  >>> factors(74)\n  [2, 3, 5]\n  >>> factors(75)\n  [2, 3, 5]\n  >>> factors(76)\n  [2, 3, 5]\n  >>> factors(77)\n  [2, 3, 5]\n  >>> factors(78)\n  [2, 3, 5]\n  >>> factors(79)\n  [2, 3, 5]\n  >>> factors(80)\n  [2, 3, 5]\n  >>> factors(81)\n  [2, 3, 5]\n  >>> factors(82)\n  [2, 3, 5]\n  >>> factors(83)\n  [2, 3, 5]\n  >>> factors(84)\n  [2, 3, 5]\n  >>> factors(85)\n  [2, 3, 5]\n  >>> factors(86)\n  [2, 3, 5]\n  >>> factors(87)\n  [2, 3, 5]\n  >>> factors(88)\n  [2, 3, 5]\n  >>> factors(89)\n  [2, 3, 5]\n  >>> factors(90)\n  [2, 3, 5]\n  >>> factors(91)\n  [2, 3, 5]\n  >>> factors(92)\n  [2, 3, 5]\n  >>> factors(93)\n  [2, 3, 5]\n  >>> factors(94)\n  [2, 3, 5]\n  >>> factors(95)\n  [2, 3, 5]\n  >>> factors(96)\n  [2, 3, 5]\n  >>> factors(97)\n  [2, 3, 5]\n  >>> factors(98)\n  [2, 3, 5]\n  >>> factors(99)\n  [2, 3, 5]\n  >>> factors(100)\n  [2, 3, 5]\n  >>> factors(101)\n  [2, 3, 5]\n  >>> factors(102)\n  [2, 3, 5]\n  >>> factors(103)\n  [2, 3, 5]\n  >>> factors(104)\n  [2, 3, 5]\n  >>> factors(105)\n  [2, 3, 5]\n  >>> factors(106)\n  [2, 3, 5]\n  >>> factors(107)\n  [2, 3, 5]\n  >>> factors(108)\n  [2, 3, 5]\n  >>> factors(109)\n  [2, 3, 5]\n  >>> factors(110)\n  [2, 3, 5]\n  >>> factors(111)\n  [2, 3, 5]\n  >>> factors(112)\n  [2, 3, 5]\n  >>> factors(113)\n  [2, 3, 5]\n  >>> factors(114)\n  [2, 3, 5]\n  >>> factors(115)\n  [2, 3, 5]\n  >>> factors(116)\n  [2, 3, 5]\n  >>> factors(117)\n  [2, 3, 5]\n  >>> factors(118)\n  [2, 3, 5]\n  >>> factors(119)\n  [2, 3, 5]\n  >>> factors(120)\n  [2, 3, 5]\n  >>> factors(121)\n  [2, 3, 5]\n  >>> factors(122)\n  [2, 3, 5]\n  >>> factors(123)\n  [2, 3, 5]\n  >>> factors(124)\n  [2, 3, 5]\n  >>> factors(125)\n  [2, 3, 5]\n  >>> factors(126)\n  [2, 3, 5]\n  >>> factors(127)\n  [2, 3, 5]\n  >>> factors(128)\n  [2, 3, 5]\n  >>> factors(129)\n  [2, 3, 5]\n  >>> factors(130)\n  [2, 3, 5]\n  >>> factors(131)\n  [2, 3, 5]\n  >>> factors(132)\n  [2, 3, 5]\n  >>> factors(133)\n  ["}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let x = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let len = xs.length;\n  while (i < len) {\n    if (xs[i] === 0) {\n      x = xs[j];\n      j = i;\n      i = j + 1;\n      k = j;\n    } else {\n      i = i + 1;\n    }\n  }\n  return x;\n}\n\n/*\n  Given a polynomial and a point x, finds the polynomial coefficients\n  that make up the point x.\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-6, 11]), 2) # f(x) = 1 + 2x\n  [1, 2]\n  >>> round(findCoefficients([1, 2], [-"}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let l2 = l.slice();\n  let l3 = l2.slice();\n  let l4 = l3.slice();\n  let l5 = l4.slice();\n  let l6 = l5.slice();\n  let l7 = l6.slice();\n  let l8 = l7.slice();\n  let l9 = l8.slice();\n  let l10 = l9.slice();\n  let l11 = l10.slice();\n  let l12 = l11.slice();\n  let l13 = l12.slice();\n  let l14 = l13.slice();\n  let l15 = l14.slice();\n  let l16 = l15.slice();\n  let l17 = l16.slice();\n  let l18 = l17.slice();\n  let l19 = l18.slice();\n  let l20 = l19.slice();\n  let l21 = l20.slice();\n  let l22 = l21.slice();\n  let l23 = l22.slice();\n  let l24 = l23.slice();\n  let l25 = l24.slice();\n  let l26 = l25.slice();\n  let l27 = l26.slice();\n  let l28 = l27.slice();\n  let l29 = l28.slice();\n  let l30 = l29.slice();\n  let l31 = l30.slice();\n  let l32 = l31.slice();\n  let l33 = l32.slice();\n  let l34 = l33.slice();\n  let l35 = l34.slice();\n  let l36 = l35.slice();\n  let l37 = l36.slice();\n  let l38 = l37.slice();\n  let l39 = l38.slice();\n  let l40 = l39.slice();\n  let l41 = l40.slice();\n  let l42 = l41.slice();\n  let l43 = l42.slice();\n  let l44 = l43.slice();\n  let l45 = l44.slice();\n  let l46 = l45.slice();\n  let l47 = l46.slice();\n  let l48 = l47.slice();\n  let l49 = l48.slice();\n  let l50 = l49.slice();\n  let l51 = l50.slice();\n  let l52 = l51.slice();\n  let l53 = l52.slice();\n  let l54 = l53.slice();\n  let l55 = l54.slice();\n  let l56 = l55.slice();\n  let l57 = l56.slice();\n  let l58 = l57.slice();\n  let l59 = l58.slice();\n  let l60 = l59.slice();\n  let l61 = l60.slice();\n  let l62 = l61.slice();\n  let l63 = l62.slice();\n  let l64 = l63.slice();\n  let l65 = l64.slice();\n  let l66 = l65.slice();\n  let l67 = l66.slice();\n  let l68 = l67.slice();\n  let l69 = l68.slice();\n  let l70 = l69.slice();\n  let l71 = l70.slice();\n  let l72 = l71.slice();\n  let l73 = l72.slice();\n  let l74 = l73.slice();\n  let l75 = l74.slice();\n  let l76 = l75.slice();\n  let l77 = l76.slice();\n  let l78 = l77.slice();\n  let l79 = l78.slice();\n  let l80 = l79.slice();\n  let l81 = l80.slice();\n  let l82 = l81.slice();\n  let l83 = l82.slice();\n  let l84 = l83.slice();\n  let l85 = l84.slice();\n  let l86 = l85.slice();\n  let l87 = l86.slice();\n  let l88 = l87.slice();\n  let l89 = l88.slice();\n  let l90 = l89.slice();\n  let l91 = l90.slice();\n  let l92 = l91.slice();\n  let l93 = l92.slice();\n  let l94 = l93.slice();\n  let l95 = l94.slice();\n  let l96 = l95.slice();\n  let l97 = l96.slice();\n  let l98 = l97.slice();\n  let l99 = l98.slice();\n  let l100 = l99.slice();\n  let l101 = l100.slice();\n  let l102 = l101.slice();\n  let l103 = l102.slice();\n  let l104 = l103.slice();\n  let l105 = l104.slice();\n  let l106 = l105.slice();\n  let l107 = l106.slice();\n  let l108 = l107.slice();\n  let l109 = l108.slice();\n  let l110 = l109.slice();\n  let l111 = l110.slice();\n  let l112 = l111.slice();\n  let l113 = l112.slice();\n  let l114 = l113.slice();\n  let l115 = l114.slice();\n  let l116 = l115.slice();\n  let l117 = l116.slice();\n  let l118 = l117.slice();\n  let l119 = l118.slice();\n  let l120 = l119.slice();\n  let l121 = l120.slice();\n  let l122 = l121.slice();\n  let l123 = l122.slice();\n  let l124 = l123.slice();\n  let l125 = l124.slice();\n  let l126 = l125.slice();\n  let l127 = l126.slice();\n  let l128 = l127.slice();\n  let l129 = l128.slice();\n  let l130 = l129.slice();\n  let l131 = l130.slice();\n  let l132 = l131.slice();\n  let l133 = l132.slice();\n  let l134 = l133.slice();\n  let l135 = l134.slice();\n  let l136 = l135.slice();\n  let l137 = l136.slice();\n  let l138 = l137.slice();\n  let l139 = l138.slice();\n  let l140 = l139.slice();\n  let l141 = l140.slice();\n  let l142 = l141.slice();\n  let l143 = l142.slice();\n  let l144 = l143.slice();\n  let l145 = l144.slice();\n  let l146 = l145.slice();\n  let l147 = l146.slice();\n  let l148 = l147.slice();\n  let l149 = l148.slice();\n  let l150 = l149.slice();\n  let l151 = l150.slice();\n  let l15"}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "gc": "<|endoftext|>/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let seen = new Set()\n  return l.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true))\n}\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (key, l) => {\n  let seen = new Set()\n  return l.filter((v, i, a) => seen.has(v)? false : (seen.set(key, v), true))\n}\n\n/*Return sorted unique elements in a list\n  >>> uniqueBy(x => x.name, [\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jill', age: 20 },\n ...   { name: 'Jill', age: 20 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ...   { name: 'Jack', age: 25 },\n ..."}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "gc": "<|endoftext|>/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*Return minimum element in the list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst minElement = (l) => {\n  let min = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] < min) {\n      min = l[i];\n    }\n  }\n  return min;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list ignoring negative numbers.\n  >>> sumElementNegative([1, 2, 3])\n  6\n  >>> sumElementNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumElementNegative = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      sum += l[i];\n    }\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list ignoring negative numbers and ignoring zeros.\n  >>> sumElementNegativeZero([1, 2, 3])\n  6\n  >>> sumElementNegativeZero([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumElementNegativeZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      sum += l[i];\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) {\n      sum += 0;\n    }\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list ignoring negative numbers and ignoring zeros.\n  >>> sumElementZero([1, 2, 3])\n  6\n  >>> sumElementZero([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumElementZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) {\n      sum += 0;\n    }\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list ignoring negative numbers and ignoring zeros.\n  >>> sumElementZeroNegative([1, 2, 3])\n  6\n  >>> sumElementZeroNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumElementZeroNegative = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      sum += l[i];\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) {\n      sum += 0;\n    }\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list ignoring negative numbers and ignoring zeros.\n  >>> sumElementZeroNegativeZero([1, 2, 3])\n  6\n  >>> sumElementZeroNegativeZero([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumElementZeroNegativeZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      sum += l[i];\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) {\n      sum += 0;\n    }\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list ignoring negative numbers and ignoring zeros.\n  >>> sumElementZeroNegativeZeroNegative([1, 2, 3])\n  6\n  >>> sumElementZeroNegativeZeroNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumElementZeroNegativeZeroNegative = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      sum += l[i];\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) {\n      sum += 0;\n    }\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list ignoring negative numbers and ignoring zeros.\n  >>> sumElementZeroNegativeZeroNegativeZero([1, 2, 3])\n  6\n  >>> sumElementZeroNegativeZeroNegativeZero([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumElementZeroNegativeZeroNegativeZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      sum += l[i];\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) {\n      sum += 0;\n    }\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list ignoring negative numbers and ignoring zeros.\n  >>> sumElementZeroNegativeZeroNegativeZeroNegative([1, 2, 3])\n  6\n  >>> sumElementZeroNegativeZeroNegativeZeroNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumElementZeroNegativeZeroNegativeZeroNegative = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      sum += l[i];\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) {\n      sum += 0;\n    }\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list ignoring negative numbers and ignoring zeros.\n  >>> sumElementZeroNegativeZeroNegativeZeroNegativeZero([1, 2, 3])\n  6\n  >>> sumElementZeroNegativeZeroNegativeZeroNegativeZero([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumElementZeroNegativeZeroNegativeZeroNegativeZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      sum += l[i];\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) {\n      sum += 0;\n    }\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list ignoring negative numbers and ignoring zeros.\n  >>> sumElementZeroNegativeZeroNegativeZeroNegativeZeroNegative([1, 2, 3])\n  6\n  >>> sumElementZeroNegativeZeroNegativeZeroNegativeZeroNegativeZero([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumElementZeroNegativeZeroNegativeZeroNegativeZeroNegative = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      sum += l[i];\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) {\n      sum += 0;\n    }\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list ignoring negative numbers and ignoring zeros.\n  >>> sumElementZeroNegativeZeroNegativeZeroNegativeZeroNegativeZero([1, 2, 3])\n  6\n  >>> sumElementZeroNegativeZeroNegativeZeroNegativeZeroNegativeZero([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumElementZeroNegativeZeroNegativeZeroNegativeZeroNegativeZeroNegative = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      sum += l[i];\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) {\n      sum += 0;\n    }\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the "}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "gc": "<|endoftext|>/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = n; i >= 1; i--) {\n    if (n % i === 7 && i % 11 === 0 || n % i === 13 && i % 11 === 0)\n      count++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return true if n is a palindrome.\n  >>> isPalindrome(123)\n  true\n  >>> isPalindrome(456)\n  false\n  >>> isPalindrome(123)\n  false\n  >>> isPalindrome(123)\n  true\n  >>> isPalindrome(123)\n  true\n  >>> isPalindrome(123)\n  false\n  */\nconst isPalindrome = (n) => {\n  let reversed = n.toString().split('').reverse().join('');\n  return reversed === n.toString().split('').reverse().join('');\n};\n\n/*\n  Given a positive integer n, return true if n is a palindrome of length n.\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  */\nconst isPalindromeOfLength = (n, m) => {\n  let reversed = n.toString().split('').reverse().join('');\n  return reversed === n.toString().split('').reverse().join('');\n};\n\n/*\n  Given a positive integer n, return true if n is a palindrome of length n.\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  */\nconst isPalindromeOfLength = (n, m) => {\n  let reversed = n.toString().split('').reverse().join('');\n  return reversed === n.toString().split('').reverse().join('');\n};\n\n/*\n  Given a positive integer n, return true if n is a palindrome of length n.\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  */\nconst isPalindromeOfLength = (n, m) => {\n  let reversed = n.toString().split('').reverse().join('');\n  return reversed === n.toString().split('').reverse().join('');\n};\n\n/*\n  Given a positive integer n, return true if n is a palindrome of length n.\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  */\nconst isPalindromeOfLength = (n, m) => {\n  let reversed = n.toString().split('').reverse().join('');\n  return reversed === n.toString().split('').reverse().join('');\n};\n\n/*\n  Given a positive integer n, return true if n is a palindrome of length n.\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  */\nconst isPalindromeOfLength = (n, m) => {\n  let reversed = n.toString().split('').reverse().join('');\n  return reversed === n.toString().split('').reverse().join('');\n};\n\n/*\n  Given a positive integer n, return true if n is a palindrome of length n.\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  */\nconst isPalindromeOfLength = (n, m) => {\n  let reversed = n.toString().split('').reverse().join('');\n  return reversed === n.toString().split('').reverse().join('');\n};\n\n/*\n  Given a positive integer n, return true if n is a palindrome of length n.\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  */\nconst isPalindromeOfLength = (n, m) => {\n  let reversed = n.toString().split('').reverse().join('');\n  return reversed === n.toString().split('').reverse().join('');\n};\n\n/*\n  Given a positive integer n, return true if n is a palindrome of length n.\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  */\nconst isPalindromeOfLength = (n, m) => {\n  let reversed = n.toString().split('').reverse().join('');\n  return reversed === n.toString().split('').reverse().join('');\n};\n\n/*\n  Given a positive integer n, return true if n is a palindrome of length n.\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  true\n  >>> isPalindromeOfLength(3, 5)\n  false\n  */\nconst isPalindromeOfLength = (n, m) => {\n  let reversed = n.toString().split('').reverse().join('');\n  return reversed === n.toString().split('').reverse().join('');\n};\n\n/*\n  Given a positive integer n, return true if n is a palindrome of length n.\n  >>> isPalindromeOf"}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 3, 2, 5]\n  */\nconst sortOdd = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEvenOdd([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [3, 4, 2, 1]\n  */\nconst sortEvenOdd = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortOddEven([1, 2, 3])\n  [3, 2, 5, 1]\n  >>> sortOddEven([5, 6, 3, 4])\n  [4, 3, 5, 6]\n  */\nconst sortOddEven = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEvenOddEven([1, 2, 3])\n  [3, 2, 5, 1]\n  >>> sortEvenOddEven([5, 6, 3, 4])\n  [4, 3, 5, 6]\n  */\nconst sortEvenOddEven = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortOddOddEven([1, 2, 3])\n  [3, 2, 5, 1]\n  >>> sortOddOddEven([5, 6, 3, 4])\n  [4, 3, 5, 6]\n  */\nconst sortOddOddEven = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortEvenOddOddEven([1, 2, 3])\n  [3, 2, 5, 1]\n  >>> sortEvenOddOddEven([5, 6, 3, 4])\n  [4, 3, 5, 6]\n  */\nconst sortEvenOddOddEven = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortOddOddOddEven([1, 2, 3])\n  [3, 2, 5, 1]\n  >>> sortOddOddOddEven([5, 6, 3, 4])\n  [4, 3, 5, 6]\n  */\nconst sortOddOddOddEven = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortEvenOddOddOddEven([1, 2, 3])\n  [3, 2, 5, 1]\n  >>> sortEvenOddOddOddEven([5, 6, 3, 4])\n  [4, 3, 5, 6]\n  */\nconst sortEvenOddOddOddEven = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortOddOddOddOddEven([1, 2, 3])\n  [3, 2, 5, 1]\n  >>> sortOddOddOddOddEven([5, 6, 3, 4])\n  [4, 3, 5, 6]\n  */\nconst sortOddOddOddOddEven = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortEvenOddOddOddOddEven([1, 2, 3])\n  [3, 2, 5, 1]\n  >>> sortEvenOddOddOddOddEven([5, 6, 3, 4])\n  [4, 3, 5, 6]\n  */\nconst sortEvenOddOddOddOddEven = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortOddOddOddOddOddEven([1, 2, 3])\n  [3, 2, 5, 1]\n  >>> sortOddOddOddOddOddEven([5, 6, 3, 4])\n  [4, 3, 5, 6]\n  */\nconst sortOddOddOddOddOddEven = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indi"}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "gc": "<|endoftext|>/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7] + group[8]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7] + group[8] + group[9]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7] + group[8] + group[9] + group[10]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7] + group[8] + group[9] + group[10] + group[11]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroupGroupGroupGroupGroup = (s) => {\n"}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "gc": "<|endoftext|>/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let a = 1;\n  let b = 2;\n  let c = 2;\n  let d = 2;\n  let prime = 1;\n  while (b <= n) {\n    if (a % b === 0) {\n      prime = prime;\n    }\n    prime = prime * b;\n    a = b;\n    b = a + c;\n    c = d;\n    d = a + b;\n  }\n  return prime;\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib2 = (n) => {\n  let a = 1;\n  let b = 2;\n  let c = 2;\n  let d = 2;\n  let prime = 1;\n  while (b <= n) {\n    if (a % b === 0) {\n      prime = prime;\n    }\n    prime = prime * b;\n    a = b;\n    b = a + c;\n    c = d;\n    d = a + b;\n  }\n  return prime;\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib3 = (n) => {\n  let a = 1;\n  let b = 2;\n  let c = 2;\n  let d = 2;\n  let prime = 1;\n  while (b <= n) {\n    if (a % b === 0) {\n      prime = prime;\n    }\n    prime = prime * b;\n    a = b;\n    b = a + c;\n    c = d;\n    d = a + b;\n  }\n  return prime;\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib4 = (n) => {\n  let a = 1;\n  let b = 2;\n  let c = 2;\n  let d = 2;\n  let prime = 1;\n  while (b <= n) {\n    if (a % b === 0) {\n      prime = prime;\n    }\n    prime = prime * b;\n    a = b;\n    b = a + c;\n    c = d;\n    d = a + b;\n  }\n  return prime;\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib5 = (n) => {\n  let a = 1;\n  let b = 2;\n  let c = 2;\n  let d = 2;\n  let prime = 1;\n  while (b <= n) {\n    if (a % b === 0) {\n      prime = prime;\n    }\n    prime = prime * b;\n    a = b;\n    b = a + c;\n    c = d;\n    d = a + b;\n  }\n  return prime;\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib6 = (n) => {\n  let a = 1;\n  let b = 2;\n  let c = 2;\n  let d = 2;\n  let prime = 1;\n  while (b <= n) {\n    if (a % b === 0) {\n      prime = prime;\n    }\n    prime = prime * b;\n    a = b;\n    b = a + c;\n    c = d;\n    d = a + b;\n  }\n  return prime;\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib7 = (n) => {\n  let a = 1;\n  let b = 2;\n  let c = 2;\n  let d = 2;\n  let prime = 1;\n  while (b <= n) {\n    if (a % b === 0) {\n      prime = prime;\n    }\n    prime = prime * b;\n    a = b;\n    b = a + c;\n    c = d;\n    d = a + b;\n  }\n  return prime;\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib8 = (n) => {\n  let a = 1;\n  let b = 2;\n  let c = 2;\n  let d = 2;\n  let prime = 1;\n  while (b <= n) {\n    if (a % b === 0) {\n      prime = prime;\n    }\n    prime = prime * b;\n    a = b;\n    b = a + c;\n    c = d;\n    d = a + b;\n  }\n  return prime;\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib9 = (n) => {\n  let a = 1;\n  let b = 2;\n  let c = 2;\n  let d = 2;\n  let prime = 1;\n  while (b <= n) {\n    if (a % b === 0) {\n      prime = prime;\n    }\n    prime = prime * b;\n    a = b;\n    b = a + c;\n    c = d;\n    d = a + b;\n  }\n  return prime;\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib10 = (n) => {\n  let a = 1;\n  let b = 2;\n  let c = 2;\n  let d = 2;\n  let prime = 1;\n  while (b <= n) {\n    if (a % b === 0) {\n      prime = prime;\n    }\n    prime = prime * b;\n    a = b;\n    b = a + c;\n    c = d;\n    d = a + b;\n  }\n  return prime;\n};\n\n/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)"}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "gc": "<|endoftext|>/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\nmodule.exports = triplesSumToZero;\n\n},{}],4:[function(require,module,exports){\nconst { isInteger } = require('./utils');\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isEven = (n, m) => {\n  return n % m === 0;\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isOdd = (n) => {\n  return n % 2 === 1;\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isDivisible = (n, m) => {\n  return isEven(n, m) && isOdd(n);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isEvenOdd = (n) => {\n  return isEven(n) && isOdd(n);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isDivisibleOdd = (n) => {\n  return isEven(n) && isOdd(n);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isDivisibleEvenOdd = (n) => {\n  return isEven(n) && isOdd(n);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isEvenDivisible = (n, m) => {\n  return isEven(n) && isDivisible(n, m);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isOddDivisible = (n) => {\n  return isEven(n) && isDivisible(n);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isEvenDivisibleOdd = (n) => {\n  return isEven(n) && isDivisible(n);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isDivisibleEvenOdd = (n) => {\n  return isEven(n) && isDivisible(n);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isEvenDivisibleOdd = (n) => {\n  return isEven(n) && isDivisible(n);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isDivisibleEvenDivisible = (n, m) => {\n  return isEven(n) && isDivisible(n, m);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isOddDivisibleEvenDivisible = (n) => {\n  return isEven(n) && isDivisible(n, m);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isEvenDivisibleEvenDivisible = (n) => {\n  return isEven(n) && isDivisible(n, m);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isOddDivisibleEvenDivisible = (n) => {\n  return isEven(n) && isDivisible(n, m);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isEvenDivisibleEvenDivisible = (n) => {\n  return isEven(n) && isDivisible(n, m);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isOddDivisibleEvenDivisible = (n) => {\n  return isEven(n) && isDivisible(n, m);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isEvenDivisibleEvenDivisible = (n) => {\n  return isEven(n) && isDivisible(n, m);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isOddDivisibleEvenDivisible = (n) => {\n  return isEven(n) && isDivisible(n, m);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isEvenDivisibleOddDivisible = (n) => {\n  return isEven(n) && isDivisible(n, m);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isOddDivisibleOddDivisible = (n) => {\n  return isEven(n) && isDivisible(n, m);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\nconst isEvenDivisibleOddDivisible = (n) => {\n  return isEven(n) && isDivisible(n, m);\n};\n\n/**\n * A function which checks if a number is evenly divisible by another number.\n *\n * @param  {number} n\n * @param  {number} m\n * @return {boolean}\n */\n"}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % n];\n    if (car1.speed > car2.speed) {\n      collisions++;\n    }\n  }\n  return collisions;\n};\n\n/*\n  Given a road with n cars, this function finds the shortest path from each car\n  to the nearest car that has reached its destination.\n\n  For example, given the following road with n cars:\n\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 "}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "gc": "<|endoftext|>/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (i--) {\n    ret.push(l[i] + 1)\n  }\n  return ret\n}\n\n/*Return list with elements decremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (i--) {\n    ret.push(l[i] - 1)\n  }\n  return ret\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (i--) {\n    ret.push(l[i] + 2)\n  }\n  return ret\n}\n\n/*Return list with elements decremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (i--) {\n    ret.push(l[i] - 2)\n  }\n  return ret\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (i--) {\n    ret.push(l[i] + 3)\n  }\n  return ret\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (i--) {\n    ret.push(l[i] - 3)\n  }\n  return ret\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (i--) {\n    ret.push(l[i] + 4)\n  }\n  return ret\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (i--) {\n    ret.push(l[i] - 4)\n  }\n  return ret\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (i--) {\n    ret.push(l[i] + 5)\n  }\n  return ret\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (i--) {\n    ret.push(l[i] - 5)\n  }\n  return ret\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (i--) {\n    ret.push(l[i] + 6)\n  }\n  return ret\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (i--) {\n    ret.push(l[i] - 6)\n  }\n  return ret\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrDecrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (i--) {\n    ret.push(l[i] + 7)\n  }\n  return ret\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrDecrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (i--) {\n    ret.push(l[i] - 7)\n  }\n  return ret\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrDecrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (i--) {\n    ret.push(l[i] + 8)\n  }\n  return ret\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrDecrDecrList = (l) => {\n  let i = l.length\n  let ret = []\n  while (i--) {\n    ret.push(l[i] - 8)\n  }\n  return ret\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incr"}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "gc": "<|endoftext|>/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  A function to check if a number is prime or not.\n  It returns true if the number is prime and false otherwise.\n  >>> isPrime(7)\n  true\n  >>> isPrime(11)\n  false\n  >>> isPrime(15)\n  false\n  >>> isPrime(17)\n  false\n  >>> isPrime(20)\n  false\n  >>> isPrime(23)\n  false\n  >>> isPrime(25)\n  false\n  >>> isPrime(27)\n  false\n  >>> isPrime(29)\n  false\n  >>> isPrime(30)\n  false\n  >>> isPrime(33)\n  false\n  >>> isPrime(35)\n  false\n  >>> isPrime(37)\n  false\n  >>> isPrime(39)\n  false\n  >>> isPrime(41)\n  false\n  >>> isPrime(43)\n  false\n  >>> isPrime(45)\n  false\n  >>> isPrime(47)\n  false\n  >>> isPrime(49)\n  false\n  >>> isPrime(51)\n  false\n  >>> isPrime(53)\n  false\n  >>> isPrime(55)\n  false\n  >>> isPrime(57)\n  false\n  >>> isPrime(59)\n  false\n  >>> isPrime(61)\n  false\n  >>> isPrime(63)\n  false\n  >>> isPrime(65)\n  false\n  >>> isPrime(67)\n  false\n  >>> isPrime(69)\n  false\n  >>> isPrime(71)\n  false\n  >>> isPrime(73)\n  false\n  >>> isPrime(75)\n  false\n  >>> isPrime(77)\n  false\n  >>> isPrime(79)\n  false\n  >>> isPrime(81)\n  false\n  >>> isPrime(83)\n  false\n  >>> isPrime(85)\n  false\n  >>> isPrime(87)\n  false\n  >>> isPrime(89)\n  false\n  >>> isPrime(91)\n  false\n  >>> isPrime(93)\n  false\n  >>> isPrime(95)\n  false\n  >>> isPrime(97)\n  false\n  >>> isPrime(99)\n  false\n  >>> isPrime(101)\n  false\n  >>> isPrime(103)\n  false\n  >>> isPrime(105)\n  false\n  >>> isPrime(107)\n  false\n  >>> isPrime(109)\n  false\n  >>> isPrime(111)\n  false\n  >>> isPrime(113)\n  false\n  >>> isPrime(115)\n  false\n  >>> isPrime(117)\n  false\n  >>> isPrime(119)\n  false\n  >>> isPrime(121)\n  false\n  >>> isPrime(123)\n  false\n  >>> isPrime(125)\n  false\n  >>> isPrime(127)\n  false\n  >>> isPrime(129)\n  false\n  >>> isPrime(131)\n  false\n  >>> isPrime(133)\n  false\n  >>> isPrime(135)\n  false\n  >>> isPrime(137)\n  false\n  >>> isPrime(139)\n  false\n  >>> isPrime(141)\n  false\n  >>> isPrime(143)\n  false\n  >>> isPrime(145)\n  false\n  >>> isPrime(147)\n  false\n  >>> isPrime(149)\n  false\n  >>> isPrime(151)\n  false\n  >>> isPrime(153)\n  false\n  >>> isPrime(155)\n  false\n  >>> isPrime(157)\n  false\n  >>> isPrime(159)\n  false\n  >>> isPrime(161)\n  false\n  >>> isPrime(163)\n  false\n  >>> isPrime(165)\n  false\n  >>> isPrime(167)\n  false\n  >>> isPrime(169)\n  false\n  >>> isPrime(171)\n  false\n  >>> isPrime(173)\n  false\n  >>> isPrime(175)\n  false\n  >>> isPrime(177)\n  false\n  >>> isPrime(179)\n  false\n  >>> isPrime(181)\n  false\n  >>> isPrime(183)\n  false\n  >>> isPrime(185)\n  false\n  >>> isPrime(187)\n  false\n  >>> isPrime(189)\n  false\n  >>> isPrime(191)\n  false\n  >>> isPrime(193)\n  false\n  >>> isPrime(195)\n  false\n  >>> isPrime(197)\n  false\n  >>> isPrime(199)\n  false\n  >>> isPrime(201)\n  false\n  >>> isPrime(203)\n  false\n  >>> isPrime(205)\n  false\n  >>> isPrime(207)\n  false\n  >>> isPrime(209)\n  false\n  >>> isPrime(211)\n  false\n  >>> isPrime(213)\n  false\n  >>> isPrime(215)\n  false\n  >>> isPrime(217)\n  false\n  >>> isPrime(219)\n  false\n  >>> isPrime(221)\n  false\n  >>> isPrime(223)\n  false\n  >>> isPrime(225)\n  false\n  >>> isPrime(227)\n  false\n  >>> isPrime(229)\n  false\n  >>> isPrime(231)\n  false\n  >>> isPrime(233)\n  false\n  >>> isPrime(235)\n  false\n  >>> isPrime(237)\n  false\n  >>> isPrime(239)\n  false\n  >>> isPrime(241)\n  false\n  >>> isPri"}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "gc": "<|endoftext|>/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if (base === 10) return x.toString();\n  const digits = Math.log10(Math.abs(x));\n  return x.toString(base).padStart(digits, '0');\n};\n\n/*\n  Convert a string to its binary representation\n  base is optional.\n  >>> toBinary(123)\n  '1010'\n  >>> toBinary(123, 2)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> toBinary(123, 8)\n  '1010'\n  >>> "}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "gc": "<|endoftext|>/*Given length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const b = Math.sqrt(a * a + h * h);\n  return b * b / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 2)\n  15\n  */\nconst triangleArea = (l, w) => {\n  const a = l * l;\n  const b = w * w;\n  return a * a / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 1)\n  25\n  */\nconst triangleArea = (l, h) => {\n  const a = l * l;\n  const b = h * h;\n  return a * a / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const a = l * l;\n  const b = w * w;\n  return b * b / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, -1)\n  0\n  */\nconst triangleArea = (l, h) => {\n  const a = l * l;\n  const b = h * h;\n  return b * b / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 1)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const a = l * l;\n  const b = w * w;\n  return a * a / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, h) => {\n  const a = l * l;\n  const b = h * h;\n  return a * a / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, -1)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const a = l * l;\n  const b = w * w;\n  return b * b / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 1)\n  0\n  */\nconst triangleArea = (l, h) => {\n  const a = l * l;\n  const b = h * h;\n  return a * a / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const a = l * l;\n  const b = w * w;\n  return b * b / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, -1)\n  0\n  */\nconst triangleArea = (l, h) => {\n  const a = l * l;\n  const b = h * h;\n  return a * a / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 1)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const a = l * l;\n  const b = w * w;\n  return b * b / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, h) => {\n  const a = l * l;\n  const b = h * h;\n  return a * a / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, -1)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const a = l * l;\n  const b = w * w;\n  return b * b / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 1)\n  0\n  */\nconst triangleArea = (l, h) => {\n  const a = l * l;\n  const b = h * h;\n  return a * a / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const a = l * l;\n  const b = w * w;\n  return b * b / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, -1)\n  0\n  */\nconst triangleArea = (l, h) => {\n  const a = l * l;\n  const b = h * h;\n  return a * a / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 1)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const a = l * l;\n  const b = w * w;\n  return b * b / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, h) => {\n  const a = l * l;\n  const b = h * h;\n  return a * a / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, -1)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const a = l * l;\n  const b = w * w;\n  return b * b / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 1)\n  0\n  */\nconst triangleArea = (l, h) => {\n  const a = l * l;\n  const b = h * h;\n  return a * a / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const a = l * l;\n  const b = w * w;\n  return b * b / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, -1)\n  0\n  */\nconst triangleArea = (l, h) => {\n  const a = l * l;\n  const b = h * h;\n  return a * a / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 1)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const a = l * l;\n  const b = w * w;\n  return b * b / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, h) => {\n  const a = l * l;\n  const b = h * h;\n  return a * a / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, -1)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const a = l * l;\n  const b = w * w;\n  return b * b / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 1)\n  0\n  */\nconst triangleArea = (l, h) => {\n  const a = l * l;\n  const b = h * h;\n  return a * a / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, h) => {\n  const a = l * l;\n  const b = h * h;\n  return b * b / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, -1)\n  0\n  */\nconst triangleArea = (l, w) => {\n  const a = l * l;\n  const b = w * w;\n  return a * a / 2;\n};\n\n/*Given length of a side and low return area for a triang"}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "gc": "<|endoftext|>/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  Do not use recursion.\n  >>> fib2(5)\n  2\n  >>> fib2(6)\n  5\n  >>> fib2(7)\n  13\n  */\nconst fib2 = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return fib2(n - 1) + fib2(n - 2);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  Do not use recursion.\n  >>> fib3(5)\n  3\n  >>> fib3(6)\n  8\n  >>> fib3(7)\n  13\n  */\nconst fib3 = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return fib3(n - 1) + fib3(n - 2) + fib3(n - 3) + fib3(n - 4);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  Do not use recursion.\n  >>> fib2(5)\n  2\n  >>> fib2(6)\n  5\n  >>> fib2(7)\n  13\n  */\nconst fib2 = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return fib2(n - 1) + fib2(n - 2);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  Do not use recursion.\n  >>> fib3(5)\n  3\n  >>> fib3(6)\n  8\n  >>> fib3(7)\n  13\n  */\nconst fib3 = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return fib3(n - 1) + fib3(n - 2) + fib3(n - 3) + fib3(n - 4);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  Do not use recursion.\n  >>> fib2(5)\n  2\n  >>> fib2(6)\n  5\n  >>> fib2(7)\n  13\n  */\nconst fib2 = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return fib2(n - 1) + fib2(n - 2);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  Do not use recursion.\n  >>> fib3(5)\n  3\n  >>> fib3(6)\n  8\n  >>> fib3(7)\n  13\n  */\nconst fib3 = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return fib3(n - 1) + fib3(n - 2) + fib3(n - 3) + fib3(n - 4);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  Do not use recursion.\n  >>> fib2(5)\n  2\n  >>> fib2(6)\n  5\n  >>> fib2(7)\n  13\n  */\nconst fib2 = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return fib2(n - 1) + fib2(n - 2);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  Do not use recursion.\n  >>> fib3(5)\n  3\n  >>> fib3(6)\n  8\n  >>> fib3(7)\n  13\n  */\nconst fib3 = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return fib3(n - 1) + fib3(n - 2) + fib3(n - 3) + fib3(n - 4);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  Do not use recursion.\n  >>> fib2(5)\n  2\n  >>> fib2(6)\n  5\n  >>> fib2(7)\n  13\n  */\nconst fib2 = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return fib2(n - 1) + fib2(n - 2);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  Do not use recursion.\n  >>> fib3(5)\n  3\n  >>> fib3(6)\n  8\n  >>> fib3(7)\n  13\n  */\nconst fib3 = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return fib3(n - 1) + fib3(n - 2) + fib3(n - 3) + fib3(n - 4);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 0) {\n"}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - 1) / 2)\n  let pivot = l[m - 1]\n  let left = l[m - 1]\n  let right = l[i]\n  let result\n  if (left > pivot) {\n    left = pivot\n  }\n  if (right < pivot) {\n    right = pivot\n  }\n  if (left === pivot) {\n    result = left\n  } else {\n    result = right\n  }\n  if (right === pivot) {\n    result = right\n  }\n  return result\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfList = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - 1) / 2)\n  let pivot = l[m - 1]\n  let left = l[m - 1]\n  let right = l[i]\n  let result\n  if (left > pivot) {\n    left = pivot\n  }\n  if (right < pivot) {\n    right = pivot\n  }\n  if (left === pivot) {\n    result = left\n  } else {\n    result = right\n  }\n  if (right === pivot) {\n    result = right\n  }\n  return result\n}\n\n/*Return median of elements in the list l.\n  >>> medianOfList([3, 1, 2, 4, 5])\n  3\n  >>> medianOfList([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfLists = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - 1) / 2)\n  let pivot = l[m - 1]\n  let left = l[m - 1]\n  let right = l[i]\n  let result\n  if (left > pivot) {\n    left = pivot\n  }\n  if (right < pivot) {\n    right = pivot\n  }\n  if (left === pivot) {\n    result = left\n  } else {\n    result = right\n  }\n  if (right === pivot) {\n    result = right\n  }\n  return result\n}\n\n/*Return median of elements in the list l.\n  >>> medianOfListOfLists([3, 1, 2, 4, 5])\n  3\n  >>> medianOfListOfLists([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfListsOfLists = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - 1) / 2)\n  let pivot = l[m - 1]\n  let left = l[m - 1]\n  let right = l[i]\n  let result\n  if (left > pivot) {\n    left = pivot\n  }\n  if (right < pivot) {\n    right = pivot\n  }\n  if (left === pivot) {\n    result = left\n  } else {\n    result = right\n  }\n  if (right === pivot) {\n    result = right\n  }\n  return result\n}\n\n/*Return median of elements in the list l.\n  >>> medianOfListOfListsOfLists([3, 1, 2, 4, 5])\n  3\n  >>> medianOfListOfListsOfLists([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfListsOfListsOfLists = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - 1) / 2)\n  let pivot = l[m - 1]\n  let left = l[m - 1]\n  let right = l[i]\n  let result\n  if (left > pivot) {\n    left = pivot\n  }\n  if (right < pivot) {\n    right = pivot\n  }\n  if (left === pivot) {\n    result = left\n  } else {\n    result = right\n  }\n  if (right === pivot) {\n    result = right\n  }\n  return result\n}\n\n/*Return median of elements in the list l.\n  >>> medianOfListOfListsOfListsOfLists([3, 1, 2, 4, 5])\n  3\n  >>> medianOfListOfListsOfListsOfLists([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfListsOfListsOfListsOfLists = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - 1) / 2)\n  let pivot = l[m - 1]\n  let left = l[m - 1]\n  let right = l[i]\n  let result\n  if (left > pivot) {\n    left = pivot\n  }\n  if (right < pivot) {\n    right = pivot\n  }\n  if (left === pivot) {\n    result = left\n  } else {\n    result = right\n  }\n  if (right === pivot) {\n    result = right\n  }\n  return result\n}\n\n/*Return median of elements in the list l.\n  >>> medianOfListOfListsOfListsOfListsOfLists([3, 1, 2, 4, 5])\n  3\n  >>> medianOfListOfListsOfListsOfListsOfLists([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOfListOfListsOfListsOfListsOfListsOfLists = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - 1) / 2)\n  let pivot = l[m - 1]\n  let left = l[m - 1]\n  let right = l[i]\n  let result\n  if (left > pivot) {\n    left = pivot\n  }\n  if (right < pivot) {\n    right = pivot\n  }\n  if (left === pivot) {\n    result = left\n  } else {\n    result = right\n  }\n  if (right === pivot) {\n    result = right\n  }\n  return result\n}\n\n/*Return median of elements in the list l.\n  >>> medianOfListOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOfListsOf"}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "gc": "<|endoftext|>/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return reversedText === text\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeWithSpaces = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return reversedText === text\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeWithSpaces('aba')\n  true\n  >>> isPalindromeWithSpaces('aaaaa')\n  true\n  >>> isPalindromeWithSpaces('zbcd')\n  false\n  */\nconst isPalindromeWithSpace = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return reversedText === text\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeWithSpace('aba')\n  true\n  >>> isPalindromeWithSpace('aaaaa')\n  true\n  >>> isPalindromeWithSpace('zbcd')\n  false\n  */\nconst isPalindromeWithSpaceAndSpace = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return reversedText === text\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeWithSpaceAndSpace('aba')\n  true\n  >>> isPalindromeWithSpaceAndSpace('aaaaa')\n  true\n  >>> isPalindromeWithSpaceAndSpace('zbcd')\n  false\n  */\nconst isPalindromeWithSpaceAndSpaceAndSpace = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return reversedText === text\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeWithSpaceAndSpaceAndSpace('aba')\n  true\n  >>> isPalindromeWithSpaceAndSpaceAndSpace('aaaaa')\n  true\n  >>> isPalindromeWithSpaceAndSpaceAndSpace('zbcd')\n  false\n  */\nconst isPalindromeWithSpaceAndSpaceAndSpace = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return reversedText === text\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeWithSpaceAndSpaceAndSpace('aba')\n  true\n  >>> isPalindromeWithSpaceAndSpaceAndSpace('aaaaa')\n  true\n  >>> isPalindromeWithSpaceAndSpaceAndSpace('zbcd')\n  false\n  */\nconst isPalindromeWithSpaceAndSpaceAndSpace = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return reversedText === text\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeWithSpaceAndSpaceAndSpace('aba')\n  true\n  >>> isPalindromeWithSpaceAndSpaceAndSpace('aaaaa')\n  true\n  >>> isPalindromeWithSpaceAndSpaceAndSpace('zbcd')\n  false\n  */\nconst isPalindromeWithSpaceAndSpaceAndSpaceAndSpace = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return reversedText === text\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeWithSpaceAndSpaceAndSpaceAndSpace('aba')\n  true\n  >>> isPalindromeWithSpaceAndSpaceAndSpaceAndSpace('aaaaa')\n  true\n  >>> isPalindromeWithSpaceAndSpaceAndSpaceAndSpace('zbcd')\n  false\n  */\nconst isPalindromeWithSpaceAndSpaceAndSpaceAndSpace = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return reversedText === text\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeWithSpaceAndSpaceAndSpaceAndSpace('aba')\n  true\n  >>> isPalindromeWithSpaceAndSpaceAndSpaceAndSpace('aaaaa')\n  true\n  >>> isPalindromeWithSpaceAndSpaceAndSpaceAndSpace('zbcd')\n  false\n  */\nconst isPalindromeWithSpaceAndSpaceAndSpaceAndSpaceAndSpace = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return reversedText === text\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeWithSpaceAndSpaceAndSpaceAndSpaceAndSpace('aba')\n  true\n  >>> isPalindromeWithSpaceAndSpaceAndSpaceAndSpaceAndSpace('aaaaa')\n  true\n  >>> isPalindromeWithSpaceAndSpaceAndSpaceAndSpaceAndSpace('zbcd')\n  false\n  */\nconst isPalindromeWithSpaceAndSpaceAndSpaceAndSpaceAndSpace = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return reversedText === text\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeWithSpaceAndSpaceAndSpaceAndSpaceAndSpace('aba')\n  true\n  >>> isPalindromeWithSpaceAndSpaceAndSpaceAndSpaceAndSpace('aaaaa')\n  true\n  >>> isPalindromeWithSpaceAndSpaceAndSpaceAndSpaceAndSpace('zbcd')\n  false\n  */\nconst isPalindromeWithSpaceAndSpaceAndSpaceAndSpaceAndSpace = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return reversedText === text\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeWithSpaceAndSpaceAndSpaceAndSpaceAndSpace('aba')\n  true\n  >>> isPalindromeWithSpaceAndSpaceAndSpaceAndSpaceAndSpace('aaaaa')\n  true\n  >>> isPalindromeWithSpaceAndSpaceAndSpaceAndSpaceAndSpace('zbcd')\n  false\n  */\nconst isPalindromeWithSpaceAndSpaceAndSpaceAndSpaceAndSpaceAndSpace = (text) => {\n  let "}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "gc": "<|endoftext|>/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p <= 0) return 0;\n  if (p === 1) return 1;\n  if (p === 2) return 2;\n  if (p === 3) return 3;\n  if (p === 4) return 4;\n  if (p === 5) return 5;\n  if (p === 6) return 6;\n  if (p === 7) return 7;\n  if (p === 8) return 8;\n  if (p === 9) return 9;\n  if (p === 10) return 10;\n  if (p === 11) return 11;\n  if (p === 12) return 12;\n  if (p === 13) return 13;\n  if (p === 14) return 14;\n  if (p === 15) return 15;\n  if (p === 16) return 16;\n  if (p === 17) return 17;\n  if (p === 18) return 18;\n  if (p === 19) return 19;\n  if (p === 20) return 20;\n  if (p === 21) return 21;\n  if (p === 22) return 22;\n  if (p === 23) return 23;\n  if (p === 24) return 24;\n  if (p === 25) return 25;\n  if (p === 26) return 26;\n  if (p === 27) return 27;\n  if (p === 28) return 28;\n  if (p === 29) return 29;\n  if (p === 30) return 30;\n  if (p === 31) return 31;\n  if (p === 32) return 32;\n  if (p === 33) return 33;\n  if (p === 34) return 34;\n  if (p === 35) return 35;\n  if (p === 36) return 36;\n  if (p === 37) return 37;\n  if (p === 38) return 38;\n  if (p === 39) return 39;\n  if (p === 40) return 40;\n  if (p === 41) return 41;\n  if (p === 42) return 42;\n  if (p === 43) return 43;\n  if (p === 44) return 44;\n  if (p === 45) return 45;\n  if (p === 46) return 46;\n  if (p === 47) return 47;\n  if (p === 48) return 48;\n  if (p === 49) return 49;\n  if (p === 50) return 50;\n  if (p === 51) return 51;\n  if (p === 52) return 52;\n  if (p === 53) return 53;\n  if (p === 54) return 54;\n  if (p === 55) return 55;\n  if (p === 56) return 56;\n  if (p === 57) return 57;\n  if (p === 58) return 58;\n  if (p === 59) return 59;\n  if (p === 60) return 60;\n  if (p === 61) return 61;\n  if (p === 62) return 62;\n  if (p === 63) return 63;\n  if (p === 64) return 64;\n  if (p === 65) return 65;\n  if (p === 66) return 66;\n  if (p === 67) return 67;\n  if (p === 68) return 68;\n  if (p === 69) return 69;\n  if (p === 70) return 70;\n  if (p === 71) return 71;\n  if (p === 72) return 72;\n  if (p === 73) return 73;\n  if (p === 74) return 74;\n  if (p === 75) return 75;\n  if (p === 76) return 76;\n  if (p === 77) return 77;\n  if (p === 78) return 78;\n  if (p === 79) return 79;\n  if (p === 80) return 80;\n  if (p === 81) return 81;\n  if (p === 82) return 82;\n  if (p === 83) return 83;\n  if (p === 84) return 84;\n  if (p === 85) return 85;\n  if (p === 86) return 86;\n  if (p === 87) return 87;\n  if (p === 88) return 88;\n  if (p === 89) return 89;\n  if (p === 90) return 90;\n  if (p === 91) return 91;\n  if (p === 92) return 92;\n  if (p === 93) return 93;\n  if (p === 94) return 94;\n  if (p === 95) return 95;\n  if (p === 96) return 96;\n  if (p === 97) return 97;\n  if (p === 98) return 98;\n  if (p === 99) return 99;\n  if (p === 100) return 100;\n  if (p === 101) return 101;\n  if (p === 102) return 102;\n  if (p === 103) return 103;\n  if (p === 104) return 104;\n  if (p === 105) return 105;\n  if (p === 106) return 106;\n  if (p === 107) return 107;\n  if (p === 108) return 108;\n  if (p === 109) return 109;\n  if (p === 110) return 110;\n  if (p === 111) return 111;\n  if (p === 112) return 112;\n  if (p === 113) return 113;\n  if (p === 114) return 114;\n  if (p === 115) return 115;\n  if (p === 116) return 116;\n  if (p === 117) return 117;\n  if (p === 118) return 118;\n  if (p === 119) return 119;\n  if (p === 120) return 120;\n  if (p === 121) return 121;\n  if (p === 122) return 122;\n  if (p === 123) return 123;\n  if (p === 124) return 124;\n  if (p === 125) return 125;\n  if (p === 126) return 126;\n  if (p === 127) return 127;\n  if (p === 128) return 128;\n  if (p === 129) return 129;\n  if (p === 130) return 130;\n  if (p === 131) return 131;\n  if (p === 132) return 132;\n  if (p === 133) return 133;\n  if (p === 134) return 134;\n  if (p === 135) return 135;\n  if (p === 136) return 136;\n  if (p === 137) return 137;\n  if (p === 138) return 138;\n  if (p === 139) return 139;\n  if (p === 140) return 140;\n  if (p === 141) return 141;\n  if (p === 142) return 142;\n  if (p === 143) return 143;\n  if (p === 144) return 144;\n  if (p === 145) return 145;\n  if (p === 146) return 146;\n  if (p === 147) return 147;\n  if (p === 148) return 148;\n  if (p === 149) return 149;\n  if (p === 150) return 150;\n  if (p === 151) return 151;\n  if (p === 152) return 152;\n  if (p === 153) return 153;\n  if (p === 154) return 154;\n  if (p === 155) return 155;\n  if (p === 156) return 156;\n  if (p === 157) return 157;\n  if (p === 158) return 158;\n  if (p === 159) return 159;\n  if (p === 160) return 160;\n  if (p === 161) return 161;\n  if (p === 162) return 162;\n  if (p === 163) return 163;\n  if (p === 164) return 164;\n  if (p === 165) return 165;\n  if (p === 166) return 166;\n  if (p === 167) return 167;\n  if (p === 168) return 168;\n  if (p === 169) return 169;\n  if (p === 170) return 170;\n  if (p === 171) return 171;\n  if (p === 172) return 172;\n  if (p === 173) return 173;\n  if (p === 174) return 174;\n  if (p === 175) return 175;\n  if (p === 176) return 176;\n  if (p === 177) return 177;\n  if (p === 178) return 178;\n  if (p === 179) return 179;\n  if (p === 180) return 180;\n"}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "gc": "<|endoftext|>/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeAndDecode = (s) => {\n  return encode(encode(s)) + decode(decode(s));\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeAndDecodeAndEncode = (s) => {\n  return encodeAndDecode(encode(encodeAndDecode(s)));\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeAndDecodeAndEncodeAndEncode = (s) => {\n  return encodeAndDecodeAndEncode(encode(encodeAndDecodeAndEncode(s)));\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeAndDecodeAndEncodeAndEncodeAndEncode = (s) => {\n  return encodeAndDecodeAndEncodeAndEncode(encode(encodeAndDecodeAndEncodeAndEncode(s)));\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncode = (s) => {\n  return encodeAndDecodeAndEncodeAndEncodeAndEncode(encode(encodeAndDecodeAndEncodeAndEncodeAndEncode(s)));\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncode = (s) => {\n  return encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncode(encode(encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncode(s)));\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncode = (s) => {\n  return encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncode(encode(encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncode(s)));\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncode = (s) => {\n  return encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncode(encode(encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncode(s)));\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncode = (s) => {\n  return encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncode(encode(encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncode(s)));\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncode = (s) => {\n  return encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncode(encode(encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncode(s)));\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeAndDecodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAndEncodeAnd"}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "gc": "<|endoftext|>/*\n  removeVowels is a function that takes string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = 'aeiouAEIOU'\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let newText = ''\n  let newTextLength = 0\n  let newTextIndex = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength = 0\n  let newTextLengthIndex = 0\n  let newTextLengthLength"}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "gc": "<|endoftext|>/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(n => n > t)\n}\n\n/*Return true if all numbers in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  true\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst aboveThreshold = (l, t) => {\n  return l.every(n => n < t)\n}\n\n/*Return true if all numbers in the list l are equal to t.\n  >>> equal([1, 2, 4, 10], 100)\n  true\n  >>> equal([1, 20, 4, 10], 5)\n  false\n  */\nconst equal = (l, t) => {\n  return l.length === t.length && l.every((n, i) => n === t[i])\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 5)\n  true\n  >>> divisible([2, 5, 10, 15], 2)\n  false\n  */\nconst divisible = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 5)\n  true\n  >>> divisible([2, 5, 10, 15], 2)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0)\n}\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisible([2, 5, 10, 15], 2)\n  true\n  >>> divisible([2, 5, 10, 15], 5)\n  false\n  */\nconst divisibleBy = (l, "}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst subtract = (x, y) => {\n  return x - y\n}\n\n/*\n  >>> subtract(2, 3)\n  3\n  >>> subtract(5, 7)\n  -1\n  */\nconst multiply = (x, y) => {\n  return x * y\n}\n\n/*\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  24\n  */\nconst divide = (x, y) => {\n  return x / y\n}\n\n/*\n  >>> divide(2, 3)\n  2\n  >>> divide(5, 7)\n  0.5\n  */\nconst modulo = (x, y) => {\n  return x % y\n}\n\n/*\n  >>> modulo(2, 3)\n  0\n  >>> modulo(5, 7)\n  1\n  */\nconst pow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> pow(2, 3)\n  8\n  >>> pow(5, 7)\n  256\n  */\nconst log = (x) => {\n  return Math.log(x)\n}\n\n/*\n  >>> log(2)\n  0.4\n  >>> log(5)\n  0.6\n  */\nconst log10 = (x) => {\n  return Math.log10(x)\n}\n\n/*\n  >>> log10(2)\n  0.4\n  >>> log10(5)\n  0.6\n  */\nconst log2 = (x) => {\n  return Math.log2(x)\n}\n\n/*\n  >>> log2(2)\n  0.4\n  >>> log2(5)\n  0.6\n  */\nconst pow10 = (x) => {\n  return Math.pow(10, x)\n}\n\n/*\n  >>> pow10(2)\n  0.4\n  >>> pow10(5)\n  0.6\n  */\nconst pow21 = (x, y) => {\n  return Math.pow(10, x + y)\n}\n\n/*\n  >>> pow21(2, 3)\n  0.4\n  >>> pow21(5, 7)\n  0.6\n  */\nconst pow3 = (x, y) => {\n  return Math.pow(10, x * y)\n}\n\n/*\n  >>> pow3(2, 3)\n  0.4\n  >>> pow3(5, 7)\n  0.6\n  */\nconst pow4 = (x, y) => {\n  return Math.pow(10, x / y)\n}\n\n/*\n  >>> pow4(2, 3)\n  0.4\n  >>> pow4(5, 7)\n  0.6\n  */\nconst pow5 = (x, y) => {\n  return Math.pow(10, x % y)\n}\n\n/*\n  >>> pow5(2, 3)\n  0.4\n  >>> pow5(7, 10)\n  0.6\n  */\nconst pow6 = (x, y) => {\n  return Math.pow(10, Math.pow(x, y))\n}\n\n/*\n  >>> pow6(2, 3)\n  0.4\n  >>> pow6(5, 7)\n  0.6\n  */\nconst pow7 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x))\n}\n\n/*\n  >>> pow7(2, 3)\n  0.4\n  >>> pow7(5, 7)\n  0.6\n  */\nconst pow8 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x) * y)\n}\n\n/*\n  >>> pow8(2, 3)\n  0.4\n  >>> pow8(5, 7)\n  0.6\n  */\nconst pow9 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x) / y)\n}\n\n/*\n  >>> pow9(2, 3)\n  0.4\n  >>> pow9(5, 7)\n  0.6\n  */\nconst pow10 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x) % y)\n}\n\n/*\n  >>> pow10(2, 3)\n  0.4\n  >>> pow10(5, 7)\n  0.6\n  */\nconst pow11 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x) * Math.pow(x, y))\n}\n\n/*\n  >>> pow11(2, 3)\n  0.4\n  >>> pow11(5, 7)\n  0.6\n  */\nconst pow12 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x) * Math.pow(x, y) * y)\n}\n\n/*\n  >>> pow12(2, 3)\n  0.4\n  >>> pow12(5, 7)\n  0.6\n  */\nconst pow13 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x) * Math.pow(x, y) * Math.pow(y, x))\n}\n\n/*\n  >>> pow13(2, 3)\n  0.4\n  >>> pow13(5, 7)\n  0.6\n  */\nconst pow14 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x) * Math.pow(x, y) * Math.pow(y, x) * y)\n}\n\n/*\n  >>> pow14(2, 3)\n  0.4\n  >>> pow14(5, 7)\n  0.6\n  */\nconst pow15 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x) * Math.pow(x, y) * Math.pow(y, x) * Math.pow(y, x))\n}\n\n/*\n  >>> pow15(2, 3)\n  0.4\n  >>> pow15(5, 7)\n  0.6\n  */\nconst pow16 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x) * Math.pow(x, y) * Math.pow(y, x) * Math.pow(y, x) * y)\n}\n\n/*\n  >>> pow16(2, 3)\n  0.4\n  >>> pow16(5, 7)\n  0.6\n  */\nconst pow17 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x) * Math.pow(x, y) * Math.pow(y, x) * Math.pow(y, x) * Math.pow(y, x))\n}\n\n/*\n  >>> pow17(2, 3)\n  0.4\n  >>> pow17(5, 7)\n  0.6\n  */\nconst pow18 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x) * Math.pow(x, y) * Math.pow(y, x) * Math.pow(y, x) * Math.pow(y, x) * y)\n}\n\n/*\n  >>> pow18(2, 3)\n  0.4\n  >>> pow18(5, 7)\n  0.6\n  */\nconst pow19 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x) * Math.pow(x, y) * Math.pow(y, x) * Math.pow(y, x) * Math.pow(y, x) * Math.pow(y, x))\n}\n\n/*\n  >>> pow19(2, 3)\n  0.4\n  >>> pow19(5, 7)\n  0.6\n  */\nconst pow20 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x) * Math.pow(x, y) * Math.pow(y, x) * Math.pow(y, x) * Math.pow(y, x) * Math.pow(y, x) * Math.pow(y, x))\n}\n\n/*\n  >>> pow20(2, 3)\n  0.4\n  >>> pow20(5, 7)\n  0.6\n  */\nconst pow21 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x) * Math.pow(x, y) * Math.pow(y, x) * Math.pow(y, x) * Math.pow(y, x) * Math.pow(y, x) * Math.pow(y, x))\n}\n\n/*\n  >>> pow21(2, 3)\n  0.4\n  >>> pow21(5, 7)\n  0.6\n  */\nconst pow22 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x) * Math.pow(x, y) * Math.pow(y, x) * Math.pow(y, x) * Math.pow(y, x) * Math.pow(y, x) * Math.pow(y, x))\n}\n\n/*\n  >>> pow22(2, 3)\n  0.4\n  >>> pow22(5, 7)\n  0.6\n  */\nconst pow23 = (x, y) => {\n  return Math.pow(10, Math.pow(y, x) * Math.pow(x, y) * Math.pow(y, x) * Math.pow(y, x) * Math.pow(y, x) * Math.pow(y, x) * Math.pow(y, x))\n}\n\n/*\n  >>> pow"}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "gc": "<|endoftext|>/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a"}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "gc": "<|endoftext|>/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  8\n  >>> fib(5)\n  3\n  >>> fib(4)\n  1\n  >>> fib(3)\n  0\n  >>> fib(2)\n  1\n  >>> fib(1) // throws\n  TypeError: fib(1) is not a function\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  8\n  >>> fib(5)\n  3\n  >>> fib(4)\n  1\n  >>> fib(3)\n  0\n  >>> fib(2)\n  1\n  >>> fib(1) // throws\n  TypeError: fib(1) is not a function\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  8\n  >>> fib(5)\n  3\n  >>> fib(4)\n  1\n  >>> fib(3)\n  0\n  >>> fib(2)\n  1\n  >>> fib(1) // throws\n  TypeError: fib(1) is not a function\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  8\n  >>> fib(5)\n  3\n  >>> fib(4)\n  1\n  >>> fib(3)\n  0\n  >>> fib(2)\n  1\n  >>> fib(1) // throws\n  TypeError: fib(1) is not a function\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  8\n  >>> fib(5)\n  3\n  >>> fib(4)\n  1\n  >>> fib(3)\n  0\n  >>> fib(2)\n  1\n  >>> fib(1) // throws\n  TypeError: fib(1) is not a function\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  8\n  >>> fib(5)\n  3\n  >>> fib(4)\n  1\n  >>> fib(3)\n  0\n  >>> fib(2)\n  1\n  >>> fib(1) // throws\n  TypeError: fib(1) is not a function\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  8\n  >>> fib(5)\n  3\n  >>> fib(4)\n  1\n  >>> fib(3)\n  0\n  >>> fib(2)\n  1\n  >>> fib(1) // throws\n  TypeError: fib(1) is not a function\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  8\n  >>> fib(5)\n  3\n  >>> fib(4)\n  1\n  >>> fib(3)\n  0\n  >>> fib(2)\n  1\n  >>> fib(1) // throws\n  TypeError: fib(1) is not a function\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  8\n  >>> fib(5)\n  3\n  >>> fib(4)\n  1\n  >>> fib(3)\n  0\n  >>> fib(2)\n  1\n  >>> fib(1) // throws\n  TypeError: fib(1) is not a function\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  8\n  >>> fib(5)\n  3\n  >>> fib(4)\n  1\n  >>> fib(3)\n  0\n  >>> fib(2)\n  1\n  >>> fib(1) // throws\n  TypeError: fib(1) is not a function\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  8\n  >>> fib(5)\n  3\n  >>> fib(4)\n  1\n  >>> fib(3)\n  0\n  >>> fib(2)\n  1\n  >>> fib(1) // throws\n  TypeError: fib(1) is not a function\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  8\n  >>> fib(5)\n  3\n  >>> fib(4)\n  1\n  >>> fib(3)\n  0\n  >>> fib(2)\n  1\n  >>> fib(1) // throws\n  TypeError: fib(1) is not a function\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  8\n  >>> fib(5)\n  3\n  >>> fib(4)\n  1\n  >>> fib(3)\n  0\n  >>> fib("}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.split(\"<\");\n  const closingBrackets = brackets.split(\">\");\n  const openingBracketsLength = openingBrackets.length;\n  const closingBracketsLength = closingBrackets.length;\n  if (openingBracketsLength!== closingBracketsLength) {\n    return false;\n  }\n  for (let i = 0; i < openingBracketsLength; i++) {\n    const openingBracket = openingBrackets[i];\n    const closingBracket = closingBrackets[i];\n    if (openingBracket!== closingBracket) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if a character is a letter or digit.\n *\n * A character is a letter if it's a letter of the alphabet or digit.\n *\n * A character is a digit if it's a digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit.\n *\n * A character is a letter or digit if it's a letter or digit of the alphabet or digit"}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "gc": "<|endoftext|>/*Return true is list elements are monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = l.length - 1;\n  let j = 0;\n  let k = 0;\n  let flag = true;\n  while (i < l.length) {\n    if (l[j] < l[k]) {\n      flag = false;\n      k++;\n    } else if (l[j] > l[k]) {\n      flag = true;\n      j++;\n    } else {\n      i++;\n      j++;\n    }\n  }\n  return flag;\n};\n\n/*\n  Return true if list elements are in sorted order.\n  >>> sorted([1, 2, 4, 20])\n  true\n  >>> sorted([1, 20, 4, 10])\n  false\n  >>> sorted([4, 1, 0, -10])\n  true\n  */\nconst sorted = (list) => {\n  let i = list.length - 1;\n  let j = 0;\n  let flag = true;\n  while (i < list.length) {\n    if (list[j] < list[i]) {\n      flag = false;\n      i++;\n    } else if (list[j] > list[i]) {\n      flag = true;\n      j++;\n    } else {\n      i++;\n      j++;\n    }\n  }\n  return flag;\n};\n\n/*\n  Return true if list elements are in sorted order.\n  >>> sorted([1, 2, 4, 20])\n  true\n  >>> sorted([1, 20, 4, 10])\n  false\n  >>> sorted([4, 1, 0, -10])\n  true\n  */\nconst sortedDesc = (list) => {\n  let i = list.length - 1;\n  let j = 0;\n  let flag = true;\n  while (i < list.length) {\n    if (list[j] > list[i]) {\n      flag = false;\n      i++;\n    } else if (list[j] < list[i]) {\n      flag = true;\n      j++;\n    } else {\n      i++;\n      j++;\n    }\n  }\n  return flag;\n};\n\n/*\n  Return true if list elements are in sorted order.\n  >>> sorted([1, 2, 4, 20])\n  true\n  >>> sorted([1, 20, 4, 10])\n  false\n  >>> sorted([4, 1, 0, -10])\n  true\n  */\nconst sortedAsc = (list) => {\n  let i = list.length - 1;\n  let j = 0;\n  let flag = true;\n  while (i < list.length) {\n    if (list[j] < list[i]) {\n      flag = false;\n      i++;\n    } else if (list[j] > list[i]) {\n      flag = true;\n      j++;\n    } else {\n      i++;\n      j++;\n    }\n  }\n  return flag;\n};\n\n/*\n  Return true if list elements are in sorted order.\n  >>> sorted([1, 2, 4, 20])\n  true\n  >>> sorted([1, 20, 4, 10])\n  false\n  >>> sorted([4, 1, 0, -10])\n  true\n  */\nconst sortedIn = (list) => {\n  let i = list.length - 1;\n  let j = 0;\n  let flag = true;\n  while (i < list.length) {\n    if (list[j] < list[i]) {\n      flag = false;\n      i++;\n    } else if (list[j] > list[i]) {\n      flag = true;\n      j++;\n    } else {\n      i++;\n      j++;\n    }\n  }\n  return flag;\n};\n\n/*\n  Return true if list elements are in sorted order.\n  >>> sorted([1, 2, 4, 20])\n  true\n  >>> sorted([1, 20, 4, 10])\n  false\n  >>> sorted([4, 1, 0, -10])\n  true\n  */\nconst sortedDescIn = (list) => {\n  let i = list.length - 1;\n  let j = 0;\n  let flag = true;\n  while (i < list.length) {\n    if (list[j] > list[i]) {\n      flag = false;\n      i++;\n    } else if (list[j] < list[i]) {\n      flag = true;\n      j++;\n    } else {\n      i++;\n      j++;\n    }\n  }\n  return flag;\n};\n\n/*\n  Return true if list elements are in sorted order.\n  >>> sorted([1, 2, 4, 20])\n  true\n  >>> sorted([1, 20, 4, 10])\n  false\n  >>> sorted([4, 1, 0, -10])\n  true\n  */\nconst sortedAscIn = (list) => {\n  let i = list.length - 1;\n  let j = 0;\n  let flag = true;\n  while (i < list.length) {\n    if (list[j] < list[i]) {\n      flag = false;\n      i++;\n    } else if (list[j] > list[i]) {\n      flag = true;\n      j++;\n    } else {\n      i++;\n      j++;\n    }\n  }\n  return flag;\n};\n\n/*\n  Return true if list elements are in sorted order.\n  >>> sorted([1, 2, 4, 20])\n  true\n  >>> sorted([1, 20, 4, 10])\n  false\n  >>> sorted([4, 1, 0, -10])\n  true\n  */\nconst sortedInDesc = (list) => {\n  let i = list.length - 1;\n  let j = 0;\n  let flag = true;\n  while (i < list.length) {\n    if (list[j] > list[i]) {\n      flag = false;\n      i++;\n    } else if (list[j] < list[i]) {\n      flag = true;\n      j++;\n    } else {\n      i++;\n      j++;\n    }\n  }\n  return flag;\n};\n\n/*\n  Return true if list elements are in sorted order.\n  >>> sorted([1, 2, 4, 20])\n  true\n  >>> sorted([1, 20, 4, 10])\n  false\n  >>> sorted([4, 1, 0, -10])\n  true\n  */\nconst sortedDescInDesc = (list) => {\n  let i = list.length - 1;\n  let j = 0;\n  let flag = true;\n  while (i < list.length) {\n    if (list[j] > list[i]) {\n      flag = false;\n      i++;\n    } else if (list[j] < list[i]) {\n      flag = true;\n      j++;\n    } else {\n      i++;\n      j++;\n    }\n  }\n  return flag;\n};\n\n/*\n  Return true if list elements are in sorted order.\n  >>> sorted([1, 2, 4, 20])\n  true\n  >>> sorted([1, 20, 4, 10])\n  false\n  >>> sorted([4, 1, 0, -10])\n  true\n  */\nconst sortedInDescIn = (list) => {\n  let i = list.length - 1;\n  let j = 0;\n  let flag = true;\n  while (i < list.length) {\n    if (list[j] > list[i]) {\n      flag = false;\n      i++;\n    } else if (list[j] < list[i]) {\n      flag = true;\n      j++;\n    } else {\n      i++;\n      j++;\n    }\n  }\n  return flag;\n};\n\n/*\n  Return true if list elements are in sorted order.\n  >>> sorted([1, 2, 4, 20])\n  true\n  >>> sorted([1, 20, 4, 10])\n  false\n  >>> sorted([4, 1, 0, -10])\n  true\n  */\nconst sortedInDescInDesc = (list) => {\n  let i = list.length - 1;\n  let j = 0;\n  let flag = true;\n  while (i < list.length) {\n    if (list[j] > list[i]) {\n      flag = false;\n      i++;\n    } else if (list[j] < list[i]) {\n      flag = true;\n      j++;\n    } else {\n      i++;\n      j++;\n    }\n  }\n  return flag;\n};\n\n/*\n  Return true if list elements are in sorted order.\n  >>> sorted([1, 2, 4, 20])\n  true\n  >>> sorted([1, 20, 4, 10])\n  false\n  >>> sorted([4, 1, 0, -10])\n  true\n  */\nconst sortedInDescInDescIn = (list) => {\n  let i = list.length - 1;\n  let j = 0;\n  let flag = true;\n  while (i < list.length) {\n    if (list[j] > list[i]) {\n      flag = false;\n      i++;\n    } else if (list[j] < list[i]) {\n      flag = true;\n      j++;\n    } else {\n      i++;\n      j++;\n    }\n  }\n  return flag;\n};\n\n/*\n  Return true if list elements are in sorted order.\n  >>> sorted([1, 2, 4, "}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "gc": "<|endoftext|>/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > l2.length) {\n        break\n      }\n      if (l1[i] > l2[j]) {\n        i++\n      } else {\n        j++\n      }\n    }\n  }\n  while (i < l1.length) {\n    result.push(l1[i])\n    i++\n  }\n  while (j < l2.length) {\n    result.push(l2[j])\n    j++\n  }\n  return result\n}\n\n/*Return sorted unique elements for two lists.\n  >>> unique([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653, 121]\n  >>> unique([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst unique = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > l2.length) {\n        break\n      }\n      if (l1[i] > l2[j]) {\n        i++\n      } else {\n        j++\n      }\n    }\n  }\n  while (i < l1.length) {\n    result.push(l1[i])\n    i++\n  }\n  while (j < l2.length) {\n    result.push(l2[j])\n    j++\n  }\n  return result\n}\n\n/*Return sorted unique elements for two lists.\n  >>> unique([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653, 121]\n  >>> unique([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueBy = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > l2.length) {\n        break\n      }\n      if (l1[i] > l2[j]) {\n        i++\n      } else {\n        j++\n      }\n    }\n  }\n  while (i < l1.length) {\n    result.push(l1[i])\n    i++\n  }\n  while (j < l2.length) {\n    result.push(l2[j])\n    j++\n  }\n  return result\n}\n\n/*Return sorted unique elements for two lists.\n  >>> uniqueBy([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653, 121]\n  >>> uniqueBy([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueBy = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > l2.length) {\n        break\n      }\n      if (l1[i] > l2[j]) {\n        i++\n      } else {\n        j++\n      }\n    }\n  }\n  while (i < l1.length) {\n    result.push(l1[i])\n    i++\n  }\n  while (j < l2.length) {\n    result.push(l2[j])\n    j++\n  }\n  return result\n}\n\n/*Return sorted unique elements for two lists.\n  >>> uniqueBy([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653, 121]\n  >>> uniqueBy([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueBy = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > l2.length) {\n        break\n      }\n      if (l1[i] > l2[j]) {\n        i++\n      } else {\n        j++\n      }\n    }\n  }\n  while (i < l1.length) {\n    result.push(l1[i])\n    i++\n  }\n  while (j < l2.length) {\n    result.push(l2[j])\n    j++\n  }\n  return result\n}\n\n/*Return sorted unique elements for two lists.\n  >>> uniqueBy([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653, 121]\n  >>> uniqueBy([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueBy = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > l2.length) {\n        break\n      }\n      if (l1[i] > l2[j]) {\n        i++\n      } else {\n        j++\n      }\n    }\n  }\n  while (i < l1.length) {\n    result.push(l1[i])\n    i++\n  }\n  while (j < l2.length) {\n    result.push(l2[j])\n    j++\n  }\n  return result\n}\n\n/*Return sorted unique elements for two lists.\n  >>> uniqueBy([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653, 121]\n  >>> uniqueBy([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueBy = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > l2.length) {\n        break\n      }\n      if (l1[i] > l2[j]) {\n        i++\n      } else {\n        j++\n      }\n    }\n  }\n  while (i < l1.length) {\n    result.push(l1[i])\n    i++\n  }\n  while (j < l2.length) {\n    result.push(l2[j])\n    j++\n  }\n  return result\n}\n\n/*Return sorted unique elements for two lists.\n  >>> uniqueBy([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653, 121]\n  >>> uniqueBy([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueBy = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > l2.length) {\n        break\n      }\n      if (l1[i] > l2[j]) {\n        i++\n      } else {\n        j++\n      }\n    }\n  }\n  while (i < l1.length) {\n    result.push(l1[i])\n    i++\n  }\n  while (j < l2.length) {\n    result.push(l2[j])\n    j++\n  }\n  return result\n}\n\n/*Return sorted unique elements for two lists.\n  >>> uniqueBy([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n"}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "gc": "<|endoftext|>/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let factor = 1;\n  while (n % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst primeFactor = (n) => {\n  let i = 2;\n  let factor = 1;\n  while (n % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst primeFactors = (num) => {\n  let i = 2;\n  let factor = 1;\n  while (num % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst primeFactorsN = (num) => {\n  let i = 2;\n  let factor = 1;\n  while (num % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst primeFactorsN2 = (num) => {\n  let i = 2;\n  let factor = 1;\n  while (num % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst primeFactorsN3 = (num) => {\n  let i = 2;\n  let factor = 1;\n  while (num % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst primeFactorsN4 = (num) => {\n  let i = 2;\n  let factor = 1;\n  while (num % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst primeFactorsN5 = (num) => {\n  let i = 2;\n  let factor = 1;\n  while (num % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst primeFactorsN6 = (num) => {\n  let i = 2;\n  let factor = 1;\n  while (num % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst primeFactorsN7 = (num) => {\n  let i = 2;\n  let factor = 1;\n  while (num % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst primeFactorsN8 = (num) => {\n  let i = 2;\n  let factor = 1;\n  while (num % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst primeFactorsN9 = (num) => {\n  let i = 2;\n  let factor = 1;\n  while (num % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst primeFactorsN10 = (num) => {\n  let i = 2;\n  let factor = 1;\n  while (num % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst primeFactorsN11 = (num) => {\n  let i = 2;\n  let factor = 1;\n  while (num % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst primeFactorsN12 = (num) => {\n  let i = 2;\n  let factor = 1;\n  while (num % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst primeFactorsN13 = (num) => {\n  let i = 2;\n  let factor = 1;\n  while (num % i!== 0) {\n    i++;\n    factor *= i;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst primeFactorsN14 = (num) => {\n  let i = 2;\n  let factor = 1;\n  while (num % i!== 0) {\n    i++;\n"}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "gc": "<|endoftext|>/*sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that takes an array and returns the sum of the elements.\n * It works like the built-in reduce function, but instead of returning the sum,\n * it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it returns the accumulated value.\n * It works like the built-in reduce function, but instead of returning the accumulated\n * value, it "}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "gc": "<|endoftext|>/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.split(\"(\").map(x => x.trim());\n  const closingBrackets = brackets.split(\")\").map(x => x.trim());\n  return openingBrackets.every(x => closingBrackets.includes(x));\n};\n\n/**\n * Returns a string that is the concatenation of all words in a string.\n *\n * >>> words(\"Hello, world!\")\n * 'Hello, world!'\n * >>> words(\"Hello, world! How are you?\")\n * 'Hello, world! How are you?'\n * >>> words(\"Hello, world! How are you? How are you?\")\n * 'Hello, world! How are you? How are you?'\n */\nconst words = str => {\n  return str\n   .split(\" \")\n   .map(x => x.trim())\n   .filter(x => x.length > 0)\n   .map(x => x.toLowerCase());\n};\n\n/**\n * Returns a string that is the concatenation of all words in a string.\n *\n * >>> words(\"Hello, world! How are you? How are you?\")\n * 'Hello, world! How are you? How are you?'\n * >>> words(\"Hello, world! How are you? How are you? How are you?\")\n * 'Hello, world! How are you? How are you? How are you?'\n */\nconst words2 = str => {\n  return str\n   .split(\" \")\n   .map(x => x.trim())\n   .filter(x => x.length > 0)\n   .map(x => x.toLowerCase())\n   .map(x => x.charAt(0).toUpperCase() + x.slice(1));\n};\n\n/**\n * Returns a string that is the concatenation of all words in a string.\n *\n * >>> words(\"Hello, world! How are you? How are you? How are you?\")\n * 'Hello, world! How are you? How are you? How are you?'\n * >>> words(\"Hello, world! How are you? How are you? How are you? How are you?\")\n * 'Hello, world! How are you? How are you? How are you? How are you?'\n */\nconst words3 = str => {\n  return str\n   .split(\" \")\n   .map(x => x.trim())\n   .filter(x => x.length > 0)\n   .map(x => x.toLowerCase())\n   .map(x => x.charAt(0).toUpperCase() + x.slice(1))\n   .map(x => x.charAt(0).toUpperCase() + x.slice(1));\n};\n\n/**\n * Returns a string that is the concatenation of all words in a string.\n *\n * >>> words(\"Hello, world! How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you? How are you"}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "gc": "<|endoftext|>/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/**\n * Evaluate polynomial at given point.\n * x = [a, b, c, d, e]\n * y = [f(a, b), g(a, b), h(a, b), i(a, b), j(a, b)]\n * Evaluate polynomial at given point using given function.\n * f(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * g(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * h(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * i(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * j(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * Evaluate polynomial at given point using given function.\n * f(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * g(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * h(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * i(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * j(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * Evaluate polynomial at given point using given function.\n * f(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * g(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * h(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * i(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * j(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * Evaluate polynomial at given point using given function.\n * f(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * g(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * h(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * i(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * j(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * Evaluate polynomial at given point using given function.\n * f(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * g(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * h(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * i(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * j(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * Evaluate polynomial at given point using given function.\n * f(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * g(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * h(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * i(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * j(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * Evaluate polynomial at given point using given function.\n * f(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * g(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * h(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * i(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * j(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * Evaluate polynomial at given point using given function.\n * f(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * g(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * h(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * i(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * j(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * Evaluate polynomial at given point using given function.\n * f(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - 1] * x^n\n * g(a, b) = x[0] + x[1] * x + x[2] * x^2 + x[3] * x^3 +... + x[n - "}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "gc": "<|endoftext|>/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and n.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(5)\n  13\n  >>> fibonacci(8)\n  34\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and n.\n  >>> fibonacci(8)\n  34\n  >>> fibonacci(9)\n  55\n  >>> fibonacci(10)\n  89\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and n.\n  >>> fibonacci(10)\n  89\n  >>> fibonacci(11)\n  144\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and n.\n  >>> fibonacci(11)\n  144\n  >>> fibonacci(12)\n  233\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and n.\n  >>> fibonacci(12)\n  233\n  >>> fibonacci(13)\n  377\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and n.\n  >>> fibonacci(13)\n  377\n  >>> fibonacci(14)\n  610\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and n.\n  >>> fibonacci(14)\n  610\n  >>> fibonacci(15)\n  987\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and n.\n  >>> fibonacci(15)\n  987\n  >>> fibonacci(16)\n  1597\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and n.\n  >>> fibonacci(16)\n  1597\n  >>> fibonacci(17)\n  2584\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and n.\n  >>> fibonacci(17)\n  2584\n  >>> fibonacci(18)\n  4181\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and n.\n  >>> fibonacci(18)\n  4181\n  >>> fibonacci(19)\n  6765\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and n.\n  >>> fibonacci(19)\n  6765\n  >>> fibonacci(20)\n  10946\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and n.\n  >>> fibonacci(20)\n  10946\n  >>> fibonacci(21)\n  15991\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and n.\n  >>> fibonacci(21)\n  15991\n  >>> fibonacci(22)\n  2584\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and n.\n  >>> fibonacci(22)\n  2584\n  >>> fibonacci(23)\n  4181\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and n.\n  >>> fibonacci(23)\n  4181\n  >>> fibonacci(24)\n  6765\n  */\nconst fibonacci = (n) => {\n  if ("}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "gc": "<|endoftext|>/*Write a function vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowelCount = 0;\n  let vowelIndex = 0;\n  let vowelEndIndex = 0;\n  let vowelEndIndex2 = 0;\n  let vowelEndIndex3 = 0;\n  let vowelEndIndex4 = 0;\n  let vowelEndIndex5 = 0;\n  let vowelEndIndex6 = 0;\n  let vowelEndIndex7 = 0;\n  let vowelEndIndex8 = 0;\n  let vowelEndIndex9 = 0;\n  let vowelEndIndex10 = 0;\n  let vowelEndIndex11 = 0;\n  let vowelEndIndex12 = 0;\n  let vowelEndIndex13 = 0;\n  let vowelEndIndex14 = 0;\n  let vowelEndIndex15 = 0;\n  let vowelEndIndex16 = 0;\n  let vowelEndIndex17 = 0;\n  let vowelEndIndex18 = 0;\n  let vowelEndIndex19 = 0;\n  let vowelEndIndex20 = 0;\n  let vowelEndIndex21 = 0;\n  let vowelEndIndex22 = 0;\n  let vowelEndIndex23 = 0;\n  let vowelEndIndex24 = 0;\n  let vowelEndIndex25 = 0;\n  let vowelEndIndex26 = 0;\n  let vowelEndIndex27 = 0;\n  let vowelEndIndex28 = 0;\n  let vowelEndIndex29 = 0;\n  let vowelEndIndex30 = 0;\n  let vowelEndIndex31 = 0;\n  let vowelEndIndex32 = 0;\n  let vowelEndIndex33 = 0;\n  let vowelEndIndex34 = 0;\n  let vowelEndIndex35 = 0;\n  let vowelEndIndex36 = 0;\n  let vowelEndIndex37 = 0;\n  let vowelEndIndex38 = 0;\n  let vowelEndIndex39 = 0;\n  let vowelEndIndex40 = 0;\n  let vowelEndIndex41 = 0;\n  let vowelEndIndex42 = 0;\n  let vowelEndIndex43 = 0;\n  let vowelEndIndex44 = 0;\n  let vowelEndIndex45 = 0;\n  let vowelEndIndex46 = 0;\n  let vowelEndIndex47 = 0;\n  let vowelEndIndex48 = 0;\n  let vowelEndIndex49 = 0;\n  let vowelEndIndex50 = 0;\n  let vowelEndIndex51 = 0;\n  let vowelEndIndex52 = 0;\n  let vowelEndIndex53 = 0;\n  let vowelEndIndex54 = 0;\n  let vowelEndIndex55 = 0;\n  let vowelEndIndex56 = 0;\n  let vowelEndIndex57 = 0;\n  let vowelEndIndex58 = 0;\n  let vowelEndIndex59 = 0;\n  let vowelEndIndex60 = 0;\n  let vowelEndIndex61 = 0;\n  let vowelEndIndex62 = 0;\n  let vowelEndIndex63 = 0;\n  let vowelEndIndex64 = 0;\n  let vowelEndIndex65 = 0;\n  let vowelEndIndex66 = 0;\n  let vowelEndIndex67 = 0;\n  let vowelEndIndex68 = 0;\n  let vowelEndIndex69 = 0;\n  let vowelEndIndex70 = 0;\n  let vowelEndIndex71 = 0;\n  let vowelEndIndex72 = 0;\n  let vowelEndIndex73 = 0;\n  let vowelEndIndex74 = 0;\n  let vowelEndIndex75 = 0;\n  let vowelEndIndex76 = 0;\n  let vowelEndIndex77 = 0;\n  let vowelEndIndex78 = 0;\n  let vowelEndIndex79 = 0;\n  let vowelEndIndex80 = 0;\n  let vowelEndIndex81 = 0;\n  let vowelEndIndex82 = 0;\n  let vowelEndIndex83 = 0;\n  let vowelEndIndex84 = 0;\n  let vowelEndIndex85 = 0;\n  let vowelEndIndex86 = 0;\n  let vowelEndIndex87 = 0;\n  let vowelEndIndex88 = 0;\n  let vowelEndIndex89 = 0;\n  let vowelEndIndex90 = 0;\n  let vowelEndIndex91 = 0;\n  let vowelEndIndex92 = 0;\n  let vowelEndIndex93 = 0;\n  let vowelEndIndex94 = 0;\n  let vowelEndIndex95 = 0;\n  let vowelEndIndex96 = 0;\n  let vowelEndIndex97 = 0;\n  let vowelEndIndex98 = 0;\n  let vowelEndIndex99 = 0;\n  let vowelEndIndex100 = 0;\n  let vowelEndIndex101 = 0;\n  let vowelEndIndex102 = 0;\n  let vowelEndIndex103 = 0;\n  let vowelEndIndex104 = 0;\n  let vowelEndIndex105 = 0;\n  let vowelEndIndex106 = 0;\n  let vowelEndIndex107 = 0;\n  let vowelEndIndex108 = 0;\n  let vowelEndIndex109 = 0;\n  let vowelEndIndex110 = 0;\n  let vowelEndIndex111 = 0;\n  let vowelEndIndex112 = 0;\n  let vowelEndIndex113 = 0;\n  let vowelEndIndex114 = 0;\n  let vowelEndIndex115 = 0;\n  let vowelEndIndex116 = 0;\n  let vowelEndIndex117 = 0;\n  let vowelEndIndex118 = 0;\n  let vowelEndIndex119 = 0;\n  let vowelEndIndex120 = 0;\n  let vowelEndIndex121 = 0;\n  let vowelEndIndex122 = 0;\n  let vowelEndIndex123 = 0;\n  let vowelEndIndex124 = 0;\n  let vowelEndIndex125 = 0;\n  let vowelEndIndex126 = 0;\n  let vowelEndIndex127 = 0;\n  let vowelEndIndex128 = 0;\n  let vowelEndIndex129 = 0;\n  let vowelEndIndex130 = 0;\n  let vowelEndIndex131 = 0;\n  let vowelEndIndex132 = 0;\n  let vowelEndIndex133 = 0;\n  let vowelEndIndex134 = 0;\n  let vowelEndIndex135 = 0;\n  let vowelEndIndex136 = 0;\n  let vowelEndIndex137 = 0;\n  let vowelEndIndex138 = 0;\n  let vowelEndIndex139 = 0;\n  let vowelEndIndex140 = 0;\n  let vowelEndIndex141 = 0;\n  let vowelEndIndex142 = 0;\n  let vowelEndIndex143 = 0;\n  let vowelEndIndex144 = 0;\n  let vowelEndIndex145 = 0;\n  let vowelEndIndex146 = 0;\n  let vowelEndIndex147 = 0;\n  let vowelEndIndex148 = 0;\n  let vowelEndIndex149 = 0;\n  let vowelEndIndex150 = 0;\n  let vowelEndIndex151 = 0;\n  let vowelEndIndex152 = 0;\n  let vowelEndIndex153 = 0;\n  let vowelEndIndex154 = 0;\n  let vowelEndIndex155 = 0;\n  let vowelEndIndex156 = 0;\n  let vowelEndIndex157 = 0;\n  let vowelEndIndex158 = 0;\n  let vowelEndIndex159 = 0;\n  let vowelEndIndex160 = 0;\n  let vowelEndIndex161 = 0;\n  let vowelEndIndex162 = 0;\n  let vowelEndIndex163 = 0;\n  let vowelEndIndex164 = 0;\n  let vowelEndIndex165 = 0;\n  let vowelEndIndex166 = 0;\n  let vowelEndIndex167 = 0;\n  let vowelEndIndex168 = 0;\n  let vowelEndIndex169 = 0;\n  let vowelEndIndex170 = 0;\n  let vowelEndIndex171 = 0;\n  let vowelEndIndex172 = 0;\n  let vowelEndIndex173 = 0;\n  let vowelEndIndex174 = 0;\n  let vowelEndIndex175 = 0;\n  let vowelEndIndex176 = 0;\n  let vowelEndIndex177 = 0;\n  let vowelEndIndex178 = 0;\n  let vowelEndIndex179 = 0;\n  let vowelEndIndex180 = 0;\n  let vowelEndIndex181 = 0;\n  let vowelEndIndex182 = 0;\n  let vowelEndIndex183 = 0;\n  let vowelEndIndex184 = 0;\n  let vowelEndIndex185 = 0;\n  let vowelEndIndex186 = 0;\n  let vowelEndIndex187 = 0;\n  let vowelEndIndex188 = 0;\n  let vowelEndIndex189 = 0;\n  let vowelEndIndex190 = 0;\n  let vowelEndIndex191 = 0;\n  let vowelEndIndex192 = 0;\n  let vowelEndIndex193 = 0;\n  let vowelEndIndex194 = 0;\n  let vowelEndIndex195 = 0;\n  let vowelEndIndex196 = 0;\n  let vowelEndIndex197 = 0;\n  let vowelEndIndex198 = 0;\n  let vowelEndIndex199 = 0;\n  let vowelEndIndex200 = 0;\n  let vowelEndIndex201 = 0;\n  let vowelEndIndex202 = 0;\n  let vowelEndIndex203 = 0;\n  let vowelEndIndex204 = 0;\n  let vowelEndIndex205 = 0;"}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "gc": "<|endoftext|>/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let str = x.toString();\n  let len = str.length;\n  let res = [];\n  for (let i = 0; i < len; i += shift) {\n    res.push(str.slice(i, i + shift));\n  }\n  return res.reverse().join('');\n};\n\n/**\n  Convert a number to a string in base 10\n  >>> toBase10(123)\n  \"123\"\n  >>> toBase10(123)\n  \"100\"\n  >>> toBase10(123)\n  \"1000\"\n  >>> toBase10(123)\n  \"10000\"\n  >>> toBase10(123)\n  \"100000\"\n  >>> toBase10(123)\n  \"1000000\"\n  >>> toBase10(123)\n  \"10000000\"\n  >>> toBase10(123)\n  \"100000000\"\n  >>> toBase10(123)\n  \"1000000000\"\n  >>> toBase10(123)\n  \"10000000000\"\n  >>> toBase10(123)\n  \"100000000000\"\n  >>> toBase10(123)\n  \"1000000000000\"\n  >>> toBase10(123)\n  \"10000000000000\"\n  >>> toBase10(123)\n  \"100000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"10000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"100000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000\"\n  >>> toBase10(123)\n  \"1000000000000000000000000000000000000\"\n  >>> toBase10(123)"}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "gc": "<|endoftext|>/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSumUpper(\"\") => 0\n      digitSumUpper(\"abAB\") => 131\n      digitSumUpper(\"abcCd\") => 67\n      digitSumUpper(\"helloE\") => 69\n      digitSumUpper(\"woArBld\") => 131\n      digitSumUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpper = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSumUpper(\"\") => 0\n      digitSumUpper(\"abAB\") => 131\n      digitSumUpper(\"abcCd\") => 67\n      digitSumUpper(\"helloE\") => 69\n      digitSumUpper(\"woArBld\") => 131\n      digitSumUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSumUpperLower(\"\") => 0\n      digitSumUpperLower(\"abAB\") => 131\n      digitSumUpperLower(\"abcCd\") => 67\n      digitSumUpperLower(\"helloE\") => 69\n      digitSumUpperLower(\"woArBld\") => 131\n      digitSumUpperLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLowerLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSumUpperLowerLower(\"\") => 0\n      digitSumUpperLowerLower(\"abAB\") => 131\n      digitSumUpperLowerLower(\"abcCd\") => 67\n      digitSumUpperLowerLower(\"helloE\") => 69\n      digitSumUpperLowerLower(\"woArBld\") => 131\n      digitSumUpperLowerLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLowerLowerLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSumUpperLowerLowerLower(\"\") => 0\n      digitSumUpperLowerLowerLower(\"abAB\") => 131\n      digitSumUpperLowerLowerLower(\"abcCd\") => 67\n      digitSumUpperLowerLowerLower(\"helloE\") => 69\n      digitSumUpperLowerLowerLower(\"woArBld\") => 131\n      digitSumUpperLowerLowerLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLowerLowerLowerLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSumUpperLowerLowerLowerLower(\"\") => 0\n      digitSumUpperLowerLowerLowerLower(\"abAB\") => 131\n      digitSumUpperLowerLowerLowerLower(\"abcCd\") => 67\n      digitSumUpperLowerLowerLowerLower(\"helloE\") => 69\n      digitSumUpperLowerLowerLowerLower(\"woArBld\") => 131\n      digitSumUpperLowerLowerLowerLower(\"aAaaaXa"}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "gc": "<|endoftext|>/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    total += parseInt(fruits[i]);\n  }\n  return total - n;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    total += parseInt(fruits[i]);\n  }\n  return total - n;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    total += parseInt(fruits[i]);\n  }\n  return total - n;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    total += parseInt(fruits[i]);\n  }\n  return total - n;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    total += parseInt(fruits[i]);\n  }\n  return total - n;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    total += parseInt(fruits[i]);\n  }\n  return total - n;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    total += parseInt(fruits[i]);\n  }\n  return total - n;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) "}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "gc": "<|endoftext|>/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let smallestEven = Number.POSITIVE_INFINITY;\n  let smallestIndex = -1;\n\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      smallestEven = arr[i];\n      smallestIndex = i;\n    }\n    i++;\n  }\n\n  while (j < len) {\n    if (arr[j] % 2 === 0) {\n      smallestEven = arr[j];\n      smallestIndex = j;\n    }\n    j++;\n  }\n\n  while (k < len) {\n    if (arr[k] % 2 === 0) {\n      smallestEven = arr[k];\n      smallestIndex = k;\n    }\n    k++;\n  }\n\n  return [smallestEven, smallestIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest odd value.\n// If multiple nodes with the same smallest odd value are found return the node that has smallest index.\n\n// The plucked node should be returned in a list, [ odd_value, its index ],\n// If there are no odd values or the given array is empty, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest odd value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest odd value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluckOdd = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let odd = Number.NEGATIVE_INFINITY;\n  let smallestOdd = Number.POSITIVE_INFINITY;\n  let smallestIndex = -1;\n\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      odd = arr[i];\n      smallestOdd = odd;\n      smallestIndex = i;\n    }\n    i++;\n  }\n\n  while (j < len) {\n    if (arr[j] % 2 === 0) {\n      odd = arr[j];\n      smallestOdd = odd;\n      smallestIndex = j;\n    }\n    j++;\n  }\n\n  while (k < len) {\n    if (arr[k] % 2 === 0) {\n      odd = arr[k];\n      smallestOdd = odd;\n      smallestIndex = k;\n    }\n    k++;\n  }\n\n  return [smallestOdd, smallestIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest positive value.\n// If multiple nodes with the same smallest positive value are found return the node that has smallest index.\n\n// The plucked node should be returned in a list, [ positive_value, its index ],\n// If there are no positive values or the given array is empty, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest positive value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest positive value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluckPositive = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let positive = Number.NEGATIVE_INFINITY;\n  let smallestPositive = Number.POSITIVE_INFINITY;\n  let smallestIndex = -1;\n\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      positive = arr[i];\n      smallestPositive = positive;\n      smallestIndex = i;\n    }\n    i++;\n  }\n\n  while (j < len) {\n    if (arr[j] % 2 === 0) {\n      positive = arr[j];\n      smallestPositive = positive;\n      smallestIndex = j;\n    }\n    j++;\n  }\n\n  while (k < len) {\n    if (arr[k] % 2 === 0) {\n      positive = arr[k];\n      smallestPositive = positive;\n      smallestIndex = k;\n    }\n    k++;\n  }\n\n  return [smallestPositive, smallestIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest negative value.\n// If multiple nodes with the same smallest negative value are found return the node that has smallest index.\n\n// The plucked node should be returned in a list, [ negative_value, its index ],\n// If there are no negative values or the given array is empty, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest negative value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest negative value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluckNegative = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let negative = Number.NEGATIVE_INFINITY;\n  let smallestNegative = Number.POSITIVE_INFINITY;\n  let smallestIndex = -1;\n\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      negative = arr[i];\n      smallestNegative"}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "gc": "<|endoftext|>/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let count = 0;\n  let maxCount = 0;\n  let maxCount2 = 0;\n  let maxCount3 = 0;\n  let maxCount4 = 0;\n  let maxCount5 = 0;\n  let maxCount6 = 0;\n  let maxCount7 = 0;\n  let maxCount8 = 0;\n  let maxCount9 = 0;\n  let maxCount10 = 0;\n  let maxCount11 = 0;\n  let maxCount12 = 0;\n  let maxCount13 = 0;\n  let maxCount14 = 0;\n  let maxCount15 = 0;\n  let maxCount16 = 0;\n  let maxCount17 = 0;\n  let maxCount18 = 0;\n  let maxCount19 = 0;\n  let maxCount20 = 0;\n  let maxCount21 = 0;\n  let maxCount22 = 0;\n  let maxCount23 = 0;\n  let maxCount24 = 0;\n  let maxCount25 = 0;\n  let maxCount26 = 0;\n  let maxCount27 = 0;\n  let maxCount28 = 0;\n  let maxCount29 = 0;\n  let maxCount30 = 0;\n  let maxCount31 = 0;\n  let maxCount32 = 0;\n  let maxCount33 = 0;\n  let maxCount34 = 0;\n  let maxCount35 = 0;\n  let maxCount36 = 0;\n  let maxCount37 = 0;\n  let maxCount38 = 0;\n  let maxCount39 = 0;\n  let maxCount40 = 0;\n  let maxCount41 = 0;\n  let maxCount42 = 0;\n  let maxCount43 = 0;\n  let maxCount44 = 0;\n  let maxCount45 = 0;\n  let maxCount46 = 0;\n  let maxCount47 = 0;\n  let maxCount48 = 0;\n  let maxCount49 = 0;\n  let maxCount50 = 0;\n  let maxCount51 = 0;\n  let maxCount52 = 0;\n  let maxCount53 = 0;\n  let maxCount54 = 0;\n  let maxCount55 = 0;\n  let maxCount56 = 0;\n  let maxCount57 = 0;\n  let maxCount58 = 0;\n  let maxCount59 = 0;\n  let maxCount60 = 0;\n  let maxCount61 = 0;\n  let maxCount62 = 0;\n  let maxCount63 = 0;\n  let maxCount64 = 0;\n  let maxCount65 = 0;\n  let maxCount66 = 0;\n  let maxCount67 = 0;\n  let maxCount68 = 0;\n  let maxCount69 = 0;\n  let maxCount70 = 0;\n  let maxCount71 = 0;\n  let maxCount72 = 0;\n  let maxCount73 = 0;\n  let maxCount74 = 0;\n  let maxCount75 = 0;\n  let maxCount76 = 0;\n  let maxCount77 = 0;\n  let maxCount78 = 0;\n  let maxCount79 = 0;\n  let maxCount80 = 0;\n  let maxCount81 = 0;\n  let maxCount82 = 0;\n  let maxCount83 = 0;\n  let maxCount84 = 0;\n  let maxCount85 = 0;\n  let maxCount86 = 0;\n  let maxCount87 = 0;\n  let maxCount88 = 0;\n  let maxCount89 = 0;\n  let maxCount90 = 0;\n  let maxCount91 = 0;\n  let maxCount92 = 0;\n  let maxCount93 = 0;\n  let maxCount94 = 0;\n  let maxCount95 = 0;\n  let maxCount96 = 0;\n  let maxCount97 = 0;\n  let maxCount98 = 0;\n  let maxCount99 = 0;\n  let maxCount100 = 0;\n  let maxCount101 = 0;\n  let maxCount102 = 0;\n  let maxCount103 = 0;\n  let maxCount104 = 0;\n  let maxCount105 = 0;\n  let maxCount106 = 0;\n  let maxCount107 = 0;\n  let maxCount108 = 0;\n  let maxCount109 = 0;\n  let maxCount110 = 0;\n  let maxCount111 = 0;\n  let maxCount112 = 0;\n  let maxCount113 = 0;\n  let maxCount114 = 0;\n  let maxCount115 = 0;\n  let maxCount116 = 0;\n  let maxCount117 = 0;\n  let maxCount118 = 0;\n  let maxCount119 = 0;\n  let maxCount120 = 0;\n  let maxCount121 = 0;\n  let maxCount122 = 0;\n  let maxCount123 = 0;\n  let maxCount124 = 0;\n  let maxCount125 = 0;\n  let maxCount126 = 0;\n  let maxCount127 = 0;\n  let maxCount128 = 0;\n  let maxCount129 = 0;\n  let maxCount130 = 0;\n  let maxCount131 = 0;\n  let maxCount132 = 0;\n  let maxCount133 = 0;\n  let maxCount134 = 0;\n  let maxCount135 = 0;\n  let maxCount136 = 0;\n  let maxCount137 = 0;\n  let maxCount138 = 0;\n  let maxCount139 = 0;\n  let maxCount140 = 0;\n  let maxCount141 = 0;\n  let maxCount142 = 0;\n  let maxCount143 = 0;\n  let maxCount144 = 0;\n  let maxCount145 = 0;\n  let maxCount146 = 0;\n  let maxCount147 = 0;\n  let maxCount148 = 0;\n  let maxCount149 = 0;\n  let maxCount150 = 0;\n  let maxCount151 = 0;\n  let maxCount152 = 0;\n  let maxCount153 = 0;\n  let maxCount154 = 0;\n  let maxCount155 = 0;\n  let maxCount156 = 0;\n  let maxCount157 = 0;\n  let maxCount158 = 0;\n  let maxCount159 = 0;\n  let maxCount160 = 0;\n  let maxCount161 = 0;\n  let maxCount162 = 0;\n  let maxCount163 = 0;\n  let maxCount164 = 0;\n  let maxCount165 = 0;\n  let maxCount166 = 0;\n  let maxCount167 = 0;\n  let maxCount168 = 0;\n  let maxCount169 = 0;\n  let maxCount170 = 0;\n  let maxCount171 = 0;\n  let maxCount172 = 0;\n  let maxCount173 = 0;\n  let maxCount174 = 0;\n  let maxCount175 = 0;\n  let maxCount176 = 0;\n  let maxCount177 = 0;\n  let maxCount178 = 0;\n  let maxCount179 = 0;\n  let maxCount180 = 0;\n  let maxCount181 = 0;\n  let maxCount182 = 0;\n  let maxCount183 = 0;\n  let maxCount184 = 0;\n  let maxCount185 = 0;\n  let maxCount186 = 0;\n  let maxCount187 = 0;\n  let maxCount188 = 0;\n  let maxCount189 = 0;\n  let maxCount190 = 0;\n  let maxCount191 = 0;\n  let maxCount192 = 0;\n  let maxCount193 = 0;\n  let maxCount194 = 0;\n  let maxCount195 = 0;\n  let maxCount196 = 0;\n  let maxCount197 = 0;\n  let maxCount198 = 0;\n  let maxCount199 = 0;\n  let maxCount200 = 0;\n  let maxCount201 = 0;\n  let maxCount202 = 0;\n  let maxCount203 = 0;\n  let maxCount204 = 0;\n  let maxCount205 = 0;\n  let maxCount206 = 0;\n  let maxCount207 = 0;\n  let maxCount208 = 0;\n  let maxCount209 = 0;\n  let maxCount210 = 0;\n  let maxCount211 = 0;\n  let maxCount212 = 0;\n  let maxCount213 = 0;\n  let maxCount214 = 0;\n  let maxCount215 = 0;\n  let maxCount216 = 0;\n  let maxCount217 = 0;\n  let maxCount218 = 0;\n  let maxCount219 = 0;\n  let maxCount220 = 0;\n  let maxCount221 = 0;\n  let maxCount222 = 0;\n  let maxCount223 = 0;\n  let maxCount224 = 0;\n  let maxCount225 = 0;\n  let maxCount226 = 0;\n  let maxCount227 = 0;\n  let maxCount228 = 0;\n  let maxCount229 = 0;\n  let maxCount230 = 0;\n  let maxCount231 = 0;\n  let maxCount232 = 0;\n  let maxCount233 = 0;\n  let maxCount234 = 0;\n  let maxCount235 = 0;\n  let maxCount236 = 0;\n  let maxCount237 = 0;\n  let maxCount238 = 0;\n  let maxCount239 = 0;\n  let maxCount240 = 0;\n"}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "gc": "<|endoftext|>/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sortedLst = lst.sort((a, b) => a - b);\n  const sortedArr = [];\n  for (let i = 0; i < sortedLst.length; i++) {\n    sortedArr.push(sortedLst[i]);\n  }\n  return sortedArr;\n};\n\n/*\n  Given array of integers, return array in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortArray([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortArray([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortArray([]) == []\n  */\nconst strangeSortArray = (arr) => {\n  const sortedArr = arr.sort((a, b) => a - b);\n  return sortedArr;\n};\n\n/*\n  Given array of integers, return array in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortArray([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortArray([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortArray([]) == []\n  */\nconst strangeSortObject = (obj) => {\n  const sortedObj = Object.keys(obj).sort((a, b) => obj[b] - obj[a]);\n  return sortedObj;\n};\n\n/*\n  Given array of integers, return array in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortArray([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortArray([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortArray([]) == []\n  */\nconst strangeSortArrayOfArrays = (arr) => {\n  const sortedArr = arr.sort((a, b) => a - b);\n  return sortedArr;\n};\n\n/*\n  Given array of integers, return array in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortArrayOfArrays([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortArrayOfArrays([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortArrayOfArrays([]) == []\n  */\nconst strangeSortArrayOfObjects = (arr) => {\n  const sortedObj = Object.keys(arr).sort((a, b) => arr[b] - arr[a]);\n  return sortedObj;\n};\n\n/*\n  Given array of integers, return array in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortArrayOfObjects([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortArrayOfObjects([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortArrayOfObjects([]) == []\n  */\nconst strangeSortArrayOfNumbers = (arr) => {\n  const sortedArr = arr.sort((a, b) => a - b);\n  return sortedArr;\n};\n\n/*\n  Given array of integers, return array in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortArrayOfNumbers([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortArrayOfNumbers([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortArrayOfNumbers([]) == []\n  */\nconst strangeSortArrayOfStrings = (arr) => {\n  const sortedArr = arr.sort((a, b) => a - b);\n  return sortedArr;\n};\n\n/*\n  Given array of integers, return array in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortArrayOfStrings([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortArrayOfStrings([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortArrayOfStrings([]) == []\n  */\nconst strangeSortArrayOfNumbersAndStrings = (arr) => {\n  const sortedArr = arr.sort((a, b) => a - b);\n  return sortedArr;\n};\n\n/*\n  Given array of integers, return array in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortArrayOfNumbersAndStrings([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortArrayOfNumbersAndStrings([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortArrayOfNumbersAndStrings([]) == []\n  */\nconst strangeSortArrayOfNumbersAndNumbers = (arr) => {\n  const sortedArr = arr.sort((a, b) => a - b);\n  return sortedArr;\n};\n\n/*\n  Given array of integers, return array in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortArrayOfNumbersAndNumbers([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortArrayOfNumbersAndNumbers([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortArrayOfNumbersAndNumbers([]) == []\n  */\nconst strangeSortArrayOfNumbersAndStringsAndNumbers = (arr) => {\n  const sortedArr = arr.sort((a, b) => a - b);\n  return sortedArr;\n};\n\n/*\n  Given array of integers, return array in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortArrayOfNumbersAndStringsAndNumbers([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortArrayOfNumbersAndStringsAndNumbers([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortArrayOfNumbersAndStringsAndNumbers([]) == []\n  */\nconst strangeSortArrayOfNumbersAndNumbersAndStringsAndNumbers = (arr) => {\n  const sortedArr = arr.sort((a, b) => a - b);\n  return sortedArr;\n};\n\n/*\n  Given array of integers, return array in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortArrayOfNumbersAndNumbersAndStringsAndNumbers([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortArrayOfNumbersAndNumbersAndStringsAndNumbers([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortArrayOfNumbersAndNumbersAndStringsAndNumbers([]) == []\n  */\nconst strangeSortArrayOfNumbersAndNumbersAndStringsAndStringsAndNumbers = (arr) => {\n  const sortedArr = arr.sort((a, b) => a - b);\n  return sortedArr;\n};\n\n/*\n  Given array of integers, return array in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the "}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "gc": "<|endoftext|>/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const sideA = a + b\n  const sideB = a + c\n  const sideC = a + b\n  const sideD = c + b\n  const sideE = c + a\n  const sideF = c + a\n  const sideG = b + a\n  const sideH = b + c\n  const sideI = b + d\n  const sideJ = b + e\n  const sideK = b + f\n  const sideL = b + g\n  const sideM = b + h\n  const sideN = b + i\n  const sideO = b + j\n  const sideP = b + k\n  const sideQ = b + l\n  const sideR = b + m\n  const sideS = b + n\n  const sideT = b + o\n  const sideU = b + p\n  const sideV = b + q\n  const sideW = b + r\n  const sideX = b + s\n  const sideY = b + t\n  const sideZ = b + u\n  const sideA = sideA > sideB? sideA : sideB\n  const sideB = sideB > sideC? sideB : sideC\n  const sideC = sideC > sideD? sideC : sideD\n  const sideD = sideD > sideE? sideD : sideE\n  const sideE = sideE > sideF? sideE : sideF\n  const sideF = sideF > sideG? sideF : sideG\n  const sideG = sideG > sideH? sideG : sideH\n  const sideH = sideH > sideI? sideH : sideI\n  const sideI = sideI > sideJ? sideI : sideJ\n  const sideJ = sideJ > sideK? sideJ : sideK\n  const sideK = sideK > sideL? sideK : sideL\n  const sideL = sideL > sideM? sideL : sideM\n  const sideM = sideM > sideN? sideM : sideN\n  const sideN = sideN > sideO? sideN : sideO\n  const sideO = sideO > sideP? sideO : sideP\n  const sideP = sideP > sideQ? sideP : sideQ\n  const sideQ = sideQ > sideR? sideQ : sideR\n  const sideR = sideR > sideS? sideR : sideS\n  const sideS = sideS > sideT? sideS : sideT\n  const sideT = sideT > sideU? sideT : sideU\n  const sideU = sideU > sideV? sideU : sideV\n  const sideV = sideV > sideW? sideV : sideW\n  const sideW = sideW > sideX? sideW : sideX\n  const sideX = sideX > sideY? sideX : sideY\n  const sideY = sideY > sideZ? sideY : sideZ\n  const sideZ = sideZ > sideA? sideZ : sideA\n  const sideA = sideA > sideB? sideA : sideB\n  const sideB = sideB > sideC? sideB : sideC\n  const sideC = sideC > sideD? sideC : sideD\n  const sideD = sideD > sideE? sideD : sideE\n  const sideE = sideE > sideF? sideE : sideF\n  const sideF = sideF > sideG? sideF : sideG\n  const sideG = sideG > sideH? sideG : sideH\n  const sideH = sideH > sideI? sideH : sideI\n  const sideI = sideI > sideJ? sideI : sideJ\n  const sideJ = sideJ > sideK? sideJ : sideK\n  const sideK = sideK > sideL? sideK : sideL\n  const sideL = sideL > sideM? sideL : sideM\n  const sideM = sideM > sideN? sideM : sideN\n  const sideN = sideN > sideO? sideN : sideO\n  const sideO = sideO > sideP? sideO : sideP\n  const sideP = sideP > sideQ? sideP : sideQ\n  const sideQ = sideQ > sideR? sideQ : sideR\n  const sideR = sideR > sideS? sideR : sideS\n  const sideS = sideS > sideT? sideS : sideT\n  const sideT = sideT > sideU? sideT : sideU\n  const sideU = sideU > sideV? sideU : sideV\n  const sideV = sideV > sideW? sideV : sideW\n  const sideW = sideW > sideX? sideW : sideX\n  const sideX = sideX > sideY? sideX : sideY\n  const sideY = sideY > sideZ? sideY : sideZ\n  const sideZ = sideZ > sideA? sideZ : sideA\n  const sideA = sideA > sideB? sideA : sideB\n  const sideB = sideB > sideC? sideB : sideC\n  const sideC = sideC > sideD? sideC : sideD\n  const sideD = sideD > sideE? sideD : sideE\n  const sideE = sideE > sideF? sideE : sideF\n  const sideF = sideF > sideG? sideF : sideG\n  const sideG = sideG > sideH? sideG : sideH\n  const sideH = sideH > sideI? sideH : sideI\n  const sideI = sideI > sideJ? sideI : sideJ\n  const sideJ = sideJ > sideK? sideJ : sideK\n  const sideK = sideK > sideL? sideK : sideL\n  const sideL = sideL > sideM? sideL : sideM\n  const sideM = sideM > sideN? sideM : sideN\n  const sideN = sideN > sideO? sideN : sideO\n  const sideO = sideO > sideP? sideO : sideP\n  const sideP = sideP > sideQ? sideP : sideQ\n  const sideQ = sideQ > sideR? sideQ : sideR\n  const sideR = sideR > sideS? sideR : sideS\n  const sideS = sideS > sideT? sideS : sideT\n  const sideT = sideT > sideU? sideT : sideU\n  const sideU = sideU > sideV? sideU : sideV\n  const sideV = sideV > sideW? sideV : sideW\n  const sideW = sideW > sideX? sideW : sideX\n  const sideX = sideX > sideY? sideX : sideY\n  const sideY = sideY > sideZ? sideY : sideZ\n  const sideZ = sideZ > sideA? sideZ : sideA\n  const sideA = sideA > sideB? sideA : sideB\n  const sideB = sideB > sideC? sideB : sideC\n  const sideC = sideC > sideD? sideC : sideD\n  const sideD = sideD > sideE? sideD : sideE\n  const sideE = sideE "}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "gc": "<|endoftext|>/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b);\n  return sumWeight <= maxWeight;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && willItFly(q.slice(0, -1), w);\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && willItFly(q.slice(0, -1), w);\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && willItFly(q.slice(0, -1), w);\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && willItFly(q.slice(0, -1), w);\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  const sumWeight = q.map(w => w).reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && willItFly(q.slice(0, -1), w);\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math."}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "gc": "<|endoftext|>/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  for (let i = 0; i < len - 1; i++) {\n    if (arr[i] === arr[i + 1]) {\n      change++;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 4\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  largestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst largestChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  for (let i = len - 1; i >= 0; i--) {\n    if (arr[i] === arr[i + 1]) {\n      change++;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangeInReverse = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  for (let i = len - 1; i >= 0; i--) {\n    if (arr[i] === arr[len - i - 1]) {\n      change++;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 4\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  largestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst largestChangeInReverse = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  for (let i = len - 1; i >= 0; i--) {\n    if (arr[i] === arr[len - i - 1]) {\n      change++;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangeInReverseInPlace = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  for (let i = len - 1; i >= 0; i--) {\n    if (arr[i] === arr[len - i - 1]) {\n      change++;\n    }\n  }\n  for (let i = len - 1; i >= 0; i--) {\n    arr[i] = arr[i + 1];\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 4\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  largestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst largestChangeInReverseInPlace = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  for (let i = len - 1; i >= 0; i--) {\n    if (arr[i] === arr[len - i - 1]) {\n      change++;\n    }\n  }\n  for (let i = len - 1; i >= 0; i--) {\n    arr[i] = arr[len - i - 1];\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangeInReverseInPlaceInReverse = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  for (let i = len - 1; i >= 0; i--) {\n    if (arr[i] === arr[len - i - 1]) {\n      change++;\n    }\n  }\n  for (let i = len - 1; i >= 0; i--) {\n    arr[i] = arr[len - i - 1];\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 4\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  largestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst largestChangeInReverseInPlaceInReverse = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  for (let i = len - 1; i >= 0; i--) {\n    if (arr[i] === arr[len - i - 1]) {\n      change++;\n    }\n  }\n  for (let i = len - 1; i >= 0; i--) {\n    arr[i] = arr[len - i - 1];\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChangeInReverseInPlaceInReverseInPlace = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  for (let i = len - 1; i >= 0; i--) {\n    if (arr[i] === arr[len - i - 1]) {\n      change++;\n    }\n  }\n  for (let i = len - 1; i >= 0; i--) {\n    arr[i] = arr[len - i - 1];\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 4\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  largestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst largestChangeIn"}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "gc": "<|endoftext|>/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const totalChars = lst1.reduce((acc, curr) => {\n    return acc + curr.length;\n  }, 0);\n  return lst2.filter(item => item.length < totalChars);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list greater than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatchGreaterThan = (lst1, lst2) => {\n  const totalChars = lst1.reduce((acc, curr) => {\n    return acc + curr.length;\n  }, 0);\n  return lst2.filter(item => item.length > totalChars);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list equal to the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatchEqualTo = (lst1, lst2) => {\n  const totalChars = lst1.reduce((acc, curr) => {\n    return acc + curr.length;\n  }, 0);\n  return lst2.filter(item => item === totalChars);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not equal to the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatchNotEqualTo = (lst1, lst2) => {\n  const totalChars = lst1.reduce((acc, curr) => {\n    return acc + curr.length;\n  }, 0);\n  return lst2.filter(item => item!== totalChars);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list greater than or equal to the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatchGreaterThanOrEqualTo = (lst1, lst2) => {\n  const totalChars = lst1.reduce((acc, curr) => {\n    return acc + curr.length;\n  }, 0);\n  return lst2.filter(item => item >= totalChars);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not equal to the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatchNotEqualToOrEqualTo = (lst1, lst2) => {\n  const totalChars = lst1.reduce((acc, curr) => {\n    return acc + curr.length;\n  }, 0);\n  return lst2.filter(item => item!== totalChars);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than or equal to the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatchLessThanOrEqualTo = (lst1, lst2) => {\n  const totalChars = lst1.reduce((acc, curr) => {\n    return acc + curr.length;\n  }, 0);\n  return lst2.filter(item => item <= totalChars);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not equal to the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['"}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "gc": "<|endoftext|>/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if ("}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "gc": "<|endoftext|>/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n % x === 0) {\n    return false\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if a number x is a prime number and\n  false in other cases.\n  x is a prime number if n%int=0 or n>1\n  For example:\n  isPrime(2) => true\n  isPrime(3) => true\n  isPrime(5) => false\n  isPrime(7) => false\n  isPrime(11) => false\n  */\nconst isPrime = (x) => {\n  if (x % 2 === 0) {\n    return false\n  }\n  if (x % 3 === 0) {\n    return false\n  }\n  if (x % 5 === 0) {\n    return false\n  }\n  if (x % 7 === 0) {\n    return false\n  }\n  if (x % 11 === 0) {\n    return false\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if a number x is a perfect square\n  and false in other cases.\n  x is a perfect square if n%int=0 or n>1\n  For example:\n  isPerfectSquare(2) => true\n  isPerfectSquare(3) => true\n  isPerfectSquare(5) => false\n  isPerfectSquare(7) => false\n  isPerfectSquare(11) => false\n  */\nconst isPerfectSquare = (x) => {\n  if (x % 2 === 0) {\n    return false\n  }\n  if (x % 3 === 0) {\n    return false\n  }\n  if (x % 5 === 0) {\n    return false\n  }\n  if (x % 7 === 0) {\n    return false\n  }\n  if (x % 11 === 0) {\n    return false\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if a number x is a perfect cube\n  and false in other cases.\n  x is a perfect cube if n%int=0 or n>1\n  For example:\n  isPerfectCube(2) => true\n  isPerfectCube(3) => true\n  isPerfectCube(5) => false\n  isPerfectCube(7) => false\n  isPerfectCube(11) => false\n  */\nconst isPerfectCube = (x) => {\n  if (x % 2 === 0) {\n    return false\n  }\n  if (x % 3 === 0) {\n    return false\n  }\n  if (x % 5 === 0) {\n    return false\n  }\n  if (x % 7 === 0) {\n    return false\n  }\n  if (x % 11 === 0) {\n    return false\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if a number x is a perfect cube\n  and false in other cases.\n  x is a perfect cube if n%int=0 or n>1\n  For example:\n  isPerfectCube(2) => true\n  isPerfectCube(3) => true\n  isPerfectCube(5) => false\n  isPerfectCube(7) => false\n  isPerfectCube(11) => false\n  */\nconst isPerfectCube = (x) => {\n  if (x % 2 === 0) {\n    return false\n  }\n  if (x % 3 === 0) {\n    return false\n  }\n  if (x % 5 === 0) {\n    return false\n  }\n  if (x % 7 === 0) {\n    return false\n  }\n  if (x % 11 === 0) {\n    return false\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if a number x is a perfect cube\n  and false in other cases.\n  x is a perfect cube if n%int=0 or n>1\n  For example:\n  isPerfectCube(2) => true\n  isPerfectCube(3) => true\n  isPerfectCube(5) => false\n  isPerfectCube(7) => false\n  isPerfectCube(11) => false\n  */\nconst isPerfectCube = (x) => {\n  if (x % 2 === 0) {\n    return false\n  }\n  if (x % 3 === 0) {\n    return false\n  }\n  if (x % 5 === 0) {\n    return false\n  }\n  if (x % 7 === 0) {\n    return false\n  }\n  if (x % 11 === 0) {\n    return false\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if a number x is a perfect cube\n  and false in other cases.\n  x is a perfect cube if n%int=0 or n>1\n  For example:\n  isPerfectCube(2) => true\n  isPerfectCube(3) => true\n  isPerfectCube(5) => false\n  isPerfectCube(7) => false\n  isPerfectCube(11) => false\n  */\nconst isPerfectCube = (x) => {\n  if (x % 2 === 0) {\n    return false\n  }\n  if (x % 3 === 0) {\n    return false\n  }\n  if (x % 5 === 0) {\n    return false\n  }\n  if (x % 7 === 0) {\n    return false\n  }\n  if (x % 11 === 0) {\n    return false\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if a number x is a perfect cube\n  and false in other cases.\n  x is a perfect cube if n%int=0 or n>1\n  For example:\n  isPerfectCube(2) => true\n  isPerfectCube(3) => true\n  isPerfectCube(5) => false\n  isPerfectCube(7) => false\n  isPerfectCube(11) => false\n  */\nconst isPerfectCube = (x) => {\n  if (x % 2 === 0) {\n    return false\n  }\n  if (x % 3 === 0) {\n    return false\n  }\n  if (x % 5 === 0) {\n    return false\n  }\n  if (x % 7 === 0) {\n    return false\n  }\n  if (x % 11 === 0) {\n    return false\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if a number x is a perfect cube\n  and false in other cases.\n  x is a perfect cube if n%int=0 or n>1\n  For example:\n  isPerfectCube(2) => true\n  isPerfectCube(3) => true\n  isPerfectCube(5) => false\n  isPerfectCube(7) => false\n  isPerfectCube(11) => false\n  */\nconst isPerfectCube = (x) => {\n  if (x % 2 === 0) {\n    return false\n  }\n  if (x % 3 === 0) {\n    return false\n  }\n  if (x % 5 === 0) {\n    return false\n  }\n  if (x % 7 === 0) {\n    return false\n  }\n  if (x % 11 === 0) {\n    return false\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if a number x is a perfect cube\n  and false in other cases.\n  x is a perfect cube if n%int=0 or n>1\n  For example:\n  isPerfectCube(2) => true\n  isPerfectCube(3) => true\n  isPerfectCube(5) => false\n  isPerfectCube(7) => false\n  isPerfectCube(11) => false\n  */\nconst isPerfectCube = (x) => {\n  if (x % 2 === 0) {"}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "gc": "<|endoftext|>/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a <= 0) return false;\n  if (a % 2 === 0) return false;\n  return iscube(a / 2);\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a pentagon of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  ispentagon(1) ==> true\n  ispentagon(2) ==> false\n  ispentagon(-1) ==> true\n  ispentagon(64) ==> true\n  ispentagon(0) ==> true\n  ispentagon(180) ==> false\n  */\nconst ispentagon = (a) => {\n  if (a <= 0) return false;\n  if (a % 2 === 0) return false;\n  return ispentagon(a / 2);\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a hexagon of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  ishexagon(1) ==> true\n  ishexagon(2) ==> false\n  ishexagon(-1) ==> true\n  ishexagon(64) ==> true\n  ishexagon(0) ==> true\n  ishexagon(180) ==> false\n  */\nconst ishexagon = (a) => {\n  if (a <= 0) return false;\n  if (a % 2 === 0) return false;\n  return ishexagon(a / 2);\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a hexadecimal number with some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  ishexadecimal(3) ==> true\n  ishexadecimal(4) ==> false\n  ishexadecimal(-1) ==> true\n  ishexadecimal(64) ==> true\n  ishexadecimal(0) ==> true\n  ishexadecimal(180) ==> false\n  */\nconst ishexadecimal = (a) => {\n  if (a <= 0) return false;\n  if (a % 2 === 0) return false;\n  return ishexadecimal(a / 2);\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a hexadecimal number with some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  ishexadecimal(3) ==> true\n  ishexadecimal(4) ==> false\n  ishexadecimal(-1) ==> true\n  ishexadecimal(64) ==> true\n  ishexadecimal(0) ==> true\n  ishexadecimal(180) ==> false\n  */\nconst ishexadecimal = (a) => {\n  if (a <= 0) return false;\n  if (a % 2 === 0) return false;\n  return ishexadecimal(a / 2);\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a hexadecimal number with some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  ishexadecimal(3) ==> true\n  ishexadecimal(4) ==> false\n  ishexadecimal(-1) ==> true\n  ishexadecimal(64) ==> true\n  ishexadecimal(0) ==> true\n  ishexadecimal(180) ==> false\n  */\nconst ishexadecimal = (a) => {\n  if (a <= 0) return false;\n  if (a % 2 === 0) return false;\n  return ishexadecimal(a / 2);\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a hexadecimal number with some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  ishexadecimal(3) ==> true\n  ishexadecimal(4) ==> false\n  ishexadecimal(-1) ==> true\n  ishexadecimal(64) ==> true\n  ishexadecimal(0) ==> true\n  ishexadecimal(180) ==> false\n  */\nconst ishexadecimal = (a) => {\n  if (a <= 0) return false;\n  if (a % 2 === 0) return false;\n  return ishexadecimal(a / 2);\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a hexadecimal number with some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  ishexadecimal(3) ==> true\n  ishexadecimal(4) ==> false\n  ishexadecimal(-1) ==> true\n  ishexadecimal(64) ==> true\n  ishexadecimal(0) ==> true\n  ishexadecimal(180) ==> false\n  */\nconst ishexadecimal = (a) => {\n  if (a <= 0) return false;\n  if (a % 2 === 0) return false;\n  return ishexadecimal(a / 2);\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a hexadecimal number with some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  ishexadecimal(3) ==> true\n  ishexadecimal(4) ==> false\n  ishexadecimal(-1) ==> true\n  ishexadecimal(64) ==> true\n  ishexadecimal(0) ==> true\n  ishexadecimal(180) ==> false\n  */\nconst ishexadecimal = (a) => {\n  if (a <= 0) return false;\n  if (a % 2 === 0) return false;\n  return ishexadecimal(a / 2);\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a hexadecimal number with some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  ishexadecimal(3) ==> true\n  ishexadecimal(4) ==> false\n  ishexadecimal(-1) ==> true\n  ishexadecimal(64) ==> true\n  ishexadecimal(0) ==> true\n  ishexadecimal(180) ==> false\n  */\nconst ishexadecimal = (a) => {\n  if (a <= 0) return false;\n  if (a % 2 === 0) return false;\n  return ishexadecimal(a / 2);\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a hexadecimal number with some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  ishexadecimal(3) ==> true\n  ishexadecimal(4) ==> false\n  ishexadecimal(-1) ==> true\n  ishexadecimal(64) ==> true\n  ishexadecimal(0) ==> true\n  ishexadecimal(180) ==> false\n  */\nconst ishexadecimal = (a) => {\n  if (a <= 0) return false;\n  if (a % 2 === 0) return false;\n  return ishexadecimal(a / 2);\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a hexa"}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "gc": "<|endoftext|>/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let count = 0;\n  let sum = 0;\n  let flag = 0;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n  let temp4 = 0;\n  let temp5 = 0;\n  let temp6 = 0;\n  let temp7 = 0;\n  let temp8 = 0;\n  let temp9 = 0;\n  let temp10 = 0;\n  let temp11 = 0;\n  let temp12 = 0;\n  let temp13 = 0;\n  let temp14 = 0;\n  let temp15 = 0;\n  let temp16 = 0;\n  let temp17 = 0;\n  let temp18 = 0;\n  let temp19 = 0;\n  let temp20 = 0;\n  let temp21 = 0;\n  let temp22 = 0;\n  let temp23 = 0;\n  let temp24 = 0;\n  let temp25 = 0;\n  let temp26 = 0;\n  let temp27 = 0;\n  let temp28 = 0;\n  let temp29 = 0;\n  let temp30 = 0;\n  let temp31 = 0;\n  let temp32 = 0;\n  let temp33 = 0;\n  let temp34 = 0;\n  let temp35 = 0;\n  let temp36 = 0;\n  let temp37 = 0;\n  let temp38 = 0;\n  let temp39 = 0;\n  let temp40 = 0;\n  let temp41 = 0;\n  let temp42 = 0;\n  let temp43 = 0;\n  let temp44 = 0;\n  let temp45 = 0;\n  let temp46 = 0;\n  let temp47 = 0;\n  let temp48 = 0;\n  let temp49 = 0;\n  let temp50 = 0;\n  let temp51 = 0;\n  let temp52 = 0;\n  let temp53 = 0;\n  let temp54 = 0;\n  let temp55 = 0;\n  let temp56 = 0;\n  let temp57 = 0;\n  let temp58 = 0;\n  let temp59 = 0;\n  let temp60 = 0;\n  let temp61 = 0;\n  let temp62 = 0;\n  let temp63 = 0;\n  let temp64 = 0;\n  let temp65 = 0;\n  let temp66 = 0;\n  let temp67 = 0;\n  let temp68 = 0;\n  let temp69 = 0;\n  let temp70 = 0;\n  let temp71 = 0;\n  let temp72 = 0;\n  let temp73 = 0;\n  let temp74 = 0;\n  let temp75 = 0;\n  let temp76 = 0;\n  let temp77 = 0;\n  let temp78 = 0;\n  let temp79 = 0;\n  let temp80 = 0;\n  let temp81 = 0;\n  let temp82 = 0;\n  let temp83 = 0;\n  let temp84 = 0;\n  let temp85 = 0;\n  let temp86 = 0;\n  let temp87 = 0;\n  let temp88 = 0;\n  let temp89 = 0;\n  let temp90 = 0;\n  let temp91 = 0;\n  let temp92 = 0;\n  let temp93 = 0;\n  let temp94 = 0;\n  let temp95 = 0;\n  let temp96 = 0;\n  let temp97 = 0;\n  let temp98 = 0;\n  let temp99 = 0;\n  let temp100 = 0;\n  let temp101 = 0;\n  let temp102 = 0;\n  let temp103 = 0;\n  let temp104 = 0;\n  let temp105 = 0;\n  let temp106 = 0;\n  let temp107 = 0;\n  let temp108 = 0;\n  let temp109 = 0;\n  let temp110 = 0;\n  let temp111 = 0;\n  let temp112 = 0;\n  let temp113 = 0;\n  let temp114 = 0;\n  let temp115 = 0;\n  let temp116 = 0;\n  let temp117 = 0;\n  let temp118 = 0;\n  let temp119 = 0;\n  let temp120 = 0;\n  let temp121 = 0;\n  let temp122 = 0;\n  let temp123 = 0;\n  let temp124 = 0;\n  let temp125 = 0;\n  let temp126 = 0;\n  let temp127 = 0;\n  let temp128 = 0;\n  let temp129 = 0;\n  let temp130 = 0;\n  let temp131 = 0;\n  let temp132 = 0;\n  let temp133 = 0;\n  let temp134 = 0;\n  let temp135 = 0;\n  let temp136 = 0;\n  let temp137 = 0;\n  let temp138 = 0;\n  let temp139 = 0;\n  let temp140 = 0;\n  let temp141 = 0;\n  let temp142 = 0;\n  let temp143 = 0;\n  let temp144 = 0;\n  let temp145 = 0;\n  let temp146 = 0;\n  let temp147 = 0;\n  let temp148 = 0;\n  let temp149 = 0;\n  let temp150 = 0;\n  let temp151 = 0;\n  let temp152 = 0;\n  let temp153 = 0;\n  let temp154 = 0;\n  let temp155 = 0;\n  let temp156 = 0;\n  let temp157 = 0;\n  let temp158 = 0;\n  let temp159 = 0;\n  let temp160 = 0;\n  let temp161 = 0;\n  let temp162 = 0;\n  let temp163 = 0;\n  let temp164 = 0;\n  let temp165 = 0;\n  let temp166 = 0;\n  let temp167 = 0;\n  let temp168 = 0;\n  let temp169 = 0;\n  let temp170 = 0;\n  let temp171 = 0;\n  let temp172 = 0;\n  let temp173 = 0;\n  let temp174 = 0;\n  let temp175 = 0;\n  let temp176 = 0;\n  let temp177 = 0;\n  let temp178 = 0;\n  let temp179 = 0;\n  let temp180 = 0;\n  let temp181 = 0;\n  let temp182 = 0;\n  let temp183 = 0;\n  let temp184 = 0;\n  let temp185 = 0;\n  let temp186 = 0;\n  let temp187 = 0;\n  let temp188 = 0;\n  let temp189 = 0;\n  let temp190 = 0;\n  let temp191 = 0;\n  let temp192 = 0;\n  let temp193 = 0;\n  let temp194 = 0;\n  let temp195 = 0;\n  let temp196 = 0;\n  let temp197 = 0;\n  let temp198 = 0;\n  let temp199 = 0;\n  let temp200 = 0;\n  let temp201 = 0;\n  let temp202 = 0;\n  let temp203 = 0;\n  let temp204 = 0;\n  let temp205 = 0;\n  let temp206 = 0;\n  let temp207 = 0;\n  let temp208 = 0;\n  let temp209 = 0;\n  let temp210 = 0;\n  let temp211 = 0;\n  let temp212 = 0;\n  let temp213 = 0;\n  let temp214 = 0;\n  let temp215 = 0;\n  let temp216 = 0;\n  let temp217 = 0;\n  let temp218 = 0;\n  let temp219 = 0;\n  let temp220 = 0;\n  let temp221 = 0;\n  let temp222 = 0;\n  let temp223 = 0;\n  let temp224 = 0;\n  let temp225 = 0;\n  let temp226 = 0;\n  let temp227 = 0;\n  let temp228 = 0;\n  let temp229 = 0;\n  let temp230 = 0;\n  let temp231 = 0;\n  let temp232 = 0;\n  let temp233 = 0;\n  let temp234 = 0;\n  let temp235 = 0;\n  let temp236 = 0;\n  let temp237 = 0;\n  let temp238 = 0;\n  let temp239 = 0;\n  let temp240 = 0;\n  let temp241 = 0;\n  let temp242 = 0;\n  let temp243 = 0;\n  let temp244 = 0;\n  let temp245 = 0;\n  let temp246 = 0;\n  let temp247 = 0;\n  let temp248 = 0;\n  let temp249 = 0;\n  let temp250 = 0;\n  let temp251 = 0;\n  let temp252 = 0;\n  let temp253 = 0;\n  let temp254 = 0;\n  let temp255 = 0;\n  let temp256 = 0;\n"}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "gc": "<|endoftext|>/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalString = decimal.toString().padStart(8, '0');\n  for (let i = 0; i < decimalString.length; i++) {\n    binary += decimalString[i].toBinary();\n  }\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal(\"1111\")  # returns 15\n  binaryToDecimal(\"100000\")  # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString().padStart(8, '0');\n  for (let i = 0; i < binaryString.length; i++) {\n    decimal += binaryString[i].toString(2);\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal(\"1111\")  # returns 15\n  binaryToDecimal(\"100000\")  # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString().padStart(8, '0');\n  for (let i = 0; i < binaryString.length; i++) {\n    decimal += binaryString[i].toString(2);\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal(\"1111\")  # returns 15\n  binaryToDecimal(\"100000\")  # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString().padStart(8, '0');\n  for (let i = 0; i < binaryString.length; i++) {\n    decimal += binaryString[i].toString(2);\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal(\"1111\")  # returns 15\n  binaryToDecimal(\"100000\")  # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString().padStart(8, '0');\n  for (let i = 0; i < binaryString.length; i++) {\n    decimal += binaryString[i].toString(2);\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal(\"1111\")  # returns 15\n  binaryToDecimal(\"100000\")  # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString().padStart(8, '0');\n  for (let i = 0; i < binaryString.length; i++) {\n    decimal += binaryString[i].toString(2);\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal(\"1111\")  # returns 15\n  binaryToDecimal(\"100000\")  # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString().padStart(8, '0');\n  for (let i = 0; i < binaryString.length; i++) {\n    decimal += binaryString[i].toString(2);\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal(\"1111\")  # returns 15\n  binaryToDecimal(\"100000\")  # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString().padStart(8, '0');\n  for (let i = 0; i < binaryString.length; i++) {\n    decimal += binaryString[i].toString(2);\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal(\"1111\")  # returns 15\n  binaryToDecimal(\"100000\")  # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString().padStart(8, '0');\n  for (let i = 0; i < binaryString.length; i++) {\n    decimal += binaryString[i].toString(2);\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal(\"1111\")  # returns 15\n  binaryToDecimal(\"100000\")  # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString().padStart(8, '0');\n  for (let i = 0; i < binaryString.length; i++) {\n    decimal += binaryString[i].toString(2);\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal(\"1111\")  # returns 15\n  binaryToDecimal(\"100000\")  # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString().padStart(8, '0');\n  for (let i = 0; i < binaryString.length; i++) {\n    decimal += binaryString[i].toString(2);\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal(\"1111\")  # returns 15\n  binaryToDecimal(\"100000\")  # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString().padStart(8, '0');\n  for (let i = 0; i < binaryString.length; i++) {\n    decimal += binaryString[i].toString(2);\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal(\"1111\")  # returns 15\n  binaryToDecimal(\"100000\")  # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString().padStart(8, '0');\n  for (let i = 0; i < binaryString.length; i++) {\n    decimal += binaryString[i].toString(2);\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal(\"1111\")  # returns 15\n  binaryToDecimal(\"100000\")  # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString().padStart(8, '0');\n  for (let i = 0; i < binaryString.length; i++) {\n    decimal += binaryString[i].toString(2);\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal(\"1111\")  # returns 15\n  binaryToDecimal(\"100000\")  # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString().padStart(8, '0');\n  for (let i = 0; i < binaryString.length; i++) {\n    decimal += binaryString[i].toString(2);\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal(\"1111\")  # returns 15\n  binaryToDecimal(\"100000\")  # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryString = binary.toString().padStart(8, '0');\n  for (let i = 0; i < binaryString.length; i++) {\n    decimal += "}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "gc": "<|endoftext|>/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let isHappy = true;\n  let isHappyLength = 0;\n  let isHappyLettersDistinct = false;\n  let isHappyLettersCount = 0;\n  let isHappyLettersIndex = 0;\n  let isHappyLettersIndex2 = 0;\n  let isHappyLettersIndex3 = 0;\n  let isHappyLettersIndex4 = 0;\n  let isHappyLettersIndex5 = 0;\n  let isHappyLettersIndex6 = 0;\n  let isHappyLettersIndex7 = 0;\n  let isHappyLettersIndex8 = 0;\n  let isHappyLettersIndex9 = 0;\n  let isHappyLettersIndex10 = 0;\n  let isHappyLettersIndex11 = 0;\n  let isHappyLettersIndex12 = 0;\n  let isHappyLettersIndex13 = 0;\n  let isHappyLettersIndex14 = 0;\n  let isHappyLettersIndex15 = 0;\n  let isHappyLettersIndex16 = 0;\n  let isHappyLettersIndex17 = 0;\n  let isHappyLettersIndex18 = 0;\n  let isHappyLettersIndex19 = 0;\n  let isHappyLettersIndex20 = 0;\n  let isHappyLettersIndex21 = 0;\n  let isHappyLettersIndex22 = 0;\n  let isHappyLettersIndex23 = 0;\n  let isHappyLettersIndex24 = 0;\n  let isHappyLettersIndex25 = 0;\n  let isHappyLettersIndex26 = 0;\n  let isHappyLettersIndex27 = 0;\n  let isHappyLettersIndex28 = 0;\n  let isHappyLettersIndex29 = 0;\n  let isHappyLettersIndex30 = 0;\n  let isHappyLettersIndex31 = 0;\n  let isHappyLettersIndex32 = 0;\n  let isHappyLettersIndex33 = 0;\n  let isHappyLettersIndex34 = 0;\n  let isHappyLettersIndex35 = 0;\n  let isHappyLettersIndex36 = 0;\n  let isHappyLettersIndex37 = 0;\n  let isHappyLettersIndex38 = 0;\n  let isHappyLettersIndex39 = 0;\n  let isHappyLettersIndex40 = 0;\n  let isHappyLettersIndex41 = 0;\n  let isHappyLettersIndex42 = 0;\n  let isHappyLettersIndex43 = 0;\n  let isHappyLettersIndex44 = 0;\n  let isHappyLettersIndex45 = 0;\n  let isHappyLettersIndex46 = 0;\n  let isHappyLettersIndex47 = 0;\n  let isHappyLettersIndex48 = 0;\n  let isHappyLettersIndex49 = 0;\n  let isHappyLettersIndex50 = 0;\n  let isHappyLettersIndex51 = 0;\n  let isHappyLettersIndex52 = 0;\n  let isHappyLettersIndex53 = 0;\n  let isHappyLettersIndex54 = 0;\n  let isHappyLettersIndex55 = 0;\n  let isHappyLettersIndex56 = 0;\n  let isHappyLettersIndex57 = 0;\n  let isHappyLettersIndex58 = 0;\n  let isHappyLettersIndex59 = 0;\n  let isHappyLettersIndex60 = 0;\n  let isHappyLettersIndex61 = 0;\n  let isHappyLettersIndex62 = 0;\n  let isHappyLettersIndex63 = 0;\n  let isHappyLettersIndex64 = 0;\n  let isHappyLettersIndex65 = 0;\n  let isHappyLettersIndex66 = 0;\n  let isHappyLettersIndex67 = 0;\n  let isHappyLettersIndex68 = 0;\n  let isHappyLettersIndex69 = 0;\n  let isHappyLettersIndex70 = 0;\n  let isHappyLettersIndex71 = 0;\n  let isHappyLettersIndex72 = 0;\n  let isHappyLettersIndex73 = 0;\n  let isHappyLettersIndex74 = 0;\n  let isHappyLettersIndex75 = 0;\n  let isHappyLettersIndex76 = 0;\n  let isHappyLettersIndex77 = 0;\n  let isHappyLettersIndex78 = 0;\n  let isHappyLettersIndex79 = 0;\n  let isHappyLettersIndex80 = 0;\n  let isHappyLettersIndex81 = 0;\n  let isHappyLettersIndex82 = 0;\n  let isHappyLettersIndex83 = 0;\n  let isHappyLettersIndex84 = 0;\n  let isHappyLettersIndex85 = 0;\n  let isHappyLettersIndex86 = 0;\n  let isHappyLettersIndex87 = 0;\n  let isHappyLettersIndex88 = 0;\n  let isHappyLettersIndex89 = 0;\n  let isHappyLettersIndex90 = 0;\n  let isHappyLettersIndex91 = 0;\n  let isHappyLettersIndex92 = 0;\n  let isHappyLettersIndex93 = 0;\n  let isHappyLettersIndex94 = 0;\n  let isHappyLettersIndex95 = 0;\n  let isHappyLettersIndex96 = 0;\n  let isHappyLettersIndex97 = 0;\n  let isHappyLettersIndex98 = 0;\n  let isHappyLettersIndex99 = 0;\n  let isHappyLettersIndex100 = 0;\n  let isHappyLettersIndex101 = 0;\n  let isHappyLettersIndex102 = 0;\n  let isHappyLettersIndex103 = 0;\n  let isHappyLettersIndex104 = 0;\n  let isHappyLettersIndex105 = 0;\n  let isHappyLettersIndex106 = 0;\n  let isHappyLettersIndex107 = 0;\n  let isHappyLettersIndex108 = 0;\n  let isHappyLettersIndex109 = 0;\n  let isHappyLettersIndex110 = 0;\n  let isHappyLettersIndex111 = 0;\n  let isHappyLettersIndex112 = 0;\n  let isHappyLettersIndex113 = 0;\n  let isHappyLettersIndex114 = 0;\n  let isHappyLettersIndex115 = 0;\n  let isHappyLettersIndex116 = 0;\n  let isHappyLettersIndex117 = 0;\n  let isHappyLettersIndex118 = 0;\n  let isHappyLettersIndex119 = 0;\n  let isHappyLettersIndex120 = 0;\n  let isHappyLettersIndex121 = 0;\n  let isHappyLettersIndex122 = 0;\n  let isHappyLettersIndex123 = 0;\n  let isHappyLettersIndex124 = 0;\n  let isHappyLettersIndex125 = 0;\n  let isHappyLettersIndex126 = 0;\n  let isHappy"}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const letterGrades = grades.map((grade) => {\n    if (grade >= 4.0) {\n      return 'A+';\n    } else if (grade >= 3.7) {\n      return 'A';\n    } else if (grade >= 3.3) {\n      return 'A-';\n    } else if (grade >= 3.0) {\n      return 'B+';\n    } else if (grade >= 2.7) {\n      return 'B';\n    } else if (grade >= 2.3) {\n      return 'B-';\n    } else if (grade >= 2.0) {\n      return 'C+';\n    } else if (grade >= 1.7) {\n      return 'C';\n    } else if (grade >= 1.3) {\n      return 'C-';\n    } else if (grade >= 1.0) {\n      return 'D+';\n    } else if (grade >= 0.7) {\n      return 'D';\n    } else if (grade >= 0.0) {\n      return 'D-';\n    } else {\n      return 'E';\n    }\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade2 = (grades) => {\n  const letterGrades = grades.map((grade) => {\n    if (grade >= 4.0) {\n      return 'A+';\n    } else if (grade >= 3.7) {\n      return 'A';\n    } else if (grade >= 3.3) {\n      return 'A-';\n    } else if (grade >= 3.0) {\n      return 'B+';\n    } else if (grade >= 2.7) {\n      return 'B';\n    } else if (grade >= 2.3) {\n      return 'B-';\n    } else if (grade >= 2.0) {\n      return 'C+';\n    } else if (grade >= 1.7) {\n      return 'C';\n    } else if (grade >= 1.3) {\n      return 'C-';\n    } else if (grade >= 1.0) {\n      return 'D+';\n    } else if (grade >= 0.7) {\n      return 'D';\n    } else if (grade >= 0.0) {\n      return 'D-';\n    } else {\n      return 'E';\n    }\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade3 = (grades) => {\n  const letterGrades = grades.map((grade) => {\n    if (grade >= 4.0) {\n      return 'A+';\n    } else if (grade >= 3.7) {\n      return 'A';\n    } else if (grade >= 3.3) {\n      return 'A-';\n    } else if (grade >= 3.0) {\n      return 'B+';\n    } else if (grade >= 2.7) {\n      return 'B';\n    } else if (grade >= 2.3) {\n      return 'B-';\n    } else if (grade >= 2.0) {\n      return 'C+';\n    } else if (grade >= 1.7) {\n      return 'C';\n    } else if (grade >= 1.3) {\n      return 'C-';\n    } else if (grade >= 1.0) {\n      return 'D+';\n    } else if (grade >= 0.7) {\n      return 'D';\n    } else if (grade >= 0.0) {\n      return 'D-';\n    } else {\n      return 'E';\n    }\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade4 = (grades) => {\n  const letterGrades = grades.map((grade) => {\n    if (grade >= 4.0) {\n      return 'A+';\n    } else if (grade >= 3.7) {\n      return 'A';\n    } else if (grade >= 3.3) {\n      return 'A-';\n    } else if (grade >= 3.0) {\n      return 'B+';\n    } else if (grade >= 2.7) {\n      return 'B';\n    } else if (grade >= 2.3) {\n      return 'B-';\n    } else if (grade >= 2.0) {\n      return 'C+';\n    } else if (grade >= 1.7) {\n      return 'C';\n    } else if (grade >= 1.3) {\n      return 'C-';\n    } else if (grade >= 1.0) {\n      return 'D+';\n    } else if (grade >= 0.7) {\n      return 'D';\n    } else if ("}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "gc": "<|endoftext|>/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let prime = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (i % 2 === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 3 or false otherwise\n  Examples\n  divisibleBy3('Hello') == true\n  divisibleBy3('kittens') == true\n  divisibleBy3('orange') == false\n  */\nconst divisibleBy3 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (i % 3 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 5 or false otherwise\n  Examples\n  divisibleBy5('Hello') == true\n  divisibleBy5('kittens') == true\n  divisibleBy5('orange') == false\n  */\nconst divisibleBy5 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (i % 5 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 7 or false otherwise\n  Examples\n  divisibleBy7('Hello') == true\n  divisibleBy7('kittens') == true\n  divisibleBy7('orange') == false\n  */\nconst divisibleBy7 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (i % 7 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 9 or false otherwise\n  Examples\n  divisibleBy9('Hello') == true\n  divisibleBy9('kittens') == true\n  divisibleBy9('orange') == false\n  */\nconst divisibleBy9 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (i % 9 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 11 or false otherwise\n  Examples\n  divisibleBy11('Hello') == true\n  divisibleBy11('kittens') == true\n  divisibleBy11('orange') == false\n  */\nconst divisibleBy11 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (i % 11 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 13 or false otherwise\n  Examples\n  divisibleBy13('Hello') == true\n  divisibleBy13('kittens') == true\n  divisibleBy13('orange') == false\n  */\nconst divisibleBy13 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (i % 13 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 15 or false otherwise\n  Examples\n  divisibleBy15('Hello') == true\n  divisibleBy15('kittens') == true\n  divisibleBy15('orange') == false\n  */\nconst divisibleBy15 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (i % 15 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 17 or false otherwise\n  Examples\n  divisibleBy17('Hello') == true\n  divisibleBy17('kittens') == true\n  divisibleBy17('orange') == false\n  */\nconst divisibleBy17 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (i % 17 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 19 or false otherwise\n  Examples\n  divisibleBy19('Hello') == true\n  divisibleBy19('kittens') == true\n  divisibleBy19('orange') == false\n  */\nconst divisibleBy19 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (i % 19 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 21 or false otherwise\n  Examples\n  divisibleBy21('Hello') == true\n  divisibleBy21('kittens') == true\n  divisibleBy21('orange') == false\n  */\nconst divisibleBy21 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (i % 21 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 23 or false otherwise\n  Examples\n  divisibleBy23('Hello') == true\n  divisibleBy23('kittens') == true\n  divisibleBy23('orange') == false\n  */\nconst divisibleBy23 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (i % 23 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 25 or false otherwise\n  Examples\n  divisibleBy25('Hello') == true\n  divisibleBy25('kittens') == true\n  divisibleBy25('orange') == false\n  */\nconst divisibleBy25 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (i % 25 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 27 or false otherwise\n  Examples\n  divisibleBy27('Hello') == true\n  divisibleBy27('kittens') == true\n  divisibleBy27('orange') == false\n  */\nconst divisibleBy27 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (i % 27 === 0) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 29 or false otherwise\n  Examples\n  divisibleBy29('Hello') == true\n  divisibleBy29('kittens') == true\n  divisibleBy29('"}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "gc": "<|endoftext|>/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst endsOneStarts = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 0.\n  */\nconst endsZeroStarts = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst endsOneEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 0.\n  */\nconst endsZeroEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst isEven = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count % 2 === 0;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 0.\n  */\nconst isOdd = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count % 2!== 0;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst isZero = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count === 0;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 0.\n  */\nconst isOne = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count === 1;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst isTwo = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count === 2;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 0.\n  */\nconst isThree = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count === 3;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst isFour = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count === 4;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 0.\n  */\nconst isFive = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count === 5;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst isSix = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count === 6;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 0.\n  */\nconst isSeven = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count === 7;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst isEight = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count === 8;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 0.\n  */\nconst isNine = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count === 9;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst isTen = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % i === 0) {\n      count += j;\n    }\n    i += 1;\n    j"}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "gc": "<|endoftext|>/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  let binary = binary.padStart(N, \"0\");\n  let binary = binary.padEnd(N, \"0\");\n  \n  for (let i = binary.length - 1; i >= 0; i--) {\n    sum += parseInt(binary.charAt(i));\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let decimal = \"\";\n  let decimal = decimal.padStart(N, \"0\");\n  let decimal = decimal.padEnd(N, \"0\");\n  \n  for (let i = decimal.length - 1; i >= 0; i--) {\n    sum += parseInt(decimal.charAt(i));\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let hexadecimal = \"\";\n  let hexadecimal = hexadecimal.padStart(N, \"0\");\n  let hexadecimal = hexadecimal.padEnd(N, \"0\");\n  \n  for (let i = hexadecimal.length - 1; i >= 0; i--) {\n    sum += parseInt(hexadecimal.charAt(i));\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in octal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of octal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let octal = \"\";\n  let octal = octal.padStart(N, \"0\");\n  let octal = octal.padEnd(N, \"0\");\n  \n  for (let i = octal.length - 1; i >= 0; i--) {\n    sum += parseInt(octal.charAt(i));\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let hexadecimal = \"\";\n  let hexadecimal = hexadecimal.padStart(N, \"0\");\n  let hexadecimal = hexadecimal.padEnd(N, \"0\");\n  \n  for (let i = hexadecimal.length - 1; i >= 0; i--) {\n    sum += parseInt(hexadecimal.charAt(i));\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in octal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of octal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let octal = \"\";\n  let octal = octal.padStart(N, \"0\");\n  let octal = octal.padEnd(N, \"0\");\n  \n  for (let i = octal.length - 1; i >= 0; i--) {\n    sum += parseInt(octal.charAt(i));\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let hexadecimal = \"\";\n  let hexadecimal = hexadecimal.padStart(N, \"0\");\n  let hexadecimal = hexadecimal.padEnd(N, \"0\");\n  \n  for (let i = hexadecimal.length - 1; i >= 0; i--) {\n    sum += parseInt(hexadecimal.charAt(i));\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let decimal = \"\";\n  let decimal = decimal.padStart(N, \"0\");\n  let decimal = decimal.padEnd(N, \"0\");\n  \n  for (let i = decimal.length - 1; i >= 0; i--) {\n    sum += parseInt(decimal.charAt(i));\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\"."}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "gc": "<|endoftext|>/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd > 0 && lst[odd] % 2 === 0) {\n    even++;\n    odd--;\n  }\n  return even + lst[even];\n};\n\n/*Given a non-empty list of integers lst. return the maximum element in the list..\n\n\n  Examples:\n      max([4, 2, 6, 7]) ==> 7\n  */\nconst max = (lst) => {\n  let max = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  return max;\n};\n\n/*Given a non-empty list of integers lst. return the minimum element in the list..\n\n\n  Examples:\n      min([4, 2, 6, 7]) ==> 4\n  */\nconst min = (lst) => {\n  let min = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i];\n    }\n  }\n  return min;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all elements in the list..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 10\n  */\nconst sum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all elements in the list that are even..\n\n\n  Examples:\n      evenSum([4, 2, 6, 7]) ==> 2\n  */\nconst evenSum = (lst) => {\n  let evenSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      evenSum += lst[i];\n    }\n  }\n  return evenSum;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all elements in the list that are odd.. \n\n\n  Examples:\n      oddSum([4, 2, 6, 7]) ==> 4\n  */\nconst oddSum = (lst) => {\n  let oddSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      oddSum += lst[i];\n    }\n  }\n  return oddSum;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all elements in the list that are divisible by 3..\n\n\n  Examples:\n      divisibleBy3([4, 2, 6, 7]) ==> 2\n  */\nconst divisibleBy3 = (lst) => {\n  let divisibleSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      divisibleSum += lst[i];\n    }\n  }\n  return divisibleSum;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all elements in the list that are divisible by 5..\n\n\n  Examples:\n      divisibleBy5([4, 2, 6, 7]) ==> 4\n  */\nconst divisibleBy5 = (lst) => {\n  let divisibleSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 5 === 0) {\n      divisibleSum += lst[i];\n    }\n  }\n  return divisibleSum;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all elements in the list that are divisible by 7..\n\n\n  Examples:\n      divisibleBy7([4, 2, 6, 7]) ==> 6\n  */\nconst divisibleBy7 = (lst) => {\n  let divisibleSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 7 === 0) {\n      divisibleSum += lst[i];\n    }\n  }\n  return divisibleSum;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all elements in the list that are divisible by 11..\n\n\n  Examples:\n      divisibleBy11([4, 2, 6, 7]) ==> 12\n  */\nconst divisibleBy11 = (lst) => {\n  let divisibleSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 11 === 0) {\n      divisibleSum += lst[i];\n    }\n  }\n  return divisibleSum;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all elements in the list that are divisible by 13..\n\n\n  Examples:\n      divisibleBy13([4, 2, 6, 7]) ==> 14\n  */\nconst divisibleBy13 = (lst) => {\n  let divisibleSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 13 === 0) {\n      divisibleSum += lst[i];\n    }\n  }\n  return divisibleSum;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all elements in the list that are divisible by 17..\n\n\n  Examples:\n      divisibleBy17([4, 2, 6, 7]) ==> 18\n  */\nconst divisibleBy17 = (lst) => {\n  let divisibleSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 17 === 0) {\n      divisibleSum += lst[i];\n    }\n  }\n  return divisibleSum;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all elements in the list that are divisible by 19..\n\n\n  Examples:\n      divisibleBy19([4, 2, 6, 7]) ==> 20\n  */\nconst divisibleBy19 = (lst) => {\n  let divisibleSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 19 === 0) {\n      divisibleSum += lst[i];\n    }\n  }\n  return divisibleSum;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all elements in the list that are divisible by 21..\n\n\n  Examples:\n      divisibleBy21([4, 2, 6, 7]) ==> 22\n  */\nconst divisibleBy21 = (lst) => {\n  let divisibleSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 21 === 0) {\n      divisibleSum += lst[i];\n    }\n  }\n  return divisibleSum;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all elements in the list that are divisible by 23..\n\n\n  Examples:\n      divisibleBy23([4, 2, 6, 7]) ==> 24\n  */\nconst divisibleBy23 = (lst) => {\n  let divisibleSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 23 === 0) {\n      divisibleSum += lst[i];\n    }\n  }\n  return divisibleSum;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all elements in the list that are divisible by 25..\n\n\n  Examples:\n      divisibleBy25([4, 2, 6, 7]) ==> 26\n  */\nconst divisibleBy25 = (lst) => {\n  let divisibleSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 25 === 0) {\n      divisibleSum += lst[i];\n    }\n  }\n  return divisibleSum;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all elements in the list that are divisible by 27..\n\n\n  Examples:\n      divisibleBy27([4, 2, 6, 7]) ==> 28\n  */\nconst divisibleBy27 = (lst) => {\n  let divisibleSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 27 === 0) {\n      divisibleSum += lst[i];\n    }\n  }\n  return divisibleSum;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all elements in the list that are divisible by 29..\n\n\n  Examples:\n      divisibleBy29([4, 2, 6, 7]) ==> 30\n  */\nconst divisibleBy29 = (lst) => {\n  let divisibleSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 29 === 0) {\n      divisibleSum += lst[i];"}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "gc": "<|endoftext|>/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));\n  words.forEach((word) => {\n    newStr += word;\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle2 = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));\n  words.forEach((word) => {\n    newStr += word;\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle3 = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));\n  words.forEach((word) => {\n    newStr += word;\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle4 = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));\n  words.forEach((word) => {\n    newStr += word;\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle5 = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));\n  words.forEach((word) => {\n    newStr += word;\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle6 = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));\n  words.forEach((word) => {\n    newStr += word;\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle7 = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));\n  words.forEach((word) => {\n    newStr += word;\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle8 = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));\n  words.forEach((word) => {\n    newStr += word;\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle9 = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));\n  words.forEach((word) => {\n    newStr += word;\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replace"}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  let row = []\n  let rowIndex = 0\n  let colIndex = 0\n  let rowLen = lst[0].length\n  let colLen = lst.length\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let colIndexMax = colLen - 1\n  let rowIndexMin = 0\n  let colIndexMin = 0\n  let rowIndexMax = rowLen - 1\n  let col"}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "gc": "<|endoftext|>/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sorted = array.sort((a, b) => a - b);\n  return sorted;\n};\n\n/**\n * Given an array of non-negative integers, return its sum.\n\n  Example:\n  * sumArray([3, -1, 2, -4]) => 10\n  * sumArray([3, -1, 2, -4, -5]) => 15\n  * sumArray([3, -1, 2, -4, -5, -6, -7, -8, -9]) => 15\n  */\nconst sumArray = (array) => {\n  let sum = 0;\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  return sum;\n};\n\n/**\n * Given an array of non-negative integers, return its maximum value.\n\n  Example:\n  * maxArray([3, -1, 2, -4]) => 4\n  * maxArray([3, -1, 2, -4, -5]) => 5\n  * maxArray([3, -1, 2, -4, -5, -6, -7, -8, -9]) => 9\n  */\nconst maxArray = (array) => {\n  let max = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] > max) {\n      max = array[i];\n    }\n  }\n  return max;\n};\n\n/**\n * Given an array of non-negative integers, return its minimum value.\n\n  Example:\n  * minArray([3, -1, 2, -4]) => -3\n  * minArray([3, -1, 2, -4, -5]) => -2\n  * minArray([3, -1, 2, -4, -5, -6, -7, -8, -9]) => -2\n  */\nconst minArray = (array) => {\n  let min = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] < min) {\n      min = array[i];\n    }\n  }\n  return min;\n};\n\n/**\n * Given an array of non-negative integers, return its average value.\n\n  Example:\n  * avgArray([3, -1, 2, -4]) => 1.5\n  * avgArray([3, -1, 2, -4, -5]) => 1.5\n  * avgArray([3, -1, 2, -4, -5, -6, -7, -8, -9]) => 1.5\n  */\nconst avgArray = (array) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/**\n * Given an array of non-negative integers, return its median value.\n\n  Example:\n  * medianArray([3, -1, 2, -4]) => 3\n  * medianArray([3, -1, 2, -4, -5]) => 2\n  * medianArray([3, -1, 2, -4, -5, -6, -7, -8, -9]) => 2\n  */\nconst medianArray = (array) => {\n  let sortedArray = sortArray(array);\n  let middle = Math.floor(sortedArray.length / 2);\n  let left = sortedArray.slice(0, middle);\n  let right = sortedArray.slice(middle, sortedArray.length);\n  return median(left, right);\n};\n\n/**\n * Given an array of non-negative integers, return its mode value.\n\n  Example:\n  * modeArray([3, -1, 2, -4]) => 4\n  * modeArray([3, -1, 2, -4, -5]) => 5\n  * modeArray([3, -1, 2, -4, -5, -6, -7, -8, -9]) => 4\n  */\nconst modeArray = (array) => {\n  let sortedArray = sortArray(array);\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < sortedArray.length; i++) {\n    if (sortedArray[i] > sortedArray[count]) {\n      mode++;\n      count++;\n    }\n  }\n  return mode;\n};\n\n/**\n * Given an array of non-negative integers, return its median absolute value.\n\n  Example:\n  * medianAbsoluteArray([3, -1, 2, -4]) => 4\n  * medianAbsoluteArray([3, -1, 2, -4, -5]) => 5\n  * medianAbsoluteArray([3, -1, 2, -4, -5, -6, -7, -8, -9]) => 4\n  */\nconst medianAbsoluteArray = (array) => {\n  let sortedArray = sortArray(array);\n  let median = 0;\n  let count = 0;\n  for (let i = 0; i < sortedArray.length; i++) {\n    if (sortedArray[i] > median) {\n      median = sortedArray[i];\n      count++;\n    }\n  }\n  return median;\n};\n\n/**\n * Given an array of non-negative integers, return its mode absolute value.\n\n  Example:\n  * modeAbsoluteArray([3, -1, 2, -4]) => 4\n  * modeAbsoluteArray([3, -1, 2, -4, -5]) => 5\n  * modeAbsoluteArray([3, -1, 2, -4, -5, -6, -7, -8, -9]) => 4\n  */\nconst modeAbsoluteArray = (array) => {\n  let sortedArray = sortArray(array);\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < sortedArray.length; i++) {\n    if (sortedArray[i] > sortedArray[count]) {\n      mode++;\n      count++;\n    }\n  }\n  return mode;\n};\n\n/**\n * Given an array of non-negative integers, return its median relative value.\n\n  Example:\n  * medianRelativeArray([3, -1, 2, -4]) => 4\n  * medianRelativeArray([3, -1, 2, -4, -5]) => 5\n  * medianRelativeArray([3, -1, 2, -4, -5, -6, -7, -8, -9]) => 4\n  */\nconst medianRelativeArray = (array) => {\n  let sortedArray = sortArray(array);\n  let median = 0;\n  let count = 0;\n  for (let i = 0; i < sortedArray.length; i++) {\n    if (sortedArray[i] > median) {\n      median = sortedArray[i];\n      count++;\n    }\n  }\n  return median / sortedArray.length;\n};\n\n/**\n * Given an array of non-negative integers, return its mode relative value.\n\n  Example:\n  * modeRelativeArray([3, -1, 2, -4]) => 4\n  * modeRelativeArray([3, -1, 2, -4, -5]) => 5\n  * modeRelativeArray([3, -1, 2, -4, -5, -6, -7, -8, -9]) => 4\n  */\nconst modeRelativeArray = (array) => {\n  let sortedArray = sortArray(array);\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < sortedArray.length; i++) {\n    if (sortedArray[i] > sortedArray[count]) {\n      mode++;\n      count++;\n    }\n  }\n  return mode / sortedArray.length;\n};\n\n/**\n * Given an array of non-negative integers, return its mode absolute value.\n\n  Example:\n  * modeAbsoluteArray([3, -1, 2, -4]) => 4\n  * modeAbsoluteArray([3, -1, 2, -4, -5]) => 5\n  * modeAbsoluteArray([3, -1, 2, -4, -5, -6, -7, -8, -9]) => 4\n  */\nconst modeAbsoluteArray = (array) => {\n  let sortedArray = sortArray(array);\n  let mode = 0;\n  let count = 0;\n  for (let i = 0; i < sortedArray.length; i++) {\n    if (sortedArray[i] > sortedArray[count]) {\n      mode++;\n      count++;\n    }\n  }\n  return mode / sortedArray.length;\n};\n\n/**\n * Given an array of non-negative integers, return its mode relative value.\n\n  Example:\n  * modeRelativeArray([3, -1, 2, -4]) => 4\n  * modeRelativeArray([3, -1, 2, -4, -5]) => 5\n  * modeRelativeArray([3, -1, 2, -4, -5, -6, -7, -8, -9]) => 4\n  */\nconst modeRelativeArray = (array"}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "gc": "<|endoftext|>/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  let j = 0\n  let len = alphabet.length\n  \n  for(let i = 0; i < s.length; i++) {\n    let c = alphabet.indexOf(s[i])\n    \n    for(let j = 0; j < len; j++) {\n      rotated += alphabet[j] + alphabet[c - j]\n    }\n  }\n  \n  return rotated\n}\n\n/*Create a function decrypt that takes a string as an argument and\n  returns a string decrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  let j = 0\n  let len = alphabet.length\n  \n  for(let i = 0; i < s.length; i++) {\n    let c = alphabet.indexOf(s[i])\n    \n    for(let j = 0; j < len; j++) {\n      rotated += alphabet[j] + alphabet[c + j]\n    }\n  }\n  \n  return rotated\n}\n\n/*Create a function rotate that takes a string as an argument and\n  returns a string rotated with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  rotate('hi') returns 'hi'\n  rotate('asdfghjkl') returns 'asdfghjkl'\n  rotate('gf') returns 'gfghjkl'\n  rotate('et') returns 'et'\n  */\nconst rotate = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  let j = 0\n  let len = alphabet.length\n  \n  for(let i = 0; i < s.length; i++) {\n    let c = alphabet.indexOf(s[i])\n    \n    for(let j = 0; j < len; j++) {\n      rotated += alphabet[j] + alphabet[c + j]\n    }\n  }\n  \n  return rotated\n}\n\n/*Create a function reverse that takes a string as an argument and\n  returns a string reversed with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  reverse('hi') returns 'asdfghjkl'\n  reverse('asdfghjkl') returns 'hi'\n  reverse('gf') returns 'gfghjkl'\n  reverse('et') returns 'et'\n  */\nconst reverse = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  let j = 0\n  let len = alphabet.length\n  \n  for(let i = 0; i < s.length; i++) {\n    let c = alphabet.indexOf(s[i])\n    \n    for(let j = 0; j < len; j++) {\n      rotated += alphabet[j] + alphabet[c + j]\n    }\n  }\n  \n  return rotated\n}\n\n/*Create a function shuffle that takes a string as an argument and\n  returns a string shuffled with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  shuffle('hi') returns 'asdfghjkl'\n  shuffle('asdfghjkl') returns 'hi'\n  shuffle('gf') returns 'gfghjkl'\n  shuffle('et') returns 'et'\n  */\nconst shuffle = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  let j = 0\n  let len = alphabet.length\n  \n  for(let i = 0; i < s.length; i++) {\n    let c = alphabet.indexOf(s[i])\n    \n    for(let j = 0; j < len; j++) {\n      rotated += alphabet[j] + alphabet[c + j]\n    }\n  }\n  \n  return rotated\n}\n\n/*Create a function reverse that takes a string as an argument and\n  returns a string reversed with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  reverse('hi') returns 'asdfghjkl'\n  reverse('asdfghjkl') returns 'hi'\n  reverse('gf') returns 'gfghjkl'\n  reverse('et') returns 'et'\n  */\nconst reverse = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  let j = 0\n  let len = alphabet.length\n  \n  for(let i = 0; i < s.length; i++) {\n    let c = alphabet.indexOf(s[i])\n    \n    for(let j = 0; j < len; j++) {\n      rotated += alphabet[j] + alphabet[c + j]\n    }\n  }\n  \n  return rotated\n}\n\n/*Create a function shuffle that takes a string as an argument and\n  returns a string shuffled with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  shuffle('hi') returns 'asdfghjkl'\n  shuffle('asdfghjkl') returns 'hi'\n  shuffle('gf') returns 'gfghjkl'\n  shuffle('et') returns 'et'\n  */\nconst shuffle = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  let j = 0\n  let len = alphabet.length\n  \n  for(let i = 0; i < s.length; i++) {\n    let c = alphabet.indexOf(s[i])\n    \n    for(let j = 0; j < len; j++) {\n      rotated += alphabet[j] + alphabet[c + j]\n    }\n  }\n  \n  return rotated\n}\n\n/*Create a function shuffle that takes a string as an argument and\n  returns a string shuffled with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  shuffle('hi') returns 'asdfghjkl'\n  shuffle('asdfghjkl') returns 'hi'\n  shuffle('gf') returns 'gfghjkl'\n  shuffle('et') returns 'et'\n  */\nconst shuffle = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let rotated = ''\n  let i = 0\n  let j = 0\n  let len = alphabet.length\n  \n  for(let i = 0; i < s.length; i++) {\n    let c = alphabet.indexOf(s[i])\n    \n    for(let j = 0; j < len; j++) {\n      rotated += alphabet[j] + alphabet[c + j]\n    }\n  }\n  \n  return rotated\n}\n\n/*Create a function shuffle that takes a string as an argument and\n  returns a string shuffled with the alphabet being rot"}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "gc": "<|endoftext|>/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || min > lst[i]) {\n      min = lst[i];\n      minIndex = i;\n    }\n  }\n  \n  return minIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextLargest() that returns the 1st largest element of the list.\n  Return null if there is no such element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 3\n  nextLargest([5, 1, 4, 3, 2]) == 3\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\nconst nextLargest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || max < lst[i]) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  \n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextHighest() that returns the highest element of the list.\n  Return null if there is no such element.\n  \n  nextHighest([1, 2, 3, 4, 5]) == 5\n  nextHighest([5, 1, 4, 3, 2]) == 5\n  nextHighest([]) == null\n  nextHighest([1, 1]) == null\n  */\nconst nextHighest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || max > lst[i]) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  \n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextHighest() that returns the lowest element of the list.\n  Return null if there is no such element.\n  \n  nextHighest([1, 2, 3, 4, 5]) == 1\n  nextHighest([5, 1, 4, 3, 2]) == 1\n  nextHighest([]) == null\n  nextHighest([1, 1]) == null\n  */\nconst nextHighest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || min < lst[i]) {\n      min = lst[i];\n      minIndex = i;\n    }\n  }\n  \n  return minIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextHighest() that returns the 2nd highest element of the list.\n  Return null if there is no such element.\n  \n  nextHighest([1, 2, 3, 4, 5]) == 4\n  nextHighest([5, 1, 4, 3, 2]) == 4\n  nextHighest([]) == null\n  nextHighest([1, 1]) == null\n  */\nconst nextHighest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || max < lst[i]) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  \n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextHighest() that returns the 3rd highest element of the list.\n  Return null if there is no such element.\n  \n  nextHighest([1, 2, 3, 4, 5]) == 5\n  nextHighest([5, 1, 4, 3, 2]) == 5\n  nextHighest([]) == null\n  nextHighest([1, 1]) == null\n  */\nconst nextHighest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || max > lst[i]) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  \n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextHighest() that returns the 4th highest element of the list.\n  Return null if there is no such element.\n  \n  nextHighest([1, 2, 3, 4, 5]) == 5\n  nextHighest([5, 1, 4, 3, 2]) == 5\n  nextHighest([]) == null\n  nextHighest([1, 1]) == null\n  */\nconst nextHighest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || max < lst[i]) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  \n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextHighest() that returns the 5th highest element of the list.\n  Return null if there is no such element.\n  \n  nextHighest([1, 2, 3, 4, 5]) == 5\n  nextHighest([5, 1, 4, 3, 2]) == 5\n  nextHighest([]) == null\n  nextHighest([1, 1]) == null\n  */\nconst nextHighest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || max > lst[i]) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  \n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextHighest() that returns the 6th highest element of the list.\n  Return null if there is no such element.\n  \n  nextHighest([1, 2, 3, 4, 5]) == 5\n  nextHighest([5, 1, 4, 3, 2]) == 5\n  nextHighest([]) == null\n  nextHighest([1, 1]) == null\n  */\nconst nextHighest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || max < lst[i]) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  \n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextHighest() that returns the 7th highest element of the list.\n  Return null if there is no such element.\n  \n  nextHighest([1, 2, 3, 4, 5]) == 5\n  nextHighest([5, 1, 4, 3, 2]) == 5\n  nextHighest([]) == null\n  nextHighest([1, 1]) == null\n  */\nconst nextHighest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || max > lst[i]) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  \n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextHighest() that returns the 8th highest element of the list.\n  Return null if there is no such element.\n  \n  nextHighest([1, 2, 3, 4, 5]) == 5\n  nextHighest([5, 1, 4, 3, 2]) == 5\n  nextHighest([]) == null\n  nextHighest([1, 1]) == null\n  */\nconst nextHighest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || max < lst[i]) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  \n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextHighe"}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "gc": "<|endoftext|>/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') bored++;\n  });\n  return bored;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of violences. A violence is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isViolent(\"Hello world\")\n  0\n  >>> isViolent(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isViolent = (S) => {\n  let violent = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') violent++;\n  });\n  return violent;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of despairs. A despair is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isDespair(\"Hello world\")\n  0\n  >>> isDespair(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isDespair = (S) => {\n  let despair = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') despair++;\n  });\n  return despair;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of fears. A fear is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isFear(\"Hello world\")\n  0\n  >>> isFear(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isFear = (S) => {\n  let fear = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') fear++;\n  });\n  return fear;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of surprises. A surprise is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isSurprise(\"Hello world\")\n  0\n  >>> isSurprise(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isSurprise = (S) => {\n  let surprise = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') surprise++;\n  });\n  return surprise;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of angers. An anger is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isAnger(\"Hello world\")\n  0\n  >>> isAnger(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isAnger = (S) => {\n  let anger = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') anger++;\n  });\n  return anger;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of disgusts. A disgust is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isDisgust (\"Hello world\")\n  0\n  >>> isDisgust (\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isDisgust = (S) => {\n  let disgust = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') disgust++;\n  });\n  return disgust;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of surprises. A surprise is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isSurprise(\"Hello world\")\n  0\n  >>> isSurprise(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isSurprise = (S) => {\n  let surprise = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') surprise++;\n  });\n  return surprise;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of fears. A fear is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isFear(\"Hello world\")\n  0\n  >>> isFear(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isFear = (S) => {\n  let fear = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') fear++;\n  });\n  return fear;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of surprises. A surprise is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isSurprise(\"Hello world\")\n  0\n  >>> isSurprise(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isSurprise = (S) => {\n  let surprise = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') surprise++;\n  });\n  return surprise;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of angers. An anger is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isAnger(\"Hello world\")\n  0\n  >>> isAnger(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isAnger = (S) => {\n"}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "gc": "<|endoftext|>/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return x === y && x === z;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7) ➞ true\n  allInt(3, 2, 2) ➞ false\n  allInt(3, -2, 1) ➞ true\n  allInt(3.6, -2.2, 2) ➞ false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return x === y && x === z;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7) ➞ true\n  allInt(3, 2, 2) ➞ false\n  allInt(3, -2, 1) ➞ true\n  allInt(3.6, -2.2, 2) ➞ false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return x === y && x === z;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7) ➞ true\n  allInt(3, 2, 2) ➞ false\n  allInt(3, -2, 1) ➞ true\n  allInt(3.6, -2.2, 2) ➞ false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return x === y && x === z;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7) ➞ true\n  allInt(3, 2, 2) ➞ false\n  allInt(3, -2, 1) ➞ true\n  allInt(3.6, -2.2, 2) ➞ false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return x === y && x === z;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7) ➞ true\n  allInt(3, 2, 2) ➞ false\n  allInt(3, -2, 1) ➞ true\n  allInt(3.6, -2.2, 2) ➞ false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return x === y && x === z;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7) ➞ true\n  allInt(3, 2, 2) ➞ false\n  allInt(3, -2, 1) ➞ true\n  allInt(3.6, -2.2, 2) ➞ false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return x === y && x === z;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7) ➞ true\n  allInt(3, 2, 2) ➞ false\n  allInt(3, -2, 1) ➞ true\n  allInt(3.6, -2.2, 2) ➞ false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return x === y && x === z;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7) ➞ true\n  allInt(3, 2, 2) ➞ false\n  allInt(3, -2, 1) ➞ true\n  allInt(3.6, -2.2, 2) ➞ false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return x === y && x === z;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7) ➞ true\n  allInt(3, 2, 2) ➞ false\n  allInt(3, -2, 1) ➞ true\n  allInt(3.6, -2.2, 2) ➞ false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return x === y && x === z;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7) ➞ true\n  allInt(3, 2, 2) ➞ false\n  allInt(3, -2, 1) ➞ true\n  allInt(3.6, -2.2, 2) ➞ false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return x === y && x === z;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7) ➞ true\n  allInt(3, 2, 2) ➞ false\n  allInt(3, -2, 1) ➞ true\n  allInt(3.6, -2.2, 2) ➞ false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return x === y && x === z;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7) ➞ true\n  allInt(3, 2, 2) ➞ false\n  allInt(3, -2, 1) ➞ true\n  allInt(3.6, -2.2, 2) ➞ false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false;\n  }\n  return x === y && x === z;\n};\n\n/* "}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "gc": "<|endoftext|>/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = '';\n  let vowels = 'aeiouAEIOU';\n  let vowelsLength = vowels.length;\n  let messageLength = message.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;"}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "gc": "<|endoftext|>/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let max = 0;\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n"}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "gc": "<|endoftext|>/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  for (let key in dict) {\n    if (typeof dict[key] ==='string') {\n      if (dict[key].toLowerCase() === dict[key].toUpperCase()) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  Given a string, return true if all characters are digits, else return false.\n  The function should return false is the given string is empty.\n  Examples:\n  checkStringCase(\"123\") should return false.\n  checkStringCase(\"abc\") should return false.\n  checkStringCase(\"a\") should return false.\n  checkStringCase(\"a123\") should return false.\n  checkStringCase(\"a123abc\") should return false.\n  checkStringCase(\"a123abc123\") should return false.\n  checkStringCase(\"a123abc123abc\") should return false.\n  checkStringCase(\"a123abc123abc123\") should return false.\n  checkStringCase(\"a123abc123abc123abc\") should return false.\n  checkStringCase(\"a123abc123abc123abc123\") should return false.\n  checkStringCase(\"a123abc123abc123abc123abc123\") should return false.\n  checkStringCase(\"a123abc123abc123abc123abc123abc123abc123\") should return false.\n  checkStringCase(\"a123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123"}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "gc": "<|endoftext|>/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let prime = true;\n  while (prime) {\n    if (primes[i] === true) {\n      primes[j] = true;\n      j++;\n    }\n    if (primes[j] === true) {\n      primes[k] = true;\n      k++;\n    }\n    if (primes[k] === true) {\n      prime = false;\n    }\n    i++;\n    j++;\n    k++;\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the integers\n  that are prime numbers and less than n.\n  for example:\n  primeNumbers(5) => [2,3]\n  primeNumbers(11) => [2,3,5,7]\n  primeNumbers(0) => []\n  primeNumbers(20) => [2,3,5,7,11,13,17,19]\n  primeNumbers(1) => []\n  primeNumbers(18) => [2,3,5,7,11,13,17]\n  */\nconst primeNumbers = (num) => {\n  let primes = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let prime = true;\n  while (prime) {\n    if (primes[i] === true) {\n      primes[j] = true;\n      j++;\n    }\n    if (primes[j] === true) {\n      primes[k] = true;\n      k++;\n    }\n    if (primes[k] === true) {\n      prime = false;\n    }\n    i++;\n    j++;\n    k++;\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the integers\n  that are prime numbers and less than n.\n  for example:\n  primeNumbers(5) => [2,3]\n  primeNumbers(11) => [2,3,5,7]\n  primeNumbers(0) => []\n  primeNumbers(20) => [2,3,5,7,11,13,17,19]\n  primeNumbers(1) => []\n  primeNumbers(18) => [2,3,5,7,11,13,17]\n  */\nconst primeFactors = (num) => {\n  let primes = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let prime = true;\n  while (prime) {\n    if (primes[i] === true) {\n      primes[j] = true;\n      j++;\n    }\n    if (primes[j] === true) {\n      primes[k] = true;\n      k++;\n    }\n    if (primes[k] === true) {\n      prime = false;\n    }\n    i++;\n    j++;\n    k++;\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the integers\n  that are prime numbers and less than n.\n  for example:\n  primeFactors(5) => [2,3]\n  primeFactors(11) => [2,3,5,7]\n  primeFactors(0) => []\n  primeFactors(20) => [2,3,5,7,11,13,17,19]\n  primeFactors(1) => []\n  primeFactors(18) => [2,3,5,7,11,13,17]\n  */\nconst primeFactorsOf = (num) => {\n  let primes = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let prime = true;\n  while (prime) {\n    if (primes[i] === true) {\n      primes[j] = true;\n      j++;\n    }\n    if (primes[j] === true) {\n      primes[k] = true;\n      k++;\n    }\n    if (primes[k] === true) {\n      prime = false;\n    }\n    i++;\n    j++;\n    k++;\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the integers\n  that are prime numbers and less than n.\n  for example:\n  primeFactorsOf(5) => [2,3]\n  primeFactorsOf(11) => [2,3,5,7]\n  primeFactorsOf(0) => []\n  primeFactorsOf(20) => [2,3,5,7,11,13,17,19]\n  primeFactorsOf(1) => []\n  primeFactorsOf(18) => [2,3,5,7,11,13,17]\n  */\nconst primeFactorsOfOf = (num) => {\n  let primes = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let prime = true;\n  while (prime) {\n    if (primes[i] === true) {\n      primes[j] = true;\n      j++;\n    }\n    if (primes[j] === true) {\n      primes[k] = true;\n      k++;\n    }\n    if (primes[k] === true) {\n      prime = false;\n    }\n    i++;\n    j++;\n    k++;\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the integers\n  that are prime numbers and less than n.\n  for example:\n  primeFactorsOfOf(5) => [2,3]\n  primeFactorsOfOf(11) => [2,3,5,7]\n  primeFactorsOfOf(0) => []\n  primeFactorsOfOf(20) => [2,3,5,7,11,13,17,19]\n  primeFactorsOfOf(1) => []\n  primeFactorsOfOf(18) => [2,3,5,7,11,13,17]\n  */\nconst primeFactorsOfOf = (num) => {\n  let primes = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let prime = true;\n  while (prime) {\n    if (primes[i] === true) {\n      primes[j] = true;\n      j++;\n    }\n    if (primes[j] === true) {\n      primes[k] = true;\n      k++;\n    }\n    if (primes[k] === true) {\n      prime = false;\n    }\n    i++;\n    j++;\n    k++;\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the integers\n  that are prime numbers and less than n.\n  for example:\n  primeFactorsOfOf(5) => [2,3]\n  primeFactorsOfOf(11) => [2,3,5,7]\n  primeFactorsOfOf(0) => []\n  primeFactorsOfOf(20) => [2,3,5,7,11,13,17,19]\n  primeFactorsOfOf(1) => []\n  primeFactorsOfOf(18) => [2,3,5,7,11,13,17]\n  */\nconst primeFactorsOfOfOf = (num) => {\n  let primes = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let prime = true;\n  while (prime) {\n    if (primes[i] === true) {\n      primes[j] = true;\n      j++;\n    }\n    if (primes[j] === true) {\n      primes[k] = true;\n      k++;\n    }\n    if (primes[k] === true) {\n      prime = false;\n    }\n    i++;\n    j++;\n    k++;\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the integers\n  that are prime numbers and less than n.\n  for example:\n  primeFactorsOfOf(5) => [2,3]\n  primeFactorsOfOf(11) => [2,3,5,7]\n  primeFactorsOfOf(0) => []\n  primeFactorsOfOf(20) => [2,3,5,7,11,13,17,19]\n  primeFactorsOfOf(1) => []\n  primeFactorsOfOf(18) => [2,3,5,7,11,13,17]\n  */\nconst primeFactorsOfOfOf = (num) => {\n  let primes = [];\n  let i = 1;\n  let j = 1;\n"}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "gc": "<|endoftext|>/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let product = 1;\n  \n  if (a === 0 || b === 0) {\n    return product;\n  }\n  \n  if (a === 1) {\n    return b;\n  }\n  \n  if (b === 1) {\n    return a;\n  }\n  \n  while (b > 0) {\n    product = product * b;\n    b = b / 10;\n  }\n  \n  return product;\n};\n\n/*Complete the function that takes two integers and returns \n  the sum of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  sum(148, 412) should return 148.\n  sum(19, 28) should return 280.\n  sum(2020, 1851) should return 1851.\n  sum(14,-15) should return 14.\n  */\nconst sum = (a, b) => {\n  let sum = 0;\n  \n  if (a === 0 || b === 0) {\n    return sum;\n  }\n  \n  if (a === 1) {\n    return b;\n  }\n  \n  if (b === 1) {\n    return a;\n  }\n  \n  while (b > 0) {\n    sum = sum + b;\n    b = b / 10;\n  }\n  \n  return sum;\n};\n\n/*Complete the function that takes two integers and returns \n  the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  difference(148, 412) should return -412.\n  difference(19, 28) should return 28.\n  difference(2020, 1851) should return 1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  \n  if (a === 0 || b === 0) {\n    return difference;\n  }\n  \n  if (a === 1) {\n    return b;\n  }\n  \n  if (b === 1) {\n    return a;\n  }\n  \n  while (b > 0) {\n    difference = difference + b;\n    b = b / 10;\n  }\n  \n  return difference;\n};\n\n/*Complete the function that takes two integers and returns \n  the product of their absolute values.\n  Assume the input is always valid.\n  Examples:\n  absolute(148, 412) should return 412.\n  absolute(19, 28) should return 28.\n  absolute(2020, 1851) should return 1851.\n  absolute(14,-15) should return 14.\n  */\nconst absolute = (a, b) => {\n  let absolute = 0;\n  \n  if (a === 0 || b === 0) {\n    return absolute;\n  }\n  \n  if (a === 1) {\n    return b;\n  }\n  \n  if (b === 1) {\n    return a;\n  }\n  \n  while (b > 0) {\n    absolute = absolute + b;\n    b = b / 10;\n  }\n  \n  return absolute;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of the product of their absolute values.\n  Assume the input is always valid.\n  Examples:\n  absolute(148, 412) should return 412.\n  absolute(19, 28) should return 28.\n  absolute(2020, 1851) should return 1851.\n  absolute(14,-15) should return 14.\n  */\nconst absoluteProduct = (a, b) => {\n  let absoluteProduct = 0;\n  \n  if (a === 0 || b === 0) {\n    return absoluteProduct;\n  }\n  \n  if (a === 1) {\n    return b;\n  }\n  \n  if (b === 1) {\n    return a;\n  }\n  \n  while (b > 0) {\n    absoluteProduct = absoluteProduct + b;\n    b = b / 10;\n  }\n  \n  return absoluteProduct;\n};\n\n/*Complete the function that takes two integers and returns \n  the product of their absolute values.\n  Assume the input is always valid.\n  Examples:\n  absoluteProduct(148, 412) should return 412.\n  absoluteProduct(19, 28) should return 28.\n  absoluteProduct(2020, 1851) should return 1851.\n  absoluteProduct(14,-15) should return 14.\n  */\nconst absoluteProductOfTwoNumbers = (a, b) => {\n  let absoluteProduct = 0;\n  \n  if (a === 0 || b === 0) {\n    return absoluteProduct;\n  }\n  \n  if (a === 1) {\n    return b;\n  }\n  \n  if (b === 1) {\n    return a;\n  }\n  \n  while (b > 0) {\n    absoluteProduct = absoluteProduct + b;\n    b = b / 10;\n  }\n  \n  return absoluteProduct;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of the difference between their absolute values.\n  Assume the input is always valid.\n  Examples:\n  absoluteDifference(148, 412) should return 412.\n  absoluteDifference(19, 28) should return 28.\n  absoluteDifference(2020, 1851) should return 1851.\n  absoluteDifference(14,-15) should return 14.\n  */\nconst absoluteDifference = (a, b) => {\n  let absoluteDifference = 0;\n  \n  if (a === 0 || b === 0) {\n    return absoluteDifference;\n  }\n  \n  if (a === 1) {\n    return b;\n  }\n  \n  if (b === 1) {\n    return a;\n  }\n  \n  while (b > 0) {\n    absoluteDifference = absoluteDifference + b;\n    b = b / 10;\n  }\n  \n  return absoluteDifference;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of the product of their absolute values.\n  Assume the input is always valid.\n  Examples:\n  absoluteDifference(148, 412) should return 412.\n  absoluteDifference(19, 28) should return 28.\n  absoluteDifference(2020, 1851) should return 1851.\n  absoluteDifference(14,-15) should return 14.\n  */\nconst absoluteProductOfTwoNumbersDifference = (a, b) => {\n  let absoluteProduct = 0;\n  \n  if (a === 0 || b === 0) {\n    return absoluteProduct;\n  }\n  \n  if (a === 1) {\n    return b;\n  }\n  \n  if (b === 1) {\n    return a;\n  }\n  \n  while (b > 0) {\n    absoluteProduct = absoluteProduct + b;\n    b = b / 10;\n  }\n  \n  return absoluteProduct;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of the difference between their absolute values.\n  Assume the input is always valid.\n  Examples:\n  absoluteDifference(148, 412) should return 412.\n  absoluteDifference(19, 28) should return 28.\n  absoluteDifference(2020, 1851) should return 1851.\n  absoluteDifference(14,-15) should return 14.\n  */\nconst absoluteDifferenceOfTwoNumbers = (a, b) => {\n  let absoluteDifference = 0;\n  \n  if (a === 0 || b === 0) {\n    return absoluteDifference;\n  }\n  \n  if (a === 1) {\n    return b;\n  }\n  \n  if (b === 1) {\n    return a;\n  }\n  \n  while (b > 0) {\n    absoluteDifference = absoluteDifference + b;\n    b = b / 10;\n  }\n  \n  return absoluteDifference;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of the product of their absolute values.\n  Assume the input is always valid.\n  Examples:\n  absoluteDifference(148, 412) should return 412.\n  absoluteDifference(19, 28) should return 28.\n  absoluteDifference(2020, 1851) should return 1851.\n  absoluteDifference(14,-15) should return 14.\n  */\nconst absoluteProductOf"}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "gc": "<|endoftext|>/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  \n  while(i < l) {\n    if(s.charAt(i).toUpperCase() === 'A') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'E') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'I') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'O') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'U') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'Y') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'W') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'a') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'b') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'c') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'd') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'e') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'f') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'g') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'h') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'i') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'j') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'k') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'l') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() ==='m') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'n') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'o') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'p') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'q') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'r') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() ==='s') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 't') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'u') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'v') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'w') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'x') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'y') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'z') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'A') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'E') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'I') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'O') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'U') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'Y') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'W') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'a') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'b') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'c') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'd') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'e') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'f') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'g') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'h') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'i') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'j') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'k') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'l') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() ==='m') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'n') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'o') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'p') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'q') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'r') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() ==='s') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 't') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'u') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'v') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'w') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'x') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'y') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'z') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'A') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'E') {\n      count++;\n      i++;\n    }\n    else if(s.charAt(i).toUpperCase() === 'I') {\n      count++;\n      i++;\n    }\n"}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "gc": "<|endoftext|>/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let num;\n  let diff;\n  let result;\n\n  // If the number is equidistant from two integers, round it away\n  // from zero.\n  if (value === \"\") {\n    return value;\n  }\n\n  // If the number is less than or equal to zero, return it.\n  if (value === 0) {\n    return value;\n  }\n\n  // If the number is greater than the maximum integer, return it.\n  if (value > MAX_INTEGER) {\n    return value;\n  }\n\n  // If the number is less than the minimum integer, return it.\n  if (value < MIN_INTEGER) {\n    return value;\n  }\n\n  // If the number is equal to or greater than the maximum integer, or\n  // less than the minimum integer, return it.\n  if (value === MAX_INTEGER || value === MIN_INTEGER) {\n    return value;\n  }\n\n  // If the number is equal to or greater than the maximum integer, or\n  // less than the minimum integer, round to the nearest integer.\n  num = parseInt(value);\n  diff = num - value;\n  result = num;\n\n  // If the number is greater than the maximum integer, round it to\n  // the nearest integer.\n  if (diff > MAX_INTEGER) {\n    result = Math.round(result);\n  }\n\n  // If the number is less than the minimum integer, round it to\n  // the nearest integer.\n  if (diff < MIN_INTEGER) {\n    result = Math.round(result);\n  }\n\n  return result;\n};\n\n/**\n * Converts a value to a string in base 10.\n */\nconst toBase10 = (value) => {\n  let base;\n  let num;\n\n  // If the value is less than or equal to zero, return an empty string.\n  if (value === 0) {\n    return \"\";\n  }\n\n  // If the value is greater than the maximum value, return an empty string.\n  if (value > MAX_INTEGER) {\n    return \"\";\n  }\n\n  // If the value is less than the minimum value, return an empty string.\n  if (value < MIN_INTEGER) {\n    return \"\";\n  }\n\n  // If the value is equal to or greater than the maximum value, or equal to\n  // the minimum value, return an empty string.\n  if (value === MAX_INTEGER || value === MIN_INTEGER) {\n    return \"\";\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // the minimum value, round to the nearest integer.\n  num = parseInt(value);\n  base = num;\n\n  // If the number is greater than the maximum value, round to the nearest integer.\n  if (num > MAX_INTEGER) {\n    num = Math.round(num);\n  }\n\n  // If the number is less than the minimum value, round to the nearest integer.\n  if (num < MIN_INTEGER) {\n    num = Math.round(num);\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // the minimum value, round to the nearest integer.\n  if (num === MAX_INTEGER || num === MIN_INTEGER) {\n    return num;\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // the minimum value, round to the nearest integer.\n  base = base.toString();\n  num = num.toString();\n\n  // If the number is greater than the maximum value, round to the nearest integer.\n  if (num > MAX_INTEGER) {\n    num = Math.round(num);\n  }\n\n  // If the number is less than the minimum value, round to the nearest integer.\n  if (num < MIN_INTEGER) {\n    num = Math.round(num);\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // the minimum value, round to the nearest integer.\n  if (num === MAX_INTEGER || num === MIN_INTEGER) {\n    return num;\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // the minimum value, round to the nearest integer.\n  base = base.toString();\n  num = num.toString();\n\n  // If the number is greater than the maximum value, round to the nearest integer.\n  if (num > MAX_INTEGER) {\n    num = Math.round(num);\n  }\n\n  // If the number is less than the minimum value, round to the nearest integer.\n  if (num < MIN_INTEGER) {\n    num = Math.round(num);\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // the minimum value, round to the nearest integer.\n  if (num === MAX_INTEGER || num === MIN_INTEGER) {\n    return num;\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // the minimum value, round to the nearest integer.\n  base = base.toString();\n  num = num.toString();\n\n  // If the number is greater than the maximum value, round to the nearest integer.\n  if (num > MAX_INTEGER) {\n    num = Math.round(num);\n  }\n\n  // If the number is less than the minimum value, round to the nearest integer.\n  if (num < MIN_INTEGER) {\n    num = Math.round(num);\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // the minimum value, round to the nearest integer.\n  if (num === MAX_INTEGER || num === MIN_INTEGER) {\n    return num;\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // the minimum value, round to the nearest integer.\n  base = base.toString();\n  num = num.toString();\n\n  // If the number is greater than the maximum value, round to the nearest integer.\n  if (num > MAX_INTEGER) {\n    num = Math.round(num);\n  }\n\n  // If the number is less than the minimum value, round to the nearest integer.\n  if (num < MIN_INTEGER) {\n    num = Math.round(num);\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // the minimum value, round to the nearest integer.\n  if (num === MAX_INTEGER || num === MIN_INTEGER) {\n    return num;\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // the minimum value, round to the nearest integer.\n  base = base.toString();\n  num = num.toString();\n\n  // If the number is greater than the maximum value, round to the nearest integer.\n  if (num > MAX_INTEGER) {\n    num = Math.round(num);\n  }\n\n  // If the number is less than the minimum value, round to the nearest integer.\n  if (num < MIN_INTEGER) {\n    num = Math.round(num);\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // the minimum value, round to the nearest integer.\n  if (num === MAX_INTEGER || num === MIN_INTEGER) {\n    return num;\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // the minimum value, round to the nearest integer.\n  base = base.toString();\n  num = num.toString();\n\n  // If the number is greater than the maximum value, round to the nearest integer.\n  if (num > MAX_INTEGER) {\n    num = Math.round(num);\n  }\n\n  // If the number is less than the minimum value, round to the nearest integer.\n  if (num < MIN_INTEGER) {\n    num = Math.round(num);\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // the minimum value, round to the nearest integer.\n  if (num === MAX_INTEGER || num === MIN_INTEGER) {\n    return num;\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // the minimum value, round to the nearest integer.\n  base = base.toString();\n  num = num.toString();\n\n  // If the number is greater than the maximum value, round to the nearest integer.\n  if (num > MAX_INTEGER) {\n    num = Math.round(num);\n  }\n\n  // If the number is less than the minimum value, round to the nearest integer.\n  if (num < MIN_INTEGER) {\n    num = Math.round(num);\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // the minimum value, round to the nearest integer.\n  if (num === MAX_INTEGER || num === MIN_INTEGER) {\n    return num;\n  }\n\n  // If the number is equal to or greater than the maximum value, or equal to\n  // "}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let levels = [];\n  let level = 0;\n  while (level < n) {\n    levels.push(level);\n    level += 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let levels = [];\n  let level = 0;\n  while (level < n) {\n    levels.push(level);\n    level += 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let levels = [];\n  let level = 0;\n  while (level < n) {\n    levels.push(level);\n    level += 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let levels = [];\n  let level = 0;\n  while (level < n) {\n    levels.push(level);\n    level += 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let levels = [];\n  let level = 0;\n  while (level < n) {\n    levels.push(level);\n    level += 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let levels = [];\n  let level = 0;\n  while (level < n) {\n    levels.push(level);\n    level += 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let levels = [];\n  let level = 0;\n  while (level < n) {\n    levels.push(level);\n    level += 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let levels = [];\n  let level = 0;\n  while (level < n) {\n    levels.push(level);\n    level += 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let levels = [];\n  let level = 0;\n  while (level < n) {\n    levels.push(level);\n    level += 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let levels = [];\n  let level = 0;\n  while (level < n) {\n    levels.push(level);\n    level += 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let levels = [];\n  let level = 0;\n  while (level < n) {\n    levels.push(level);\n    level += 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number "}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "gc": "<|endoftext|>/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[,\\s\\s]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[,\\s\\s]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[,\\s\\s]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[,\\s\\s]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[,\\s\\s]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[,\\s\\s]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[,\\s\\s]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[,\\s\\s]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[,\\s\\s]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[,\\s\\s]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[,\\s\\s]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[,\\s\\s]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[,\\s\\s]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\""}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "gc": "<|endoftext|>/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const num1 = Math.floor(x / 2);\n  const num2 = Math.floor(y / 2);\n  if (num2 === num1) {\n    return -1;\n  }\n  return num2;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest odd integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const num1 = Math.floor(x / 2);\n  const num2 = Math.floor(y / 2);\n  if (num1 === num2) {\n    return -1;\n  }\n  return num1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const num1 = Math.floor(x / 2);\n  const num2 = Math.floor(y / 2);\n  if (num1 === num2) {\n    return -1;\n  }\n  return num2;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest negative integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const num1 = Math.floor(x / 2);\n  const num2 = Math.floor(y / 2);\n  if (num1 === num2) {\n    return -1;\n  }\n  return num1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const num1 = Math.floor(x / 2);\n  const num2 = Math.floor(y / 2);\n  if (num1 === num2) {\n    return -1;\n  }\n  return num2;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const num1 = Math.floor(x / 2);\n  const num2 = Math.floor(y / 2);\n  if (num1 === num2) {\n    return -1;\n  }\n  return num1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const num1 = Math.floor(x / 2);\n  const num2 = Math.floor(y / 2);\n  if (num1 === num2) {\n    return -1;\n  }\n  return num2;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const num1 = Math.floor(x / 2);\n  const num2 = Math.floor(y / 2);\n  if (num1 === num2) {\n    return -1;\n  }\n  return num1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const num1 = Math.floor(x / 2);\n  const num2 = Math.floor(y / 2);\n  if (num1 === num2) {\n    return -1;\n  }\n  return num2;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const num1 = Math.floor(x / 2);\n  const num2 = Math.floor(y / 2);\n  if (num1 === num2) {\n    return -1;\n  }\n  return num1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const num1 = Math.floor(x / 2);\n  const num2 = Math.floor(y / 2);\n  if (num1 === num2) {\n    return -1;\n  }\n  return num2;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const num1 = Math.floor(x / 2);\n  const num2 = Math.floor(y / 2);\n  if (num1 === num2) {\n    return -1;\n  }\n  return num1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const num1 = Math.floor(x / 2);\n  const num2 = Math.floor(y / 2);\n  if (num1 === num2) {\n    return -1;\n  }\n  return num1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const num1 = Math.floor(x / 2);\n  const num2 = Math.floor(y / 2);\n  if (num1 === num2) {\n    return -1;\n  }\n  return num1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const num1 = Math.floor(x / 2);\n  const num2 = Math.floor(y / 2);\n  if (num1 === num2) {\n    return -1;\n  }\n  return num1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  choose"}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "gc": "<|endoftext|>/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  let binCount = 0;\n  let binCount2 = 0;\n  let binCount3 = 0;\n  let binCount4 = 0;\n  let binCount5 = 0;\n  let binCount6 = 0;\n  let binCount7 = 0;\n  let binCount8 = 0;\n  let binCount9 = 0;\n  let binCount10 = 0;\n  let binCount11 = 0;\n  let binCount12 = 0;\n  let binCount13 = 0;\n  let binCount14 = 0;\n  let binCount15 = 0;\n  let binCount16 = 0;\n  let binCount17 = 0;\n  let binCount18 = 0;\n  let binCount19 = 0;\n  let binCount20 = 0;\n  let binCount21 = 0;\n  let binCount22 = 0;\n  let binCount23 = 0;\n  let binCount24 = 0;\n  let binCount25 = 0;\n  let binCount26 = 0;\n  let binCount27 = 0;\n  let binCount28 = 0;\n  let binCount29 = 0;\n  let binCount30 = 0;\n  let binCount31 = 0;\n  let binCount32 = 0;\n  let binCount33 = 0;\n  let binCount34 = 0;\n  let binCount35 = 0;\n  let binCount36 = 0;\n  let binCount37 = 0;\n  let binCount38 = 0;\n  let binCount39 = 0;\n  let binCount40 = 0;\n  let binCount41 = 0;\n  let binCount42 = 0;\n  let binCount43 = 0;\n  let binCount44 = 0;\n  let binCount45 = 0;\n  let binCount46 = 0;\n  let binCount47 = 0;\n  let binCount48 = 0;\n  let binCount49 = 0;\n  let binCount50 = 0;\n  let binCount51 = 0;\n  let binCount52 = 0;\n  let binCount53 = 0;\n  let binCount54 = 0;\n  let binCount55 = 0;\n  let binCount56 = 0;\n  let binCount57 = 0;\n  let binCount58 = 0;\n  let binCount59 = 0;\n  let binCount60 = 0;\n  let binCount61 = 0;\n  let binCount62 = 0;\n  let binCount63 = 0;\n  let binCount64 = 0;\n  let binCount65 = 0;\n  let binCount66 = 0;\n  let binCount67 = 0;\n  let binCount68 = 0;\n  let binCount69 = 0;\n  let binCount70 = 0;\n  let binCount71 = 0;\n  let binCount72 = 0;\n  let binCount73 = 0;\n  let binCount74 = 0;\n  let binCount75 = 0;\n  let binCount76 = 0;\n  let binCount77 = 0;\n  let binCount78 = 0;\n  let binCount79 = 0;\n  let binCount80 = 0;\n  let binCount81 = 0;\n  let binCount82 = 0;\n  let binCount83 = 0;\n  let binCount84 = 0;\n  let binCount85 = 0;\n  let binCount86 = 0;\n  let binCount87 = 0;\n  let binCount88 = 0;\n  let binCount89 = 0;\n  let binCount90 = 0;\n  let binCount91 = 0;\n  let binCount92 = 0;\n  let binCount93 = 0;\n  let binCount94 = 0;\n  let binCount95 = 0;\n  let binCount96 = 0;\n  let binCount97 = 0;\n  let binCount98 = 0;\n  let binCount99 = 0;\n  let binCount100 = 0;\n  let binCount101 = 0;\n  let binCount102 = 0;\n  let binCount103 = 0;\n  let binCount104 = 0;\n  let binCount105 = 0;\n  let binCount106 = 0;\n  let binCount107 = 0;\n  let binCount108 = 0;\n  let binCount109 = 0;\n  let binCount110 = 0;\n  let binCount111 = 0;\n  let binCount112 = 0;\n  let binCount113 = 0;\n  let binCount114 = 0;\n  let binCount115 = 0;\n  let binCount116 = 0;\n  let binCount117 = 0;\n  let binCount118 = 0;\n  let binCount119 = 0;\n  let binCount120 = 0;\n  let binCount121 = 0;\n  let binCount122 = 0;\n  let binCount123 = 0;\n  let binCount124 = 0;\n  let binCount125 = 0;\n  let binCount126 = 0;\n  let binCount127 = 0;\n  let binCount128 = 0;\n  let binCount129 = 0;\n  let binCount130 = 0;\n  let binCount131 = 0;\n  let binCount132 = 0;\n  let binCount133 = 0;\n  let binCount134 = 0;\n  let binCount135 = 0;\n  let binCount136 = 0;\n  let binCount137 = 0;\n  let binCount138 = 0;\n  let binCount139 = 0;\n  let binCount140 = 0;\n  let binCount141 = 0;\n  let binCount142 = 0;\n  let binCount143 = 0;\n  let binCount144 = 0;\n  let binCount145 = 0;\n  let binCount146 = 0;\n  let binCount147 = 0;\n  let binCount148 = 0;\n  let binCount149 = 0;\n  let binCount150 = 0;\n  let binCount151 = 0;\n  let binCount152 = 0;\n  let binCount153 = 0;\n  let binCount154 = 0;\n  let binCount155 = 0;\n  let binCount156 = 0;\n  let binCount157 = 0;\n  let binCount158 = 0;\n  let binCount159 = 0;\n  let binCount160 = 0;\n  let binCount161 = 0;\n  let binCount162 = 0;\n  let binCount163 = 0;\n  let binCount164 = 0;\n  let binCount165 = 0;\n  let binCount166 = 0;\n  let binCount167 = 0;\n  let binCount168 = 0;\n  let binCount169 = 0;\n  let binCount170 = 0;\n  let binCount171 = 0;\n  let binCount172 = 0;\n  let binCount173 = 0;\n  let binCount174 = 0;\n  let binCount175 = 0;\n  let binCount176 = 0;\n  let binCount177 = 0;\n  let binCount178 = 0;\n  let binCount179 = 0;\n  let binCount180 = 0;\n  let binCount181 = 0;\n  let binCount182 = 0;\n  let binCount183 = 0;\n  let binCount184 = 0;\n  let binCount185 = 0;\n  let binCount186 = 0;\n  let binCount187 = 0;\n  let binCount188 = 0;\n  let binCount189 = 0;\n  let binCount190 = 0;\n  let binCount191 = 0;\n  let binCount192 = 0;\n  let binCount193 = 0;\n  let binCount194 = 0;\n  let binCount195 = 0;\n  let binCount196 = 0;\n  let binCount197 = 0;\n  let binCount198 = 0;\n  let binCount199 = 0;\n  let binCount200 = 0;\n  let binCount201 = 0;\n  let binCount202 = 0;\n  let binCount203 = 0;\n  let binCount204 = 0;\n  let binCount205 = 0;\n  let binCount206 = 0;\n  let binCount207 = 0;\n  let binCount208 = 0;\n  let binCount209 = 0;\n  let binCount210 = 0;\n  let binCount211 = 0;\n  let binCount212 = 0;\n  let binCount213 = 0;\n  let binCount214 = 0;\n  let binCount215 = 0;\n  let binCount216 = 0;\n  let binCount217 = 0;\n  let binCount218 = 0;\n  let binCount219 = 0;\n  let binCount220 = 0;\n  let binCount221 = 0;\n  let binCount222 = 0;\n  let binCount223 = 0;\n  let binCount224 = 0;\n  let binCount225 = 0;\n  let binCount226 = 0;\n  let binCount227 = 0;\n  let binCount228 = 0;\n  let binCount229 = 0;\n  let binCount230 = 0;\n  let binCount231 = 0;\n  let binCount232 = 0;\n  let binCount233 = 0;\n  let binCount234 = 0;\n  let binCount235 = 0;\n  let "}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "gc": "<|endoftext|>/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  let result = [];\n  let digits = [];\n  let digit;\n  let i;\n  \n  for(i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if(!digits[digit]) {\n      digits[digit] = 1;\n      result.push(digit);\n    }\n  }\n  \n  return result;\n}\n\nmodule.exports = uniqueDigits;\n\n},{}],6:[function(require,module,exports){\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> oddDigits([152, 323, 1422, 10])\n  []\n  */\nconst oddDigits = (x) => {\n  let result = [];\n  let digits = [];\n  let digit;\n  let i;\n  \n  for(i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if(digits[digit]) {\n      digits[digit] = 1;\n    } else {\n      digits[digit] = 0;\n    }\n  }\n  \n  return result;\n}\n\nmodule.exports = oddDigits;\n\n},{}],7:[function(require,module,exports){\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> evenDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> evenDigits([152, 323, 1422, 10])\n  []\n  */\nconst evenDigits = (x) => {\n  let result = [];\n  let digits = [];\n  let digit;\n  let i;\n  \n  for(i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if(digits[digit]) {\n      digits[digit] = 1;\n    } else {\n      digits[digit] = 0;\n    }\n  }\n  \n  return result;\n}\n\nmodule.exports = evenDigits;\n\n},{}],8:[function(require,module,exports){\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> oddOrEvenDigits([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigits = (x) => {\n  let result = [];\n  let digits = [];\n  let digit;\n  let i;\n  \n  for(i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if(digits[digit]) {\n      digits[digit] = 1;\n    } else {\n      digits[digit] = 0;\n    }\n  }\n  \n  return result;\n}\n\nmodule.exports = oddOrEvenDigits;\n\n},{}],9:[function(require,module,exports){\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> oddOrEvenDigits([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigits = (x) => {\n  let result = [];\n  let digits = [];\n  let digit;\n  let i;\n  \n  for(i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if(digits[digit]) {\n      digits[digit] = 1;\n    } else {\n      digits[digit] = 0;\n    }\n  }\n  \n  return result;\n}\n\nmodule.exports = oddOrEvenDigits;\n\n},{}],10:[function(require,module,exports){\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> oddOrEvenDigits([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigits = (x) => {\n  let result = [];\n  let digits = [];\n  let digit;\n  let i;\n  \n  for(i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if(digits[digit]) {\n      digits[digit] = 1;\n    } else {\n      digits[digit] = 0;\n    }\n  }\n  \n  return result;\n}\n\nmodule.exports = oddOrEvenDigits;\n\n},{}],11:[function(require,module,exports){\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> oddOrEvenDigits([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigits = (x) => {\n  let result = [];\n  let digits = [];\n  let digit;\n  let i;\n  \n  for(i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if(digits[digit]) {\n      digits[digit] = 1;\n    } else {\n      digits[digit] = 0;\n    }\n  }\n  \n  return result;\n}\n\nmodule.exports = oddOrEvenDigits;\n\n},{}],12:[function(require,module,exports){\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> oddOrEvenDigits([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigits = (x) => {\n  let result = [];\n  let digits = [];\n  let digit;\n  let i;\n  \n  for(i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if(digits[digit]) {\n      digits[digit] = 1;\n    } else {\n      digits[digit] = 0;\n    }\n  }\n  \n  return result;\n}\n\nmodule.exports = oddOrEvenDigits;\n\n},{}],13:[function(require,module,exports){\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> oddOrEvenDigits([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigits = (x) => {\n  let result = [];\n  let digits = [];\n  let digit;\n  let i;\n  \n  for(i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if(digits[digit]) {\n      digits[digit] = 1;\n    } else {\n      digits[digit] = 0;\n    }\n  }\n  \n  return result;\n}\n\nmodule.exports = oddOrEvenDigits;\n\n},{}],14:[function(require,module,exports){\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOr"}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "gc": "<|endoftext|>/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  let len = arr.length;\n  let reversed = arr.slice().reverse();\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    let name = reversed[i];\n    let digit = parseInt(name.charAt(0), 10);\n    res.push(digit);\n  }\n  return res;\n};\n\nconst byLengthAndName = (arr) => {\n  let len = arr.length;\n  let reversed = arr.slice().reverse();\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    let name = reversed[i];\n    let digit = parseInt(name.charAt(0), 10);\n    res.push(digit);\n  }\n  return byLength(res);\n};\n\nconst byName = (arr) => {\n  let len = arr.length;\n  let reversed = arr.slice().reverse();\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    let name = reversed[i];\n    let digit = parseInt(name.charAt(0), 10);\n    res.push(name);\n  }\n  return res;\n};\n\nconst byNameAndLength = (arr) => {\n  let len = arr.length;\n  let reversed = arr.slice().reverse();\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    let name = reversed[i];\n    let digit = parseInt(name.charAt(0), 10);\n    res.push(name, digit);\n  }\n  return byName(res);\n};\n\nconst byNameAndLengthAndName = (arr) => {\n  let len = arr.length;\n  let reversed = arr.slice().reverse();\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    let name = reversed[i];\n    let digit = parseInt(name.charAt(0), 10);\n    res.push(name, digit);\n  }\n  return byNameAndLength(res);\n};\n\nconst byNameAndLengthAndNameAndLength = (arr) => {\n  let len = arr.length;\n  let reversed = arr.slice().reverse();\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    let name = reversed[i];\n    let digit = parseInt(name.charAt(0), 10);\n    res.push(name, digit);\n  }\n  return byNameAndLengthAndName(res);\n};\n\nconst byNameAndLengthAndNameAndLengthAndName = (arr) => {\n  let len = arr.length;\n  let reversed = arr.slice().reverse();\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    let name = reversed[i];\n    let digit = parseInt(name.charAt(0), 10);\n    res.push(name, digit);\n  }\n  return byNameAndLengthAndNameAndLength(res);\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLength = (arr) => {\n  let len = arr.length;\n  let reversed = arr.slice().reverse();\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    let name = reversed[i];\n    let digit = parseInt(name.charAt(0), 10);\n    res.push(name, digit);\n  }\n  return byNameAndLengthAndNameAndLengthAndName(res);\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndName = (arr) => {\n  let len = arr.length;\n  let reversed = arr.slice().reverse();\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    let name = reversed[i];\n    let digit = parseInt(name.charAt(0), 10);\n    res.push(name, digit);\n  }\n  return byNameAndLengthAndNameAndLengthAndNameAndLength(res);\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLength = (arr) => {\n  let len = arr.length;\n  let reversed = arr.slice().reverse();\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    let name = reversed[i];\n    let digit = parseInt(name.charAt(0), 10);\n    res.push(name, digit);\n  }\n  return byNameAndLengthAndNameAndLengthAndNameAndLengthAndName(res);\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndName = (arr) => {\n  let len = arr.length;\n  let reversed = arr.slice().reverse();\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    let name = reversed[i];\n    let digit = parseInt(name.charAt(0), 10);\n    res.push(name, digit);\n  }\n  return byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLength(res);\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLength = (arr) => {\n  let len = arr.length;\n  let reversed = arr.slice().reverse();\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    let name = reversed[i];\n    let digit = parseInt(name.charAt(0), 10);\n    res.push(name, digit);\n  }\n  return byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndName(res);\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndName = (arr) => {\n  let len = arr.length;\n  let reversed = arr.slice().reverse();\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    let name = reversed[i];\n    let digit = parseInt(name.charAt(0), 10);\n    res.push(name, digit);\n  }\n  return byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLength(res);\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndName = (arr) => {\n  let len = arr.length;\n  let reversed = arr.slice().reverse();\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    let name = reversed[i];\n    let digit = parseInt(name.charAt(0), 10);\n    res.push(name, digit);\n  }\n  return byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLength(res);\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndName = (arr) => {\n  let len = arr.length;\n  let reversed = arr.slice().reverse();\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    let name = reversed[i];\n    let digit = parseInt(name.charAt(0), 10);\n    res.push(name, digit);\n  }\n  return byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLength(res);\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndName = (arr) => {\n  let len = arr.length;\n  let reversed = arr.slice().reverse();\n  let res = [];\n  for (let i = 0; i < len; i++) {\n    let name = reversed[i];\n    let digit = parseInt(name.charAt(0), 10);\n    res.push(name, digit);\n  }\n  return byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLength(res);\n};\n\nconst byNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAndLengthAndNameAnd"}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "gc": "<|endoftext|>/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement the function g that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  g(5) == [1, 2, 6, 24, 15]\n  */\nconst g = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement the function h that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  h(5) == [1, 2, 6, 24, 15]\n  */\nconst h = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement the function i that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  i(5) == [1, 2, 6, 24, 15]\n  */\nconst i = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement the function j that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  j(5) == [1, 2, 6, 24, 15]\n  */\nconst j = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement the function k that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  k(5) == [1, 2, 6, 24, 15]\n  */\nconst k = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement the function l that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  l(5) == [1, 2, 6, 24, 15]\n  */\nconst l = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement the function m that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  m(5) == [1, 2, 6, 24, 15]\n  */\nconst m = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement the function n that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  n(5) == [1, 2, 6, 24, 15]\n  */\nconst n = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement the function o that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  o(5) == [1, 2, 6, 24, 15]\n  */\nconst o = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement the function p that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  p(5) == [1, 2, 6, 24, 15]\n  */\nconst p = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement the function q that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  q(5) == [1, 2, 6, 24, 15]\n  */\nconst q = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }"}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = Array.from({ length: n }, (_, i) => i);\n  const oddPalindromes = Array.from({ length: n }, (_, i) => i);\n  evenPalindromes.reverse();\n  oddPalindromes.reverse();\n  const evenPalindromeCount = evenPalindromes.filter(\n    (_, i) => evenPalindromes.includes(i),\n  ).length;\n  const oddPalindromeCount = oddPalindromes.filter(\n    (_, i) => oddPalindromes.includes(i),\n  ).length;\n  return [evenPalindromeCount, oddPalindromeCount];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that do not fall within the range(1, n), inclusive.\n\n// Example 1:\n\n// Input: 3\n// Output: (1, 2)\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n// Example 2:\n\n// Input: 12\n// Output: (4, 6)\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nconst oddEvenPalindrome = (n) => {\n  const evenPalindromes = Array.from({ length: n }, (_, i) => i);\n  const oddPalindromes = Array.from({ length: n }, (_, i) => i);\n  evenPalindromes.reverse();\n  oddPalindromes.reverse();\n  const evenPalindromeCount = evenPalindromes.filter(\n    (_, i) =>!evenPalindromes.includes(i),\n  ).length;\n  const oddPalindromeCount = oddPalindromes.filter(\n    (_, i) =>!oddPalindromes.includes(i),\n  ).length;\n  return [evenPalindromeCount, oddPalindromeCount];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that do not fall within the range(1, n), inclusive.\n\n// Example 1:\n\n// Input: 3\n// Output: (1, 2)\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n// Example 2:\n\n// Input: 12\n// Output: (4, 6)\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nconst oddEvenPalindromeNoZero = (n) => {\n  const evenPalindromes = Array.from({ length: n }, (_, i) => i);\n  const oddPalindromes = Array.from({ length: n }, (_, i) => i);\n  evenPalindromes.reverse();\n  oddPalindromes.reverse();\n  const evenPalindromeCount = evenPalindromes.filter(\n    (_, i) =>!evenPalindromes.includes(i),\n  ).length;\n  const oddPalindromeCount = oddPalindromes.filter(\n    (_, i) =>!oddPalindromes.includes(i),\n  ).length;\n  return [evenPalindromeCount, oddPalindromeCount];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that do not fall within the range(1, n), inclusive.\n\n// Example 1:\n\n// Input: 3\n// Output: (1, 2)\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n// Example 2:\n\n// Input: 12\n// Output: (4, 6)\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nconst oddEvenPalindromeNoZeroNoZero = (n) => {\n  const evenPalindromes = Array.from({ length: n }, (_, i) => i);\n  const oddPalindromes = Array.from({ length: n }, (_, i) => i);\n  evenPalindromes.reverse();\n  oddPalindromes.reverse();\n  const evenPalindromeCount = evenPalindromes.filter(\n    (_, i) =>!evenPalindromes.includes(i),\n  ).length;\n  const oddPalindromeCount = oddPalindromes.filter(\n    (_, i) =>!oddPalindromes.includes(i),\n  ).length;\n  return [evenPalindromeCount, oddPalindromeCount];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that do not fall within the range(1, n), inclusive.\n\n// Example 1:\n\n// Input: 3\n// Output: (1, 2)\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n// Example 2:\n\n// Input: 12\n// Output: (4, 6)\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nconst oddEvenPalindromeNoZeroNoZeroNoZero = (n) => {\n  const evenPalindromes = Array.from({ length: n }, (_, i) => i);\n  const oddPalindromes = Array.from({ length: n }, (_, i) => i);\n  evenPalindromes.reverse();\n  oddPalindromes.reverse();\n  const evenPalindromeCount = evenPalindromes.filter(\n    (_, i) =>!evenPalindromes.includes(i),\n  ).length;\n  const oddPalindromeCount = oddPalindromes.filter(\n    (_, i) =>!oddPalindromes.includes(i),\n  ).length;\n  return [evenPalindromeCount, oddPalindromeCount];\n};\n\n// "}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "gc": "<|endoftext|>/*\n  Write a function countNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countZeros which takes an array of integers and returns\n  the number of elements which has all its digits set to 0.\n  >>> countZeros([]) == 0\n  >>> countZeros([-1, 11, -11]) == 1\n  >>> countZeros([1, 1, 2]) == 3\n  */\nconst countZeros = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countOnes which takes an array of integers and returns\n  the number of elements which has all its digits set to 1.\n  >>> countOnes([]) == 0\n  >>> countOnes([-1, 11, -11]) == 1\n  >>> countOnes([1, 1, 2]) == 3\n  */\nconst countOnes = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNegs which takes an array of integers and returns\n  the number of elements which has a negative sum of digits.\n  >>> countNegs([]) == 0\n  >>> countNegs([-1, 11, -11]) == 1\n  >>> countNegs([1, 1, 2]) == 3\n  */\nconst countNegs = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countPos which takes an array of integers and returns\n  the number of elements which has a positive sum of digits.\n  >>> countPos([]) == 0\n  >>> countPos([-1, 11, -11]) == 1\n  >>> countPos([1, 1, 2]) == 3\n  */\nconst countPos = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countDiv which takes an array of integers and returns\n  the number of elements which has a positive sum of digits and\n  negative sum of digits.\n  >>> countDiv([-1, 11, -11]) == 2\n  >>> countDiv([1, 1, 2]) == 1\n  */\nconst countDiv = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0 && arr[i] < 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countMod which takes an array of integers and returns\n  the number of elements which has a positive sum of digits and\n  negative sum of digits.\n  >>> countMod([-1, 11, -11]) == 2\n  >>> countMod([1, 1, 2]) == 1\n  */\nconst countMod = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0 && arr[i] < 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countDivided which takes an array of integers and returns\n  the number of elements which has a positive sum of digits and\n  negative sum of digits.\n  >>> countDivided([-1, 11, -11]) == 2\n  >>> countDivided([1, 1, 2]) == 1\n  */\nconst countDivided = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0 && arr[i] < 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countModulod which takes an array of integers and returns\n  the number of elements which has a positive sum of digits and\n  negative sum of digits.\n  >>> countModulod([-1, 11, -11]) == 2\n  >>> countModulod([1, 1, 2]) == 1\n  */\nconst countModulod = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0 && arr[i] < 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countPower which takes an array of integers and returns\n  the number of elements which has a positive sum of digits and\n  negative sum of digits.\n  >>> countPower([-1, 11, -11]) == 2\n  >>> countPower([1, 1, 2]) == 1\n  */\nconst countPower = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0 && arr[i] < 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countPowModd which takes an array of integers and returns\n  the number of elements which has a positive sum of digits and\n  negative sum of digits.\n  >>> countPowModd([-1, 11, -11]) == 2\n  >>> countPowModd([1, 1, 2]) == 1\n  */\nconst countPowModd = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0 && arr[i] < 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countPowDivided which takes an array of integers and returns\n  the number of elements which has a positive sum of digits and\n  negative sum of digits.\n  >>> countPowDivided([-1, 11, -11]) == 2\n  >>> countPowDivided([1, 1, 2]) == 1\n  */\nconst countPowDivided = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0 && arr[i] < 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countPowModulod which takes an array of integers and returns\n  the number of elements which has a positive sum of digits and\n  negative sum of digits.\n  >>> countPowModulod([-1, 11, -11]) == 2\n  >>> countPowModulod([1, 1, 2]) == 1\n  */\nconst countPowModulod = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0 && arr[i] < 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countPowDivided which takes an array of integers and returns\n  the number of elements which has a positive sum of digits and\n  negative sum of digits.\n  >>> countPowDivided([-1, 11, -11]) == 2\n  >>> countPowDivided([1, 1, 2]) == 1\n  */\nconst countPowDivided = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0 && arr[i] < 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countPowModulod which takes an array of integers and returns\n  the number of elements which has a positive sum of digits and\n  negative sum of digits.\n  >>> countPowModulod([-1, 11, -11]) == 2\n  >>> countPowModulod([1, 1, 2]) == 1\n  */\nconst countPowModulod = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0 && arr[i] < 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countPowModulod which takes an array of integers and returns\n  the number of elements which has a positive sum of digits and\n  negative sum of digits.\n  >>> countPowModulod([-1, 11, -11]) == 2\n  >>> countPowMo"}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let result=true;\n  if (arr.length==0) {\n    result=true;\n  }\n  else {\n    let temp=arr[0];\n    arr.shift();\n    arr.unshift(temp);\n    result=moveOneBall(arr);\n  }\n  return result;\n};\n\n/*\n  You are given an integer array nums containing N integers. Your task is to find\n  the minimum number of moves required to move all elements of the array to\n  the end of the array.\n\n  Example:\n  \n  moveOneBall(nums)==>3\n  Explanation: By performing the following operations, we can achieve the minimum \n              number of moves required to move all the elements of the array to the \n              end of the array:\n              \n              nums[0]=nums[0]+1\n              nums[1]=nums[1]+1\n              nums[2]=nums[2]+1\n              nums[3]=nums[3]+1\n              nums[4]=nums[4]+1\n              nums[5]=nums[5]+1\n              nums[6]=nums[6]+1\n              nums[7]=nums[7]+1\n              nums[8]=nums[8]+1\n              nums[9]=nums[9]+1\n              nums[10]=nums[10]+1\n              nums[11]=nums[11]+1\n              nums[12]=nums[12]+1\n              nums[13]=nums[13]+1\n              nums[14]=nums[14]+1\n              nums[15]=nums[15]+1\n              nums[16]=nums[16]+1\n              nums[17]=nums[17]+1\n              nums[18]=nums[18]+1\n              nums[19]=nums[19]+1\n              nums[20]=nums[20]+1\n              nums[21]=nums[21]+1\n              nums[22]=nums[22]+1\n              nums[23]=nums[23]+1\n              nums[24]=nums[24]+1\n              nums[25]=nums[25]+1\n              nums[26]=nums[26]+1\n              nums[27]=nums[27]+1\n              nums[28]=nums[28]+1\n              nums[29]=nums[29]+1\n              nums[30]=nums[30]+1\n              nums[31]=nums[31]+1\n              nums[32]=nums[32]+1\n              nums[33]=nums[33]+1\n              nums[34]=nums[34]+1\n              nums[35]=nums[35]+1\n              nums[36]=nums[36]+1\n              nums[37]=nums[37]+1\n              nums[38]=nums[38]+1\n              nums[39]=nums[39]+1\n              nums[40]=nums[40]+1\n              nums[41]=nums[41]+1\n              nums[42]=nums[42]+1\n              nums[43]=nums[43]+1\n              nums[44]=nums[44]+1\n              nums[45]=nums[45]+1\n              nums[46]=nums[46]+1\n              nums[47]=nums[47]+1\n              nums[48]=nums[48]+1\n              nums[49]=nums[49]+1\n              nums[50]=nums[50]+1\n              nums[51]=nums[51]+1\n              nums[52]=nums[52]+1\n              nums[53]=nums[53]+1\n              nums[54]=nums[54]+1\n              nums[55]=nums[55]+1\n              nums[56]=nums[56]+1\n              nums[57]=nums[57]+1\n              nums[58]=nums[58]+1\n              nums[59]=nums[59]+1\n              nums[60]=nums[60]+1\n              nums[61]=nums[61]+1\n              nums[62]=nums[62]+1\n              nums[63]=nums[63]+1\n              nums[64]=nums[64]+1\n              nums[65]=nums[65]+1\n              nums[66]=nums[66]+1\n              nums[67]=nums[67]+1\n              nums[68]=nums[68]+1\n              nums[69]=nums[69]+1\n              nums[70]=nums[70]+1\n              nums[71]=nums[71]+1\n              nums[72]=nums[72]+1\n              nums[73]=nums[73]+1\n              nums[74]=nums[74]+1\n              nums[75]=nums[75]+1\n              nums[76]=nums[76]+1\n              nums[77]=nums[77]+1\n              nums[78]=nums[78]+1\n              nums[79]=nums[79]+1\n              nums[80]=nums[80]+1\n              nums[81]=nums[81]+1\n              nums[82]=nums[82]+1\n              nums[83]=nums[83]+1\n              nums[84]=nums[84]+1\n              nums[85]=nums[85]+1\n              nums[86]=nums[86]+1\n              nums[87]=nums[87]+1\n              nums[88]=nums[88]+1\n              nums[89]=nums[89]+1\n              nums[90]=nums[90]+1\n              nums[91]=nums[91]+1\n              nums[92]=nums[92]+1\n              nums[93]=nums[93]+1\n              nums[94]=nums[94]+1\n              nums[95]=nums[95]+1\n              nums[96]=nums[96]+1\n              nums[97]=nums[97]+1\n              nums[98]=nums[98]+1\n              nums[99]=nums[99]+1\n              nums[100]=nums[100]+1\n              nums[101]=nums[101]+1\n              nums[102]=nums[102]+1\n              nums[10"}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an exchange of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of exchanged elements between lst1 and lst2.\n  If it is possible to exchange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "gc": "<|endoftext|>/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an exchange of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of exchanged elements between lst1 and lst2.\n  If it is possible to exchange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  // Your code here\n}\n\n/*\n  Write a function that takes an array of numbers and returns true if the\n  array is sorted in ascending order, and false if it is sorted in descending\n  order.\n  For example:\n  isSorted([3, 2, 1]) => true\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => true\n*/\nconst isSorted = (arr) => {\n  // Your code here\n}\n\n/*\n  Write a function that takes an array of numbers and returns true if the\n  array is sorted in ascending order, and false if it is sorted in descending\n  order.\n  For example:\n  isSorted([3, 2, 1]) => true\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => true\n*/\nconst isSorted = (arr) => {\n  // Your code here\n}\n\n/*\n  Write a function that takes an array of numbers and returns true if the\n  array is sorted in ascending order, and false if it is sorted in descending\n  order.\n  For example:\n  isSorted([3, 2, 1]) => true\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => true\n*/\nconst isSorted = (arr) => {\n  // Your code here\n}\n\n/*\n  Write a function that takes an array of numbers and returns true if the\n  array is sorted in ascending order, and false if it is sorted in descending\n  order.\n  For example:\n  isSorted([3, 2, 1]) => true\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => true\n*/\nconst isSorted = (arr) => {\n  // Your code here\n}\n\n/*\n  Write a function that takes an array of numbers and returns true if the\n  array is sorted in ascending order, and false if it is sorted in descending\n  order.\n  For example:\n  isSorted([3, 2, 1]) => true\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => true\n*/\nconst isSorted = (arr) => {\n  // Your code here\n}\n\n/*\n  Write a function that takes an array of numbers and returns true if the\n  array is sorted in ascending order, and false if it is sorted in descending\n  order.\n  For example:\n  isSorted([3, 2, 1]) => true\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => true\n*/\nconst isSorted = (arr) => {\n  // Your code here\n}\n\n/*\n  Write a function that takes an array of numbers and returns true if the\n  array is sorted in ascending order, and false if it is sorted in descending\n  order.\n  For example:\n  isSorted([3, 2, 1]) => true\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => true\n*/\nconst isSorted = (arr) => {\n  // Your code here\n}\n\n/*\n  Write a function that takes an array of numbers and returns true if the\n  array is sorted in ascending order, and false if it is sorted in descending\n  order.\n  For example:\n  isSorted([3, 2, 1]) => true\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => true\n*/\nconst isSorted = (arr) => {\n  // Your code here\n}\n\n/*\n  Write a function that takes an array of numbers and returns true if the\n  array is sorted in ascending order, and false if it is sorted in descending\n  order.\n  For example:\n  isSorted([3, 2, 1]) => true\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => true\n*/\nconst isSorted = (arr) => {\n  // Your code here\n}\n\n/*\n  Write a function that takes an array of numbers and returns true if the\n  array is sorted in ascending order, and false if it is sorted in descending\n  order.\n  For example:\n  isSorted([3, 2, 1]) => true\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => true\n*/\nconst isSorted = (arr) => {\n  // Your code here\n}\n\n/*\n  Write a function that takes an array of numbers and returns true if the\n  array is sorted in ascending order, and false if it is sorted in descending\n  order.\n  For example:\n  isSorted([3, 2, 1]) => true\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => true\n*/\nconst isSorted = (arr) => {\n  // Your code here\n}\n\n/*\n  Write a function that takes an array of numbers and returns true if the\n  array is sorted in ascending order, and false if it is sorted in descending\n  order.\n  For example:\n  isSorted([3, 2, 1]) => true\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => true\n*/\nconst isSorted = (arr) => {\n  // Your code here\n}\n\n/*\n  Write a function that takes an array of numbers and returns true if the\n  array is sorted in ascending order, and false if it is sorted in descending\n  order.\n  For example:\n  isSorted([3, 2, 1]) => true\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => true\n*/\nconst isSorted = (arr) => {\n  // Your code here\n}\n\n/*\n  Write a function that takes an array of numbers and returns true if the\n  array is sorted in ascending order, and false if it is sorted in descending\n  order.\n  For example:\n  isSorted([3, 2, 1]) => true\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => true\n*/\nconst isSorted = (arr) => {\n  // Your code here\n}\n\n/*\n  Write a function that takes an array of numbers and returns true if the\n  array is sorted in ascending order, and false if it is sorted in descending\n  order.\n  For example:\n  isSorted([3, 2, 1]) => true\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => false\n  isSorted([3, 2, 1]) => true\n*/\nconst isSorted = (arr) => {\n  // Your code here\n}\n\n/*\n  Write a function that takes an array of numbers and returns true if the\n  array is sorted in ascending order, and false if it is sorted in descending\n  order.\n  For example:\n  isSorted([3, 2, 1]"}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "gc": "<|endoftext|>/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = {}\n  let counts = {}\n  let letterCounts = {}\n  let letterCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letterCountCountCounts = {}\n  let letter"}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "gc": "<|endoftext|>/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = '';\n  let isPalindrome = true;\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) === c.charAt(i)) {\n      result += s.charAt(i);\n      isPalindrome = false;\n    }\n  }\n  return [result, isPalindrome];\n};\n\n/*Task\n  Given a string s and an integer n, you have to delete all the characters from s from n positions starting from 0.\n  Then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 2, the result should be ('abcde',false)\n  For s = \"abcde\", n = 4, the result should be ('abcde',true)\n  For s = \"abcde\", n = 6, the result should be ('abcde',false)\n  For s = \"abcde\", n = 8, the result should be ('abcde',false)\n  For s = \"abcde\", n = 10, the result should be ('abcde',false)\n  For s = \"abcde\", n = 12, the result should be ('abcde',false)\n  For s = \"abcde\", n = 14, the result should be ('abcde',false)\n  For s = \"abcde\", n = 16, the result should be ('abcde',false)\n  For s = \"abcde\", n = 18, the result should be ('abcde',false)\n  For s = \"abcde\", n = 20, the result should be ('abcde',false)\n  For s = \"abcde\", n = 22, the result should be ('abcde',false)\n  For s = \"abcde\", n = 24, the result should be ('abcde',false)\n  For s = \"abcde\", n = 26, the result should be ('abcde',false)\n  For s = \"abcde\", n = 28, the result should be ('abcde',false)\n  For s = \"abcde\", n = 30, the result should be ('abcde',false)\n  For s = \"abcde\", n = 32, the result should be ('abcde',false)\n  For s = \"abcde\", n = 34, the result should be ('abcde',false)\n  For s = \"abcde\", n = 36, the result should be ('abcde',false)\n  For s = \"abcde\", n = 38, the result should be ('abcde',false)\n  For s = \"abcde\", n = 40, the result should be ('abcde',false)\n  For s = \"abcde\", n = 42, the result should be ('abcde',false)\n  For s = \"abcde\", n = 44, the result should be ('abcde',false)\n  For s = \"abcde\", n = 46, the result should be ('abcde',false)\n  For s = \"abcde\", n = 48, the result should be ('abcde',false)\n  For s = \"abcde\", n = 50, the result should be ('abcde',false)\n  For s = \"abcde\", n = 52, the result should be ('abcde',false)\n  For s = \"abcde\", n = 54, the result should be ('abcde',false)\n  For s = \"abcde\", n = 56, the result should be ('abcde',false)\n  For s = \"abcde\", n = 58, the result should be ('abcde',false)\n  For s = \"abcde\", n = 60, the result should be ('abcde',false)\n  For s = \"abcde\", n = 62, the result should be ('abcde',false)\n  For s = \"abcde\", n = 64, the result should be ('abcde',false)\n  For s = \"abcde\", n = 66, the result should be ('abcde',false)\n  For s = \"abcde\", n = 68, the result should be ('abcde',false)\n  For s = \"abcde\", n = 70, the result should be ('abcde',false)\n  For s = \"abcde\", n = 72, the result should be ('abcde',false)\n  For s = \"abcde\", n = 74, the result should be ('abcde',false)\n  For s = \"abcde\", n = 76, the result should be ('abcde',false)\n  For s = \"abcde\", n = 78, the result should be ('abcde',false)\n  For s = \"abcde\", n = 80, the result should be ('abcde',false)\n  For s = \"abcde\", n = 82, the result should be ('abcde',false)\n  For s = \"abcde\", n = 84, the result should be ('abcde',false)\n  For s = \"abcde\", n = 86, the result should be ('abcde',false)\n  For s = \"abcde\", n = 88, the result should be ('abcde',false)\n  For s = \"abcde\", n = 90, the result should be ('abcde',false)\n  For s = \"abcde\", n = 92, the result should be ('abcde',false)\n  For s = \"abcde\", n = 94, the result should be ('abcde',false)\n  For s = \"abcde\", n = 96, the result should be ('abcde',false)\n  For s = \"abcde\", n = 98, the result should be ('abcde',false)\n  For s = \"abcde\", n = 100, the result should be ('abcde',false)\n  For s = \"abcde\", n = 102, the result should be ('abcde',false)\n  For s = \"abcde\", n = 104, the result should be ('abcde',false)\n  For s = \"abcde\", n = 106, the result should be ('abcde',false)\n  For s = \"abcde\", n = 108, the result should be ('abcde',false)\n  For s = \"abcde\", n = 110, the result should be ('abcde',false)\n  For s = \"abcde\", n = 112, the result should be ('abcde',false)\n  For s = \"abcde\", n = 114, the result should be ('abcde',false)\n  For s = \"abcde\", n = 116, the result should be ('abcde',false)\n  For s = \"abcde\", n = 118, the result should be ('abcde',false)\n  For s = \"abcde\", n = 120, the result should be ('abcde',false)\n  For s = \"abcde\", n = 122, the result should be ('abcde',false)\n  For s = \"abcde\", n = 124, the result should be ('abcde',false)\n  For s = \"abcde\", n = 126, the result should be ('abcde',false)\n  For s = \"abcde\", n = 128, the result should be ('abcde',false)\n  For s = \"abcde\", n = 130, the result should be ('abcde',false)\n  For s = \"abcde\", n = 132, the result should be ('abcde',false)\n  For s = \"abcde\", n = 134, the result should be ('abcde',false)\n  For s = \"abcde\", n = 136, the result should be ('abcde',false)\n  For s = \"abcde\", n = 138, the result should be ('abcde',false)\n  For s = \"abcde\", n = 140, the result should be ('abcde',false)\n  For s = \"abcde\", n = 142, the result should be ('abcde',false)\n  For s = \"abcde\", n = 144, the result should be ('abcde',false)\n  For s = \"abcde\", n = 146, the result should be ('abcde',false)\n  For s = \"abcde\", n = 148, the result should be ('abc"}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "gc": "<|endoftext|>/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      oddCount++;\n    }\n  }\n  return [oddCount];\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      evenCount++;\n    }\n  }\n  return [evenCount];\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of pairs of adjacent elements\n  in the string i of the input.\" where all the i's should be replaced by the number\n  of pairs of adjacent digits in the i'th string of the input.\n\n  >>> pairCount(['1234567'])\n  [\"the number of pairs of adjacent elements 4n the str4ng 4 of the 4nput.\"]\n  >>> pairCount(['3',\"11111111\"])\n  [\"the number of pairs of adjacent elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of pairs of adjacent elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst pairCount = (lst) => {\n  let pairCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      pairCount++;\n    }\n  }\n  return [pairCount];\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of triples of adjacent elements\n  in the string i of the input.\" where all the i's should be replaced by the number\n  of triples of adjacent digits in the i'th string of the input.\n\n  >>> tripleCount(['1234567'])\n  [\"the number of triples of adjacent elements 4n the str4ng 4 of the 4nput.\"]\n  >>> tripleCount(['3',\"11111111\"])\n  [\"the number of triples of adjacent elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of triples of adjacent elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst tripleCount = (lst) => {\n  let tripleCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      tripleCount++;\n    }\n  }\n  return [tripleCount];\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of quads of adjacent elements\n  in the string i of the input.\" where all the i's should be replaced by the number\n  of quads of adjacent digits in the i'th string of the input.\n\n  >>> quadCount(['1234567'])\n  [\"the number of quads of adjacent elements 4n the str4ng 4 of the 4nput.\"]\n  >>> quadCount(['3',\"11111111\"])\n  [\"the number of quads of adjacent elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of quads of adjacent elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst quadCount = (lst) => {\n  let quadCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      quadCount++;\n    }\n  }\n  return [quadCount];\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of quins of adjacent elements\n  in the string i of the input.\" where all the i's should be replaced by the number\n  of quins of adjacent digits in the i'th string of the input.\n\n  >>> quinCount(['1234567'])\n  [\"the number of quins of adjacent elements 4n the str4ng 4 of the 4nput.\"]\n  >>> quinCount(['3',\"11111111\"])\n  [\"the number of quins of adjacent elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of quins of adjacent elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst quinCount = (lst) => {\n  let quinCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      quinCount++;\n    }\n  }\n  return [quinCount];\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of nicks of adjacent elements\n  in the string i of the input.\" where all the i's should be replaced by the number\n  of nicks of adjacent digits in the i'th string of the input.\n\n  >>> nickCount(['1234567'])\n  [\"the number of nicks of adjacent elements 4n the str4ng 4 of the 4nput.\"]\n  >>> nickCount(['3',\"11111111\"])\n  [\"the number of nicks of adjacent elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of nicks of adjacent elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst nickCount = (lst) => {\n  let nickCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      nickCount++;\n    }\n  }\n  return [nickCount];\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of pens of adjacent elements\n  in the string i of the input.\" where all the i's should be replaced by the number\n  of pens of adjacent digits in the i'th string of the input.\n\n  >>> penCount(['1234567'])\n  [\"the number of pens of adjacent elements 4n the str4ng 4 of the 4nput.\"]\n  >>> penCount(['3',\"11111111\"])\n  [\"the number of pens of adjacent elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of pens of adjacent elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst penCount = (lst) => {\n  let penCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      penCount++;\n    }\n  }\n  return [penCount];\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of nicks of adjacent elements\n  in the string i "}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "gc": "<|endoftext|>/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 6\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the minimum number of distinct sub-arrays\n  of nums.\n  Example\n  minDistinctSubArrays([2, 3, 4, 1, 2, 4]) == 3\n  minDistinctSubArrays([-1, -2, -3]) == 4\n  */\nconst minDistinctSubArrays = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers nums, find the maximum number of distinct sub-arrays\n  of nums.\n  Example\n  maxDistinctSubArrays([2, 3, 4, 1, 2, 4]) == 3\n  maxDistinctSubArrays([-1, -2, -3]) == 4\n  */\nconst maxDistinctSubArrays = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers nums, find the minimum number of distinct sub-arrays\n  of nums.\n  Example\n  minDistinctSubArrays([2, 3, 4, 1, 2, 4]) == 3\n  minDistinctSubArrays([-1, -2, -3]) == 4\n  */\nconst minDistinctSubArraysNoDuplicate = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers nums, find the maximum number of distinct sub-arrays\n  of nums.\n  Example\n  maxDistinctSubArrays([2, 3, 4, 1, 2, 4]) == 3\n  maxDistinctSubArrays([-1, -2, -3]) == 4\n  */\nconst maxDistinctSubArraysNoDuplicate = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers nums, find the minimum number of distinct sub-arrays\n  of nums.\n  Example\n  minDistinctSubArraysNoDuplicate([2, 3, 4, 1, 2, 4]) == 3\n  minDistinctSubArraysNoDuplicate([-1, -2, -3]) == 4\n  */\nconst minDistinctSubArraysNoDuplicate = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers nums, find the maximum number of distinct sub-arrays\n  of nums.\n  Example\n  maxDistinctSubArraysNoDuplicate([2, 3, 4, 1, 2, 4]) == 3\n  maxDistinctSubArraysNoDuplicate([-1, -2, -3]) == 4\n  */\nconst maxDistinctSubArraysNoDuplicate = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers nums, find the minimum number of distinct sub-arrays\n  of nums.\n  Example\n  minDistinctSubArraysNoDuplicate([2, 3, 4, 1, 2, 4]) == 3\n  minDistinctSubArraysNoDuplicate([-1, -2, -3]) == 4\n  */\nconst minDistinctSubArraysNoDuplicate = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers nums, find the maximum number of distinct sub-arrays\n  of nums.\n  Example\n  maxDistinctSubArraysNoDuplicate([2, 3, 4, 1, 2, 4]) == 3\n  maxDistinctSubArraysNoDuplicate([-1, -2, -3]) == 4\n  */\nconst maxDistinctSubArraysNoDuplicate = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers nums, find the minimum number of distinct sub-arrays\n  of nums.\n  Example\n  minDistinctSubArraysNoDuplicate([2, 3, 4, 1, 2, 4]) == 3\n  minDistinctSubArraysNoDuplicate([-1, -2, -3]) == 4\n  */\nconst minDistinctSubArraysNoDuplicate = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers nums, find the maximum number of distinct sub-arrays\n  of nums.\n  Example\n  maxDistinctSubArraysNoDuplicate([2, 3, 4, 1, 2, 4]) == 3\n  maxDistinctSubArraysNoDuplicate([-1, -2, -3]) == 4\n  */\nconst maxDistinctSubArraysNoDuplicate = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers nums, find the minimum number of distinct sub-arrays\n  of nums.\n  Example\n  minDistinctSubArraysNoDuplicate([2, 3, 4, 1, 2, 4]) == 3\n  minDistinctSubArraysNoDuplicate([-1, -2, -3]) == 4\n  */\nconst minDistinctSubArraysNoDuplicate = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers nums, find the maximum number of distinct sub-arrays\n  of nums.\n  Example\n  maxDistinctSubArraysNoDuplicate([2, 3, 4, 1, 2, 4]) == 3\n  maxDistinctSubArraysNoDuplicate([-1, -2, -3]) == 4\n  */\nconst maxDistinctSubArraysNoDuplicate = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers nums, find the minimum number of distinct sub-arrays\n  of nums.\n  Example\n  minDistinctSubArraysNoDuplicate([2, 3, 4, 1, 2, 4]) == 3\n  minDistinctSubArraysNoDuplicate([-1, -2, -3]) == 4\n  */\nconst minDistinctSubArraysNoDuplicate = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers nums, find the maximum number of distinct sub-arrays\n  of nums.\n  Example\n  maxDistin"}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    \n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            if(grid[i][j] === 1){\n                result += (grid[i][j] * capacity);\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Your MaxFill function will be called as follows:\n *\n * const result = maxFill(grid, capacity)\n * var result = 0\n * var grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n * var capacity = 1\n * var n = grid.length\n * var m = grid[0].length\n * var result = 0\n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * "}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "gc": "<|endoftext|>/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const arrCopy = arr.slice();\n  const arrLength = arrCopy.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp;\n  let tempCopy;\n  let tempCopyLength;\n  let tempCopyIndex;\n  let tempCopyLengthCopy;\n  let tempCopyIndexCopy;\n  let tempCopyLengthCopyLength;\n  let tempCopyIndexCopyLength;\n  let tempCopyLengthCopyIndex;\n  let tempCopyIndexCopyIndex;\n  let tempCopyLengthCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopy;\n  let tempCopyLengthCopyIndexCopyLength;\n  let tempCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndex;\n  let tempCopyIndexCopyIndexCopyIndex;\n  let tempCopyLengthCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyLengthCopyIndexCopyIndexCopyLength;\n  let tempCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndex;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndex;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndex;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndex;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndex;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndex;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyLength;\n  let tempCopyLengthCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopy;\n  let tempCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndexCopyIndex"}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "gc": "<|endoftext|>/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = [];\n  let word = '';\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let "}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "gc": "<|endoftext|>/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsLength = vowels.length;\n  let vowelsArray = vowels.split('');\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayIndex = 0;\n  let vowelsArrayIndex2 = 0;\n  let vowelsArrayIndex3 = 0;\n  let vowelsArrayIndex4 = 0;\n  let vowelsArrayIndex5 = 0;\n  let vowelsArrayIndex6 = 0;\n  let vowelsArrayIndex7 = 0;\n  let vowelsArrayIndex8 = 0;\n  let vowelsArrayIndex9 = 0;\n  let vowelsArrayIndex10 = 0;\n  let vowelsArrayIndex11 = 0;\n  let vowelsArrayIndex12 = 0;\n  let vowelsArrayIndex13 = 0;\n  let vowelsArrayIndex14 = 0;\n  let vowelsArrayIndex15 = 0;\n  let vowelsArrayIndex16 = 0;\n  let vowelsArrayIndex17 = 0;\n  let vowelsArrayIndex18 = 0;\n  let vowelsArrayIndex19 = 0;\n  let vowelsArrayIndex20 = 0;\n  let vowelsArrayIndex21 = 0;\n  let vowelsArrayIndex22 = 0;\n  let vowelsArrayIndex23 = 0;\n  let vowelsArrayIndex24 = 0;\n  let vowelsArrayIndex25 = 0;\n  let vowelsArrayIndex26 = 0;\n  let vowelsArrayIndex27 = 0;\n  let vowelsArrayIndex28 = 0;\n  let vowelsArrayIndex29 = 0;\n  let vowelsArrayIndex30 = 0;\n  let vowelsArrayIndex31 = 0;\n  let vowelsArrayIndex32 = 0;\n  let vowelsArrayIndex33 = 0;\n  let vowelsArrayIndex34 = 0;\n  let vowelsArrayIndex35 = 0;\n  let vowelsArrayIndex36 = 0;\n  let vowelsArrayIndex37 = 0;\n  let vowelsArrayIndex38 = 0;\n  let vowelsArrayIndex39 = 0;\n  let vowelsArrayIndex40 = 0;\n  let vowelsArrayIndex41 = 0;\n  let vowelsArrayIndex42 = 0;\n  let vowelsArrayIndex43 = 0;\n  let vowelsArrayIndex44 = 0;\n  let vowelsArrayIndex45 = 0;\n  let vowelsArrayIndex46 = 0;\n  let vowelsArrayIndex47 = 0;\n  let vowelsArrayIndex48 = 0;\n  let vowelsArrayIndex49 = 0;\n  let vowelsArrayIndex50 = 0;\n  let vowelsArrayIndex51 = 0;\n  let vowelsArrayIndex52 = 0;\n  let vowelsArrayIndex53 = 0;\n  let vowelsArrayIndex54 = 0;\n  let vowelsArrayIndex55 = 0;\n  let vowelsArrayIndex56 = 0;\n  let vowelsArrayIndex57 = 0;\n  let vowelsArrayIndex58 = 0;\n  let vowelsArrayIndex59 = 0;\n  let vowelsArrayIndex60 = 0;\n  let vowelsArrayIndex61 = 0;\n  let vowelsArrayIndex62 = 0;\n  let vowelsArrayIndex63 = 0;\n  let vowelsArrayIndex64 = 0;\n  let vowelsArrayIndex65 = 0;\n  let vowelsArrayIndex66 = 0;\n  let vowelsArrayIndex67 = 0;\n  let vowelsArrayIndex68 = 0;\n  let vowelsArrayIndex69 = 0;\n  let vowelsArrayIndex70 = 0;\n  let vowelsArrayIndex71 = 0;\n  let vowelsArrayIndex72 = 0;\n  let vowelsArrayIndex73 = 0;\n  let vowelsArrayIndex74 = 0;\n  let vowelsArrayIndex75 = 0;\n  let vowelsArrayIndex76 = 0;\n  let vowelsArrayIndex77 = 0;\n  let vowelsArrayIndex78 = 0;\n  let vowelsArrayIndex79 = 0;\n  let vowelsArrayIndex80 = 0;\n  let vowelsArrayIndex81 = 0;\n  let vowelsArrayIndex82 = 0;\n  let vowelsArrayIndex83 = 0;\n  let vowelsArrayIndex84 = 0;\n  let vowelsArrayIndex85 = 0;\n  let vowelsArrayIndex86 = 0;\n  let vowelsArrayIndex87 = 0;\n  let vowelsArrayIndex88 = 0;\n  let vowelsArrayIndex89 = 0;\n  let vowelsArrayIndex90 = 0;\n  let vowelsArrayIndex91 = 0;\n  let vowelsArrayIndex92 = 0;\n  let vowelsArrayIndex93 = 0;\n  let vowelsArrayIndex94 = 0;\n  let vowelsArrayIndex95 = 0;\n  let vowelsArrayIndex96 = 0;\n  let vowelsArrayIndex97 = 0;\n  let vowelsArrayIndex98 = 0;\n  let vowelsArrayIndex99 = 0;\n  let vowelsArrayIndex100 = 0;\n  let vowelsArrayIndex101 = 0;\n  let vowelsArrayIndex102 = 0;\n  let vowelsArrayIndex103 = 0;\n  let vowelsArrayIndex104 = 0;\n  let vowelsArrayIndex105 = 0;\n  let vowelsArrayIndex106 = 0;\n  let vowelsArrayIndex107 = 0;\n  let vowelsArrayIndex108 = 0;\n  let vowelsArrayIndex109 = 0;\n  let vowelsArrayIndex110 = 0;\n  let vowelsArrayIndex111 = 0;\n  let vowelsArrayIndex112 = 0;\n  let vowelsArrayIndex113 = 0;\n  let vowelsArrayIndex114 = 0;\n  let vowelsArrayIndex115 = 0;\n  let vowelsArrayIndex116 = 0;\n  let vowelsArrayIndex117 = 0;\n  let vowelsArrayIndex118 = 0;\n  let vowelsArrayIndex119 = 0;\n  let vowelsArrayIndex120 = 0;\n  let vowelsArrayIndex121 = 0;\n  let vowelsArrayIndex122 = 0;\n  let vowelsArrayIndex123 = 0;\n  let vowelsArrayIndex124 = 0;\n  let vowelsArrayIndex125 = 0;\n  let vowelsArrayIndex126 = 0;\n  let vowelsArrayIndex127 = 0;\n  let vowelsArrayIndex128 = 0;\n  let vowelsArrayIndex129 = 0;\n  let vowelsArrayIndex130 = 0;\n  let vowelsArrayIndex131 = 0;\n  let vowelsArrayIndex132 = 0;\n  let vowelsArrayIndex133 = 0;\n  let vowelsArrayIndex134 = 0;\n  let vowelsArrayIndex135 = 0;\n  let vowelsArrayIndex136 = 0;\n  let vowelsArrayIndex137 = 0;\n  let vowelsArrayIndex138 = 0;\n  let vowelsArrayIndex139 = 0;\n  let vowelsArrayIndex140 = 0;\n  let vowelsArrayIndex141 = 0;\n  let vowelsArrayIndex142 = 0;\n  let vowelsArrayIndex143 = 0;\n  let vowelsArrayIndex144 = 0;\n  let vowelsArrayIndex145 = 0;\n  let vowelsArrayIndex146 = 0;\n  let vowelsArrayIndex147 = 0;\n  let vowelsArrayIndex148 = 0;\n  let vowelsArrayIndex149 = 0;\n  let vowelsArrayIndex150 = 0;\n  let vowelsArrayIndex151 = 0;\n  let vowelsArrayIndex152 = 0;\n  let vowelsArrayIndex153 = 0;\n  let vowelsArrayIndex154 = 0;\n  let vowelsArrayIndex155 = 0;\n  let vowelsArrayIndex156 = 0;\n  let vowelsArrayIndex157 = 0;\n  let vowelsArrayIndex158 = 0;\n  let vowelsArrayIndex159 = 0;\n  let vowelsArrayIndex160 = 0;\n  let vowelsArrayIndex161 = 0;\n  let vowelsArrayIndex162 = 0;\n  let vowelsArrayIndex163 = 0;\n  let vowelsArrayIndex164 = 0;\n  let vowelsArrayIndex165 = 0;\n  let vowelsArrayIndex166 = 0;\n  let vowelsArrayIndex167 = 0;\n  let vowelsArrayIndex168 = 0;\n  let vowelsArrayIndex169 = 0;\n"}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "gc": "<|endoftext|>/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = [];\n  let curr = lst[0];\n  let next = lst[1];\n  while (curr && next && curr.match(/\\(|\\)/g)) {\n    if (curr.match(/\\(|\\)/g)) {\n      stack.push(curr);\n      curr = next;\n      next = undefined;\n    } else {\n      next = curr.match(/\\(|\\)/g);\n      curr = next;\n    }\n  }\n  if (curr) {\n    stack.push(curr);\n  }\n  let res = true;\n  for (let i = 0; i < stack.length; i++) {\n    if (stack[i]!== stack[i - 1]) {\n      res = false;\n      break;\n    }\n  }\n  return res;\n};\n\n/**\n * Given a string of parentheses, return the string with only the\n * opening parentheses removed.\n * Examples:\n * removeParens('(())()') === '()()'\n * removeParens('(())') === '()'\n * removeParens('()()') === '()'\n */\nconst removeParens = (str) => {\n  let res = '';\n  let stack = [];\n  let curr = str;\n  while (curr && curr.match(/\\(|\\)/g)) {\n    if (curr.match(/\\(|\\)/g)) {\n      stack.push(curr);\n      curr = undefined;\n    } else {\n      curr = curr.match(/\\(|\\)/g);\n    }\n  }\n  if (curr) {\n    stack.push(curr);\n  }\n  for (let i = 0; i < stack.length; i++) {\n    if (stack[i]!== stack[i - 1]) {\n      res = stack[i];\n      break;\n    }\n  }\n  return res;\n};\n\n/**\n * Given a string of parentheses, return the string with only the\n * closing parentheses removed.\n * Examples:\n * removeParens('(())()') === '()()'\n * removeParens('(())') === '()'\n * removeParens('()()') === '()'\n */\nconst removeParens2 = (str) => {\n  let res = '';\n  let stack = [];\n  let curr = str;\n  while (curr && curr.match(/\\(|\\)/g)) {\n    if (curr.match(/\\(|\\)/g)) {\n      stack.push(curr);\n      curr = undefined;\n    } else {\n      curr = curr.match(/\\(|\\)/g);\n    }\n  }\n  if (curr) {\n    stack.push(curr);\n  }\n  for (let i = 0; i < stack.length; i++) {\n    if (stack[i]!== stack[i - 1]) {\n      res = stack[i];\n      break;\n    }\n  }\n  return res;\n};\n\n/**\n * Given a string of parentheses, return the string with only the\n * opening parentheses removed.\n * Examples:\n * removeParens('(())()') === '()()'\n * removeParens('(())') === '()'\n * removeParens('()()') === '()'\n */\nconst removeParens3 = (str) => {\n  let res = '';\n  let stack = [];\n  let curr = str;\n  while (curr && curr.match(/\\(|\\)/g)) {\n    if (curr.match(/\\(|\\)/g)) {\n      stack.push(curr);\n      curr = undefined;\n    } else {\n      curr = curr.match(/\\(|\\)/g);\n    }\n  }\n  if (curr) {\n    stack.push(curr);\n  }\n  for (let i = 0; i < stack.length; i++) {\n    if (stack[i]!== stack[i - 1]) {\n      res = stack[i];\n      break;\n    }\n  }\n  return res;\n};\n\n/**\n * Given a string of parentheses, return the string with only the\n * opening parentheses removed.\n * Examples:\n * removeParens('(())()') === '()()'\n * removeParens('(())') === '()'\n * removeParens('()()') === '()'\n */\nconst removeParens4 = (str) => {\n  let res = '';\n  let stack = [];\n  let curr = str;\n  while (curr && curr.match(/\\(|\\)/g)) {\n    if (curr.match(/\\(|\\)/g)) {\n      stack.push(curr);\n      curr = undefined;\n    } else {\n      curr = curr.match(/\\(|\\)/g);\n    }\n  }\n  if (curr) {\n    stack.push(curr);\n  }\n  for (let i = 0; i < stack.length; i++) {\n    if (stack[i]!== stack[i - 1]) {\n      res = stack[i];\n      break;\n    }\n  }\n  return res;\n};\n\n/**\n * Given a string of parentheses, return the string with only the\n * opening parentheses removed.\n * Examples:\n * removeParens('(())()') === '()()'\n * removeParens('(())') === '()'\n * removeParens('()()') === '()'\n */\nconst removeParens5 = (str) => {\n  let res = '';\n  let stack = [];\n  let curr = str;\n  while (curr && curr.match(/\\(|\\)/g)) {\n    if (curr.match(/\\(|\\)/g)) {\n      stack.push(curr);\n      curr = undefined;\n    } else {\n      curr = curr.match(/\\(|\\)/g);\n    }\n  }\n  if (curr) {\n    stack.push(curr);\n  }\n  for (let i = 0; i < stack.length; i++) {\n    if (stack[i]!== stack[i - 1]) {\n      res = stack[i];\n      break;\n    }\n  }\n  return res;\n};\n\n/**\n * Given a string of parentheses, return the string with only the\n * opening parentheses removed.\n * Examples:\n * removeParens('(())()') === '()()'\n * removeParens('(())') === '()'\n * removeParens('()()') === '()'\n */\nconst removeParens6 = (str) => {\n  let res = '';\n  let stack = [];\n  let curr = str;\n  while (curr && curr.match(/\\(|\\)/g)) {\n    if (curr.match(/\\(|\\)/g)) {\n      stack.push(curr);\n      curr = undefined;\n    } else {\n      curr = curr.match(/\\(|\\)/g);\n    }\n  }\n  if (curr) {\n    stack.push(curr);\n  }\n  for (let i = 0; i < stack.length; i++) {\n    if (stack[i]!== stack[i - 1]) {\n      res = stack[i];\n      break;\n    }\n  }\n  return res;\n};\n\n/**\n * Given a string of parentheses, return the string with only the\n * opening parentheses removed.\n * Examples:\n * removeParens('(())()') === '()()'\n * removeParens('(())') === '()'\n * removeParens('()()') === '()'\n */\nconst removeParens7 = (str) => {\n  let res = '';\n  let stack = [];\n  let curr = str;\n  while (curr && curr.match(/\\(|\\)/g)) {\n    if (curr.match(/\\(|\\)/g)) {\n      stack.push(curr);\n      curr = undefined;\n    } else {\n      curr = curr.match(/\\(|\\)/g);\n    }\n  }\n  if (curr) {\n    stack.push(curr);\n  }\n  for (let i = 0; i < stack.length; i++) {\n    if (stack[i]!== stack[i - 1]) {\n      res = stack[i];\n      break;\n    }\n  }\n  return res;\n};\n\n/**\n * Given a string of parentheses, return the string with only the\n * "}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "gc": "<|endoftext|>/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const result = [];\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n    if (max === arr[i]) {\n      result.push(max);\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let ans = Number.MAX_VALUE;\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n    }\n    if (max === nums[i]) {\n      ans = i;\n    }\n  }\n  return ans;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let ans = Number.MAX_VALUE;\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n    }\n    if (max === nums[i]) {\n      ans = i;\n    }\n  }\n  return ans;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let ans = Number.MAX_VALUE;\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n    }\n    if (max === nums[i]) {\n      ans = i;\n    }\n  }\n  return ans;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let ans = Number.MAX_VALUE;\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n    }\n    if (max === nums[i]) {\n      ans = i;\n    }\n  }\n  return ans;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let ans = Number.MAX_VALUE;\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n    }\n    if (max === nums[i]) {\n      ans = i;\n    }\n  }\n  return ans;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let ans = Number.MAX_VALUE;\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n    }\n    if (max === nums[i]) {\n      ans = i;\n    }\n  }\n  return ans;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let ans = Number.MAX_VALUE;\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n    }\n    if (max === nums[i]) {\n      ans = i;\n    }\n  }\n  return ans;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let ans = Number.MAX_VALUE;\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n    }\n    if (max === nums[i]) {\n      ans = i;\n    }\n  }\n  return ans;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let ans = Number.MAX_VALUE;\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n    }\n    if (max === nums[i]) {\n      ans = i;\n    }\n  }\n  return ans;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let ans = Number.MAX_VALUE;\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n    }\n    if (max === nums[i]) {\n      ans = i;\n    }\n  }\n  return ans;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let ans = Number.MAX_VALUE;\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n    }\n    if (max === nums[i]) {\n      ans = i;\n    }\n  }\n  return ans;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let ans = Number.MAX_VALUE;\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n    }\n    if (max === nums[i]) {\n      ans = i;\n    }\n  }\n  return ans;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxSubArraySum = function(nums) {\n  let ans = Number.MAX_VALUE;\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n    }\n    if (max === nums[i]) {\n      ans = i;\n    }\n  }\n  return ans;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum"}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "gc": "<|endoftext|>/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution\n};\n\n},{}],4:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution\n};\n\n},{}],5:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution\n};\n\n},{}],6:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution\n};\n\n},{}],7:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution\n};\n\n},{}],8:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution\n};\n\n},{}],9:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution\n};\n\n},{}],10:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution\n};\n\n},{}],11:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution\n};\n\n},{}],12:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution\n};\n\n},{}],13:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution\n};\n\n},{}],14:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution\n};\n\n},{}],15:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum"}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "gc": "<|endoftext|>/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most three digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 36 # sum of 3 + 5 + 7 + 8\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most four digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 60 # sum of 3 + 5 + 7 + 8 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most five digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 120 # sum of 3 + 5 + 7 + 8 + 9 + 11\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most six digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 240 # sum of 3 + 5 + 7 + 8 + 9 + 11 + 12\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most seven digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 360 # sum of 3 + 5 + 7 + 8 + 9 + 11 + 12 + 13 + 14 + 15\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most eight digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 720 # sum of 3 + 5 + 7 + 8 + 9 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most nine digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 720 # sum of 3 + 5 + 7 + 8 + 9 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most ten digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 720 # sum of 3 + 5 + 7 + 8 + 9 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most eleven digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 720 # sum of 3 + 5 + 7 + 8 + 9 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most twenty digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 720 # sum of 3 + 5 + 7 + 8 + 9 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += "}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      n /= 2;\n    } else {\n      i++;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5, 3] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are 1, 5, 3, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      n /= 2;\n    } else {\n      i++;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are 1, 3, 5, 7, 9, and 5.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      n /= 2;\n    } else {\n      i++;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are 1, 3, 5, 7, 9, and 5.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      n /= 2;\n    } else {\n      i++;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are 1, 3, 5, 7, 9, and 5.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      n /= 2;\n    } else {\n      i++;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are 1, 3, 5, 7, 9, and 5.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let i = 1;\n  while (n > 0) {\n    if (n % 2 === 0) {\n      collatz.push(i);\n      n /= 2;\n    } else {\n      i++;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus "}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "gc": "<|endoftext|>/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  let isValid = true;\n  let dateArray = date.split('-');\n  let monthArray = dateArray[0].split('-');\n  let dayArray = dateArray[1].split('-');\n  let year = dateArray[2];\n  let month = monthArray[0];\n  let day = dayArray[0];\n  let dateArrayLength = dateArray.length;\n  let monthArrayLength = monthArray.length;\n  let dayArrayLength = dayArray.length;\n  if (dateArrayLength < 1 || dateArrayLength > 31) {\n    isValid = false;\n  }\n  if (monthArrayLength < 1 || monthArrayLength > 12) {\n    isValid = false;\n  }\n  if (dayArrayLength < 1 || dayArrayLength > 31) {\n    isValid = false;\n  }\n  if (year < 1900 || year > 2099) {\n    isValid = false;\n  }\n  if (month < 1 || month > 12) {\n    isValid = false;\n  }\n  if (day < 1 || day > 31) {\n    isValid = false;\n  }\n  return isValid;\n};\n\n/*\n  You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  let isValid = true;\n  let dateArray = date.split('-');\n  let monthArray = dateArray[0].split('-');\n  let dayArray = dateArray[1].split('-');\n  let year = dateArray[2];\n  let month = monthArray[0];\n  let day = dayArray[0];\n  let dateArrayLength = dateArray.length;\n  let monthArrayLength = monthArray.length;\n  let dayArrayLength = dayArray.length;\n  if (dateArrayLength < 1 || dateArrayLength > 31) {\n    isValid = false;\n  }\n  if (monthArrayLength < 1 || monthArrayLength > 12) {\n    isValid = false;\n  }\n  if (dayArrayLength < 1 || dayArrayLength > 31) {\n    isValid = false;\n  }\n  if (year < 1900 || year > 2099) {\n    isValid = false;\n  }\n  if (month < 1 || month > 12) {\n    isValid = false;\n  }\n  if (day < 1 || day > 31) {\n    isValid = false;\n  }\n  return isValid;\n};\n\n/*\n  You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  let isValid = true;\n  let dateArray = date.split('-');\n  let monthArray = dateArray[0].split('-');\n  let dayArray = dateArray[1].split('-');\n  let year = dateArray[2];\n  let month = monthArray[0];\n  let day = dayArray[0];\n  let dateArrayLength = dateArray.length;\n  let monthArrayLength = monthArray.length;\n  let dayArrayLength = dayArray.length;\n  if (dateArrayLength < 1 || dateArrayLength > 31) {\n    isValid = false;\n  }\n  if (monthArrayLength < 1 || monthArrayLength > 12) {\n    isValid = false;\n  }\n  if (dayArrayLength < 1 || dayArrayLength > 31) {\n    isValid = false;\n  }\n  if (year < 1900 || year > 2099) {\n    isValid = false;\n  }\n  if (month < 1 || month > 12) {\n    isValid = false;\n  }\n  if (day < 1 || day > 31) {\n    isValid = false;\n  }\n  return isValid;\n};\n\n/*\n  You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  let isValid = true;\n  let dateArray = date.split('-');\n  let monthArray = dateArray[0].split('-');\n  let dayArray = dateArray[1].split('-');\n  let year = dateArray[2];\n  let month = monthArray[0];\n  let day = dayArray[0];\n  let dateArrayLength = dateArray.length;\n  let monthArrayLength = monthArray.length;\n  let dayArrayLength = dayArray.length;\n  if (dateArrayLength < 1 || dateArrayLength > 31) {\n    isValid = false;\n  }\n  if (monthArrayLength < 1 || monthArrayLength > 12) {\n    isValid = false;\n  }\n  if (dayArrayLength < 1 || dayArrayLength > 31) {\n    isValid = false;\n  }\n  if (year < 1900 || year > 2099) {\n    isValid = false;\n  }\n  if (month < 1 || month > 12) {\n    isValid = false;\n  }\n  if (day < 1 || day > 31) {\n    isValid = false;\n  }\n  return isValid;\n};\n\n/*\n  You have to write a function which validate"}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "gc": "<|endoftext|>/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      const lowerCaseLetters = word.toLowerCase().split(\"\");\n      const oddOrder = lowerCaseLetters.filter(x => x % 2 === 0);\n      if (oddOrder.length > 0) {\n        result.push(word);\n      }\n    }\n  }\n  return result;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsNoWhitespaces = (txt) => {\n  const words = txt.split(\"\");\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      const lowerCaseLetters = word.toLowerCase().split(\"\");\n      const oddOrder = lowerCaseLetters.filter(x => x % 2 === 0);\n      if (oddOrder.length > 0) {\n        result.push(word);\n      }\n    }\n  }\n  return result;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsNoWhitespaces_noWhitespaces = (txt) => {\n  const words = txt.split(\"\");\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      const lowerCaseLetters = word.toLowerCase().split(\"\");\n      const oddOrder = lowerCaseLetters.filter(x => x % 2 === 0);\n      if (oddOrder.length > 0) {\n        result.push(word);\n      }\n    }\n  }\n  return result;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsNoWhitespaces_noWhitespaces_noWhitespaces = (txt) => {\n  const words = txt.split(\"\");\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      const lowerCaseLetters = word.toLowerCase().split(\"\");\n      const oddOrder = lowerCaseLetters.filter(x => x % 2 === 0);\n      if (oddOrder.length > 0) {\n        result.push(word);\n      }\n    }\n  }\n  return result;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsNoWhitespaces_noWhitespaces_noWhitespaces_noWhitespaces = (txt) => {\n  const words = txt.split(\"\");\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      const lowerCaseLetters = word.toLowerCase().split(\"\");\n      const oddOrder = lowerCaseLetters.filter(x => x % 2 === 0);\n      if (oddOrder.length > 0) {\n        result.push(word);\n      }\n    }\n  }\n  return result;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsNoWhitespaces_noWhitespaces_noWhitespaces_noWhitespaces_noWhitespaces = (txt) => {\n  const words = txt.split(\"\");\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      const lowerCaseLetters = word.toLowerCase().split(\"\");\n      const oddOrder = lowerCaseLetters.filter(x => x % 2 === 0);\n      if (oddOrder.length > 0) {\n        result.push(word);\n      }\n    }\n  }\n  return result;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsNoWhitespaces_noWhitespaces_noWhitespaces_noWhitespaces_noWhitespaces_noWhitespaces = (txt) => {\n  const words = txt.split(\"\");\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length > 0) {\n      const lowerCaseLetters = word.toLowerCase().split(\"\");\n      const oddOrder = lowerCaseLetters.filter(x => x % 2 === 0);\n      if (oddOrder.length > 0) {\n        result.push(word);\n      }\n    }\n  }\n  return result;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  "}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "gc": "<|endoftext|>/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  const len = lst.length\n  if (len <= 1) return true\n  const [first,...rest] = lst\n  if (first === rest[0]) return false\n  return isSorted(rest)\n}\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n * in descending order. If list has more than 1 duplicate of the same\n * number, return false. Assume no negative numbers and only integers.\n * Examples\n  isSorted([5, 4, 3, 2, 1]) ➞ false\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) �"}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "gc": "<|endoftext|>/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  let start1 = interval1[0];\n  let end1 = interval1[1];\n  let start2 = interval2[0];\n  let end2 = interval2[1];\n\n  if (start1 < end1 && start2 < end2) {\n    if (start1 < start2) {\n      return (end1 < end2)? false : true;\n    }\n    if (start2 < start1) {\n      return (end2 < end1)? false : true;\n    }\n  }\n  return false;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] boolean: true if intervals intersect\n*/\nconst isIntersect = (intervals) => {\n  let start1 = intervals[0][0];\n  let end1 = intervals[0][1];\n  let start2 = intervals[1][0];\n  let end2 = intervals[1][1];\n\n  if (start1 < end1 && start2 < end2) {\n    if (start1 < start2) {\n      return (end1 < end2)? false : true;\n    }\n    if (start2 < start1) {\n      return (end2 < end1)? false : true;\n    }\n  }\n  return false;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] boolean: true if intervals intersect\n*/\nconst isIntersect2 = (intervals) => {\n  let start1 = intervals[0][0];\n  let end1 = intervals[0][1];\n  let start2 = intervals[1][0];\n  let end2 = intervals[1][1];\n\n  if (start1 < end1 && start2 < end2) {\n    if (start1 < start2) {\n      return (end1 < end2)? false : true;\n    }\n    if (start2 < start1) {\n      return (end2 < end1)? false : true;\n    }\n  }\n  return false;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] boolean: true if intervals intersect\n*/\nconst isIntersect3 = (intervals) => {\n  let start1 = intervals[0][0];\n  let end1 = intervals[0][1];\n  let start2 = intervals[1][0];\n  let end2 = intervals[1][1];\n\n  if (start1 < end1 && start2 < end2) {\n    if (start1 < start2) {\n      return (end1 < end2)? false : true;\n    }\n    if (start2 < start1) {\n      return (end2 < end1)? false : true;\n    }\n  }\n  return false;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] boolean: true if intervals intersect\n*/\nconst isIntersect4 = (intervals) => {\n  let start1 = intervals[0][0];\n  let end1 = intervals[0][1];\n  let start2 = intervals[1][0];\n  let end2 = intervals[1][1];\n\n  if (start1 < end1 && start2 < end2) {\n    if (start1 < start2) {\n      return (end1 < end2)? false : true;\n    }\n    if (start2 < start1) {\n      return (end2 < end1)? false : true;\n    }\n  }\n  return false;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] boolean: true if intervals intersect\n*/\nconst isIntersect5 = (intervals) => {\n  let start1 = intervals[0][0];\n  let end1 = intervals[0][1];\n  let start2 = intervals[1][0];\n  let end2 = intervals[1][1];\n\n  if (start1 < end1 && start2 < end2) {\n    if (start1 < start2) {\n      return (end1 < end2)? false : true;\n    }\n    if (start2 < start1) {\n      return (end2 < end1)? false : true;\n    }\n  }\n  return false;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] boolean: true if intervals intersect\n*/\nconst isIntersect6 = (intervals) => {\n  let start1 = intervals[0][0];\n  let end1 = intervals[0][1];\n  let start2 = intervals[1][0];\n  let end2 = intervals[1][1];\n\n  if (start1 < end1 && start2 < end2) {\n    if (start1 < start2) {\n      return (end1 < end2)? false : true;\n    }\n    if (start2 < start1) {\n      return (end2 < end1)? false : true;\n    }\n  }\n  return false;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] boolean: true if intervals intersect\n*/\nconst isIntersect7 = (intervals) => {\n  let start1 = intervals[0][0];\n  let end1 = intervals[0][1];\n  let start2 = intervals[1][0];\n  let end2 = intervals[1][1];\n\n  if (start1 < end1 && start2 < end2) {\n    if (start1 < start2) {\n      return (end1 < end2)? false : true;\n    }\n    if (start2 < start1) {\n      return (end2 < end1)? false : true;\n    }\n  }\n  return false;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] boolean: true if intervals intersect\n*/\nconst isIntersect8 = (intervals) => {\n  let start1 = intervals[0][0];\n  let end1 = intervals[0][1];\n  let start2 = intervals[1][0];\n  let end2 = intervals[1][1];\n\n  if (start1 < end1 && start2 < end2) {\n    if (start1 < start2) {\n      return (end1 < end2)? false : true;\n    }\n    if (start2 < start1) {\n      return (end2 < end1)? false : true;\n    }\n  }\n  return false;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] boolean: true if intervals intersect\n*/\nconst isIntersect9 = (intervals) => {\n  let start1 = intervals[0][0];\n  let end1 = intervals[0][1];\n  let start2 = intervals[1][0];\n  let end2 = intervals[1][1];\n\n  if (start1 < end1 && start2 < end2) {\n    if (start1 < start2) {\n      return (end1 < end2)? false : true;\n    }\n    if (start2 < start1) {\n      return (end2 < end1)? false : true;\n    }\n  }\n  return false;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] boolean: true if intervals intersect\n*/\nconst isIntersect10 = (intervals) => {\n  let start1 = intervals[0][0];\n  let end1 = intervals[0][1];\n  let start2 = intervals[1][0];\n  let end2 = intervals[1][1];\n\n  if (start1 < end1 && start2 < end2) {\n    if (start1 < start2) {\n      return (end1 < end2)? false : true;\n    }\n    if (start2 < start1) {\n      return (end2 < end1)? false : true;\n    }\n  }\n  return false;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] boolean: true if intervals intersect\n*/\nconst isIntersect11 = (intervals) => {\n  let start1 = intervals[0][0];\n  let end1 = intervals[0][1];\n  let start2 = intervals[1][0];\n  let end2 = intervals[1][1];\n\n  if (start1 < end1 && start2 < end2) {\n    if (start1 < start2) {\n      return (end1 < end2)? false : true;\n    }\n    if (start2 < start1) {\n      return (end2 < end1)? false : true;\n    }"}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "gc": "<|endoftext|>/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(n => n % 1)\n  const signsLength = signs.length\n  const sums = signs.map(n => n * signsLength)\n  return sums.reduce((acc, n) => acc + Math.abs(n), 0)\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSigns([1, 2, 2, -4]) == -9\n  >>> absSigns([0, 1]) == 0\n  >>> absSigns([]) == null\n  */\nconst absSigns = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(n => n % 1)\n  const signsLength = signs.length\n  const sums = signs.map(n => Math.abs(n) * signsLength)\n  return sums.reduce((acc, n) => acc + Math.abs(n), 0)\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSigns([1, 2, 2, -4]) == -9\n  >>> absSigns([0, 1]) == 0\n  >>> absSigns([]) == null\n  */\nconst absSignsAll = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(n => n % 1)\n  const signsLength = signs.length\n  const sums = signs.map(n => Math.abs(n) * signsLength)\n  return sums.reduce((acc, n) => acc + Math.abs(n), 0)\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSignsAll([1, 2, 2, -4]) == -9\n  >>> absSignsAll([0, 1]) == 0\n  >>> absSignsAll([[]]) == null\n  */\nconst absSignsAllAll = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(n => n % 1)\n  const signsLength = signs.length\n  const sums = signs.map(n => Math.abs(n) * signsLength)\n  return sums.reduce((acc, n) => acc + Math.abs(n), 0)\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSignsAllAll([1, 2, 2, -4]) == -9\n  >>> absSignsAllAll([0, 1]) == 0\n  >>> absSignsAllAll([[]]) == null\n  */\nconst absSignsAllAllAll = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(n => n % 1)\n  const signsLength = signs.length\n  const sums = signs.map(n => Math.abs(n) * signsLength)\n  return sums.reduce((acc, n) => acc + Math.abs(n), 0)\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSignsAllAllAll([1, 2, 2, -4]) == -9\n  >>> absSignsAllAllAll([0, 1]) == 0\n  >>> absSignsAllAllAll([[]]) == null\n  */\nconst absSignsAllAllAllAll = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(n => n % 1)\n  const signsLength = signs.length\n  const sums = signs.map(n => Math.abs(n) * signsLength)\n  return sums.reduce((acc, n) => acc + Math.abs(n), 0)\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSignsAllAllAllAll([1, 2, 2, -4]) == -9\n  >>> absSignsAllAllAllAll([0, 1]) == 0\n  >>> absSignsAllAllAllAll([[]]) == null\n  */\nconst absSignsAllAllAllAllAll = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(n => n % 1)\n  const signsLength = signs.length\n  const sums = signs.map(n => Math.abs(n) * signsLength)\n  return sums.reduce((acc, n) => acc + Math.abs(n), 0)\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSignsAllAllAllAll([1, 2, 2, -4]) == -9\n  >>> absSignsAllAllAllAllAll([0, 1]) == 0\n  >>> absSignsAllAllAllAllAll([[]]) == null\n  */\nconst absSignsAllAllAllAllAll = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(n => n % 1)\n  const signsLength = signs.length\n  const sums = signs.map(n => Math.abs(n) * signsLength)\n  return sums.reduce((acc, n) => acc + Math.abs(n), 0)\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSignsAllAllAllAllAll([1, 2, 2, -4]) == -9\n  >>> absSignsAllAllAllAllAll([0, 1]) == 0\n  >>> absSignsAllAllAllAllAll([[]]) == null\n  */\nconst absSignsAllAllAllAllAllAll = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(n => n % 1)\n  const signsLength = signs.length\n  const sums = signs.map(n => Math.abs(n) * signsLength)\n  return sums.reduce((acc, n) => acc + Math.abs(n), 0)\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSignsAllAllAllAllAll([1, 2, 2, -4]) == -9\n  >>> absSignsAllAllAllAllAllAll([0, 1]) == 0\n  >>> absSignsAllAllAllAllAll([[]]) == null"}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [path] = [];\n  const visited = new Set();\n  const queue = [...grid];\n  while (queue.length) {\n    const cell = queue.shift();\n    if (visited.has(cell)) {\n      continue;\n    }\n    visited.add(cell);\n    path.push(cell);\n    if (k === 1) {\n      return path;\n    }\n    const neighbors = grid[cell].filter(cell =>!visited.has(cell));\n    neighbors.forEach(cell => {\n      if (visited.has(cell)) {\n        return;\n      }\n      queue.push(cell);\n      visited.add(cell);\n    });\n  }\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-sum-ii/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iii/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iiii/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n// https://leetcode.com/problems/find-the-minimum-path-sum-iv/\n"}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "gc": "<|endoftext|>/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  if (n <= 1) return [1];\n  if (n <= 2) return [n, 1];\n  if (n <= 3) return [n, 1, 1];\n  if (n <= 4) return [n, 1, 3, 2];\n  if (n <= 5) return [n, 1, 3, 6, 10];\n  if (n <= 6) return [n, 1, 5, 15, 31];\n  if (n <= 7) return [n, 1, 7, 31, 61];\n  if (n <= 8) return [n, 1, 9, 63, 127, 258, 429, 671]\n  if (n <= 9) return [n, 1, 13, 129, 259, 531, 1021];\n  if (n <= 10) return [n, 1, 21, 429, 1023, 2039, 4095];\n  if (n <= 11) return [n, 1, 43, 921, 2039, 4095, 6149];\n  if (n <= 12) return [n, 1, 97, 2411, 4141, 9213, 20401];\n  if (n <= 13) return [n, 1, 2039, 4095, 6149, 9213, 2411];\n  if (n <= 14) return [n, 1, 4141, 9213, 2411, 4141, 9213];\n  if (n <= 15) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 16) return [n, 1, 20401, 2039, 4095, 6149, 9213, 2411];\n  if (n <= 17) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 18) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 19) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 20) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 21) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 22) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 23) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 24) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 25) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 26) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 27) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 28) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 29) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 30) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 31) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 32) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 33) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 34) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 35) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 36) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 37) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 38) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 39) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 40) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 41) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 42) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 43) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 44) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 45) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 46) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 47) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 48) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 49) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 50) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 51) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 52) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 53) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 54) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 55) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 56) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 57) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 58) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 59) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 60) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 61) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 62) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 63) return [n, 1, 4141, 9213, 2411, 4141, 9213, 20401];\n  if (n <= 64) return [n, 1, 9213, 2411, 4141, 9213, 20401, 2039];\n  if (n <= 65) return [n, 1, 414"}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "gc": "<|endoftext|>/*Given a positive integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the even digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result /= i;\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the sum of all the even digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the sum of all the odd digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result /= i;\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the sum of all the even and odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result += digits(i);\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the sum of all the even and odd digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result += digits(i);\n  }\n  return result % 2 === 0? result : 0;\n};\n\n/*Given a positive integer n, return the sum of all the even and odd digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result += digits(i);\n  }\n  return result % 2 === 0? result : 0;\n};\n\n/*Given a positive integer n, return the sum of all the even and odd digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result += digits(i);\n  }\n  return result % 2 === 0? result : 0;\n};\n\n/*Given a positive integer n, return the sum of all the even and odd digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result += digits(i);\n  }\n  return result % 2 === 0? result : 0;\n};\n\n/*Given a positive integer n, return the sum of all the even and odd digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result += digits(i);\n  }\n  return result % 2 === 0? result : 0;\n};\n\n/*Given a positive integer n, return the sum of all the even and odd digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result += digits(i);\n  }\n  return result % 2 === 0? result : 0;\n};\n\n/*Given a positive integer n, return the sum of all the even and odd digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result += digits(i);\n  }\n  return result % 2 === 0? result : 0;\n};\n\n/*Given a positive integer n, return the sum of all the even and odd digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result += digits(i);\n  }\n  return result % 2 === 0? result : 0;\n};\n\n/*Given a positive integer n, return the sum of all the even and odd digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result += digits(i);\n  }\n  return result % 2 === 0? result : 0;\n};\n\n/*Given a positive integer n, return the sum of all the even and odd digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result += digits(i);\n  }\n  return result % 2 === 0? result : 0;\n};\n\n/*Given a positive integer n, return the sum of all the even and odd digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result += digits(i);\n  }\n  return result % 2 === 0? result : 0;\n};\n\n/*Given a positive integer n, return the sum of all the even and odd digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result += digits(i);\n  }\n  return result % 2 === 0? result : 0;\n};\n\n/*Given a positive integer n, return the sum of all the even and odd digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result += digits(i);\n  }\n  return result % 2 === 0? result : 0;\n};\n\n/*Given a positive integer n, return the "}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "gc": "<|endoftext|>/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const stack = [string];\n  while (stack.length > 0) {\n    const char = stack.pop();\n    if (char === '[') {\n      if (stack.length > 0) {\n        stack.push(stack.pop());\n      } else {\n        return true;\n      }\n    } else if (char === ']') {\n      if (stack.length > 0) {\n        stack.push(stack.pop());\n      } else {\n        return false;\n      }\n    } else if (char === '[' || char === ']') {\n      if (stack.length > 0) {\n        stack.push(char);\n      } else {\n        return false;\n      }\n    }\n  }\n};\n\n/**\n * Given a string of characters, return a string that consists of only the characters in the\n * string that are in the given set.\n *\n * Examples:\n *\n * isSubset('abc', ['a', 'b', 'c']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'a']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'a', 'b']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'a', 'b', 'c', 'd']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'a', 'b', 'c', 'd', 'e']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'a', 'b', 'c', 'd', 'e', 'f']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'a', 'b', 'c', 'd', 'e', 'f', 'g']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']) ➞ 'abc'\n * isSubset('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'a', 'b', 'c', 'd', '"}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "gc": "<|endoftext|>/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You are given an integer C.\n  You are to find the minimum number of steps to reach C.\n  Examples:\n  For lst = [1,2,3,4,5,6,7,8,9,10] the output should be 1\n  For lst = [1,3,5,7] the output should be 2\n  For lst = [1,3,5,7,9] the output should be 3\n  For lst = [1,3,5,7,9,10] the output should be 4\n  For lst = [1,3,5,7,9,10,11] the output should be 5\n  For lst = [1,3,5,7,9,10,11,12] the output should be 6\n  For lst = [1,3,5,7,9,10,11,12,13] the output should be 7\n  For lst = [1,3,5,7,9,10,11,12,13,14] the output should be 8\n  For lst = [1,3,5,7,9,10,11,12,13,14,15] the output should be 9\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16] the output should be 10\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17] the output should be 11\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18] the output should be 12\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19] the output should be 13\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20] the output should be 14\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21] \n  the output should be 15\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22] \n  the output should be 16\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23] \n  the output should be 17\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24] \n  the output should be 18\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25] \n  the output should be 19\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26] \n  the output should be 20\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27] \n  the output should be 21\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28] \n  the output should be 22\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29] \n  the output should be 23\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30] \n  the output should be 24\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31] \n  the output should be 25\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32] \n  the output should be 26\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33] \n  the output should be 27\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34] \n  the output should be 28\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35] \n  the output should be 29\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36] \n  the output should be 30\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37] \n  the output should be 31\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38] \n  the output should be 32\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39] \n  the output should be 33\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40] \n  the output should be 34\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41] \n  the output should be 35\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42] \n  the output should be 36\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43] \n  the output should be 37\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44] \n  the output should be 38\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45] \n  the output should be 39\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46] \n  the output should be 40\n  For lst = [1,3,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,"}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "gc": "<|endoftext|>/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar ==='' && lastChar!== '.' && lastChar!== '?';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALnum = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar ==='' && lastChar!== '.' && lastChar!== '?';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALnum2 = txt => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar ==='' && lastChar!== '.' && lastChar!== '?';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALnum3 = txt => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar ==='' && lastChar!== '.' && lastChar!== '?';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALnum4 = txt => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar ==='' && lastChar!== '.' && lastChar!== '?';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALnum5 = txt => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar ==='' && lastChar!== '.' && lastChar!== '?';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALnum6 = txt => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar ==='' && lastChar!== '.' && lastChar!== '?';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALnum7 = txt => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar ==='' && lastChar!== '.' && lastChar!== '?';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALnum8 = txt => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar ==='' && lastChar!== '.' && last"}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "gc": "<|endoftext|>/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = 0;\n  let index = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[max]) {\n      max = i;\n      index = i;\n    }\n  }\n  return index;\n};\n\n/**\n  Given an array of numbers, return an array which contains all the\n  numbers in the array except the number at the given index.\n\n  Examples:\n  removeFromArray([1,2,3,4,5,6,7,8,9], 2) = [3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 3) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 4) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 5) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 6) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 7) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 8) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 9) = [1,2,3,4,5,6,7,8,9]\n  */\nconst removeFromArray = (arr, index) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (i!== index) {\n      newArr.push(arr[i]);\n    }\n  }\n  return newArr;\n};\n\n/**\n  Given an array of numbers, return an array which contains all the\n  numbers in the array except the number at the given index.\n\n  Examples:\n  removeFromArray([1,2,3,4,5,6,7,8,9], 2) = [3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 3) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 4) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 5) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 6) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 7) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 8) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 9) = [1,2,3,4,5,6,7,8,9]\n  */\nconst removeFromArray = (arr, index) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (i!== index) {\n      newArr.push(arr[i]);\n    }\n  }\n  return newArr;\n};\n\n/**\n  Given an array of numbers, return an array which contains all the\n  numbers in the array except the number at the given index.\n\n  Examples:\n  removeFromArray([1,2,3,4,5,6,7,8,9], 2) = [3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 3) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 4) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 5) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 6) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 7) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 8) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 9) = [1,2,3,4,5,6,7,8,9]\n  */\nconst removeFromArray = (arr, index) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (i!== index) {\n      newArr.push(arr[i]);\n    }\n  }\n  return newArr;\n};\n\n/**\n  Given an array of numbers, return an array which contains all the\n  numbers in the array except the number at the given index.\n\n  Examples:\n  removeFromArray([1,2,3,4,5,6,7,8,9], 2) = [3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 3) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 4) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 5) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 6) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 7) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 8) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 9) = [1,2,3,4,5,6,7,8,9]\n  */\nconst removeFromArray = (arr, index) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (i!== index) {\n      newArr.push(arr[i]);\n    }\n  }\n  return newArr;\n};\n\n/**\n  Given an array of numbers, return an array which contains all the\n  numbers in the array except the number at the given index.\n\n  Examples:\n  removeFromArray([1,2,3,4,5,6,7,8,9], 2) = [3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 3) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 4) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 5) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 6) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 7) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 8) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 9) = [1,2,3,4,5,6,7,8,9]\n  */\nconst removeFromArray = (arr, index) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (i!== index) {\n      newArr.push(arr[i]);\n    }\n  }\n  return newArr;\n};\n\n/**\n  Given an array of numbers, return an array which contains all the\n  numbers in the array except the number at the given index.\n\n  Examples:\n  removeFromArray([1,2,3,4,5,6,7,8,9], 2) = [3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 3) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 4) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 5) = [1,2,3,4,5,6,7,8,9]\n  removeFromArray([1,2,3,4,5,6,7,8,9], 6) = [1,2,3,4,5,6,"}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "gc": "<|endoftext|>/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  if (lst == null || lst.length === 0) {\n    return null;\n  }\n  let largest = lst[0];\n  let smallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, largest];\n};\n\n// Given a list containing integers, return the largest and smallest\n// positive and negative integers such that they add up to a certain\n// value.\nconst sumOfPositiveIntegers = (lst) => {\n  if (lst == null || lst.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return [sum, sum];\n};\n\n// Given a list containing integers, return the largest and smallest\n// positive and negative integers such that they add up to a certain\n// value.\nconst sumOfNegativeIntegers = (lst) => {\n  if (lst == null || lst.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return [sum, sum];\n};\n\n// Given a list containing integers, return the largest and smallest\n// positive and negative integers such that they add up to a certain\n// value.\nconst sumOfPositiveAndNegativeIntegers = (lst) => {\n  if (lst == null || lst.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return [sum, sum];\n};\n\n// Given a list containing integers, return the largest and smallest\n// positive and negative integers such that they add up to a certain\n// value.\nconst sumOfPositiveIntegersAndNegativeIntegers = (lst) => {\n  if (lst == null || lst.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return [sum, sum];\n};\n\n// Given a list containing integers, return the largest and smallest\n// positive and negative integers such that they add up to a certain\n// value.\nconst sumOfPositiveAndNegativeIntegersAndSumOfPositiveIntegers = (lst) => {\n  if (lst == null || lst.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return [sum, sum];\n};\n\n// Given a list containing integers, return the largest and smallest\n// positive and negative integers such that they add up to a certain\n// value.\nconst sumOfPositiveIntegersAndSumOfNegativeIntegers = (lst) => {\n  if (lst == null || lst.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return [sum, sum];\n};\n\n// Given a list containing integers, return the largest and smallest\n// positive and negative integers such that they add up to a certain\n// value.\nconst sumOfPositiveIntegersAndSumOfNegativeIntegersAndSumOfPositiveIntegers = (lst) => {\n  if (lst == null || lst.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return [sum, sum];\n};\n\n// Given a list containing integers, return the largest and smallest\n// positive and negative integers such that they add up to a certain\n// value.\nconst sumOfPositiveIntegersAndSumOfNegativeIntegersAndSumOfPositiveAndNegativeIntegers = (lst) => {\n  if (lst == null || lst.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return [sum, sum];\n};\n\n// Given a list containing integers, return the largest and smallest\n// positive and negative integers such that they add up to a certain\n// value.\nconst sumOfPositiveIntegersAndSumOfNegativeIntegersAndSumOfPositiveIntegersAndSumOfNegativeIntegers = (lst) => {\n  if (lst == null || lst.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return [sum, sum];\n};\n\n// Given a list containing integers, return the largest and smallest\n// positive and negative integers such that they add up to a certain\n// value.\nconst sumOfPositiveIntegersAndSumOfNegativeIntegersAndSumOfPositiveIntegersAndSumOfNegativeIntegersAndSumOfPositiveAndNegativeIntegers = (lst) => {\n  if (lst == null || lst.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return [sum, sum];\n};\n\n// Given a list containing integers, return the largest and smallest\n// positive and negative integers such that they add up to a certain\n// value.\nconst sumOfPositiveIntegersAndSumOfNegativeIntegersAndSumOfPositiveIntegersAndSumOfNegativeIntegersAndSumOfPositiveAndNegativeIntegersAndSumOfPositiveAndNegativeIntegers = (lst) => {\n  if (lst == null || lst.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return [sum, sum];\n};\n\n// Given a list containing integers, return the largest and smallest\n// positive and negative integers such that they add up to a certain\n// value.\nconst sumOfPositiveIntegersAndSumOfNegativeIntegersAndSumOfPositiveIntegersAndSumOfNegativeIntegersAndSumOfPositiveAndNegativeIntegersAndSumOfPositiveAndNegativeIntegers = (lst) => {\n  if (lst == null || lst.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return [sum, sum];\n};\n\n// Given a list containing integers, return the largest and smallest\n// positive and negative integers such that they add up to a certain\n// value.\nconst sumOfPositiveIntegersAndSumOfNegativeIntegersAndSumOfPositiveIntegersAndSumOfNegativeIntegersAndSumOfPositiveAndNegativeIntegersAndSumOfPositiveAndNegativeIntegers = (lst) => {\n  if (lst == null || lst.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return [sum, sum];\n};\n\n// Given a list containing integers, return the largest and smallest\n// positive and negative integers such that they add up to a certain\n// value.\nconst sumOfPositiveIntegersAndSumOfNegativeIntegersAndSumOfPositiveIntegersAndSumOfNegativeIntegersAndSumOfPositiveAndNegativeIntegersAndSumOfPositiveAndNegativeIntegers = (lst) => {\n  if (lst == null || lst.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return [sum, sum];\n};\n\n// Given a list containing integers, return the largest and smallest\n// positive and negative integers such that they add up to a certain\n// value.\nconst sumOfPositiveIntegersAndSumOfNegativeIntegersAndSumOfPositiveIntegersAndSumOfNegativeInteger"}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "gc": "<|endoftext|>/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === null || b === null) {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (isNaN(a) || isNaN(b)) {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if (a === \"\" || b === \"\") {\n    return null;\n  }\n  if ("}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "gc": "<|endoftext|>/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n <= 0) return false;\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    if (i % 2 === 0) return false;\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 negative even numbers\n  Example\n  isEqualToSumEven(-4) == false\n  isEqualToSumEven(-6) == false\n  isEqualToSumEven(-8) == true\n  */\nconst isEqualToSumEvenNegative = (n) => {\n  if (n <= 0) return false;\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    if (i % 2 === 1) return false;\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 negative odd numbers\n  Example\n  isEqualToSumEvenNegative(-4) == false\n  isEqualToSumEvenNegative(-6) == false\n  isEqualToSumEvenNegative(-8) == true\n  */\nconst isEqualToSumEvenNegativeNegative = (n) => {\n  if (n <= 0) return false;\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    if (i % 2 === 0) return false;\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumEvenPositive(4) == false\n  isEqualToSumEvenPositive(6) == false\n  isEqualToSumEvenPositive(8) == true\n  */\nconst isEqualToSumEvenPositive = (n) => {\n  if (n <= 0) return false;\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    if (i % 2 === 1) return false;\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 negative odd numbers\n  Example\n  isEqualToSumEvenNegative(-4) == false\n  isEqualToSumEvenNegative(-6) == false\n  isEqualToSumEvenNegative(-8) == true\n  */\nconst isEqualToSumEvenNegativeNegative = (n) => {\n  if (n <= 0) return false;\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    if (i % 2 === 0) return false;\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumEvenPositivePositive(4) == false\n  isEqualToSumEvenPositivePositive(6) == false\n  isEqualToSumEvenPositivePositive(8) == true\n  */\nconst isEqualToSumEvenPositivePositive = (n) => {\n  if (n <= 0) return false;\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    if (i % 2 === 1) return false;\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 negative even numbers\n  Example\n  isEqualToSumEvenNegativePositive(-4) == false\n  isEqualToSumEvenNegativePositive(-6) == false\n  isEqualToSumEvenNegativePositive(-8) == true\n  */\nconst isEqualToSumEvenNegativePositive = (n) => {\n  if (n <= 0) return false;\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    if (i % 2 === 0) return false;\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEvenPositivePositive(4) == false\n  isEqualToSumEvenPositivePositive(6) == false\n  isEqualToSumEvenPositivePositive(8) == true\n  */\nconst isEqualToSumEvenPositivePositive = (n) => {\n  if (n <= 0) return false;\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    if (i % 2 === 1) return false;\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 negative odd numbers\n  Example\n  isEqualToSumEvenNegativeNegative(-4) == false\n  isEqualToSumEvenNegativeNegative(-6) == false\n  isEqualToSumEvenNegativeNegative(-8) == true\n  */\nconst isEqualToSumEvenNegativeNegative = (n) => {\n  if (n <= 0) return false;\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    if (i % 2 === 0) return false;\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumEvenPositivePositive(4) == false\n  isEqualToSumEvenPositivePositive(6) == false\n  isEqualToSumEvenPositivePositive(8) == true\n  */\nconst isEqualToSumEvenPositivePositive = (n) => {\n  if (n <= 0) return false;\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    if (i % 2 === 1) return false;\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 negative even numbers\n  Example\n  isEqualToSumEvenNegativePositive(-4) == false\n  isEqualToSumEvenNegativePositive(-6) == false\n  isEqualToSumEvenNegativePositive(-8) == true\n  */\nconst isEqualToSumEvenNegativePositive = (n) => {\n  if (n <= 0) return false;\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    if (i % 2 === 0) return false;\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 negative odd numbers\n  Example\n  isEqualToSumEvenPositiveNegative(-4) == false\n  isEqualToSumEvenPositiveNegative(-6) == false\n  isEqualToSumEvenPositiveNegative(-8) == true\n  */\nconst isEqualToSumEvenPositiveNegative = (n) => {\n  if (n <= 0) return false;\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    if (i % 2 === 1) return false;\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumEvenPositivePositive(4) == false\n  isEqualToSumEvenPositivePositive(6) == false\n  isEqualToSumEvenPositivePositive(8) == true\n  */\nconst isEqualToSumEvenPositivePositive = (n) => {\n  if (n <= 0) return false;\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    if (i % 2 === 1) return false;\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 negative odd numbers\n  Example\n  isEqualToSumEvenNegativeNegative(-4) == false\n  isEqualToSumEvenNegativeNegative(-6) == false\n  isEqualToSumEvenNegativeNegative(-8) == true\n  */\nconst isEqualToSumEvenNegativeNegative = (n) => {\n  if (n <= 0) return false;\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    if (i % 2 === 0) return false;\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEvenPositivePositive(4) == false\n  isEqualToSumEvenPositivePositive(6"}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "gc": "<|endoftext|>/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of a number greater than or equal to n\n  For example:\n  >>> factorial(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number less than or equal to n\n  For example:\n  >>> factorial(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialLessThan = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number greater than or equal to n\n  For example:\n  >>> factorialLessThan(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialGreaterThan = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number less than or equal to n\n  For example:\n  >>> factorialGreaterThan(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialLessThanOrEqual = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number greater than or equal to n\n  For example:\n  >>> factorialLessThanOrEqual(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialGreaterThanOrEqual = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number less than or equal to n\n  For example:\n  >>> factorialLessThanOrEqual(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialGreaterThanOrEqual = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number greater than or equal to n\n  For example:\n  >>> factorialGreaterThanOrEqual(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialLessThanOrEqual = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number greater than or equal to n\n  For example:\n  >>> factorialGreaterThanOrEqual(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialLessThan = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number less than or equal to n\n  For example:\n  >>> factorialLessThan(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialGreaterThan = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number greater than or equal to n\n  For example:\n  >>> factorialGreaterThan(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialGreaterThanOrEqual = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number greater than or equal to n\n  For example:\n  >>> factorialGreaterThanOrEqual(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialLessThanOrEqual = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number greater than or equal to n\n  For example:\n  >>> factorialLessThanOrEqual(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialGreaterThanOrEqual = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number greater than or equal to n\n  For example:\n  >>> factorialGreaterThanOrEqual(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialLessThan = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number less than or equal to n\n  For example:\n  >>> factorialLessThan(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialGreaterThan = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number greater than or equal to n\n  For example:\n  >>> factorialGreaterThan(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialGreaterThanOrEqual = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number greater than or equal to n\n  For example:\n  >>> factorialGreaterThanOrEqual(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialLessThanOrEqual = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number greater than or equal to n\n  For example:\n  >>> factorialGreaterThanOrEqual(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialGreaterThan = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number less than or equal to n\n  For example:\n  >>> factorialLessThanOrEqual(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialLessThanOrEqual = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number greater than or equal to n\n  For example:\n  >>> factorialLessThanOrEqual(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialLessThan = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of a number greater than or equal to n\n  For example:\n  >>> factorialLessThan(5)\n  120\n\n  The function will receive an integer as input and should return the factorial of this integer.\n  */\nconst factorialGreater"}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "gc": "<|endoftext|>/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let newText;\n  \n  newText = text.replace(/\\s+/g,'');\n  \n  if (newText.length > 2) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  if (newText.length > 1) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let newText;\n  \n  newText = text.replace(/\\s+/g,'');\n  \n  if (newText.length > 2) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  if (newText.length > 1) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let newText;\n  \n  newText = text.replace(/\\s+/g,'');\n  \n  if (newText.length > 2) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  if (newText.length > 1) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let newText;\n  \n  newText = text.replace(/\\s+/g,'');\n  \n  if (newText.length > 2) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  if (newText.length > 1) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let newText;\n  \n  newText = text.replace(/\\s+/g,'');\n  \n  if (newText.length > 2) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  if (newText.length > 1) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let newText;\n  \n  newText = text.replace(/\\s+/g,'');\n  \n  if (newText.length > 2) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  if (newText.length > 1) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let newText;\n  \n  newText = text.replace(/\\s+/g,'');\n  \n  if (newText.length > 2) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  if (newText.length > 1) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let newText;\n  \n  newText = text.replace(/\\s+/g,'');\n  \n  if (newText.length > 2) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  if (newText.length > 1) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let newText;\n  \n  newText = text.replace(/\\s+/g,'');\n  \n  if (newText.length > 2) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  if (newText.length > 1) {\n    newText = newText.replace(/\\s+/g,'');\n  }\n  \n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fix"}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "gc": "<|endoftext|>/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'"}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "gc": "<|endoftext|>/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and \n  will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function \n  shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and \n  will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function \n  shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and \n  will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function \n  shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNoChange = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and \n  will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function \n  shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNoChangeAndSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and \n  will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function \n  shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNoChangeAndSquareAndSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and \n  will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function \n  shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNoChangeAndSquareAndSquareAndSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and \n  will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function \n  shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNoChangeAndSquareAndSquareAndSquareAndSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and \n  will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function \n  shall then return the sum of all entrie"}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "gc": "<|endoftext|>/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  let newWords = [];\n  let newWordsLength = 0;\n  let newWordsOrder = [];\n\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const isPrime = prime(word);\n    if (isPrime) {\n      newWords.push(word);\n      newWordsLength += 1;\n      newWordsOrder.push(word);\n    }\n  }\n\n  return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithOrder = (sentence) => {\n  const words = sentence.split(\" \");\n  let newWords = [];\n  let newWordsLength = 0;\n  let newWordsOrder = [];\n\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const isPrime = prime(word);\n    if (isPrime) {\n      newWords.push(word);\n      newWordsLength += 1;\n      newWordsOrder.push(word);\n    }\n  }\n\n  return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithOrderAndLength = (sentence) => {\n  const words = sentence.split(\" \");\n  let newWords = [];\n  let newWordsLength = 0;\n  let newWordsOrder = [];\n\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const isPrime = prime(word);\n    if (isPrime) {\n      newWords.push(word);\n      newWordsLength += 1;\n      newWordsOrder.push(word);\n    }\n  }\n\n  return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithOrderAndLengthAndOrder = (sentence) => {\n  const words = sentence.split(\" \");\n  let newWords = [];\n  let newWordsLength = 0;\n  let newWordsOrder = [];\n\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const isPrime = prime(word);\n    if (isPrime) {\n      newWords.push(word);\n      newWordsLength += 1;\n      newWordsOrder.push(word);\n    }\n  }\n\n  return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithOrderAndLengthAndOrderAndLength = (sentence) => {\n  const words = sentence.split(\" \");\n  let newWords = [];\n  let newWordsLength = 0;\n  let newWordsOrder = [];\n\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const isPrime = prime(word);\n    if (isPrime) {\n      newWords.push(word);\n      newWordsLength += 1;\n      newWordsOrder.push(word);\n    }\n  }\n\n  return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithOrderAndLengthAndOrderAndLengthAndLength = (sentence) => {\n  const words = sentence.split(\" \");\n  let newWords = [];\n  let newWordsLength = 0;\n  let newWordsOrder = [];\n\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const isPrime = prime(word);\n    if (isPrime) {\n      newWords.push(word);\n      newWordsLength += 1;\n      newWordsOrder.push(word);\n    }\n  }\n\n  return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithOrderAndLengthAndOrderAndLengthAndLength = (sentence) => {\n  const words = sentence.split(\" \");\n  let newWords = [];\n  let newWordsLength = 0;\n  let newWordsOrder = [];\n\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const isPrime = prime(word);\n    if (isPrime) {\n      newWords.push(word);\n"}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "gc": "<|endoftext|>/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  const [numerator, denominator] = x.split('/')\n  const [numeratorPart, denominatorPart] = numerator.split('/')\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = denominatorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/').map(Number)\n  const [numeratorPart, denominatorPart] = numeratorPart.split('/')."}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "gc": "<|endoftext|>/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sortedNumsSum = sortedNums.reduce((a, b) => a + b, 0);\n  return sortedNumsSum > 0? sortedNums : [];\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in descending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const sortedNums = nums.sort((a, b) => b - a);\n  const sortedNumsSum = sortedNums.reduce((a, b) => a + b, 0);\n  return sortedNumsSum > 0? sortedNums : [];\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescAsc = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sortedNumsSum = sortedNums.reduce((a, b) => a + b, 0);\n  return sortedNumsSum > 0? sortedNums : [];\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in descending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescDesc = (nums) => {\n  const sortedNums = nums.sort((a, b) => b - a);\n  const sortedNumsSum = sortedNums.reduce((a, b) => a + b, 0);\n  return sortedNumsSum > 0? sortedNums : [];\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescDescAsc = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sortedNumsSum = sortedNums.reduce((a, b) => a + b, 0);\n  return sortedNumsSum > 0? sortedNums : [];\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescDescDesc = (nums) => {\n  const sortedNums = nums.sort((a, b) => b - a);\n  const sortedNumsSum = sortedNums.reduce((a, b) => a + b, 0);\n  return sortedNumsSum > 0? sortedNums : [];\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescDescDescAsc = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sortedNumsSum = sortedNums.reduce((a, b) => a + b, 0);\n  return sortedNumsSum > 0? sortedNums : [];\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescDescDescDesc = (nums) => {\n  const sortedNums = nums.sort((a, b) => b - a);\n  const sortedNumsSum = sortedNums.reduce((a, b) => a + b, 0);\n  return sortedNumsSum > 0? sortedNums : [];\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescDescDescAsc = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sortedNumsSum = sortedNums.reduce((a, b) => a + b, 0);\n  return sortedNumsSum > 0? sortedNums : [];\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescDescDescDesc = (nums) => {\n  const sortedNums = nums.sort((a, b) => b - a);\n  const sortedNumsSum = sortedNums.reduce((a, b) => a + b, 0);\n  return sortedNumsSum > 0? sortedNums : [];\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescDescDescDescAsc = (nums) => {\n  const sorted"}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "gc": "<|endoftext|>/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:"}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "gc": "<|endoftext|>/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [...Array(n - 1)].map(() => 0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i; j < n; j++) {\n      a[j] += a[j - i];\n    }\n  }\n  return a.filter((x) => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [...Array(n - 1)].map(() => 0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i; j < n; j++) {\n      a[j] += a[j - i];\n    }\n  }\n  return a.filter((x) => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [...Array(n - 1)].map(() => 0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i; j < n; j++) {\n      a[j] += a[j - i];\n    }\n  }\n  return a.filter((x) => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [...Array(n - 1)].map(() => 0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i; j < n; j++) {\n      a[j] += a[j - i];\n    }\n  }\n  return a.filter((x) => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [...Array(n - 1)].map(() => 0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i; j < n; j++) {\n      a[j] += a[j - i];\n    }\n  }\n  return a.filter((x) => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [...Array(n - 1)].map(() => 0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i; j < n; j++) {\n      a[j] += a[j - i];\n    }\n  }\n  return a.filter((x) => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [...Array(n - 1)].map(() => 0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i; j < n; j++) {\n      a[j] += a[j - i];\n    }\n  }\n  return a.filter((x) => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [...Array(n - 1)].map(() => 0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i; j < n; j++) {\n      a[j] += a[j - i];\n    }\n  }\n  return a.filter((x) => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and "}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "gc": "<|endoftext|>/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let orbit1 = planet1.toUpperCase();\n  let orbit2 = planet2.toUpperCase();\n  let orbit1Index = orbit1.indexOf(orbit1);\n  let orbit2Index = orbit2.indexOf(orbit2);\n  let orbit1Orbit = orbit1.slice(orbit1Index + 2, orbit1Index + 4);\n  let orbit2Orbit = orbit2.slice(orbit2Index + 2, orbit2Index + 4);\n  let orbit1OrbitArr = orbit1Orbit.split('');\n  let orbit2OrbitArr = orbit2Orbit.split('');\n  let orbit1OrbitArr2 = orbit1OrbitArr.map(x => x.charCodeAt(0));\n  let orbit2OrbitArr2 = orbit2OrbitArr.map(x => x.charCodeAt(0));\n  let orbit1OrbitArr3 = orbit1OrbitArr2.filter(x => x!== 0);\n  let orbit2OrbitArr3 = orbit2OrbitArr2.filter(x => x!== 0);\n  let orbit1OrbitArr4 = orbit1OrbitArr3.filter(x => x!== 0);\n  let orbit2OrbitArr4 = orbit2OrbitArr3.filter(x => x!== 0);\n  let orbit1OrbitArr5 = orbit1OrbitArr4.filter(x => x!== 0);\n  let orbit2OrbitArr5 = orbit2OrbitArr4.filter(x => x!== 0);\n  let orbit1OrbitArr6 = orbit1OrbitArr5.filter(x => x!== 0);\n  let orbit2OrbitArr6 = orbit2OrbitArr5.filter(x => x!== 0);\n  let orbit1OrbitArr7 = orbit1OrbitArr6.filter(x => x!== 0);\n  let orbit2OrbitArr7 = orbit2OrbitArr6.filter(x => x!== 0);\n  let orbit1OrbitArr8 = orbit1OrbitArr7.filter(x => x!== 0);\n  let orbit2OrbitArr8 = orbit2OrbitArr7.filter(x => x!== 0);\n  let orbit1OrbitArr9 = orbit1OrbitArr8.filter(x => x!== 0);\n  let orbit2OrbitArr9 = orbit2OrbitArr8.filter(x => x!== 0);\n  let orbit1OrbitArr10 = orbit1OrbitArr9.filter(x => x!== 0);\n  let orbit2OrbitArr10 = orbit2OrbitArr9.filter(x => x!== 0);\n  let orbit1OrbitArr11 = orbit1OrbitArr10.filter(x => x!== 0);\n  let orbit2OrbitArr11 = orbit2OrbitArr10.filter(x => x!== 0);\n  let orbit1OrbitArr12 = orbit1OrbitArr11.filter(x => x!== 0);\n  let orbit2OrbitArr12 = orbit2OrbitArr11.filter(x => x!== 0);\n  let orbit1OrbitArr13 = orbit1OrbitArr12.filter(x => x!== 0);\n  let orbit2OrbitArr13 = orbit2OrbitArr12.filter(x => x!== 0);\n  let orbit1OrbitArr14 = orbit1OrbitArr13.filter(x => x!== 0);\n  let orbit2OrbitArr14 = orbit2OrbitArr13.filter(x => x!== 0);\n  let orbit1OrbitArr15 = orbit1OrbitArr14.filter(x => x!== 0);\n  let orbit2OrbitArr15 = orbit2OrbitArr14.filter(x => x!== 0);\n  let orbit1OrbitArr16 = orbit1OrbitArr15.filter(x => x!== 0);\n  let orbit2OrbitArr16 = orbit2OrbitArr15.filter(x => x!== 0);\n  let orbit1OrbitArr17 = orbit1OrbitArr16.filter(x => x!== 0);\n  let orbit2OrbitArr17 = orbit2OrbitArr16.filter(x => x!== 0);\n  let orbit1OrbitArr18 = orbit1OrbitArr17.filter(x => x!== 0);\n  let orbit2OrbitArr18 = orbit2OrbitArr17.filter(x => x!== 0);\n  let orbit1OrbitArr19 = orbit1OrbitArr18.filter(x => x!== 0);\n  let orbit2OrbitArr19 = orbit2OrbitArr18.filter(x => x!== 0);\n  let orbit1OrbitArr20 = orbit1OrbitArr19.filter(x => x!== 0);\n  let orbit2OrbitArr20 = orbit2OrbitArr19.filter(x => x!== 0);\n  let orbit1OrbitArr21 = orbit1OrbitArr20.filter(x => x!== 0);\n  let orbit2OrbitArr21 = orbit2OrbitArr20.filter(x => x!== 0);\n  let orbit1OrbitArr22 = orbit1OrbitArr21.filter(x => x!== 0);\n  let orbit2OrbitArr22 = orbit2OrbitArr21.filter(x => x!== 0);\n  let orbit1OrbitArr23 = orbit1OrbitArr22.filter(x => x!== 0);\n  let orbit2OrbitArr23 = orbit2OrbitArr22.filter(x => x!== 0);\n  let orbit1OrbitArr24 = orbit1OrbitArr23.filter(x => x!== 0);\n  let orbit2OrbitArr24 = orbit2OrbitArr23.filter(x => x!== 0);\n  let orbit1OrbitArr25 = orbit1OrbitArr24.filter(x => x!== 0);\n  let orbit2OrbitArr25 = orbit2OrbitArr24.filter(x => x!== 0);\n  let orbit1OrbitArr26 = orbit1OrbitArr25.filter(x => x!== 0);\n  let orbit2OrbitArr26 = orbit2OrbitArr25.filter(x => x!== 0);\n  let orbit1OrbitArr27 = orbit1OrbitArr26.filter(x => x!== 0);\n  let orbit2OrbitArr27 = orbit2OrbitArr26.filter(x => x!== 0);\n  let orbit1OrbitArr28 = orbit1OrbitArr27.filter(x => x!== 0);\n  let orbit2OrbitArr28 = orbit2OrbitArr27.filter(x => x!== 0);\n  let orbit1OrbitArr29 = orbit1OrbitArr28.filter(x => x!== 0);\n  let orbit2OrbitArr29 = orbit2OrbitArr28.filter(x => x!== 0);\n  let orbit1OrbitArr30 = orbit1OrbitArr29.filter(x => x!== 0);\n  let orbit2OrbitArr30 = orbit2OrbitArr29.filter(x => x!== 0);\n  let orbit1OrbitArr31 = orbit1OrbitArr30.filter(x => "}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "gc": "<|endoftext|>/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2!== 0) {\n      sum += lst[i].length;\n    }\n  }\n  return lst.sort((a, b) => a - b).map(str => str.length).reduce((a, b) => a + b, sum);\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the number of characters in that string.\n  You may assume that the string will contain only lowercase letters.\n  For example:\n  assert string_length(\"abc\") == 2\n  assert string_length(\"ab\") == 1\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length(\"a\") == 0\n  assert string_length"}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "gc": "<|endoftext|>/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    throw new Error('n must be between 2 and 100');\n  }\n  if (n % 2 === 0) {\n    return y;\n  }\n  return x;\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    throw new Error('n must be between 2 and 100');\n  }\n  if (n % 2 === 0) {\n    return y;\n  }\n  return x;\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    throw new Error('n must be between 2 and 100');\n  }\n  if (n % 2 === 0) {\n    return y;\n  }\n  return x;\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    throw new Error('n must be between 2 and 100');\n  }\n  if (n % 2 === 0) {\n    return y;\n  }\n  return x;\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    throw new Error('n must be between 2 and 100');\n  }\n  if (n % 2 === 0) {\n    return y;\n  }\n  return x;\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    throw new Error('n must be between 2 and 100');\n  }\n  if (n % 2 === 0) {\n    return y;\n  }\n  return x;\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    throw new Error('n must be between 2 and 100');\n  }\n  if (n % 2 === 0) {\n    return y;\n  }\n  return x;\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    throw new Error('n must be between 2 and 100');\n  }\n  if (n % 2 === 0) {\n    return y;\n  }\n  return x;\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    throw new Error('n must be between 2 and 100');\n  }\n  if (n % 2 === 0) {\n    return y;\n  }\n  return x;\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    throw new Error('n must be between 2 and 100');\n  }\n  if (n % 2 === 0) {\n    return y;\n  }\n  return x;\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    throw new Error('n must be between 2 and 100');\n  }\n  if (n % 2 === 0) {\n    return y;\n  }\n  return x;\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    throw new Error('n must be between 2 and 100');\n  }\n  if (n % 2 === 0) {\n    return y;\n  }\n  return x;\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    throw new Error('n must be between 2 and 100');\n  }\n  if (n % 2 === 0) {\n    return y;\n  }\n  return x;\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    throw new Error('n must be between 2 and 100');\n  }\n  if (n % 2 === 0) {\n    return y;\n  }\n  return x;\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    throw new Error('n must be between 2 and 100');\n  }\n  if (n % 2 === 0) {\n    return y;\n  }\n  return x;\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    throw new Error('n must be between 2 and 100');\n  }\n  if (n % 2 === 0) {\n    return y;\n  }\n  return x;\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a "}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "gc": "<|endoftext|>/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 2 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 1\n  doubleTheDifference([-1, -2, 0]) == -1\n  doubleTheDifference([9, -2]) == 9\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 2 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 1\n  doubleTheDifference([-1, -2, 0]) == -1\n  doubleTheDifference([9, -2]) == 9\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 3 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 5. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 5 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 7. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 7 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 11. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 11 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 13. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 13 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 17. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 17 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 19. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 19 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 21. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 21 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 23. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 23 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 25. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 25 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 27. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 27 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 29. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 29 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 31. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 31 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 35. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 35 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 37. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 37 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 39. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 39 === 0? sum : 0;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 41. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const sum = lst.reduce((acc, curr) => acc + curr * curr, 0);\n  return sum % 41 === 0? sum : 0;\n};\n\n/* Given a list of "}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "gc": "<|endoftext|>/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const [gameScore, gameGuesses] = game;\n  const [guessScore, guessGuesses] = guess;\n  const [gameScoreDiff, gameGuessesDiff] = gameScore-gameGuesses;\n  const [guessScoreDiff, guessGuessesDiff] = guessScore-guessGuesses;\n  const [gameScoreDiffAbs, gameGuessesDiffAbs] = gameScoreDiff>0? gameScoreDiff : -gameScoreDiff;\n  const [guessScoreDiffAbs, guessGuessesDiffAbs] = guessScoreDiff>0? guessScoreDiff : -guessScoreDiff;\n  const [gameScoreDiffAbsDiff, gameGuessesDiffAbsDiff] = gameScoreDiffAbs>0? gameScoreDiffAbs : -gameScoreDiffAbs;\n  const [guessScoreDiffAbsDiff, guessGuessesDiffAbsDiff] = guessScoreDiffAbs>0? guessScoreDiffAbs : -guessScoreDiffAbs;\n  const [gameScoreDiffAbsDiffAbsDiff, gameGuessesDiffAbsDiffAbsDiff] = gameScoreDiffAbsDiff>0? gameScoreDiffAbsDiff : -gameScoreDiffAbsDiff;\n  const [guessScoreDiffAbsDiffAbsDiff, guessGuessesDiffAbsDiff] = guessScoreDiffAbsDiff>0? guessScoreDiffAbsDiff : -guessScoreDiffAbsDiff;\n  const [gameScoreDiffAbsDiffAbsDiffAbsDiff, gameGuessesDiffAbsDiffAbsDiff] = gameScoreDiffAbsDiffAbsDiff>0? gameScoreDiffAbsDiffAbsDiff : -gameScoreDiffAbsDiffAbsDiff;\n  const [guessScoreDiffAbsDiffAbsDiffAbsDiff, guessGuessesDiffAbsDiffAbsDiff] = guessScoreDiffAbsDiffAbsDiff>0? guessScoreDiffAbsDiffAbsDiff : -guessScoreDiffAbsDiffAbsDiff;\n  const [gameScoreDiffAbsDiffAbsDiffAbsDiffAbsDiff, gameGuessesDiffAbsDiffAbsDiffAbsDiff] = gameScoreDiffAbsDiffAbsDiffAbsDiff>0? gameScoreDiffAbsDiffAbsDiffAbsDiff : -gameScoreDiffAbsDiffAbsDiffAbsDiff;\n  const [guessScoreDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff, guessGuessesDiffAbsDiffAbsDiffAbsDiff] = guessScoreDiffAbsDiffAbsDiffAbsDiff>0? guessScoreDiffAbsDiffAbsDiffAbsDiff : -guessScoreDiffAbsDiffAbsDiffAbsDiff;\n  const [gameScoreDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff, gameGuessesDiffAbsDiffAbsDiffAbsDiffAbsDiff] = gameScoreDiffAbsDiffAbsDiffAbsDiffAbsDiff>0? gameScoreDiffAbsDiffAbsDiffAbsDiff : -gameScoreDiffAbsDiffAbsDiffAbsDiffAbsDiff;\n  const [guessScoreDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff, guessGuessesDiffAbsDiffAbsDiffAbsDiffAbsDiff] = guessScoreDiffAbsDiffAbsDiffAbsDiffAbsDiff>0? guessScoreDiffAbsDiffAbsDiffAbsDiff : -guessScoreDiffAbsDiffAbsDiffAbsDiffAbsDiff;\n  const [gameScoreDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff, gameGuessesDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff] = gameScoreDiffAbsDiffAbsDiffAbsDiffAbsDiff>0? gameScoreDiffAbsDiffAbsDiffAbsDiff : -gameScoreDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff;\n  const [guessScoreDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff, guessGuessesDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff] = guessScoreDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff>0? guessScoreDiffAbsDiffAbsDiffAbsDiffAbsDiff : -guessScoreDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff;\n  const [gameScoreDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs"}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "gc": "<|endoftext|>/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_class.length;\n    if (extension_strength > extension_strength) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension_1 = (strongest_extension, extensions) => {\n  let extension_strength = -1;\n  let extension_class = strongest_extension;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_class.length;\n    if (extension_strength > extension_strength) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtension_1('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension_2 = (strongest_extension, extensions) => {\n  let extension_strength = -1;\n  let extension_class = strongest_extension;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_class.length;\n    if (extension_strength > extension_strength) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtension_2('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension_3 = (strongest_extension, extensions) => {\n  let extension_strength = -1;\n  let extension_class = strongest_extension;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_class.length;\n    if (extension_strength > extension_strength) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtension_3('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension_4 = (strongest_extension, extensions) => {\n  let extension_strength = -1;\n  let extension_class = strongest_extension;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_class.length;\n    if (extension_strength > extension_strength) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtension_4('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension_5 = (strongest_extension, extensions) => {\n  let extension_strength = -1;\n  let extension_class = strongest_extension;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_class.length;\n    if (extension_strength > extension_strength) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtension_5('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension_6 = (strongest_extension, extensions) => {\n  let extension_strength = -1;\n  let extension_class = strongest_extension;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_class.length;\n    if (extension_strength > extension_strength) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtension_6('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension_7 = (strongest_extension, extensions) => {\n  let extension_strength = -1;\n  let extension_class = strongest_extension;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_class.length;\n    if (extension_strength > extension_strength) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtension_7('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension_8 = (strongest_extension, extensions) => {\n  let extension_strength = -1;\n  let extension_class = strongest_extension;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_class.length;\n    if (extension_strength > extension_strength) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtension_8('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension_9 = (strongest_extension, extensions) => {\n  let extension_strength = -1;\n  let extension_class = strongest_extension;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_class.length;\n    if (extension_strength > extension_strength) {\n      extension"}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "gc": "<|endoftext|>/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let pattern = a.split('')\n  let rotation = b.split('')\n  let result = []\n  for (let i = 0; i < pattern.length; i++) {\n    let letter = pattern[i]\n    let rotation = rotation[i]\n    if (letter == rotation) {\n      result.push(letter)\n    }\n  }\n  return result.join('') === b.split('')\n}\n\nmodule.exports = cycpatternCheck\n\n},{}],9:[function(require,module,exports){\nconst cycpatternCheck = require('./cycpatternCheck')\n\nconst cycpatternCheck2 = (a, b) => {\n  let pattern = a.split('')\n  let rotation = b.split('')\n  let result = []\n  for (let i = 0; i < pattern.length; i++) {\n    let letter = pattern[i]\n    let rotation = rotation[i]\n    if (letter == rotation) {\n      result.push(letter)\n    }\n  }\n  return result.join('') === b.split('')\n}\n\nmodule.exports = cycpatternCheck2\n\n},{\"./cycpatternCheck\":8}],10:[function(require,module,exports){\nconst cycpatternCheck = require('./cycpatternCheck')\n\nconst cycpatternCheck2 = (a, b) => {\n  let pattern = a.split('')\n  let rotation = b.split('')\n  let result = []\n  for (let i = 0; i < pattern.length; i++) {\n    let letter = pattern[i]\n    let rotation = rotation[i]\n    if (letter == rotation) {\n      result.push(letter)\n    }\n  }\n  return result.join('') === b.split('')\n}\n\nmodule.exports = cycpatternCheck2\n\n},{\"./cycpatternCheck\":8}],11:[function(require,module,exports){\nconst cycpatternCheck = require('./cycpatternCheck')\n\nconst cycpatternCheck2 = (a, b) => {\n  let pattern = a.split('')\n  let rotation = b.split('')\n  let result = []\n  for (let i = 0; i < pattern.length; i++) {\n    let letter = pattern[i]\n    let rotation = rotation[i]\n    if (letter == rotation) {\n      result.push(letter)\n    }\n  }\n  return result.join('') === b.split('')\n}\n\nmodule.exports = cycpatternCheck2\n\n},{\"./cycpatternCheck\":8}],12:[function(require,module,exports){\nconst cycpatternCheck = require('./cycpatternCheck')\n\nconst cycpatternCheck2 = (a, b) => {\n  let pattern = a.split('')\n  let rotation = b.split('')\n  let result = []\n  for (let i = 0; i < pattern.length; i++) {\n    let letter = pattern[i]\n    let rotation = rotation[i]\n    if (letter == rotation) {\n      result.push(letter)\n    }\n  }\n  return result.join('') === b.split('')\n}\n\nmodule.exports = cycpatternCheck2\n\n},{\"./cycpatternCheck\":8}],13:[function(require,module,exports){\nconst cycpatternCheck = require('./cycpatternCheck')\n\nconst cycpatternCheck2 = (a, b) => {\n  let pattern = a.split('')\n  let rotation = b.split('')\n  let result = []\n  for (let i = 0; i < pattern.length; i++) {\n    let letter = pattern[i]\n    let rotation = rotation[i]\n    if (letter == rotation) {\n      result.push(letter)\n    }\n  }\n  return result.join('') === b.split('')\n}\n\nmodule.exports = cycpatternCheck2\n\n},{\"./cycpatternCheck\":8}],14:[function(require,module,exports){\nconst cycpatternCheck = require('./cycpatternCheck')\n\nconst cycpatternCheck2 = (a, b) => {\n  let pattern = a.split('')\n  let rotation = b.split('')\n  let result = []\n  for (let i = 0; i < pattern.length; i++) {\n    let letter = pattern[i]\n    let rotation = rotation[i]\n    if (letter == rotation) {\n      result.push(letter)\n    }\n  }\n  return result.join('') === b.split('')\n}\n\nmodule.exports = cycpatternCheck2\n\n},{\"./cycpatternCheck\":8}],15:[function(require,module,exports){\nconst cycpatternCheck = require('./cycpatternCheck')\n\nconst cycpatternCheck2 = (a, b) => {\n  let pattern = a.split('')\n  let rotation = b.split('')\n  let result = []\n  for (let i = 0; i < pattern.length; i++) {\n    let letter = pattern[i]\n    let rotation = rotation[i]\n    if (letter == rotation) {\n      result.push(letter)\n    }\n  }\n  return result.join('') === b.split('')\n}\n\nmodule.exports = cycpatternCheck2\n\n},{\"./cycpatternCheck\":8}],16:[function(require,module,exports){\nconst cycpatternCheck = require('./cycpatternCheck')\n\nconst cycpatternCheck2 = (a, b) => {\n  let pattern = a.split('')\n  let rotation = b.split('')\n  let result = []\n  for (let i = 0; i < pattern.length; i++) {\n    let letter = pattern[i]\n    let rotation = rotation[i]\n    if (letter == rotation) {\n      result.push(letter)\n    }\n  }\n  return result.join('') === b.split('')\n}\n\nmodule.exports = cycpatternCheck2\n\n},{\"./cycpatternCheck\":8}],17:[function(require,module,exports){\nconst cycpatternCheck = require('./cycpatternCheck')\n\nconst cycpatternCheck2 = (a, b) => {\n  let pattern = a.split('')\n  let rotation = b.split('')\n  let result = []\n  for (let i = 0; i < pattern.length; i++) {\n    let letter = pattern[i]\n    let rotation = rotation[i]\n    if (letter == rotation) {\n      result.push(letter)\n    }\n  }\n  return result.join('') === b.split('')\n}\n\nmodule.exports = cycpatternCheck2\n\n},{\"./cycpatternCheck\":8}],18:[function(require,module,exports){\nconst cycpatternCheck = require('./cycpatternCheck')\n\nconst cycpatternCheck2 = (a, b) => {\n  let pattern = a.split('')\n  let rotation = b.split('')\n  let result = []\n  for (let i = 0; i < pattern.length; i++) {\n    let letter = pattern[i]\n    let rotation = rotation[i]\n    if (letter == rotation) {\n      result.push(letter)\n    }\n  }\n  return result.join('') === b.split('')\n}\n\nmodule.exports = cycpatternCheck2\n\n},{\"./cycpatternCheck\":8}],19:[function(require,module,exports){\nconst cycpatternCheck = require('./cycpatternCheck')\n\nconst cycpatternCheck2 = (a, b) => {\n  let pattern = a.split('')\n  let rotation = b.split('')\n  let result = []\n  for (let i = 0; i < pattern.length; i++) {\n    let letter = pattern[i]\n    let rotation = rotation[i]\n    if (letter == rotation) {\n      result.push(letter)\n    }\n  }\n  return result.join('') === b.split('')\n}\n\nmodule.exports = cycpatternCheck2\n\n},{\"./cycpatternCheck\":8}],20:[function(require,module,exports){\nconst cycpatternCheck = require('./cycpatternCheck')\n\nconst cycpatternCheck2 = (a, b) => {\n  let pattern = a.split('')\n  let rotation = b.split('')\n  let result = []\n  for (let i = 0; i < pattern.length; i++) {\n    let letter = pattern[i]\n    let rotation = rotation[i]\n    if (letter == rotation) {\n      result.push(letter)\n    }\n  }\n  return result.join('') === b.split('')\n}\n\nmodule.exports = cycpatternCheck2\n\n},{\"./cycpatternCheck\":8}],21:[function(require"}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "gc": "<|endoftext|>/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let digitCount = 0;\n  let digit;\n  let i;\n  let numStr;\n  let numStrLen = num.toString().length;\n  let numStrLen2 = numStrLen * numStrLen;\n  let numStrLen3 = numStrLen2 * numStrLen;\n  let numStrLen4 = numStrLen3 * numStrLen;\n  let numStrLen5 = numStrLen4 * numStrLen;\n  let numStrLen6 = numStrLen5 * numStrLen;\n  let numStrLen7 = numStrLen6 * numStrLen;\n  let numStrLen8 = numStrLen7 * numStrLen;\n  let numStrLen9 = numStrLen8 * numStrLen;\n  let numStrLen10 = numStrLen9 * numStrLen;\n  let numStrLen11 = numStrLen10 * numStrLen;\n  let numStrLen12 = numStrLen11 * numStrLen;\n  let numStrLen13 = numStrLen12 * numStrLen;\n  let numStrLen14 = numStrLen13 * numStrLen;\n  let numStrLen15 = numStrLen14 * numStrLen;\n  let numStrLen16 = numStrLen15 * numStrLen;\n  let numStrLen17 = numStrLen16 * numStrLen;\n  let numStrLen18 = numStrLen17 * numStrLen;\n  let numStrLen19 = numStrLen18 * numStrLen;\n  let numStrLen20 = numStrLen19 * numStrLen;\n  let numStrLen21 = numStrLen20 * numStrLen;\n  let numStrLen22 = numStrLen21 * numStrLen;\n  let numStrLen23 = numStrLen22 * numStrLen;\n  let numStrLen24 = numStrLen23 * numStrLen;\n  let numStrLen25 = numStrLen24 * numStrLen;\n  let numStrLen26 = numStrLen25 * numStrLen;\n  let numStrLen27 = numStrLen26 * numStrLen;\n  let numStrLen28 = numStrLen27 * numStrLen;\n  let numStrLen29 = numStrLen28 * numStrLen;\n  let numStrLen30 = numStrLen29 * numStrLen;\n  let numStrLen31 = numStrLen30 * numStrLen;\n  let numStrLen32 = numStrLen31 * numStrLen;\n  let numStrLen33 = numStrLen32 * numStrLen;\n  let numStrLen34 = numStrLen33 * numStrLen;\n  let numStrLen35 = numStrLen34 * numStrLen;\n  let numStrLen36 = numStrLen35 * numStrLen;\n  let numStrLen37 = numStrLen36 * numStrLen;\n  let numStrLen38 = numStrLen37 * numStrLen;\n  let numStrLen39 = numStrLen38 * numStrLen;\n  let numStrLen40 = numStrLen39 * numStrLen;\n  let numStrLen41 = numStrLen40 * numStrLen;\n  let numStrLen42 = numStrLen41 * numStrLen;\n  let numStrLen43 = numStrLen42 * numStrLen;\n  let numStrLen44 = numStrLen43 * numStrLen;\n  let numStrLen45 = numStrLen44 * numStrLen;\n  let numStrLen46 = numStrLen45 * numStrLen;\n  let numStrLen47 = numStrLen46 * numStrLen;\n  let numStrLen48 = numStrLen47 * numStrLen;\n  let numStrLen49 = numStrLen48 * numStrLen;\n  let numStrLen50 = numStrLen49 * numStrLen;\n  let numStrLen51 = numStrLen50 * numStrLen;\n  let numStrLen52 = numStrLen51 * numStrLen;\n  let numStrLen53 = numStrLen52 * numStrLen;\n  let numStrLen54 = numStrLen53 * numStrLen;\n  let numStrLen55 = numStrLen54 * numStrLen;\n  let numStrLen56 = numStrLen55 * numStrLen;\n  let numStrLen57 = numStrLen56 * numStrLen;\n  let numStrLen58 = numStrLen57 * numStrLen;\n  let numStrLen59 = numStrLen58 * numStrLen;\n  let numStrLen60 = numStrLen59 * numStrLen;\n  let numStrLen61 = numStrLen60 * numStrLen;\n  let numStrLen62 = numStrLen61 * numStrLen;\n  let numStrLen63 = numStrLen62 * numStrLen;\n  let numStrLen64 = numStrLen63 * numStrLen;\n  let numStrLen65 = numStrLen64 * numStrLen;\n  let numStrLen66 = numStrLen65 * numStrLen;\n  let numStrLen67 = numStrLen66 * numStrLen;\n  let numStrLen68 = numStrLen67 * numStrLen;\n  let numStrLen69 = numStrLen68 * numStrLen;\n  let numStrLen70 = numStrLen69 * numStrLen;\n  let numStrLen71 = numStrLen70 * numStrLen;\n  let numStrLen72 = numStrLen71 * numStrLen;\n  let numStrLen73 = numStrLen72 * numStrLen;\n  let numStrLen74 = numStrLen73 * numStrLen;\n  let numStrLen75 = numStrLen74 * numStrLen;\n  let numStrLen76 = numStrLen75 * numStrLen;\n  let numStrLen77 = numStrLen76 * numStrLen;\n  let numStrLen78 = numStrLen77 * numStrLen;\n  let numStrLen79 = numStrLen78 * numStrLen;\n  let numStrLen80 = numStrLen79 * numStrLen;\n  let numStrLen81 = numStrLen80 * numStrLen;\n  let numStrLen82 = numStrLen81 * numStrLen;\n  let numStrLen83 = numStrLen82 * numStrLen;\n  let numStrLen84 = numStrLen83 * numStrLen;\n  let numStrLen85 = numStrLen84 * numStrLen;\n  let numStrLen86 = numStrLen85 * numStrLen;\n  let numStrLen87 = numStrLen86 * numStrLen;\n  let numStrLen88 = numStrLen87 * numStrLen;\n  let numStrLen89 = numStrLen88 * numStrLen;\n  let numStrLen90 = numStrLen89 * numStrLen;\n  let numStrLen91 = numStrLen90 * numStrLen;\n  let numStrLen92 = numStrLen91 * numStrLen;\n  let numStrLen93 = numStrLen"}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "gc": "<|endoftext|>/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const romanTable = {\n    'I': 1,\n    'V': 5,\n    'X': 10,\n    'L': 50,\n    'C': 100,\n    'D': 500,\n    'M': 1000\n  };\n  let result = \"\";\n  let digit = number % 10;\n  let roman = romanTable[digit];\n  while (roman) {\n    result += roman;\n    roman = romanTable[digit % 10];\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to its decimal equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToDecimal(19) == '19'\n  >>> intToDecimal(152) == '152'\n  >>> intToDecimal(426) == '426'\n  */\nconst intToDecimal = (number) => {\n  let result = \"\";\n  let digit = number % 10;\n  let decimal = digit - 1;\n  while (decimal) {\n    result += decimal.toString(10);\n    decimal = decimal % 10;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to its hexadecimal equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToHex(19) == '0x19'\n  >>> intToHex(152) == '0x152'\n  >>> intToHex(426) == '0x426'\n  */\nconst intToHex = (number) => {\n  let result = \"\";\n  let digit = number % 10;\n  let hex = digit - 1;\n  while (hex) {\n    result += hex.toString(16);\n    hex = hex % 16;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to its octal equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToOctal(19) == '0o19'\n  >>> intToOctal(152) == '0o152'\n  >>> intToOctal(426) == '0o426'\n  */\nconst intToOctal = (number) => {\n  let result = \"\";\n  let digit = number % 10;\n  let octal = digit - 1;\n  while (octal) {\n    result += octal.toString(8);\n    octal = octal % 8;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to its binary equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToBinary(19) == '0b111'\n  >>> intToBinary(152) == '0b100'\n  >>> intToBinary(426) == '0b101'\n  */\nconst intToBinary = (number) => {\n  let result = \"\";\n  let digit = number % 10;\n  let binary = digit - 1;\n  while (binary) {\n    result += binary.toString(2);\n    binary = binary % 2;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to its hexadecimal equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToHexadecimal(19) == '0x19'\n  >>> intToHexadecimal(152) == '0x152'\n  >>> intToHexadecimal(426) == '0x426'\n  */\nconst intToHexadecimal = (number) => {\n  let result = \"\";\n  let digit = number % 10;\n  let hex = digit - 1;\n  while (hex) {\n    result += hex.toString(16);\n    hex = hex % 16;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to its octal equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToOctaladecimal(19) == '0o19'\n  >>> intToOctaladecimal(152) == '0o152'\n  >>> intToOctaladecimal(426) == '0o426'\n  */\nconst intToOctaladecimal = (number) => {\n  let result = \"\";\n  let digit = number % 10;\n  let octal = digit - 1;\n  while (octal) {\n    result += octal.toString(8);\n    octal = octal % 8;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to its binary equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToBinaryadecimal(19) == '0b111'\n  >>> intToBinaryadecimal(152) == '0b100'\n  >>> intToBinaryadecimal(426) == '0b101'\n  */\nconst intToBinaryadecimal = (number) => {\n  let result = \"\";\n  let digit = number % 10;\n  let binary = digit - 1;\n  while (binary) {\n    result += binary.toString(2);\n    binary = binary % 2;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to its decimal equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToDecimaladecimal(19) == '19'\n  >>> intToDecimaladecimal(152) == '152'\n  >>> intToDecimaladecimal(426) == '426'\n  */\nconst intToDecimaladecimal = (number) => {\n  let result = \"\";\n  let digit = number % 10;\n  let decimal = digit - 1;\n  while (decimal) {\n    result += decimal.toString(10);\n    decimal = decimal % 10;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to its hexadecimal equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToHexadecimal(19) == '0x19'\n  >>> intToHexadecimal(152) == '0x152'\n  >>> intToHexadecimal(426) == '0x426'\n  */\nconst intToHexadecimal = (number) => {\n  let result = \"\";\n  let digit = number % 10;\n  let hex = digit - 1;\n  while (hex) {\n    result += hex.toString(16);\n    hex = hex % 16;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to its octal equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToOctaladecimal(19) == '0o19'\n  >>> intToOctaladecimal(152) == '0o152'\n  >>> intToOctaladecimal(426) == '0o426'\n  */\nconst intToOctaladecimal = (number) => {\n  let result = \"\";\n  let digit = number % 10;\n  let octal = digit - 1;\n  while (octal) {\n    result += octal.toString(8);\n    octal = octal % 8;\n  }\n  return result.toLowerCase();\n};\n\n/*\n  Given a positive integer, convert it to its binary equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToBinaryadecimal(19"}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "gc": "<|endoftext|>/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(c * Math.PI / 180);\n  const c2 = Math.sin(c * Math.PI / 180);\n  const det = a1 * b2 - a2 * b1;\n  return det >= 0 && det <= 1 && b1 * c2 > a2 * c1;\n};\n\n/*\n Given the lengths of the three sides of a rectangle. Return true if the three\n  sides form a square, false otherwise.\n  A square is a rectangle in which all sides are equal.\n  Example:\n  square(3, 4) == true\n  square(1, 2) == false\n  */\nconst square = (a, b) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  return a1 * b1 == a2 * b2;\n};\n\n/*\n Given the lengths of the three sides of a pentagon. Return true if the three\n  sides form a pentagon, false otherwise.\n  A pentagon is a pentagon whose sides are all equal.\n  Example:\n  pentagon(3, 4) == true\n  pentagon(1, 2) == false\n  */\nconst pentagon = (a, b) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  return a1 * b1 == a2 * b2;\n};\n\n/*\n Given the lengths of the three sides of a hexagon. Return true if the three\n  sides form a hexagon, false otherwise.\n  A hexagon is a hexagon whose sides are all equal.\n  Example:\n  hexagon(3, 4) == true\n  hexagon(1, 2) == false\n  */\nconst hexagon = (a, b) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  return a1 * b1 == a2 * b2;\n};\n\n/*\n Given the lengths of the three sides of a heptagon. Return true if the three\n  sides form a heptagon, false otherwise.\n  A heptagon is a heptagon whose sides are all equal.\n  Example:\n  heptagon(3, 4) == true\n  heptagon(1, 2) == false\n  */\nconst heptagon = (a, b) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  return a1 * b1 == a2 * b2;\n};\n\n/*\n Given the lengths of the three sides of a decagon. Return true if the three\n  sides form a decagon, false otherwise.\n  A decagon is a decagon whose sides are all equal.\n  Example:\n  decagon(3, 4) == true\n  decagon(1, 2) == false\n  */\nconst decagon = (a, b) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  return a1 * b1 == a2 * b2;\n};\n\n/*\n Given the lengths of the three sides of a trigon. Return true if the three\n  sides form a trigon, false otherwise.\n  A trigon is a triangle whose sides are all equal.\n  Example:\n  trigon(3, 4) == true\n  trigon(1, 2) == false\n  */\nconst trigon = (a, b) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  return a1 * b1 == a2 * b2;\n};\n\n/*\n Given the lengths of the three sides of a heptagon with radius r. Return true if\n  the three sides form a heptagon with radius r, false otherwise.\n  A heptagon is a heptagon whose sides are all equal.\n  Example:\n  heptagon(3, 4) == true\n  heptagon(5, 6) == false\n  */\nconst heptagonWithRadius = (a, b, r) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(r * Math.PI / 180);\n  const c2 = Math.sin(r * Math.PI / 180);\n  return a1 * b1 == a2 * b2 && b1 * c2 > a2 * c1;\n};\n\n/*\n Given the lengths of the three sides of a hexagon with radius r. Return true if\n  the three sides form a hexagon with radius r, false otherwise.\n  A hexagon is a hexagon whose sides are all equal.\n  Example:\n  hexagon(3, 4) == true\n  hexagon(5, 6) == false\n  */\nconst hexagonWithRadius = (a, b, r) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(r * Math.PI / 180);\n  const c2 = Math.sin(r * Math.PI / 180);\n  return a1 * b1 == a2 * b2 && b1 * c2 > a2 * c1;\n};\n\n/*\n Given the lengths of the three sides of a heptagon with radius r. Return true if\n  the three sides form a heptagon with radius r, false otherwise.\n  A heptagon is a heptagon whose sides are all equal.\n  Example:\n  heptagon(3, 4) == true\n  heptagon(5, 6) == false\n  */\nconst decagonWithRadius = (a, b, r"}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "gc": "<|endoftext|>/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let maxLength = 0;\n  let maxWord = \"\";\n  let maxChar = 0;\n  let maxCharCount = 0;\n  let maxCharCount2 = 0;\n  let maxCharCount3 = 0;\n  let maxCharCount4 = 0;\n  let maxCharCount5 = 0;\n  let maxCharCount6 = 0;\n  let maxCharCount7 = 0;\n  let maxCharCount8 = 0;\n  let maxCharCount9 = 0;\n  let maxCharCount10 = 0;\n  let maxCharCount11 = 0;\n  let maxCharCount12 = 0;\n  let maxCharCount13 = 0;\n  let maxCharCount14 = 0;\n  let maxCharCount15 = 0;\n  let maxCharCount16 = 0;\n  let maxCharCount17 = 0;\n  let maxCharCount18 = 0;\n  let maxCharCount19 = 0;\n  let maxCharCount20 = 0;\n  let maxCharCount21 = 0;\n  let maxCharCount22 = 0;\n  let maxCharCount23 = 0;\n  let maxCharCount24 = 0;\n  let maxCharCount25 = 0;\n  let maxCharCount26 = 0;\n  let maxCharCount27 = 0;\n  let maxCharCount28 = 0;\n  let maxCharCount29 = 0;\n  let maxCharCount30 = 0;\n  let maxCharCount31 = 0;\n  let maxCharCount32 = 0;\n  let maxCharCount33 = 0;\n  let maxCharCount34 = 0;\n  let maxCharCount35 = 0;\n  let maxCharCount36 = 0;\n  let maxCharCount37 = 0;\n  let maxCharCount38 = 0;\n  let maxCharCount39 = 0;\n  let maxCharCount40 = 0;\n  let maxCharCount41 = 0;\n  let maxCharCount42 = 0;\n  let maxCharCount43 = 0;\n  let maxCharCount44 = 0;\n  let maxCharCount45 = 0;\n  let maxCharCount46 = 0;\n  let maxCharCount47 = 0;\n  let maxCharCount48 = 0;\n  let maxCharCount49 = 0;\n  let maxCharCount50 = 0;\n  let maxCharCount51 = 0;\n  let maxCharCount52 = 0;\n  let maxCharCount53 = 0;\n  let maxCharCount54 = 0;\n  let maxCharCount55 = 0;\n  let maxCharCount56 = 0;\n  let maxCharCount57 = 0;\n  let maxCharCount58 = 0;\n  let maxCharCount59 = 0;\n  let maxCharCount60 = 0;\n  let maxCharCount61 = 0;\n  let maxCharCount62 = 0;\n  let maxCharCount63 = 0;\n  let maxCharCount64 = 0;\n  let maxCharCount65 = 0;\n  let maxCharCount66 = 0;\n  let maxCharCount67 = 0;\n  let maxCharCount68 = 0;\n  let maxCharCount69 = 0;\n  let maxCharCount70 = 0;\n  let maxCharCount71 = 0;\n  let maxCharCount72 = 0;\n  let maxCharCount73 = 0;\n  let maxCharCount74 = 0;\n  let maxCharCount75 = 0;\n  let maxCharCount76 = 0;\n  let maxCharCount77 = 0;\n  let maxCharCount78 = 0;\n  let maxCharCount79 = 0;\n  let maxCharCount80 = 0;\n  let maxCharCount81 = 0;\n  let maxCharCount82 = 0;\n  let maxCharCount83 = 0;\n  let maxCharCount84 = 0;\n  let maxCharCount85 = 0;\n  let maxCharCount86 = 0;\n  let maxCharCount87 = 0;\n  let maxCharCount88 = 0;\n  let maxCharCount89 = 0;\n  let maxCharCount90 = 0;\n  let maxCharCount91 = 0;\n  let maxCharCount92 = 0;\n  let maxCharCount93 = 0;\n  let maxCharCount94 = 0;\n  let maxCharCount95 = 0;\n  let maxCharCount96 = 0;\n  let maxCharCount97 = 0;\n  let maxCharCount98 = 0;\n  let maxCharCount99 = 0;\n  let maxCharCount100 = 0;\n  let maxCharCount101 = 0;\n  let maxCharCount102 = 0;\n  let maxCharCount103 = 0;\n  let maxCharCount104 = 0;\n  let maxCharCount105 = 0;\n  let maxCharCount106 = 0;\n  let maxCharCount107 = 0;\n  let maxCharCount108 = 0;\n  let maxCharCount109 = 0;\n  let maxCharCount110 = 0;\n  let maxCharCount111 = 0;\n  let maxCharCount112 = 0;\n  let maxCharCount113 = 0;\n  let maxCharCount114 = 0;\n  let maxCharCount115 = 0;\n  let maxCharCount116 = 0;\n  let maxCharCount117 = 0;\n  let maxCharCount118 = 0;\n  let maxCharCount119 = 0;\n  let maxCharCount120 = 0;\n  let maxCharCount121 = 0;\n  let maxCharCount122 = 0;\n  let maxCharCount123 = 0;\n  let maxCharCount124 = 0;\n  let maxCharCount125 = 0;\n  let maxCharCount126 = 0;\n  let maxCharCount127 = 0;\n  let maxCharCount128 = 0;\n  let maxCharCount129 = 0;\n  let maxCharCount130 = 0;\n  let maxCharCount131 = 0;\n  let maxCharCount132 = 0;\n  let maxCharCount133 = 0;\n  let maxCharCount134 = 0;\n  let maxCharCount135 = 0;\n  let maxCharCount136 = 0;\n  let maxCharCount137 = 0;\n  let maxCharCount138 = 0;\n  let maxCharCount139 = 0;\n  let maxCharCount140 = 0;\n  let maxCharCount141 = 0;\n  let maxCharCount142 = 0;\n  let maxCharCount143 = 0;\n  let maxCharCount144 = 0;\n  let maxCharCount145 = 0;\n  let maxCharCount146 = 0;\n  let maxCharCount147 = 0;\n  let maxCharCount148 = 0;\n  let maxCharCount149 = 0;\n  let maxCharCount150 = 0;\n  let maxCharCount151 = 0;\n  let maxCharCount152 = 0;\n  let maxCharCount153 = 0;\n  let maxCharCount154 = 0;\n  let maxCharCount155 = 0;\n  let maxCharCount156 = 0;\n  let maxCharCount157 = 0;\n  let maxCharCount158 = 0;\n  let maxCharCount159 = 0;\n  let maxCharCount160 = 0;\n  let maxCharCount161 = 0;\n  let maxCharCount162 = 0;\n  let maxCharCount163 = 0;\n  let maxCharCount164 = 0;\n  let maxCharCount165 = 0;\n  let maxCharCount166 = 0;\n  let maxCharCount167 = 0;\n  let maxCharCount168 = 0;\n  let maxCharCount169 = 0;\n  let maxCharCount170 = 0;\n  let maxCharCount171 = 0;\n  let maxCharCount172 = 0;\n  let maxCharCount173 = 0;\n  let maxCharCount174 = 0;\n  let maxCharCount175 = 0;\n  let maxCharCount176 = 0;\n  let maxCharCount177 = 0;\n  let maxCharCount178 = 0;\n  let maxCharCount179 = 0;\n  let maxCharCount180 = 0;\n  let maxCharCount181 = 0;\n  let maxCharCount182 = 0;\n  let maxCharCount183 = 0;\n  let maxCharCount184 = 0;\n  let maxCharCount185 = 0;\n  let maxCharCount186 = 0;\n  let maxCharCount187 = 0;\n  let maxCharCount188 = 0;\n  let maxCharCount189 = 0;\n  let maxCharCount190 = 0;\n  let maxCharCount191 = 0;\n  let maxCharCount192 = 0;\n  let maxCharCount193 = 0;\n  let maxCharCount194 = 0;\n  let maxCharCount195 = 0;\n  let maxCharCount196 = 0;\n  let maxCharCount197 = 0;\n  let maxCharCount198 = 0;\n  let maxCharCount199 = 0;\n  let maxCharCount200 = 0;\n  let maxCharCount201 = 0;\n  let maxCharCount202 = 0;\n  let maxCharCount203 = 0;"}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(number * Math.ceil(need / 100));\n  const remaining = Math.ceil(remaining / 100);\n  const meals = Math.ceil(remaining / carrots);\n  const carrotLeft = carrots - meals;\n  const carrotEaten = carrotLeft - remaining;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = carrotLeft - carrotEaten;\n  const carrotLeft = "}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n\n  return result;\n};\n\nconst doMath = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n\n  return result;\n};\n\nconst doArithmetic = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n\n  return result;\n};\n\nconst doBitwise = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n\n  return result;\n};\n\nconst doComparison = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n\n  return result;\n};\n\nconst doLogical = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n\n  return result;\n};\n\nconst doLogicalOr = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n\n  return result;\n};\n\nconst doLogicalXor = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n\n  return result;\n};\n\nconst doBitwiseOr = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n\n  return result;\n};\n\nconst doBitwiseXor = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n\n  return result;\n};\n\nconst doShift = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n\n  return result;\n};\n\nconst doShiftLeft = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n\n  return result;\n};\n\nconst doShiftRight = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n\n  return result;\n};\n\nconst doShiftRightLogical = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      result += operator[operatorIndex] * operand[operandIndex];\n      operatorIndex++;\n    } else {\n      result += operand[operandIndex];\n      operandIndex++;\n    }\n  }\n\n  return result;\n};\n\nconst doShiftRightArithmetic = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (operandIndex < operandLength) {\n    if (operatorIndex < "}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "gc": "<|endoftext|>/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let reversedString = \"\";\n  let reversedString2 = \"\";\n  let reversedString3 = \"\";\n  let reversedString4 = \"\";\n  let reversedString5 = \"\";\n  let reversedString6 = \"\";\n  let reversedString7 = \"\";\n  let reversedString8 = \"\";\n  let reversedString9 = \"\";\n  let reversedString10 = \"\";\n  let reversedString11 = \"\";\n  let reversedString12 = \"\";\n  let reversedString13 = \"\";\n  let reversedString14 = \"\";\n  let reversedString15 = \"\";\n  let reversedString16 = \"\";\n  let reversedString17 = \"\";\n  let reversedString18 = \"\";\n  let reversedString19 = \"\";\n  let reversedString20 = \"\";\n  let reversedString21 = \"\";\n  let reversedString22 = \"\";\n  let reversedString23 = \"\";\n  let reversedString24 = \"\";\n  let reversedString25 = \"\";\n  let reversedString26 = \"\";\n  let reversedString27 = \"\";\n  let reversedString28 = \"\";\n  let reversedString29 = \"\";\n  let reversedString30 = \"\";\n  let reversedString31 = \"\";\n  let reversedString32 = \"\";\n  let reversedString33 = \"\";\n  let reversedString34 = \"\";\n  let reversedString35 = \"\";\n  let reversedString36 = \"\";\n  let reversedString37 = \"\";\n  let reversedString38 = \"\";\n  let reversedString39 = \"\";\n  let reversedString40 = \"\";\n  let reversedString41 = \"\";\n  let reversedString42 = \"\";\n  let reversedString43 = \"\";\n  let reversedString44 = \"\";\n  let reversedString45 = \"\";\n  let reversedString46 = \"\";\n  let reversedString47 = \"\";\n  let reversedString48 = \"\";\n  let reversedString49 = \"\";\n  let reversedString50 = \"\";\n  let reversedString51 = \"\";\n  let reversedString52 = \"\";\n  let reversedString53 = \"\";\n  let reversedString54 = \"\";\n  let reversedString55 = \"\";\n  let reversedString56 = \"\";\n  let reversedString57 = \"\";\n  let reversedString58 = \"\";\n  let reversedString59 = \"\";\n  let reversedString60 = \"\";\n  let reversedString61 = \"\";\n  let reversedString62 = \"\";\n  let reversedString63 = \"\";\n  let reversedString64 = \"\";\n  let reversedString65 = \"\";\n  let reversedString66 = \"\";\n  let reversedString67 = \"\";\n  let reversedString68 = \"\";\n  let reversedString69 = \"\";\n  let reversedString70 = \"\";\n  let reversedString71 = \"\";\n  let reversedString72 = \"\";\n  let reversedString73 = \"\";\n  let reversedString74 = \"\";\n  let reversedString75 = \"\";\n  let reversedString76 = \"\";\n  let reversedString77 = \"\";\n  let reversedString78 = \"\";\n  let reversedString79 = \"\";\n  let reversedString80 = \"\";\n  let reversedString81 = \"\";\n  let reversedString82 = \"\";\n  let reversedString83 = \"\";\n  let reversedString84 = \"\";\n  let reversedString85 = \"\";\n  let reversedString86 = \"\";\n  let reversedString87 = \"\";\n  let reversedString88 = \"\";\n  let reversedString89 = \"\";\n  let reversedString90 = \"\";\n  let reversedString91 = \"\";\n  let reversedString92 = \"\";\n  let reversedString93 = \"\";\n  let reversedString94 = \"\";\n  let reversedString95 = \"\";\n  let reversedString96 = \"\";\n  let reversedString97 = \"\";\n  let reversedString98 = \"\";\n  let reversedString99 = \"\";\n  let reversedString100 = \"\";\n  let reversedString101 = \"\";\n  let reversedString102 = \"\";\n  let reversedString103 = \"\";\n  let reversedString104 = \"\";\n  let reversedString105 = \"\";\n  let reversedString106 = \"\";\n  let reversedString107 = \"\";\n  let reversedString108 = \" \";\n  let reversedString109 = \"\";\n  let reversedString110 = \"\";\n  let reversedString111 = \"\";\n  let reversedString112 = \"\";\n  let reversedString113 = \"\";\n  let reversedString114 = \"\";\n  let reversedString115 = \"\";\n  let reversedString116 = \"\";\n  let reversedString117 = \"\";\n  let reversedString118 = \" \";\n  let reversedString119 = \"\";\n  let reversedString120 = \"\";\n  let reversedString121 = \"\";\n  let reversedString122 = \"\";\n  let reversedString123 = \"\";\n  let reversedString124 = \"\";\n  let reversedString125 = \"\";\n  let reversedString126 = \"\";\n  let reversedString127 = \"\";\n  let reversedString128 = \"\";\n  let reversedString129 = \"\";\n  let reversedString130 = \"\";\n  let reversedString131 = \"\";\n  let reversedString132 = \"\";\n  let reversedString133 = \"\";\n  let reversedString134 = \"\";\n  let reversedString135 = \"\";\n  let reversedString136 = \"\";\n  let reversedString137 = \"\";\n  let reversedString138 = \" \";\n  let reversedString139 = \"\";\n  let reversedString140 = \"\";\n  let reversedString141 = \"\";\n  let reversedString142 = \"\";\n  let reversedString143 = \"\";\n  let reversedString144 = \"\";\n  let reversedString145 = \"\";\n  let reversedString146 = \"\";\n  let reversedString147 = \"\";\n  let reversedString148 = \" \";\n  let reversedString149 = \"\";\n  let reversedString150 = \"\";\n  let reversedString151 = \"\";\n  let reversedString152 = \"\";\n  let reversedString153 = \"\";\n  let reversedString154 = \"\";\n  let reversedString155 = \"\";\n  let reversedString156 = \"\";\n  let reversedString157 = \" \";\n  let reversedString158 = \"\";\n  let reversedString159 = \"\";\n  let reversedString160 = \"\";\n  let reversedString161 = \"\";\n  let reversedString162 = \"\";\n  let reversedString163 = \"\";\n  let reversedString164 = \"\";\n  let reversedString165 = \"\";\n  let reversedString166 = \"\";\n  let reversedString167 = \" \";\n  let reversedString168 = \"\";\n  let reversedString169 = \"\";\n  let reversedString170 = \"\";\n  let reversedString171 = \"\";\n  let reversedString172 = \"\";\n  let reversedString173 = \"\";\n  let reversedString174 = \"\";\n  let reversedString175 = \"\";\n  let reversedString176 = \"\";\n  let reversedString177 = \"\";\n  let reversedString178 = \" \";\n  let reversedString179 = \"\";\n  let reversedString180 = \"\";\n  let reversedString181 = \"\";\n  let reversedString182 = \"\";\n  let reversedString183 = \"\";\n  let reversedString184 = \"\";\n  let reversedString185 = \"\";\n  let reversedString186 = \"\";\n  let reversedString187 = \"\";\n  let reversedString188 = \" \";\n  let reversedString189 = \"\";\n  let reversedString190 = \"\";\n  let reversedString191 = \"\";\n  let reversedString192 = \"\";\n  let reverse"}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "gc": "<|endoftext|>/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) return null\n  return crypto.createHash('md5').update(text).digest('hex')\n}\n\n/*\n  Given a string 'text', return its sha1 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == '5baeea9dabe449f2b9f95efa7dde9f60'\n  */\nconst stringToSha1 = (text) => {\n  if (!text) return null\n  return crypto.createHash('sha1').update(text).digest('hex')\n}\n\n/*\n  Given a string 'text', return its sha256 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha256('Hello world') == '9f8f7a67b009f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e5b9f86e"}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "gc": "<|endoftext|>/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  let i = a;\n  let j = 0;\n  while (i < b) {\n    const digit = i % 10;\n    result.push(digit);\n    i = Math.floor(i / 10);\n    j++;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest power of 10 less than or equal\n  to n.\n\n  For example:\n  powerOf10(100) => 100\n  powerOf10(200) => 200\n  powerOf10(300) => 300\n  powerOf10(400) => 400\n  powerOf10(500) => 500\n  powerOf10(600) => 600\n  powerOf10(700) => 700\n  powerOf10(800) => 800\n  powerOf10(900) => 900\n  powerOf10(1000) => 1000\n  powerOf10(1100) => 1100\n  powerOf10(1200) => 1200\n  powerOf10(1300) => 1300\n  powerOf10(1400) => 1400\n  powerOf10(1500) => 1500\n  powerOf10(1600) => 1600\n  powerOf10(1700) => 1700\n  powerOf10(1800) => 1800\n  powerOf10(1900) => 1900\n  powerOf10(2000) => 2000\n  powerOf10(2100) => 2100\n  powerOf10(2200) => 2200\n  powerOf10(2300) => 2300\n  powerOf10(2400) => 2400\n  powerOf10(2500) => 2500\n  powerOf10(2600) => 2600\n  powerOf10(2700) => 2700\n  powerOf10(2800) => 2800\n  powerOf10(2900) => 2900\n  powerOf10(3000) => 3000\n  powerOf10(3100) => 3100\n  powerOf10(3200) => 3200\n  powerOf10(3300) => 3300\n  powerOf10(3400) => 3400\n  powerOf10(3500) => 3500\n  powerOf10(3600) => 3600\n  powerOf10(3700) => 3700\n  powerOf10(3800) => 3800\n  powerOf10(3900) => 3900\n  powerOf10(4000) => 4000\n  powerOf10(4001) => 4001\n  powerOf10(4002) => 4002\n  powerOf10(4003) => 4003\n  powerOf10(4004) => 4004\n  powerOf10(4005) => 4005\n  powerOf10(4006) => 4006\n  powerOf10(4007) => 4007\n  powerOf10(4008) => 4008\n  powerOf10(4009) => 4009\n  powerOf10(4010) => 4010\n  powerOf10(4011) => 4011\n  powerOf10(4012) => 4012\n  powerOf10(4013) => 4013\n  powerOf10(4014) => 4014\n  powerOf10(4015) => 4015\n  powerOf10(4016) => 4016\n  powerOf10(4017) => 4017\n  powerOf10(4018) => 4018\n  powerOf10(4019) => 4019\n  powerOf10(4020) => 4020\n  powerOf10(4030) => 4030\n  powerOf10(4040) => 4040\n  powerOf10(4050) => 4050\n  powerOf10(4060) => 4060\n  powerOf10(4070) => 4070\n  powerOf10(4080) => 4080\n  powerOf10(4090) => 4090\n  powerOf10(4100) => 4100\n  powerOf10(4200) => 4200\n  powerOf10(4300) => 4300\n  powerOf10(4300) => 4300\n  powerOf10(4350) => 4350\n  powerOf10(4360) => 4360\n  powerOf10(4640) => 4640\n  powerOf10(4650) => 4650\n  powerOf10(4670) => 4670\n  powerOf10(4690) => 4690\n  powerOf10(4691) => 4691\n  powerOf10(4692) => 4692\n  powerOf10(4693) => 4693\n  powerOf10(4694) => 4694\n  powerOf10(4695) => 4695\n  powerOf10(4696) => 4696\n  powerOf10(4697) => 4697\n  powerOf10(4698) => 4698\n  powerOf10(4699) => 4699\n  powerOf10(4700) => 4700\n  powerOf10(4750) => 4750\n  powerOf10(4760) => 4760\n  powerOf10(4780) => 4780\n  powerOf10(4785) => 4785\n  powerOf10(4786) => 4786\n  powerOf10(4787) => 4787\n  powerOf10(4788) => 4788\n  powerOf10(4789) => 4789\n  powerOf10(4790) => 4790\n  powerOf10(4791) => 4791\n  powerOf10(4792) => 4792\n  powerOf10(4793) => 4793\n  powerOf10(4794) => 4794\n  powerOf10(4795) => 4795\n  powerOf10(4796) => 4796\n  powerOf10(4797) => 4797\n  powerOf10(4798) => 4798\n  powerOf10(4799) => 4799\n  powerOf10(4800) => 4800\n  powerOf10(4801) => 4801\n  powerOf10(4802) => 4802\n  powerOf10(4803) => 4803\n  powerOf10(4804) => 4804\n  powerOf10(4805) => 4805\n  powerOf10(4806) => 4806\n  powerOf10(4807) => 4807\n  powerOf10(4808) => 4808\n  powerOf10(4809) => 4809\n  powerOf10(4810) => 4810\n  powerOf10(4811) => 4811\n  powerOf10(4812) => 4812\n  powerOf10(4813) => 4813\n  powerOf10(4814) => 4814\n  powerOf10(4815) => 4815\n  powerOf10(4816) => 4816\n  powerOf10(4817) => 4817\n  powerOf10(4818) => 4818\n  powerOf10(4819) => 4819\n  powerOf10(4820) => 4820\n  powerOf10(4821) => 4821\n  powerOf10(4822) => 4822\n  powerOf10(4823) => 4823\n  powerOf10(4824) => 4824\n  powerOf10(4825) => 4825\n  powerOf10(4826"}
