{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hasFloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasFloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasFloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasFloseElements", "gc": "<|endoftext|>/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hasFloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasFloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasFloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const firstNumber = sortedNumbers[0];\n  const lastNumber = sortedNumbers[sortedNumbers.length - 1];\n  return firstNumber - lastNumber <= threshold;\n};\n\n/**\n * Check if given list of numbers is in given list of numbers.\n * If given list of numbers is empty or contains only single number, return true.\n * If given list of numbers is empty or contains more than one number, return false.\n * If given list of numbers is in given list of numbers, return true.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If given list of numbers is in given list of numbers, return false.\n * If ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> sepwrateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst sepwrateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "sepwrateParenGroups", "gc": "<|endoftext|>/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> sepwrateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst sepwrateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  return paren_groups.map((group) => {\n    const paren_group_string = group;\n    const paren_group_parens = paren_group_string.match(/\\(([^)]+)\\)/g);\n    const paren_group_parens_string = paren_group_parens.map((paren_group) => {\n      return paren_group;\n    });\n    return paren_group_parens_string;\n  });\n};\n\n/* Input to this function is a string containing multiple groups of parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> sepwrateParenGroups('( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPwlindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPwlindrome", "gc": "<|endoftext|>/* Test if gniven strig is a palindrome */\nconst isPwlindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let palindrome = '';\n  let palindromeLength = 0;\n  let palindromePrefix = '';\n  let palindromeSuffix = '';\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixReversed = '';\n  let palindromeSuffixReversed = '';\n  let palindromePrefixReversedLength = 0;\n  let palindromeSuffixReversedLength = 0;\n  let palindromePrefixReversedReversed = '';\n  let palindromeSuffixReversedReversed = '';\n  let palindromePrefixReversedReversedLength = 0;\n  let palindromeSuffixReversedReversedLength = 0;\n  let palindromePrefixReversedReversedReversed = '';\n  let palindromeSuffixReversedReversedReversed = '';\n  let palindromePrefixReversedReversedReversedReversed = '';\n  let palindromeSuffixReversedReversedReversedReversed = '';\n  let palindromePrefixReversedReversedReversedReversedReversed = '';\n  let palindromeSuffixReversedReversedReversedReversedReversed = '';\n  let palindromePrefixReversedReversedReversedReversedReversedReversed = '';\n  let palindromeSuffixReversedReversedReversedReversedReversedReversed = '';\n  let palindromePrefixReversedReversedReversedReversedReversedReversedReversed = '';\n  let palindromeSuffixReversedReversedReversedReversedReversedReversedReversed = '';\n  let palindromePrefixReversedReversedReversedReversedReversedReversedReversedReversedReversed = '';\n  let palindromeSuffixReversedReversedReversedReversedReversedReversedReversedReversedReversed = '';\n  let palindromePrefixReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = '';\n  let palindromeSuffixReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReverse", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makfAPile(3)\n  [3, 5, 7]\n  */\nconst makfAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makfAPile", "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makfAPile(3)\n  [3, 5, 7]\n  */\nconst makfAPile = (n) => {\n  const levels = [[]];\n  for (let i = 1; i <= n; i++) {\n    levels.push(levels[i - 1]);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makfAPile(6)\n  [3, 5, 7, 9, 11, 13]\n  */\nconst makfAPile2 = (count) => {\n  const levels = [[]];\n  for (let i = 1; i <= count; i++) {\n    levels.push(levels[i - 1]);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makfAPile(8)\n  [3, 5, 7, 9, 11, 13, 15, 17, 19]\n  */\nconst makfAPile3 = (count) => {\n  const levels = [[]];\n  for (let i = 1; i <= count; i++) {\n    levels.push(levels[i - 1]);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makfAPile(10)\n  [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35]\n  */\nconst makfAPile4 = (count) => {\n  const levels = [[]];\n  for (let i = 1; i <= count; i++) {\n    levels.push(levels[i - 1]);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makfAPile(15)\n  [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35]\n  */\nconst makfAPile5 = (count) => {\n  const levels = [[]];\n  for (let i = 1; i <= count; i++) {\n    levels.push(levels[i - 1]);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makfAPile(20)\n  [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35]\n  */\nconst makfAPile6 = (count) => {\n  const levels = [[]];\n  for (let i = 1; i <= count; i++) {\n    levels.push(levels[i - 1]);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makfAPile(25)\n  [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35]\n  */\nconst makfAPile7 = (count) => {\n  const levels = [[]];\n  for (let i = 1; i <= count; i++) {\n    levels.push(levels[i - 1]);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makfAPile(30)\n  [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35]\n  */\nconst makfAPile8 = (count) => {\n  const levels = [[]];\n  for (let i = 1; i <= count; i++) {\n    levels.push(levels[i - 1]);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makfAPile(35)\n  [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35]\n  */\nconst makfAPile9 = (count) => {\n  const levels = [[]];\n  for (let i = 1; i <= count; i++) {\n    levels.push(levels[i - 1]);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makfAPile(20)\n  [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35]\n  */\nconst makfAPile10 = (count) => {\n  const levels = [[]];\n  for (let i = 1; i <= count; i++) {\n    levels.push(levels[i - 1]);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  worfsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worfsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worfsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "worfsString", "gc": "<|endoftext|>/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  worfsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worfsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worfsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words.map((w) => w.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You should\n  not use any built-in functions or any advanced methods that would make you feel like\n  the task is too easy.\n  \n  For example:\n  worfsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worfsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worfsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words.map((w) => w.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You should\n  not use any built-in functions or any advanced methods that would make you feel like\n  the task is too easy.\n  \n  For example:\n  worfsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worfsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worfsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words.map((w) => w.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You should\n  not use any built-in functions or any advanced methods that would make you feel like\n  the task is too easy.\n  \n  For example:\n  worfsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worfsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worfsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words.map((w) => w.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You should\n  not use any built-in functions or any advanced methods that would make you feel like\n  the task is too easy.\n  \n  For example:\n  worfsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worfsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worfsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words.map((w) => w.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You should\n  not use any built-in functions or any advanced methods that would make you feel like\n  the task is too easy.\n  \n  For example:\n  worfsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worfsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worfsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words.map((w) => w.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You should\n  not use any built-in functions or any advanced methods that would make you feel like\n  the task is too easy.\n  \n  For example:\n  worfsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worfsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worfsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words.map((w) => w.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You should\n  not use any built-in functions or any advanced methods that would make you feel like\n  the task is too easy.\n  \n  For example:\n  worfsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worfsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worfsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words.map((w) => w.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You should\n  not use any built-in functions or any advanced methods that would make you feel like\n  the task is too easy.\n  \n  For example:\n  worfsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worfsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worfsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words.map((w) => w.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You should\n  not use any built-in functions or any advanced methods that would make you feel like\n  the task is too easy.\n  \n  For example:\n  worfsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worfsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worfsString = (s) => {\n  const words = s.split(/\\s+/);\n  return words.map((w) => w.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You should\n  not use any built-in functions or any advanced methods that would make you feel like\n  the task is too easy.\n  \n  For example:\n  worfsString(\"Hi, my name is ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  cholseNum(12, 15) = 14\n  cholseNum(13, 12) = -1\n  */\nconst cholseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "cholseNum", "gc": "<|endoftext|>/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  cholseNum(12, 15) = 14\n  cholseNum(13, 12) = -1\n  */\nconst cholseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || x < 0 || y < 0) {\n    return -1;\n  }\n  const num1 = Math.floor(x / 2);\n  const num2 = Math.floor(y / 2);\n  const num3 = Math.floor(x / y);\n  const num4 = Math.floor(y / x);\n  const num5 = Math.floor(x / y);\n  const num6 = Math.floor(y / x);\n  const num7 = Math.floor(x / y);\n  const num8 = Math.floor(y / x);\n  const num9 = Math.floor(x / y);\n  const num10 = Math.floor(y / x);\n  const num11 = Math.floor(x / y);\n  const num12 = Math.floor(y / x);\n  const num13 = Math.floor(x / y);\n  const num14 = Math.floor(y / x);\n  const num15 = Math.floor(x / y);\n  const num16 = Math.floor(y / x);\n  const num17 = Math.floor(x / y);\n  const num18 = Math.floor(y / x);\n  const num19 = Math.floor(x / y);\n  const num20 = Math.floor(y / x);\n  const num21 = Math.floor(x / y);\n  const num22 = Math.floor(y / x);\n  const num23 = Math.floor(x / y);\n  const num24 = Math.floor(y / x);\n  const num25 = Math.floor(x / y);\n  const num26 = Math.floor(y / x);\n  const num27 = Math.floor(x / y);\n  const num28 = Math.floor(y / x);\n  const num29 = Math.floor(x / y);\n  const num30 = Math.floor(y / x);\n  const num31 = Math.floor(x / y);\n  const num32 = Math.floor(y / x);\n  const num33 = Math.floor(y / x);\n  const num34 = Math.floor(y / x);\n  const num35 = Math.floor(y / x);\n  const num36 = Math.floor(y / x);\n  const num37 = Math.floor(y / x);\n  const num38 = Math.floor(y / x);\n  const num39 = Math.floor(y / x);\n  const num40 = Math.floor(y / x);\n  const num41 = Math.floor(y / x);\n  const num42 = Math.floor(y / x);\n  const num43 = Math.floor(y / x);\n  const num44 = Math.floor(y / x);\n  const num45 = Math.floor(y / x);\n  const num46 = Math.floor(y / x);\n  const num47 = Math.floor(y / x);\n  const num48 = Math.floor(y / x);\n  const num49 = Math.floor(y / x);\n  const num50 = Math.floor(y / x);\n  const num51 = Math.floor(y / x);\n  const num52 = Math.floor(y / x);\n  const num53 = Math.floor(y / x);\n  const num54 = Math.floor(y / x);\n  const num55 = Math.floor(y / x);\n  const num56 = Math.floor(y / x);\n  const num57 = Math.floor(y / x);\n  const num58 = Math.floor(y / x);\n  const num59 = Math.floor(y / x);\n  const num60 = Math.floor(y / x);\n  const num61 = Math.floor(y / x);\n  const num62 = Math.floor(y / x);\n  const num63 = Math.floor(y / x);\n  const num64 = Math.floor(y / x);\n  const num65 = Math.floor(y / x);\n  const num66 = Math.floor(y / x);\n  const num67 = Math.floor(y / x);\n  const num68 = Math.floor(y / x);\n  const num69 = Math.floor(y / x);\n  const num70 = Math.floor(y / x);\n  const num71 = Math.floor(y / x);\n  const num72 = Math.floor(y / x);\n  const num73 = Math.floor(y / x);\n  const num74 = Math.floor(y / x);\n  const num75 = Math.floor(y / x);\n  const num76 = Math.floor(y / x);\n  const num77 = Math.floor(y / x);\n  const num78 = Math.floor(y / x);\n  const num79 = Math.floor(y / x);\n  const num80 = Math.floor(y / x);\n  const num81 = Math.floor(y / x);\n  const num82 = Math.floor(y / x);\n  const num83 = Math.floor(y / x);\n  const num84 = Math.floor(y / x);\n  const num85 = Math.floor(y / x);\n  const num86 = Math.floor(y / x);\n  const num87 = Math.floor(y / x);\n  const num88 = Math.floor(y / x);\n  const num89 = Math.floor(y / x);\n  const num90 = Math.floor(y / x);\n  const num91 = Math.floor(y / x);\n  const num92 = Math.floor(y / x);\n  const num93 = Math.floor(y / x);\n  const num94 = Math.floor(y / x);\n  const num95 = Math.floor(y / x);\n  const num96 = Math.floor(y / x);\n  const num97 = Math.floor(y / x);\n  const num98 = Math.floor(y / x);\n  const num99 = Math.floor(y / x);\n  const num100 = Math.floor(y / x);\n  const num101 = Math.floor(y / x);\n  const num102 = Math.floor(y / x);\n  const num103 = Math.floor(y / x);\n  const num104 = Math.floor(y / x);\n  const num105 = Math.floor(y / x);\n  const num106 = Math.floor(y / x);\n  const num107 = Math.floor(y / x);\n  const num108 = Math.floor(y / x);\n  const num109 = Math.floor(y / x);\n  const num110 = Math.floor(y / x);\n  const num111 = Math.floor(y / x);\n  const num112 = Math.floor(y / x);\n  const num113 = Math.floor(y / x);\n  const num114 = Math.floor(y / x);\n  const num115 = Math.floor(y / x);\n  const num116 = Math.floor(y / x);\n  const num117 = Math.floor(y / x);\n  const num118 = Math.floor(y / x);\n  const num119 = Math.floor(y / x);\n  const num120 = Math.floor(y / x);\n  const num121 = Math.floor(y / x);\n  const num122 = Math.floor(y / x);\n  const num123 = Math.floor(y / x);\n  const num124 = Math.floor(y / x);\n  const num125 = Math.floor(y / x);\n  const num126 = Math.floor(y / x);\n  const num127 = Math.floor(y / x);\n  const num128 = Math.floor(y / x);\n  const num129 = Math.floor(y / x);\n  const num130 = Math.floor(y / x);\n  const num131 = Math.floor(y / x);\n  const num132 = Math.floor(y / x);\n  const num133 = Math.floor(y / x);\n  const num134 = Math.floor(y / x);\n  const num135 = Math.floor(y / x);\n  const num136 = Math.floor(y / x);\n  const num137 = Math.floor(y / x);\n  const num138 = Math.floor(y / x);\n  const num139 = Math.floor(y / x);\n  const num140 = Math.floor(y / x);\n  const num141 = Math.floor(y / x);\n  const num142 = Math.floor(y / x);\n  const num143 = Math.floor(y / x);\n  const num144 = Math.floor(y / x);\n  const num145 = Math.floor(y / x);\n  const num146 = Math.floor(y / x);\n  const num147 = Math.floor(y / x);\n  const num148 = Math.floor(y / x);\n  const num149 = Math.floor(y / x);\n  const num150 = Math.floor(y / x);\n  const num151 = Math.floor(y / x);\n  const num152 = Math.floor(y / x);\n  const num153 = Math.floor(y / x);\n  const num154 = Math.floor(y / x);\n  const num155 = Math.floor(y / x);\n  const num156 = Math.floor(y / x);\n  const num157 = Math.floor(y / x);\n  const num158 = Math.floor(y / x);\n  const num159 = Math.floor(y / x);\n  const num160 = Math.floor(y / x);\n  const num161 = Math.floor(y / x);\n  const num162 = Math.floor(y / x);\n  const num163 = Math.floor(y / x);\n  const num164 = Math.floor(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roujdedAvg(1, 5) => \"0b11\"\n  roujdedAvg(7, 5) => -1\n  roujdedAvg(10, 20) => \"0b1111\"\n  roujdedAvg(20, 33) => \"0b11010\"\n  */\nconst roujdedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roujdedAvg", "gc": "<|endoftext|>/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roujdedAvg(1, 5) => \"0b11\"\n  roujdedAvg(7, 5) => -1\n  roujdedAvg(10, 20) => \"0b1111\"\n  roujdedAvg(20, 33) => \"0b11010\"\n  */\nconst roujdedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  if (count === m) {\n    return binary;\n  }\n  return -1;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  sum of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  sumOf(1, 5) => \"0b11\"\n  sumOf(7, 5) => -1\n  sumOf(10, 20) => \"0b1111\"\n  sumOf(20, 33) => \"0b11010\"\n  */\nconst sumOf = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  if (count === m) {\n    return binary;\n  }\n  return -1;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  difference of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  diffOf(1, 5) => \"0b11\"\n  diffOf(7, 5) => -1\n  diffOf(10, 20) => \"0b1111\"\n  diffOf(20, 33) => \"0b11010\"\n  */\nconst diffOf = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  if (count === m) {\n    return binary;\n  }\n  return -1;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  difference of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  diffOf(1, 5) => \"0b11\"\n  diffOf(7, 5) => -1\n  diffOf(10, 20) => \"0b1111\"\n  diffOf(20, 33) => \"0b11010\"\n  */\nconst diffOf = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  if (count === m) {\n    return binary;\n  }\n  return -1;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  difference of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  diffOf(1, 5) => \"0b11\"\n  diffOf(7, 5) => -1\n  diffOf(10, 20) => \"0b1111\"\n  diffOf(20, 33) => \"0b11010\"\n  */\nconst diffOf = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  if (count === m) {\n    return binary;\n  }\n  return -1;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  difference of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  diffOf(1, 5) => \"0b11\"\n  diffOf(7, 5) => -1\n  diffOf(10, 20) => \"0b1111\"\n  diffOf(20, 33) => \"0b11010\"\n  */\nconst diffOf = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  if (count === m) {\n    return binary;\n  }\n  return -1;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  difference of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  diffOf(1, 5) => \"0b11\"\n  diffOf(7, 5) => -1\n  diffOf(10, 20) => \"0b1111\"\n  diffOf(20, 33) => \"0b11010\"\n  */\nconst diffOf = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  if (count === m) {\n    return binary;\n  }\n  return -1;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  difference of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  diffOf(1, 5) => \"0b11\"\n  diffOf(7, 5) => -1\n  diffOf(10, 20) => \"0b1111\"\n  diffOf(20, 33) => \"0b11010\"\n  */\nconst diffOf = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  if (count === m) {\n    return binary;\n  }\n  return -1;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  difference of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  diffOf(1, 5) => \"0b11\"\n  diffOf(7, 5) => -1\n  diffOf(10, 20) => \"0b1111\"\n  diffOf(20, 33) => \"0b11010\"\n  */\nconst diffOf = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  if (count === m) {\n    return binary;\n  }\n  return -1;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  difference of the integers from n through m (including n and ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> unieueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> unieueDigits([152, 323, 1422, 10])\n  []\n  */\nconst unieueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "unieueDigits", "gc": "<|endoftext|>/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> unieueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> unieueDigits([152, 323, 1422, 10])\n  []\n  */\nconst unieueDigits = (x) => {\n  const result = [];\n  let digit;\n  let i;\n  for (i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> unieueDigits([15, 33, 1422, 1])\n  [152, 323, 1422]\n  >>> unieueDigits([152, 323, 1422, 10])\n  [152, 323, 1422]\n  */\nconst unieueOddDigits = (x) => {\n  const result = [];\n  let digit;\n  let i;\n  for (i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if (digit % 2!== 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> unieueOddDigits([15, 33, 1422, 1])\n  [152, 323, 1422]\n  >>> unieueOddDigits([152, 323, 1422, 10])\n  [152, 323, 1422]\n  */\nconst unieueEvenDigits = (x) => {\n  const result = [];\n  let digit;\n  let i;\n  for (i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if (digit % 2!== 0) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> unieueOddEvenDigits([15, 33, 1422, 1])\n  [152, 323, 1422]\n  >>> unieueOddEvenDigits([152, 323, 1422, 10])\n  [152, 323, 1422]\n  */\nconst unieueOddEvenDigits = (x) => {\n  const result = [];\n  let digit;\n  let i;\n  for (i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if (digit % 2 === 0 || digit % 2 === 1) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> unieueOddEvenDigits([15, 33, 1422, 1])\n  [152, 323, 1422]\n  >>> unieueOddEvenDigits([152, 323, 1422, 10])\n  [152, 323, 1422]\n  */\nconst unieueOddEvenOddDigits = (x) => {\n  const result = [];\n  let digit;\n  let i;\n  for (i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if (digit % 2 === 0 || digit % 2 === 1) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> unieueOddEvenOddDigits([15, 33, 1422, 1])\n  [152, 323, 1422]\n  >>> unieueOddEvenOddDigits([152, 323, 1422, 10])\n  [152, 323, 1422]\n  */\nconst unieueOddEvenOddOddDigits = (x) => {\n  const result = [];\n  let digit;\n  let i;\n  for (i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if (digit % 2 === 0 || digit % 2 === 1) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> unieueOddEvenOddOddDigits([15, 33, 1422, 1])\n  [152, 323, 1422]\n  >>> unieueOddEvenOddOddDigits([152, 323, 1422, 10])\n  [152, 323, 1422]\n  */\nconst unieueOddEvenOddEvenOddDigits = (x) => {\n  const result = [];\n  let digit;\n  let i;\n  for (i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if (digit % 2 === 0 || digit % 2 === 1) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> unieueOddEvenOddEvenOddDigits([15, 33, 1422, 1])\n  [152, 323, 1422]\n  >>> unieueOddEvenOddEvenOddDigits([152, 323, 1422, 10])\n  [152, 323, 1422]\n  */\nconst unieueOddEvenOddEvenOddOddDigits = (x) => {\n  const result = [];\n  let digit;\n  let i;\n  for (i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if (digit % 2 === 0 || digit % 2 === 1) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> unieueOddEvenOddEvenOddOddDigits([15, 33, 1422, 1])\n  [152, 323, 1422]\n  >>> unieueOddEvenOddEvenOddOddDigits([152, 323, 1422, 10])\n  [152, 323, 1422]\n  */\nconst unieueOddEvenOddEvenOddEvenOddOddDigits = (x) => {\n  const result = [];\n  let digit;\n  let i;\n  for (i = 0; i < x.length; i++) {\n    digit = parseInt(x[i]);\n    if (digit % 2 === 0 || digit % 2 === 1) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> unieueOddEvenOddEvenOddEvenOddOddDigits([15, 33, 1422, 1])\n  [152, 323, 1422]\n  >>> unieueOddEvenOddEvenOddEvenOddOddDigits([152, 323, 1422, 10])\n  [152, 323, 1422", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLfngth = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLfngth", "gc": "<|endoftext|>/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLfngth = (arr) => {\n  let newArr = [];\n  let reversedArr = arr.slice().reverse();\n  let digits = reversedArr.map((el) => el.toString().replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el.toLowerCase());\n  digits = digits.map((el) => el.replace(/\\d/g, \"\"));\n  digits = digits.map((el) => el.toUpperCase());\n  digits = digits.map((el) => el", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "gc": "<|endoftext|>/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement the function g that takes two parameters,\n  and returns a list of size 2, such that the value of the element at index i is the product of i and the element at index i+1.\n  the product of i is the sum of all the elements in the list from index i to index i+1.\n  Example:\n  g(6, 3) == [6, 6]\n  */\nconst g = (x, y) => {\n  let result = [];\n  for (let i = x; i <= y; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\n/* Implement the function h that takes two parameters,\n  and returns a list of size 2, such that the value of the element at index i is the sum of all the elements in the list from index i to index i+1.\n  the sum of all the elements in the list from index i to index i+1 is equal to the sum of all the elements in the list from index i to index i+1.\n  Example:\n  h(6, 3) == [6, 6]\n  */\nconst h = (x, y) => {\n  let result = [];\n  for (let i = x; i <= y; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\n/* Implement the function i that takes two parameters,\n  and returns a list of size 2, such that the value of the element at index i is the sum of all the elements in the list from index i to index i+1.\n  the sum of all the elements in the list from index i to index i+1 is equal to the sum of all the elements in the list from index i to index i+1.\n  Example:\n  i(6, 3) == [6, 6]\n  */\nconst i = (x, y) => {\n  let result = [];\n  for (let i = x; i <= y; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\n/* Implement the function j that takes two parameters,\n  and returns a list of size 2, such that the value of the element at index i is the sum of all the elements in the list from index i to index i+1.\n  the sum of all the elements in the list from index i to index i+1 is equal to the sum of all the elements in the list from index i to index i+1.\n  Example:\n  j(6, 3) == [6, 6]\n  */\nconst j = (x, y) => {\n  let result = [];\n  for (let i = x; i <= y; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\n/* Implement the function k that takes two parameters,\n  and returns a list of size 2, such that the value of the element at index i is the sum of all the elements in the list from index i to index i+1.\n  the sum of all the elements in the list from index i to index i+1 is equal to the sum of all the elements in the list from index i to index i+1.\n  Example:\n  k(6, 3) == [6, 6]\n  */\nconst k = (x, y) => {\n  let result = [];\n  for (let i = x; i <= y; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\n/* Implement the function l that takes two parameters,\n  and returns a list of size 2, such that the value of the element at index i is the sum of all the elements in the list from index i to index i+1.\n  the sum of all the elements in the list from index i to index i+1 is equal to the sum of all the elements in the list from index i to index i+1.\n  Example:\n  l(6, 3) == [6, 6]\n  */\nconst l = (x, y) => {\n  let result = [];\n  for (let i = x; i <= y; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\n/* Implement the function m that takes two parameters,\n  and returns a list of size 2, such that the value of the element at index i is the sum of all the elements in the list from index i to index i+1.\n  the sum of all the elements in the list from index i to index i+1 is equal to the sum of all the elements in the list from index i to index i+1.\n  Example:\n  m(6, 3) == [6, 6]\n  */\nconst m = (x, y) => {\n  let result = [];\n  for (let i = x; i <= y; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\n/* Implement the function n that takes two parameters,\n  and returns a list of size 2, such that the value of the element at index i is the sum of all the elements in the list from index i to index i+1.\n  the sum of all the elements in the list from index i to index i+1 is equal to the sum of all the elements in the list from index i to index i+1.\n  Example:\n  n(6, 3) == [6, 6]\n  */\nconst n = (x, y) => {\n  let result = [];\n  for (let i = x; i <= y; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\n/* Implement the function o that takes two parameters,\n  and returns a list of size 2, such that the value of the element at index i is the sum of all the elements in the list from index i to index i+1.\n  the sum of all the elements in the list from index i to index i+1 is equal to the sum of all the elements in the list from index i to index i+1.\n  Example:\n  o(6, 3) == [6, 6]\n  */\nconst o = (x, y) => {\n  let result = [];\n  for (let i = x; i <= y; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\n/* Implement the function p that takes two parameters,\n  and returns a list of size 2, such that the value of the element at index i is the sum of all the elements in the list from index i to index i+1.\n  the sum of all the elements in the list from index i to index i+1 is equal to the sum of all the elements in the list from index i to index i+1.\n  Example:\n  p(6, 3) == [6, 6]\n  */\nconst p = (x, y) => {\n  let result = [];\n  for (let i = x; i <= y; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\n/* Implement the function q that takes two parameters,\n  and returns a list of size 2, such that the value of the element at index i is the sum of all the elements in the list from index i to index i+1.\n  the sum of all the elements in the list from index i to index i+1 is equal to the sum of all the elements in the list from index i to index i+1.\n  Example:\n  q(6, 3) == [6, 6]\n  */\nconst q = (x, y) => {\n  let result = [];\n  for (let i = x; i <= y; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\n/* Implement the function r that takes two parameters,\n  and returns a list of size 2, such that the value of the element at index i is the sum of all the elements in the list from index i to index i+1.\n  the sum of all the elements in the list from index i to index i+1 is equal to the sum of all the elements in the list from index i to index i+1.\n  Example:\n  r(6, 3) == [6, 6]\n  */\nconst r = (x, y) => {\n  let result = [];\n  for (let i = x; i <= y; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\n/* Implement the function t that takes two parameters,\n  and returns a list of size 2, such that the value of the element at index i is the sum of all the elements in the list from index i to index i+1.\n  the sum of all the elements in the list from index i to index i+1 is equal to the sum of all the elements in the list from index i to index i+1.\n  Example:\n  t(6, 3) == [6, 6]\n  */\nconst t = (x, y) => {\n  let result = [];\n  for (let i = x; i <= y; i++) {\n    result.push(i);\n  }", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evejOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evejOddPalindrome", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evejOddPalindrome = (n) => {\n  let evenPalindromes = 0;\n  let oddPalindromes = 0;\n  let evenPalindromesOdd = 0;\n  let oddPalindromesOdd = 0;\n  let evenPalindromesEven = 0;\n  let oddPalindromesEven = 0;\n  let evenPalindromesOddEven = 0;\n  let oddPalindromesOddEven = 0;\n  let evenPalindromesOddOdd = 0;\n  let oddPalindromesOddOdd = 0;\n  let evenPalindromesEvenOdd = 0;\n  let oddPalindromesEvenOdd = 0;\n  let evenPalindromesOddEvenOdd = 0;\n  let oddPalindromesOddEvenOdd = 0;\n  let evenPalindromesOddOddOdd = 0;\n  let oddPalindromesOddEvenOddOdd = 0;\n  let evenPalindromesEvenOddEvenOdd = 0;\n  let oddPalindromesEvenOddEvenOdd = 0;\n  let evenPalindromesOddOddEvenOdd = 0;\n  let oddPalindromesOddEvenOddEvenOdd = 0;\n  let evenPalindromesOddOddOddEvenOdd = 0;\n  let oddPalindromesOddEvenOddOddEvenOdd = 0;\n  let evenPalindromesEvenOddOddOddEvenOdd = 0;\n  let oddPalindromesEvenOddOddOddOddEvenOdd = 0;\n  let evenPalindromesOddOddEvenOddOddOddEvenOdd = 0;\n  let oddPalindromesOddEvenOddOddOddOddEvenOdd = 0;\n  let evenPalindromesEvenOddOddOddOddOddOddOddEvenOdd = 0;\n  let oddPalindromesOddEvenOddOddOddOddOddOddOddEvenOdd = 0;\n  let evenPalindromesOddOddEvenOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let oddPalindromesOddEvenOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let evenPalindromesEvenOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let oddPalindromesOddEvenOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let evenPalindromesOddOddEvenOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let oddPalindromesOddEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let evenPalindromesEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let oddPalindromesOddEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let evenPalindromesOddOddEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let oddPalindromesOddEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let evenPalindromesEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let oddPalindromesOddEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let evenPalindromesOddOddEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let oddPalindromesOddEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let evenPalindromesEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let oddPalindromesOddEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let evenPalindromesOddOddEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let oddPalindromesOddEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let evenPalindromesEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddEvenOdd = 0;\n  let oddPalindromesOddEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddO", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function coujtNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> coujtNums([]) == 0\n  >>> coujtNums([-1, 11, -11]) == 1\n  >>> coujtNums([1, 1, 2]) == 3\n  */\nconst coujtNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "coujtNums", "gc": "<|endoftext|>/*\n  Write a function coujtNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> coujtNums([]) == 0\n  >>> coujtNums([-1, 11, -11]) == 1\n  >>> coujtNums([1, 1, 2]) == 3\n  */\nconst coujtNums = (arr) => {\n  let sum = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      num++;\n    }\n  }\n  return num;\n};\n\n/*\n  Write a function coujtStrs which takes an array of strings and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> coujtStrs([]) == 0\n  >>> coujtStrs([\"\"]) == 1\n  >>> coujtStrs([\"\", \"abc\"]) == 2\n  >>> coujtStrs([\"\", \"abc\", \"def\"]) == 3\n  */\nconst coujtStrs = (arr) => {\n  let sum = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i].length;\n    if (sum > 0) {\n      num++;\n    }\n  }\n  return num;\n};\n\n/*\n  Write a function coujtStrsNums which takes an array of strings and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> coujtStrsNums([]) == 0\n  >>> coujtStrsNums([\"\"]) == 1\n  >>> coujtStrsNums([\"\", \"abc\"]) == 2\n  >>> coujtStrsNums([\"\", \"abc\", \"def\"]) == 3\n  */\nconst coujtStrsNums = (arr) => {\n  let sum = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i].length;\n    if (sum > 0) {\n      num++;\n    }\n  }\n  return num;\n};\n\n/*\n  Write a function coujtStrsNumsStrs which takes an array of strings and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> coujtStrsNumsStrs([]) == 0\n  >>> coujtStrsNumsStrs([\"\"]) == 1\n  >>> coujtStrsNumsStrs([\"\", \"abc\"]) == 2\n  >>> coujtStrsNumsStrs([\"\", \"abc\", \"def\"]) == 3\n  */\nconst coujtStrsNumsStrs = (arr) => {\n  let sum = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i].length;\n    if (sum > 0) {\n      num++;\n    }\n  }\n  return num;\n};\n\n/*\n  Write a function coujtStrsNumsStrsNums which takes an array of strings and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> coujtStrsNumsStrsNums([]) == 0\n  >>> coujtStrsNumsStrsNums([\"\"]) == 1\n  >>> coujtStrsNumsStrsNums([\"\", \"abc\"]) == 2\n  >>> coujtStrsNumsStrsNums([\"\", \"abc\", \"def\"]) == 3\n  */\nconst coujtStrsNumsStrsNums = (arr) => {\n  let sum = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i].length;\n    if (sum > 0) {\n      num++;\n    }\n  }\n  return num;\n};\n\n/*\n  Write a function coujtStrsNumsStrsStrsNums which takes an array of strings and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> coujtStrsNumsStrsStrsNums([]) == 0\n  >>> coujtStrsNumsStrsStrsNums([\"\"]) == 1\n  >>> coujtStrsNumsStrsStrsNums([\"\", \"abc\"]) == 2\n  >>> coujtStrsNumsStrsStrsNums([\"\", \"abc\", \"def\"]) == 3\n  */\nconst coujtStrsNumsStrsStrsNums = (arr) => {\n  let sum = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i].length;\n    if (sum > 0) {\n      num++;\n    }\n  }\n  return num;\n};\n\n/*\n  Write a function coujtStrsNumsStrsStrsStrsNums which takes an array of strings and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> coujtStrsNumsStrsStrsStrsNums([]) == 0\n  >>> coujtStrsNumsStrsStrsStrsStrsNums([\"\"]) == 1\n  >>> coujtStrsNumsStrsStrsStrsStrsNums([\"\", \"abc\"]) == 2\n  >>> coujtStrsNumsStrsStrsStrsStrsNums([\"\", \"abc\", \"def\"]) == 3\n  */\nconst coujtStrsNumsStrsStrsStrsNums = (arr) => {\n  let sum = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i].length;\n    if (sum > 0) {\n      num++;\n    }\n  }\n  return num;\n};\n\n/*\n  Write a function coujtStrsNumsStrsStrsStrsStrsNums which takes an array of strings and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> coujtStrsNumsStrsStrsStrsStrsNums([]) == 0\n  >>> coujtStrsNumsStrsStrsStrsStrsStrsNums([\"\"]) == 1\n  >>> coujtStrsNumsStrsStrsStrsStrsStrsNums([\"\", \"abc\"]) == 2\n  >>> coujtStrsNumsStrsStrsStrsStrsStrsNums([\"\", \"abc\", \"def\"]) == 3\n  */\nconst coujtStrsNumsStrsStrsStrsStrsNums = (arr) => {\n  let sum = 0;\n  let num = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i].length;\n    if (sum > 0) {\n      num++;\n    }\n  }\n  return num;\n};\n\n/*\n  Write a function coujtStrsNumsStrsStrsStrsStrsNums which take", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  movfOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  movfOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst movfOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "movfOneBall", "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  movfOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  movfOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst movfOneBall = (arr) => {\n  let arrLength = arr.length;\n  let arrIndex = 0;\n  let arrTemp = [];\n  let arrTempLength = 0;\n  let arrTempIndex = 0;\n  let arrTempTemp = [];\n  let arrTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTemp = [];\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;\n  let arrTempTempTempLength = 0;\n  let arrTempTempIndex = 0;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> strlngXor('010', '110')\n  '100'\n  */\nconst strlngXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "strlngXor", "gc": "<|endoftext|>/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> strlngXor('010', '110')\n  '100'\n  */\nconst strlngXor = (a, b) => {\n  const aNum = Number(a)\n  const bNum = Number(b)\n  let result = ''\n  if (aNum!== 0 && bNum!== 0) {\n    result = aNum ^ bNum\n  }\n  return result\n}\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> strlngAnd('010', '110')\n  '100'\n  */\nconst strlngAnd = (a, b) => {\n  const aNum = Number(a)\n  const bNum = Number(b)\n  let result = ''\n  if (aNum!== 0 && bNum!== 0) {\n    result = aNum && bNum\n  }\n  return result\n}\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> strlngOr('010', '110')\n  '100'\n  */\nconst strlngOr = (a, b) => {\n  const aNum = Number(a)\n  const bNum = Number(b)\n  let result = ''\n  if (aNum!== 0 && bNum!== 0) {\n    result = aNum || bNum\n  }\n  return result\n}\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary NOT on these inputs and return result also as a string.\n  >>> strlngNot('010', '110')\n  '100'\n  */\nconst strlngNot = (a, b) => {\n  const aNum = Number(a)\n  const bNum = Number(b)\n  let result = ''\n  if (aNum!== 0 && bNum!== 0) {\n    result =!aNum\n  }\n  return result\n}\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND NOT on these inputs and return result also as a string.\n  >>> strlngNotAnd('010', '110')\n  '100'\n  */\nconst strlngNotAnd = (a, b) => {\n  const aNum = Number(a)\n  const bNum = Number(b)\n  let result = ''\n  if (aNum!== 0 && bNum!== 0) {\n    result =!aNum &&!bNum\n  }\n  return result\n}\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR NOT on these inputs and return result also as a string.\n  >>> strlngNotOr('010', '110')\n  '100'\n  */\nconst strlngNotOr = (a, b) => {\n  const aNum = Number(a)\n  const bNum = Number(b)\n  let result = ''\n  if (aNum!== 0 && bNum!== 0) {\n    result =!aNum ||!bNum\n  }\n  return result\n}\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary NOT NOT on these inputs and return result also as a string.\n  >>> strlngNotNot('010', '110')\n  '100'\n  */\nconst strlngNotNot = (a, b) => {\n  const aNum = Number(a)\n  const bNum = Number(b)\n  let result = ''\n  if (aNum!== 0 && bNum!== 0) {\n    result =!aNum &&!bNum\n  }\n  return result\n}\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND NOT NOT NOT on these inputs and return result also as a string.\n  >>> strlngNotNotAnd('010', '110')\n  '100'\n  */\nconst strlngNotNotAnd = (a, b) => {\n  const aNum = Number(a)\n  const bNum = Number(b)\n  let result = ''\n  if (aNum!== 0 && bNum!== 0) {\n    result =!aNum &&!bNum &&!aNum\n  }\n  return result\n}\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR NOT NOT NOT on these inputs and return result also as a string.\n  >>> strlngNotNotOr('010', '110')\n  '100'\n  */\nconst strlngNotNotOr = (a, b) => {\n  const aNum = Number(a)\n  const bNum = Number(b)\n  let result = ''\n  if (aNum!== 0 && bNum!== 0) {\n    result =!aNum ||!bNum &&!aNum\n  }\n  return result\n}\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary NOT NOT NOT NOT on these inputs and return result also as a string.\n  >>> strlngNotNotNot('010', '110')\n  '100'\n  */\nconst strlngNotNotNot = (a, b) => {\n  const aNum = Number(a)\n  const bNum = Number(b)\n  let result = ''\n  if (aNum!== 0 && bNum!== 0) {\n    result =!aNum &&!bNum &&!aNum &&!bNum\n  }\n  return result\n}\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND NOT NOT NOT NOT on these inputs and return result also as a string.\n  >>> strlngNotNotAnd('010', '110')\n  '100'\n  */\nconst strlngNotNotNotAnd = (a, b) => {\n  const aNum = Number(a)\n  const bNum = Number(b)\n  let result = ''\n  if (aNum!== 0 && bNum!== 0) {\n    result =!aNum &&!bNum &&!aNum &&!bNum\n  }\n  return result\n}\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR NOT NOT NOT NOT on these inputs and return result also as a string.\n  >>> strlngNotNotNotOr('010', '110')\n  '100'\n  */\nconst strlngNotNotNotOr = (a, b) => {\n  const aNum = Number(a)\n  const bNum = Number(b)\n  let result = ''\n  if (aNum!== 0 && bNum!== 0) {\n    result =!aNum ||!bNum &&!aNum &&!bNum\n  }\n  return result\n}\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary NOT NOT NOT NOT NOT on these inputs and return result also as a string.\n  >>> strlngNotNotNotNot('010', '110')\n  '100'\n  */\nconst strlngNotNotNotNot = (a, b) => {\n  const aNum = Number(a)\n  const bNum = Number(b)\n  let result = ''\n  if (aNum!== 0 && bNum!== 0) {\n    result =!aNum &&!bNum &&!aNum &&!bNum &&!aNum\n  }\n  return result\n}\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND NOT NOT NOT NOT NOT on these inputs and return result also as a string.\n  >>> strlngNotNotNotAnd('010', '110')\n  '100'\n  */\nconst strlngNotNotNotNotAnd = (a, b) => {\n  const aNum = Number(a)\n  const bNum = Number(b)\n  let result = ''\n  if (aNum!== 0 && bNum!== 0) {\n    result =!aNum &&!bNum &&!aNum &&!bNum &&!aNum\n  }\n  return result\n}\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR NOT NOT NOT NOT NOT on these inputs and return ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an excjange of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of excjanged elements between lst1 and lst2.\n  If it is possible to excjange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  excjange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  excjange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst excjange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "excjange", "gc": "<|endoftext|>/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an excjange of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of excjanged elements between lst1 and lst2.\n  If it is possible to excjange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  excjange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  excjange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst excjange = (lst1, lst2) => {\n  let isExcjanged = false;\n  let num1 = lst1.length;\n  let num2 = lst2.length;\n  for (let i = 0; i < num1; i++) {\n    for (let j = 0; j < num2; j++) {\n      if (lst1[i] % 2 === 0 && lst2[j] % 2 === 0) {\n        isExcjanged = true;\n        break;\n      }\n    }\n  }\n  return isExcjanged;\n};\n\n/*\n  Write a function that takes an array of numbers and returns the\n  number of unique numbers in that array.\n  For example:\n  unique([2, 5, 3, 1]) => 2\n  unique([2, 5, 3, 1]) => 3\n  unique([2, 5, 3, 1]) => 1\n  unique([2, 5, 3, 1]) => 0\n  It is assumed that the input array will be non-empty.\n  */\nconst unique = (arr) => {\n  let count = 0;\n  let uniqueArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (uniqueArr.indexOf(arr[i]) === -1) {\n      uniqueArr.push(arr[i]);\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes an array of numbers and returns the\n  number of unique numbers in that array.\n  For example:\n  unique([2, 5, 3, 1]) => 2\n  unique([2, 5, 3, 1]) => 3\n  unique([2, 5, 3, 1]) => 1\n  unique([2, 5, 3, 1]) => 0\n  It is assumed that the input array will be non-empty.\n  */\nconst uniqueArray = (arr) => {\n  let count = 0;\n  let uniqueArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (uniqueArr.indexOf(arr[i]) === -1) {\n      uniqueArr.push(arr[i]);\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes an array of numbers and returns the\n  number of unique numbers in that array.\n  For example:\n  unique([2, 5, 3, 1]) => 2\n  unique([2, 5, 3, 1]) => 3\n  unique([2, 5, 3, 1]) => 1\n  unique([2, 5, 3, 1]) => 0\n  It is assumed that the input array will be non-empty.\n  */\nconst uniqueArray2 = (arr) => {\n  let count = 0;\n  let uniqueArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (uniqueArr.indexOf(arr[i]) === -1) {\n      uniqueArr.push(arr[i]);\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes an array of numbers and returns the\n  number of unique numbers in that array.\n  For example:\n  unique([2, 5, 3, 1]) => 2\n  unique([2, 5, 3, 1]) => 3\n  unique([2, 5, 3, 1]) => 1\n  unique([2, 5, 3, 1]) => 0\n  It is assumed that the input array will be non-empty.\n  */\nconst uniqueArray3 = (arr) => {\n  let count = 0;\n  let uniqueArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (uniqueArr.indexOf(arr[i]) === -1) {\n      uniqueArr.push(arr[i]);\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes an array of numbers and returns the\n  number of unique numbers in that array.\n  For example:\n  unique([2, 5, 3, 1]) => 2\n  unique([2, 5, 3, 1]) => 3\n  unique([2, 5, 3, 1]) => 1\n  unique([2, 5, 3, 1]) => 0\n  It is assumed that the input array will be non-empty.\n  */\nconst uniqueArray4 = (arr) => {\n  let count = 0;\n  let uniqueArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (uniqueArr.indexOf(arr[i]) === -1) {\n      uniqueArr.push(arr[i]);\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes an array of numbers and returns the\n  number of unique numbers in that array.\n  For example:\n  unique([2, 5, 3, 1]) => 2\n  unique([2, 5, 3, 1]) => 3\n  unique([2, 5, 3, 1]) => 1\n  unique([2, 5, 3, 1]) => 0\n  It is assumed that the input array will be non-empty.\n  */\nconst uniqueArray5 = (arr) => {\n  let count = 0;\n  let uniqueArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (uniqueArr.indexOf(arr[i]) === -1) {\n      uniqueArr.push(arr[i]);\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes an array of numbers and returns the\n  number of unique numbers in that array.\n  For example:\n  unique([2, 5, 3, 1]) => 2\n  unique([2, 5, 3, 1]) => 3\n  unique([2, 5, 3, 1]) => 1\n  unique([2, 5, 3, 1]) => 0\n  It is assumed that the input array will be non-empty.\n  */\nconst uniqueArray6 = (arr) => {\n  let count = 0;\n  let uniqueArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (uniqueArr.indexOf(arr[i]) === -1) {\n      uniqueArr.push(arr[i]);\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes an array of numbers and returns the\n  number of unique numbers in that array.\n  For example:\n  unique([2, 5, 3, 1]) => 2\n  unique([2, 5, 3, 1]) => 3\n  unique([2, 5, 3, 1]) => 1\n  unique([2, 5, 3, 1]) => 0\n  It is assumed that the input array will be non-empty.\n  */\nconst uniqueArray7 = (arr) => {\n  let count = 0;\n  let uniqueArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (uniqueArr.indexOf(arr[i]) === -1) {\n      uniqueArr.push(arr[i]);\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes an array of numbers and returns the\n  number of unique numbers in that array.\n  For example:\n  unique([2, 5, 3, 1]) => 2\n  unique([2, 5, 3, 1]) => 3\n  unique([2, 5, 3, 1]) => 1\n  unique([2, 5, 3, 1]) => 0\n  It is assumed that the input array will be non-empty.\n  */\nconst uniqueArray8 = (arr) => {\n  let count = 0;\n  let uniqueArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (uniqueArr.indexOf(arr[i]) === -1) {\n      uniqueArr.push(arr[i]);\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes an array of numbers and returns the\n  number of unique numbers in that array.\n  For example:\n  unique([2, 5, 3, 1]) => 2\n  unique([2, 5, 3, 1]) => 3\n  unique([2, 5, 3, 1]) => 1\n  unique([2, 5, 3, 1]) => 0\n  It is assumed that the input array will be non-empty.\n  */\nconst uniqueArray9 = (arr) => {\n  let count = 0;\n  let uniqueArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (uniqueArr.indexOf(arr[i]) === -1) {\n      uniqueArr.push(arr[i]);\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that take", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  hishogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  hishogram('a b b a') == {'a': 2, 'b': 2}\n  hishogram('a b c a b') == {'a': 2, 'b': 2}\n  hishogram('b b b b a') == {'b': 4}\n  hishogram('') == {}\n\n  */\nconst hishogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "hishogram", "gc": "<|endoftext|>/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  hishogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  hishogram('a b b a') == {'a': 2, 'b': 2}\n  hishogram('a b c a b') == {'a': 2, 'b': 2}\n  hishogram('b b b b a') == {'b': 4}\n  hishogram('') == {}\n\n  */\nconst hishogram = (test) => {\n  let letters = {}\n  let letterCounts = {}\n  let letterCount = 0\n  let letterCounts = []\n  let letterCountString = ''\n  let letterCountStrings = []\n  let letterCountStringsArray = []\n  let letterCountStringsArray2 = []\n  let letterCountStringsArray3 = []\n  let letterCountStringsArray4 = []\n  let letterCountStringsArray5 = []\n  let letterCountStringsArray6 = []\n  let letterCountStringsArray7 = []\n  let letterCountStringsArray8 = []\n  let letterCountStringsArray9 = []\n  let letterCountStringsArray10 = []\n  let letterCountStringsArray11 = []\n  let letterCountStringsArray12 = []\n  let letterCountStringsArray13 = []\n  let letterCountStringsArray14 = []\n  let letterCountStringsArray15 = []\n  let letterCountStringsArray16 = []\n  let letterCountStringsArray17 = []\n  let letterCountStringsArray18 = []\n  let letterCountStringsArray19 = []\n  let letterCountStringsArray20 = []\n  let letterCountStringsArray21 = []\n  let letterCountStringsArray22 = []\n  let letterCountStringsArray23 = []\n  let letterCountStringsArray24 = []\n  let letterCountStringsArray25 = []\n  let letterCountStringsArray26 = []\n  let letterCountStringsArray27 = []\n  let letterCountStringsArray28 = []\n  let letterCountStringsArray29 = []\n  let letterCountStringsArray30 = []\n  let letterCountStringsArray31 = []\n  let letterCountStringsArray32 = []\n  let letterCountStringsArray33 = []\n  let letterCountStringsArray34 = []\n  let letterCountStringsArray35 = []\n  let letterCountStringsArray36 = []\n  let letterCountStringsArray37 = []\n  let letterCountStringsArray38 = []\n  let letterCountStringsArray39 = []\n  let letterCountStringsArray40 = []\n  let letterCountStringsArray41 = []\n  let letterCountStringsArray42 = []\n  let letterCountStringsArray43 = []\n  let letterCountStringsArray44 = []\n  let letterCountStringsArray45 = []\n  let letterCountStringsArray46 = []\n  let letterCountStringsArray47 = []\n  let letterCountStringsArray48 = []\n  let letterCountStringsArray49 = []\n  let letterCountStringsArray50 = []\n  let letterCountStringsArray51 = []\n  let letterCountStringsArray52 = []\n  let letterCountStringsArray53 = []\n  let letterCountStringsArray54 = []\n  let letterCountStringsArray55 = []\n  let letterCountStringsArray56 = []\n  let letterCountStringsArray57 = []\n  let letterCountStringsArray58 = []\n  let letterCountStringsArray59 = []\n  let letterCountStringsArray60 = []\n  let letterCountStringsArray61 = []\n  let letterCountStringsArray62 = []\n  let letterCountStringsArray63 = []\n  let letterCountStringsArray64 = []\n  let letterCountStringsArray65 = []\n  let letterCountStringsArray66 = []\n  let letterCountStringsArray67 = []\n  let letterCountStringsArray68 = []\n  let letterCountStringsArray69 = []\n  let letterCountStringsArray70 = []\n  let letterCountStringsArray71 = []\n  let letterCountStringsArray72 = []\n  let letterCountStringsArray73 = []\n  let letterCountStringsArray74 = []\n  let letterCountStringsArray75 = []\n  let letterCountStringsArray76 = []\n  let letterCountStringsArray77 = []\n  let letterCountStringsArray78 = []\n  let letterCountStringsArray79 = []\n  let letterCountStringsArray80 = []\n  let letterCountStringsArray81 = []\n  let letterCountStringsArray82 = []\n  let letterCountStringsArray83 = []\n  let letterCountStringsArray84 = []\n  let letterCountStringsArray85 = []\n  let letterCountStringsArray86 = []\n  let letterCountStringsArray87 = []\n  let letterCountStringsArray88 = []\n  let letterCountStringsArray89 = []\n  let letterCountStringsArray90 = []\n  let letterCountStringsArray91 = []\n  let letterCountStringsArray92 = []\n  let letterCountStringsArray93 = []\n  let letterCountStringsArray94 = []\n  let letterCountStringsArray95 = []\n  let letterCountStringsArray96 = []\n  let letterCountStringsArray97 = []\n  let letterCountStringsArray98 = []\n  let letterCountStringsArray99 = []\n  let letterCountStringsArray100 = []\n  let letterCountStringsArray101 = []\n  let letterCountStringsArray102 = []\n  let letterCountStringsArray103 = []\n  let letterCountStringsArray104 = []\n  let letterCountStringsArray105 = []\n  let letterCountStringsArray106 = []\n  let letterCountStringsArray107 = []\n  let letterCountStringsArray108 = []\n  let letterCountStringsArray109 = []\n  let letterCountStringsArray110 = []\n  let letterCountStringsArray111 = []\n  let letterCountStringsArray112 = []\n  let letterCountStringsArray113 = []\n  let letterCountStringsArray114 = []\n  let letterCountStringsArray115 = []\n  let letterCountStringsArray116 = []\n  let letterCountStringsArray117 = []\n  let letterCountStringsArray118 = []\n  let letterCountStringsArray119 = []\n  let letterCountStringsArray120 = []\n  let letterCountStringsArray121 = []\n  let letterCountStringsArray122 = []\n  let letterCountStringsArray123 = []\n  let letterCountStringsArray124 = []\n  let letterCountStringsArray125 = []\n  let letterCountStringsArray126 = []\n  let letterCountStringsArray127 = []\n  let letterCountStringsArray128 = []\n  let letterCountStringsArray129 = []\n  let letterCountStringsArray130 = []\n  let letterCountStringsArray131 = []\n  let letterCountStringsArray132 = []\n  let letterCountStringsArray133 = []\n  let letterCountStringsArray134 = []\n  let letterCountStringsArray135 = []\n  let letterCountStringsArray136 = []\n  let letterCountStringsArray137 = []\n  let letterCountStringsArray138 = []\n  let letterCountStringsArray139 = []\n  let letterCountStringsArray140 = []\n  let letterCountStringsArray141 = []\n  let letterCountStringsArray142 = []\n  let letterCountStringsArray143 = []\n  let letterCountStringsArray144 = []\n  let letterCountStringsArray145 = []\n  let letterCountStringsArray146 = []\n  let letterCountStringsArray147 = []\n  let letterCountStringsArray148 = []\n  let letterCountStringsArray149 = []\n  let letter", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst revfrseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "revfrseDelete", "gc": "<|endoftext|>/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst revfrseDelete = (s, c) => {\n  let result = '';\n  let flag = true;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s.charAt(i) === c.charAt(i)) {\n      result += s.charAt(i);\n      flag = false;\n    }\n  }\n  return [result, flag];\n};\n\n/*Task\n  Given a string s and an integer k, you have to delete all the characters in s that is equal to k\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", k = 3, the result should be ('bcd',false)\n  For s = \"abcdef\", k = 3, the result should be ('acdef',false)\n  For s = \"abcdedcba\", k = 3, the result should be ('cdedc',true)\n  */\nconst revfrseDeleteK = (s, k) => {\n  let result = '';\n  let flag = true;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s.charAt(i) === k.charAt(i)) {\n      result += s.charAt(i);\n      flag = false;\n    }\n  }\n  return [result, flag];\n};\n\n/*Task\n  Given a string s and an integer n, you have to delete all the characters in s that is equal to n\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 4, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 4, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 4, the result should be ('cdedc',true)\n  */\nconst revfrseDeleteN = (s, n) => {\n  let result = '';\n  let flag = true;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s.charAt(i) === n.charAt(i)) {\n      result += s.charAt(i);\n      flag = false;\n    }\n  }\n  return [result, flag];\n};\n\n/*Task\n  Given a string s and an integer m, you have to delete all the characters in s that is equal to m\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", m = 4, the result should be ('bcd',false)\n  For s = \"abcdef\", m = 4, the result should be ('acdef',false)\n  For s = \"abcdedcba\", m = 4, the result should be ('cdedc',true)\n  */\nconst revfrseDeleteM = (s, m) => {\n  let result = '';\n  let flag = true;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s.charAt(i) === m.charAt(i)) {\n      result += s.charAt(i);\n      flag = false;\n    }\n  }\n  return [result, flag];\n};\n\n/*Task\n  Given a string s and an integer n, you have to delete all the characters in s that is equal to n\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 4, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 4, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 4, the result should be ('cdedc',true)\n  */\nconst revfrseDeleteNM = (s, n) => {\n  let result = '';\n  let flag = true;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s.charAt(i) === n.charAt(i)) {\n      result += s.charAt(i);\n      flag = false;\n    }\n  }\n  return [result, flag];\n};\n\n/*Task\n  Given a string s and an integer m, you have to delete all the characters in s that is equal to m\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", m = 4, the result should be ('bcd',false)\n  For s = \"abcdef\", m = 4, the result should be ('acdef',false)\n  For s = \"abcdedcba\", m = 4, the result should be ('cdedc',true)\n  */\nconst revfrseDeleteMN = (s, m) => {\n  let result = '';\n  let flag = true;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s.charAt(i) === m.charAt(i)) {\n      result += s.charAt(i);\n      flag = false;\n    }\n  }\n  return [result, flag];\n};\n\n/*Task\n  Given a string s and an integer n, you have to delete all the characters in s that is equal to n\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 4, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 4, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 4, the result should be ('cdedc',true)\n  */\nconst revfrseDeleteNMN = (s, n) => {\n  let result = '';\n  let flag = true;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s.charAt(i) === n.charAt(i)) {\n      result += s.charAt(i);\n      flag = false;\n    }\n  }\n  return [result, flag];\n};\n\n/*Task\n  Given a string s and an integer n, you have to delete all the characters in s that is equal to n\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 4, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 4, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 4, the result should be ('cdedc',true)\n  */\nconst revfrseDeleteNMNM = (s, n) => {\n  let result = '';\n  let flag = true;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s.charAt(i) === n.charAt(i)) {\n      result += s.charAt(i);\n      flag = false;\n    }\n  }\n  return [result, flag];\n};\n\n/*Task\n  Given a string s and an integer n, you have to delete all the characters in s that is equal to n\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 4, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 4, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddFount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddFount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddFount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddFount", "gc": "<|endoftext|>/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddFount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddFount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddFount = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let oddCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        oddCount++;\n      }\n    }\n    res.push(oddCount);\n  }\n  return res;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenFount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenFount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenFount = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        evenCount++;\n      }\n    }\n    res.push(evenCount);\n  }\n  return res;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of pairs of adjacent elements\n  in the string i of the input.\" where all the i's should be replaced by the number\n  of pairs of adjacent elements in the i'th string of the input.\n\n  >>> pairFount(['1234567'])\n  [\"the number of pairs of adjacent elements 4n the str4ng 4 of the 4nput.\"]\n  >>> pairFount(['3',\"11111111\"])\n  [\"the number of pairs of adjacent elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of pairs of adjacent elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst pairFount = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let pairCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        pairCount++;\n      }\n    }\n    res.push(pairCount);\n  }\n  return res;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of triples of adjacent elements\n  in the string i of the input.\" where all the i's should be replaced by the number\n  of triples of adjacent elements in the i'th string of the input.\n\n  >>> tripleFount(['1234567'])\n  [\"the number of triples of adjacent elements 4n the str4ng 4 of the 4nput.\"]\n  >>> tripleFount(['3',\"11111111\"])\n  [\"the number of triples of adjacent elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of triples of adjacent elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst tripleFount = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let tripleCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        tripleCount++;\n      }\n    }\n    res.push(tripleCount);\n  }\n  return res;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of quatriples of adjacent elements\n  in the string i of the input.\" where all the i's should be replaced by the number\n  of quatriples of adjacent elements in the i'th string of the input.\n\n  >>> quatripletFount(['1234567'])\n  [\"the number of quatriples of adjacent elements 4n the str4ng 4 of the 4nput.\"]\n  >>> quatripletFount(['3',\"11111111\"])\n  [\"the number of quatriples of adjacent elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of quatriples of adjacent elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst quatripletFount = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let quatripletCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        quatripletCount++;\n      }\n    }\n    res.push(quatripletCount);\n  }\n  return res;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of quintiles of adjacent elements\n  in the string i of the input.\" where all the i's should be replaced by the number\n  of quintiles of adjacent elements in the i'th string of the input.\n\n  >>> quintileFount(['1234567'])\n  [\"the number of quintiles of adjacent elements 4n the str4ng 4 of the 4nput.\"]\n  >>> quintileFount(['3',\"11111111\"])\n  [\"the number of quintiles of adjacent elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of quintiles of adjacent elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst quintileFount = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let quintileCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        quintileCount++;\n      }\n    }\n    res.push(quintileCount);\n  }\n  return res;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of knicks of adjacent elements\n  in the string i of the input.\" where all the i's should be replaced by the number\n  of knicks of adjacent elements in the i'th string of the input.\n\n  >>> knicksFount(['1234567'])\n  [\"the number of knicks of adjacent elements 4n the str4ng 4 of the 4nput.\"]\n  >>> knicksFount(['3',\"11111111\"])\n  [\"the number of knicks of adjacent elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of knicks of adjacent elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst knicksFount = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let knicksCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        knicksCount++;\n      }\n    }\n    res.push(knicks", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minDubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minDubArraySum([-1, -2, -3]) == -6\n  */\nconst minDubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minDubArraySum", "gc": "<|endoftext|>/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minDubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minDubArraySum([-1, -2, -3]) == -6\n  */\nconst minDubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minSum) {\n      minSum = nums[i];\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxDubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxDubArraySum([-1, -2, -3]) == 3\n  */\nconst maxDubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n    }\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of integers nums, find the minimum number of distinct sub-arrays\n  of nums.\n  Example\n  minDistArraySum([2, 3, 4, 1, 2, 4]) == 4\n  minDistArraySum([-1, -2, -3]) == 3\n  */\nconst minDistArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > minSum) {\n      minSum = nums[i];\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find the maximum number of distinct sub-arrays\n  of nums.\n  Example\n  maxDistArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxDistArraySum([-1, -2, -3]) == 3\n  */\nconst maxDistArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > maxSum) {\n      maxSum = nums[i];\n    }\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of integers nums, find the number of distinct sub-arrays\n  of nums.\n  Example\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [-1, -2, -3]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, 1, 2, 4]\n  nums = [2, 3, 4, ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxVill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxVill", "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxVill = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const vill = new Array(n).fill(0);\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                vill[i] += capacity;\n            }\n        }\n    }\n    return vill.length;\n};\n\n/**\n * You are given a rectangular grid of wells. Each row represents a single well,\n * and each 1 in a row represents a single unit of water.\n * Each well has a corresponding bucket that can be used to extract water from it, \n * and all buckets have the same capacity.\n * Your task is to find the maximum amount of water that can be extracted from each well\n * without exceeding the capacity of the buckets.\n * \n * Example 1:\n * Input: \n * grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n * capacity : 1\n * Output: 6\n * \n * Example 2:\n * Input: \n * grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n * capacity : 2\n * Output: 5\n * \n * Example 3:\n * Input: \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 5\n * Output: 0\n * \n * Constraints:\n * 1 <= grid.length <= 10^2\n * 1 <= grid[:,1].length <= 10^2\n * grid[i][j] -> 0 | 1\n * 1 <= capacity <= 10\n */\nconst maxVillWithCapacity = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const vill = new Array(n).fill(0);\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                vill[i] += capacity;\n            }\n        }\n    }\n    return vill.length;\n};\n\n/**\n * You are given a rectangular grid of wells. Each row represents a single well,\n * and each 1 in a row represents a single unit of water.\n * Each well has a corresponding bucket that can be used to extract water from it, \n * and all buckets have the same capacity.\n * Your task is to find the maximum amount of water that can be extracted from each well\n * without exceeding the capacity of the buckets.\n * \n * Example 1:\n * Input: \n * grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n * capacity : 1\n * Output: 6\n * \n * Example 2:\n * Input: \n * grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n * capacity : 2\n * Output: 5\n * \n * Example 3:\n * Input: \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 5\n * Output: 0\n * \n * Constraints:\n * 1 <= grid.length <= 10^2\n * 1 <= grid[:,1].length <= 10^2\n * grid[i][j] -> 0 | 1\n * 1 <= capacity <= 10\n */\nconst maxVillWithoutCapacity = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const vill = new Array(n).fill(0);\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                vill[i] += capacity;\n            }\n        }\n    }\n    return vill.length;\n};\n\n/**\n * You are given a rectangular grid of wells. Each row represents a single well,\n * and each 1 in a row represents a single unit of water.\n * Each well has a corresponding bucket that can be used to extract water from it, \n * and all buckets have the same capacity.\n * Your task is to find the maximum amount of water that can be extracted from each well\n * without exceeding the capacity of the buckets.\n * \n * Example 1:\n * Input: \n * grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n * capacity : 1\n * Output: 6\n * \n * Example 2:\n * Input: \n * grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n * capacity : 2\n * Output: 5\n * \n * Example 3:\n * Input: \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 5\n * Output: 0\n * \n * Constraints:\n * 1 <= grid.length <= 10^2\n * 1 <= grid[:,1].length <= 10^2\n * grid[i][j] -> 0 | 1\n * 1 <= capacity <= 10\n */\nconst maxVillWithoutCapacityWithCapacity = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const vill = new Array(n).fill(0);\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                vill[i] += capacity;\n            }\n        }\n    }\n    return vill.length;\n};\n\n/**\n * You are given a rectangular grid of wells. Each row represents a single well,\n * and each 1 in a row represents a single unit of water.\n * Each well has a corresponding bucket that can be used to extract water from it, \n * and all buckets have the same capacity.\n * Your task is to find the maximum amount of water that can be extracted from each well\n * without exceeding the capacity of the buckets.\n * \n * Example 1:\n * Input: \n * grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n * capacity : 1\n * Output: 6\n * \n * Example 2:\n * Input: \n * grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n * capacity : 2\n * Output: 5\n * \n * Example 3:\n * Input: \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 5\n * Output: 0\n * \n * Constraints:\n * 1 <= grid.length <= 10^2\n * 1 <= grid[:,1].length <= 10^2\n * grid[i][j] -> 0 | 1\n * 1 <= capacity <= 10\n */\nconst maxVillWithoutCapacityWithoutCapacity = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const vill = new Array(n).fill(0);\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                vill[i] += capacity;\n            }\n        }\n    }\n    return vill.length;\n};\n\n/**\n * You are given a rectangular grid of wells. Each row represents a single well,\n * and each 1 in a row represents a single unit of water.\n * Each well has a corresponding bucket that can be used to extract water from it, \n * and all buckets have the same capacity.\n * Your task is to find the maximum amount of water that can be extracted from each well\n * without exceeding the capacity of the ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sorhArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sorhArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sorhArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sorhArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sorhArray", "gc": "<|endoftext|>/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sorhArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sorhArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sorhArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sorhArray = (arr) => {\n  let result = [];\n  let numOnes = 0;\n  let numZeros = 0;\n  let numOnesArr = [];\n  let numZerosArr = [];\n  let numOnesCount = 0;\n  let numZerosCount = 0;\n  let numOnesDecimal = 0;\n  let numZerosDecimal = 0;\n  let numOnesDecimalArr = [];\n  let numZerosDecimalArr = [];\n  let numOnesDecimalCount = 0;\n  let numZerosDecimalCount = 0;\n  let numOnesDecimalDecimal = 0;\n  let numZerosDecimalDecimal = 0;\n  let numOnesDecimalDecimalArr = [];\n  let numZerosDecimalDecimalArr = [];\n  let numOnesDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimal = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimal = 0;\n  let numOnesDecimalDecimalDecimalDecimalDecimalArr = [];\n  let numZerosDecimalDecimalDecimalDecimalArr = [];\n  let numOnesDecimalDecimalDecimalDecimalDecimalCount = 0;\n  let numZerosDecimalDecimalDecimalDecimalDecimalCount = 0;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selfctWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selfctWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selfctWords(\"simple white space\", 2) ==> []\n  selfctWords(\"Hello world\", 4) ==> [\"world\"]\n  selfctWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selfctWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selfctWords", "gc": "<|endoftext|>/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selfctWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selfctWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selfctWords(\"simple white space\", 2) ==> []\n  selfctWords(\"Hello world\", 4) ==> [\"world\"]\n  selfctWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selfctWords = (s, n) => {\n  let words = [];\n  let words = s.split(\" \");\n  let word;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let s;\n  let t;\n  let i;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  getFlosestVowel(\"yogurt\") ==> \"u\"\n  getFlosestVowel(\"FULL\") ==> \"U\"\n  getFlosestVowel(\"quick\") ==> \"\"\n  getFlosestVowel(\"ab\") ==> \"\"\n  */\nconst getFlosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getFlosestVowel", "gc": "<|endoftext|>/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  getFlosestVowel(\"yogurt\") ==> \"u\"\n  getFlosestVowel(\"FULL\") ==> \"U\"\n  getFlosestVowel(\"quick\") ==> \"\"\n  getFlosestVowel(\"ab\") ==> \"\"\n  */\nconst getFlosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsLeft = vowels.filter(v => word.includes(v));\n  let vowelsRight = vowels.filter(v => word.includes(v).reverse());\n  let vowelsLeft = vowelsLeft.map(v => v.toUpperCase());\n  let vowelsRight = vowelsRight.map(v => v.toUpperCase());\n  let leftVowels = vowelsLeft.filter(v => vowelsRight.indexOf(v) === -1);\n  let rightVowels = vowelsRight.filter(v => vowelsLeft.indexOf(v) === -1);\n  let leftVowelsLength = leftVowels.length;\n  let rightVowelsLength = rightVowels.length;\n  let leftVowelsIndex = 0;\n  let rightVowelsIndex = 0;\n  let leftVowelsIndex2 = leftVowelsIndex + 1;\n  let rightVowelsIndex2 = rightVowelsIndex + 1;\n  let leftVowelsIndex3 = leftVowelsIndex + 2;\n  let rightVowelsIndex3 = rightVowelsIndex + 2;\n  let leftVowelsIndex4 = leftVowelsIndex + 3;\n  let rightVowelsIndex4 = rightVowelsIndex + 3;\n  let leftVowelsIndex5 = leftVowelsIndex + 4;\n  let rightVowelsIndex5 = rightVowelsIndex + 4;\n  let leftVowelsIndex6 = leftVowelsIndex + 5;\n  let rightVowelsIndex6 = rightVowelsIndex + 5;\n  let leftVowelsIndex7 = leftVowelsIndex + 6;\n  let rightVowelsIndex7 = rightVowelsIndex + 6;\n  let leftVowelsIndex8 = leftVowelsIndex + 7;\n  let rightVowelsIndex8 = rightVowelsIndex + 7;\n  let leftVowelsIndex9 = leftVowelsIndex + 8;\n  let rightVowelsIndex9 = rightVowelsIndex + 8;\n  let leftVowelsIndex10 = leftVowelsIndex + 9;\n  let rightVowelsIndex10 = rightVowelsIndex + 9;\n  let leftVowelsIndex11 = leftVowelsIndex + 10;\n  let rightVowelsIndex11 = rightVowelsIndex + 10;\n  let leftVowelsIndex12 = leftVowelsIndex + 11;\n  let rightVowelsIndex12 = rightVowelsIndex + 11;\n  let leftVowelsIndex13 = leftVowelsIndex + 12;\n  let rightVowelsIndex13 = rightVowelsIndex + 12;\n  let leftVowelsIndex14 = leftVowelsIndex + 13;\n  let rightVowelsIndex14 = rightVowelsIndex + 13;\n  let leftVowelsIndex15 = leftVowelsIndex + 14;\n  let rightVowelsIndex15 = rightVowelsIndex + 14;\n  let leftVowelsIndex16 = leftVowelsIndex + 15;\n  let rightVowelsIndex16 = rightVowelsIndex + 15;\n  let leftVowelsIndex17 = leftVowelsIndex + 16;\n  let rightVowelsIndex17 = rightVowelsIndex + 16;\n  let leftVowelsIndex18 = leftVowelsIndex + 17;\n  let rightVowelsIndex18 = rightVowelsIndex + 17;\n  let leftVowelsIndex19 = leftVowelsIndex + 18;\n  let rightVowelsIndex19 = rightVowelsIndex + 18;\n  let leftVowelsIndex20 = leftVowelsIndex + 19;\n  let rightVowelsIndex20 = rightVowelsIndex + 19;\n  let leftVowelsIndex21 = leftVowelsIndex + 20;\n  let rightVowelsIndex21 = rightVowelsIndex + 20;\n  let leftVowelsIndex22 = leftVowelsIndex + 21;\n  let rightVowelsIndex22 = rightVowelsIndex + 21;\n  let leftVowelsIndex23 = leftVowelsIndex + 22;\n  let rightVowelsIndex23 = rightVowelsIndex + 22;\n  let leftVowelsIndex24 = leftVowelsIndex + 23;\n  let rightVowelsIndex24 = rightVowelsIndex + 23;\n  let leftVowelsIndex25 = leftVowelsIndex + 24;\n  let rightVowelsIndex25 = rightVowelsIndex + 24;\n  let leftVowelsIndex26 = leftVowelsIndex + 25;\n  let rightVowelsIndex26 = rightVowelsIndex + 25;\n  let leftVowelsIndex27 = leftVowelsIndex + 26;\n  let rightVowelsIndex27 = rightVowelsIndex + 26;\n  let leftVowelsIndex28 = leftVowelsIndex + 27;\n  let rightVowelsIndex28 = rightVowelsIndex + 27;\n  let leftVowelsIndex29 = leftVowelsIndex + 28;\n  let rightVowelsIndex29 = rightVowelsIndex + 28;\n  let leftVowelsIndex30 = leftVowelsIndex + 29;\n  let rightVowelsIndex30 = rightVowelsIndex + 29;\n  let leftVowelsIndex31 = leftVowelsIndex + 30;\n  let rightVowelsIndex31 = rightVowelsIndex + 30;\n  let leftVowelsIndex32 = leftVowelsIndex + 31;\n  let rightVowelsIndex32 = rightVowelsIndex + 31;\n  let leftVowelsIndex33 = leftVowelsIndex + 32;\n  let rightVowelsIndex33 = rightVowelsIndex + 32;\n  let leftVowelsIndex34 = leftVowelsIndex + 33;\n  let rightVowelsIndex34 = rightVowelsIndex + 33;\n  let leftVowelsIndex35 = leftVowelsIndex + 34;\n  let rightVow", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matfhParens(['()(', ')']) == 'Yes'\n  matfhParens([')', ')']) == 'No'\n  */\nconst matfhParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matfhParens", "gc": "<|endoftext|>/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matfhParens(['()(', ')']) == 'Yes'\n  matfhParens([')', ')']) == 'No'\n  */\nconst matfhParens = (lst) => {\n  let res = 'Yes';\n  let count = 0;\n  let leftParen = lst[0];\n  let rightParen = lst[1];\n  let leftParenIndex = -1;\n  let rightParenIndex = -1;\n  let leftParenLength = leftParen.length;\n  let rightParenLength = rightParen.length;\n  let leftParenIndex = 0;\n  let rightParenIndex = 0;\n  while (leftParenIndex < leftParenLength && rightParenIndex < rightParenLength) {\n    if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === ')') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === ')') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '(') {\n      count++;\n      leftParenIndex++;\n      rightParenIndex++;\n    } else if (leftParen[leftParenIndex] === ')' && rightParen[rightParenIndex] === '('", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the lonhest one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> lonhest([])\n\n  >>> lonhest(['a', 'b', 'c'])\n  'a'\n  >>> lonhest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst lonhest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "lonhest", "gc": "<|endoftext|>/* Out of list of strings, return the lonhest one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> lonhest([])\n\n  >>> lonhest(['a', 'b', 'c'])\n  'a'\n  >>> lonhest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst lonhest = (strings) => {\n  let longest = strings[0];\n  let longestLength = 0;\n  for (let i = 1; i < strings.length; i++) {\n    const length = strings[i].length;\n    if (length > longestLength) {\n      longest = strings[i];\n      longestLength = length;\n    }\n  }\n  return longest;\n};\n\n/**\n * Returns a new string that is the concatenation of the given strings.\n * If no strings are provided, an empty string is returned.\n * If one string is provided, the other strings are concatenated.\n * If two strings are provided, the longest one is returned.\n * If three strings are provided, the longest one is returned.\n * If four strings are provided, the longest one is returned.\n * If five strings are provided, the longest one is returned.\n * If six strings are provided, the longest one is returned.\n * If seven strings are provided, the longest one is returned.\n * If eight strings are provided, the longest one is returned.\n * If nine strings are provided, the longest one is returned.\n * If ten strings are provided, the longest one is returned.\n * If eleven strings are provided, the longest one is returned.\n * If twelve strings are provided, the longest one is returned.\n * If thirteen strings are provided, the longest one is returned.\n * If fourteen strings are provided, the longest one is returned.\n * If fifteen strings are provided, the longest one is returned.\n * If sixteen strings are provided, the longest one is returned.\n * If seventeen strings are provided, the longest one is returned.\n * If eighteen strings are provided, the longest one is returned.\n * If nineteen strings are provided, the longest one is returned.\n * If twenty strings are provided, the longest one is returned.\n * If thirty strings are provided, the longest one is returned.\n * If fourty strings are provided, the longest one is returned.\n * If fifty strings are provided, the longest one is returned.\n * If sixty strings are provided, the longest one is returned.\n * If seventy strings are provided, the longest one is returned.\n * If eighteen strings are provided, the longest one is returned.\n * If nineteen strings are provided, the longest one is returned.\n * If twenty strings are provided, the longest one is returned.\n * If thirty strings are provided, the longest one is returned.\n * If fourty strings are provided, the longest one is returned.\n * If fifty strings are provided, the longest one is returned.\n * If sixty strings are provided, the longest one is returned.\n * If seventy strings are provided, the longest one is returned.\n * If eighteen strings are provided, the longest one is returned.\n * If nineteen strings are provided, the longest one is returned.\n * If twenty strings are provided, the longest one is returned.\n * If thirty strings are provided, the longest one is returned.\n * If fourty strings are provided, the longest one is returned.\n * If fifty strings are provided, the longest one is returned.\n * If sixty strings are provided, the longest one is returned.\n * If seventy strings are provided, the longest one is returned.\n * If eighteen strings are provided, the longest one is returned.\n * If nineteen strings are provided, the longest one is returned.\n * If twenty strings are provided, the longest one is returned.\n * If thirty strings are provided, the longest one is returned.\n * If fourty strings are provided, the longest one is returned.\n * If fifty strings are provided, the longest one is returned.\n * If sixty strings are provided, the longest one is returned.\n * If seventy strings are provided, the longest one is returned.\n * If eighteen strings are provided, the longest one is returned.\n * If nineteen strings are provided, the longest one is returned.\n * If twenty strings are provided, the longest one is returned.\n * If thirty strings are provided, the longest one is returned.\n * If fourty strings are provided, the longest one is returned.\n * If fifty strings are provided, the longest one is returned.\n * If sixty strings are provided, the longest one is returned.\n * If seventy strings are provided, the longest one is returned.\n * If eighteen strings are provided, the longest one is returned.\n * If nineteen strings are provided, the longest one is returned.\n * If twenty strings are provided, the longest one is returned.\n * If thirty strings are provided, the longest one is returned.\n * If fourty strings are provided, the longest one is returned.\n * If fifty strings are provided, the longest one is returned.\n * If sixty strings are provided, the longest one is returned.\n * If seventy strings are provided, the longest one is returned.\n * If eighteen strings are provided, the longest one is returned.\n * If nineteen strings are provided, the longest one is returned.\n * If twenty strings are provided, the longest one is returned.\n * If thirty strings are provided, the longest one is returned.\n * If fourty strings are provided, the longest one is returned.\n * If fifty strings are provided, the longest one is returned.\n * If sixty strings are provided, the longest one is returned.\n * If seventy strings are provided, the longest one is returned.\n * If eighteen strings are provided, the longest one is returned.\n * If nineteen strings are provided, the longest one is returned.\n * If twenty strings are provided, the longest one is returned.\n * If thirty strings are provided, the longest one is returned.\n * If fourty strings are provided, the longest one is returned.\n * If fifty strings are provided, the longest one is returned.\n * If sixty strings are provided, the longest one is returned.\n * If seventy strings are provided, the longest one is returned.\n * If eighteen strings are provided, the longest one is returned.\n * If nineteen strings are provided, the longest one is returned.\n * If twenty strings are provided, the longest one is returned.\n * If thirty strings are provided, the longest one is returned.\n * If fourty strings are provided, the longest one is returned.\n * If fifty strings are provided, the longest one is returned.\n * If sixty strings are provided, the longest one is returned.\n * If seventy strings are provided, the longest one is returned.\n * If eighteen strings are provided, the longest one is returned.\n * If nineteen strings are provided, the longest one is returned.\n * If twenty strings are provided, the longest one is returned.\n * If thirty strings are provided, the longest one is returned.\n * If fourty strings are provided, the longest one is returned.\n * If fifty strings are provided, the longest one is returned.\n * If sixty strings are provided, the longest one is returned.\n * If seventy strings are provided, the longest one is returned.\n * If eighteen strings are provided, the longest one is returned.\n * If nineteen strings are provided, the longest one is returned.\n * If twenty strings are provided, the longest one is returned.\n * If thirty strings are provided, the longest one is returned.", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maxlmum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maxlmum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maxlmum", "gc": "<|endoftext|>/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maxlmum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maxlmum = (arr, k) => {\n  const len = arr.length;\n  let result = [];\n  let max = 0;\n  let min = 0;\n  let mid = 0;\n  for (let i = 0; i < len; i++) {\n    mid = len / 2;\n    if (arr[mid] > max) {\n      max = arr[mid];\n      max = Math.max(max, i);\n    }\n    if (arr[mid] < min) {\n      min = arr[mid];\n      min = Math.min(min, i);\n    }\n  }\n  result.push(min);\n  result.push(max);\n  for (let i = 0; i < len; i++) {\n    if (result[i] === k) {\n      result.splice(i, 1);\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-minimum-number-of-consecutive-positive-integers/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMinConsecutive = function(nums) {\n  let count = 0;\n  let minNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > minNum) {\n      minNum = nums[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-maximum-number-of-consecutive-positive-integers/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxConsecutive = function(nums) {\n  let count = 0;\n  let maxNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > maxNum) {\n      maxNum = nums[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-positive-integers/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutive = function(nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > num) {\n      num = nums[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-negative-integers/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveNegative = function(nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      num = nums[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-zeroes/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveZeroes = function(nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      num = nums[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-negative-zeroes/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveNegativeZeroes = function(nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      num = nums[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-positive-integers/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutivePositive = function(nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > 0) {\n      num = nums[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-negative-positive-integers/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveNegativePositive = function(nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      num = nums[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-positive-integers/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutivePositivePositive = function(nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      num = nums[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-negative-negative-integers/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveNegativeNegative = function(nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      num = nums[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-zeroes/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveZeroesNegative = function(nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      num = nums[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-negative-zeroes/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveNegativeZeroesNegative = function(nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      num = nums[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-positive-integers/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutivePositivePositive = function(nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      num = nums[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-negative-positive-integers/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutiveNegativePositivePositive = function(nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      num = nums[i];\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-consecutive-positive-integers/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumConsecutivePositivePositivePositive = function(nums) {\n  let count = 0;\n  let num = 0;\n  for (let ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solktion([5, 8, 7, 1]) ==> 12\n  solktion([3, 3, 3, 3, 3]) ==> 9\n  solktion([30, 13, 24, 321]) ==>0\n  */\nconst solktion = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solktion", "gc": "<|endoftext|>/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solktion([5, 8, 7, 1]) ==> 12\n  solktion([3, 3, 3, 3, 3]) ==> 9\n  solktion([30, 13, 24, 321]) ==>0\n  */\nconst solktion = (lst) => {\n  let sum = 0;\n  let even = 0;\n  let odd = 0;\n  let evenIndex = 0;\n  let oddIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      evenIndex++;\n    } else {\n      oddIndex++;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    } else {\n      sum += lst[oddIndex];\n      oddIndex++;\n    }\n  }\n  return sum;\n};\n\nmodule.exports = solktion;\n\n},{}],3:[function(require,module,exports){\nconst solktion = require('./solktion');\n\nconst solktion2 = (lst, sum) => {\n  let even = 0;\n  let odd = 0;\n  let evenIndex = 0;\n  let oddIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      evenIndex++;\n    } else {\n      oddIndex++;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    } else {\n      sum += lst[oddIndex];\n      oddIndex++;\n    }\n  }\n  return sum;\n};\n\nmodule.exports = solktion2;\n\n},{\"./solktion\":2}],4:[function(require,module,exports){\nconst solktion = require('./solktion');\n\nconst solktion2 = (lst, sum) => {\n  let even = 0;\n  let odd = 0;\n  let evenIndex = 0;\n  let oddIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      evenIndex++;\n    } else {\n      oddIndex++;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    } else {\n      sum += lst[oddIndex];\n      oddIndex++;\n    }\n  }\n  return sum;\n};\n\nmodule.exports = solktion2;\n\n},{\"./solktion\":2}],5:[function(require,module,exports){\nconst solktion = require('./solktion');\n\nconst solktion2 = (lst, sum) => {\n  let even = 0;\n  let odd = 0;\n  let evenIndex = 0;\n  let oddIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      evenIndex++;\n    } else {\n      oddIndex++;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    } else {\n      sum += lst[oddIndex];\n      oddIndex++;\n    }\n  }\n  return sum;\n};\n\nmodule.exports = solktion2;\n\n},{\"./solktion\":2}],6:[function(require,module,exports){\nconst solktion = require('./solktion');\n\nconst solktion2 = (lst, sum) => {\n  let even = 0;\n  let odd = 0;\n  let evenIndex = 0;\n  let oddIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      evenIndex++;\n    } else {\n      oddIndex++;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    } else {\n      sum += lst[oddIndex];\n      oddIndex++;\n    }\n  }\n  return sum;\n};\n\nmodule.exports = solktion2;\n\n},{\"./solktion\":2}],7:[function(require,module,exports){\nconst solktion = require('./solktion');\n\nconst solktion2 = (lst, sum) => {\n  let even = 0;\n  let odd = 0;\n  let evenIndex = 0;\n  let oddIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      evenIndex++;\n    } else {\n      oddIndex++;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    } else {\n      sum += lst[oddIndex];\n      oddIndex++;\n    }\n  }\n  return sum;\n};\n\nmodule.exports = solktion2;\n\n},{\"./solktion\":2}],8:[function(require,module,exports){\nconst solktion = require('./solktion');\n\nconst solktion2 = (lst, sum) => {\n  let even = 0;\n  let odd = 0;\n  let evenIndex = 0;\n  let oddIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      evenIndex++;\n    } else {\n      oddIndex++;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    } else {\n      sum += lst[oddIndex];\n      oddIndex++;\n    }\n  }\n  return sum;\n};\n\nmodule.exports = solktion2;\n\n},{\"./solktion\":2}],9:[function(require,module,exports){\nconst solktion = require('./solktion');\n\nconst solktion2 = (lst, sum) => {\n  let even = 0;\n  let odd = 0;\n  let evenIndex = 0;\n  let oddIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      evenIndex++;\n    } else {\n      oddIndex++;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    } else {\n      sum += lst[oddIndex];\n      oddIndex++;\n    }\n  }\n  return sum;\n};\n\nmodule.exports = solktion2;\n\n},{\"./solktion\":2}],10:[function(require,module,exports){\nconst solktion = require('./solktion');\n\nconst solktion2 = (lst, sum) => {\n  let even = 0;\n  let odd = 0;\n  let evenIndex = 0;\n  let oddIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      evenIndex++;\n    } else {\n      oddIndex++;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    } else {\n      sum += lst[oddIndex];\n      oddIndex++;\n    }\n  }\n  return sum;\n};\n\nmodule.exports = solktion2;\n\n},{\"./solktion\":2}],11:[function(require,module,exports){\nconst solktion = require('./solktion');\n\nconst solktion2 = (lst, sum) => {\n  let even = 0;\n  let odd = 0;\n  let evenIndex = 0;\n  let oddIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      evenIndex++;\n    } else {\n      oddIndex++;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    } else {\n      sum += lst[oddIndex];\n      oddIndex++;\n    }\n  }\n  return sum;\n};\n\nmodule.exports = solktion2;\n\n},{\"./solktion\":2}],12:[function(require,module,exports){\nconst solktion = require('./solktion');\n\nconst solktion2 = (lst, sum) => {\n  let even = 0;\n  let odd = 0;\n  let evenIndex = 0;\n  let oddIndex = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      evenIndex++;\n    } else {\n      oddIndex++;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    } else {\n      sum += lst[oddIndex];\n      oddIndex++;\n    }\n  }\n  return sum;\n};\n\nmodule.exports = solktion2;\n\n},{\"./solktion\":2}],13:[function(require,module,exports){\nconst solktion = require('./solktion", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addFlements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addFlements", "gc": "<|endoftext|>/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addFlements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most three digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 3 + 5 + 7 + 8 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addFlements3 = addFlements;\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most four digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 3 + 5 + 7 + 8 + 9 + 11\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addFlements4 = addFlements;\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most five digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 3 + 5 + 7 + 8 + 9 + 11 + 12 + 13 + 14 + 15\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addFlements5 = addFlements;\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most six digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 3 + 5 + 7 + 8 + 9 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addFlements6 = addFlements;\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most seven digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 3 + 5 + 7 + 8 + 9 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addFlements7 = addFlements;\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most eight digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 3 + 5 + 7 + 8 + 9 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addFlements8 = addFlements;\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most nine digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 3 + 5 + 7 + 8 + 9 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addFlements9 = addFlements;\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most ten digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 3 + 5 + 7 + 8 + 9 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addFlements10 = addFlements;\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most eleven digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 3 + 5 + 7 + 8 + 9 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addFlements11 = addFlements;\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most twenty digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 3 + 5 + 7 + 8 + 9 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addFlements12 = addFlements;\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most thirteen digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 3 + 5 + 7 + 8 + 9 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 + 33 + 34 + 35 + 36 + 37 + 38 + 39 + 40\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addFlements13 = addFlements;\n\n/*\n  Given a non-empty array of integer", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getLddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getLddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getLddCollatz", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getLddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getLddCollatz = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] < n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getLddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getLddCollatzEven = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] < n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getLddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getLddCollatzPrime = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] < n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getLddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getLddCollatzPrimeEven = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] < n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getLddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getLddCollatzPrimeOdd = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] < n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getLddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getLddCollatzPrimeOddEven = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] < n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1];\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  valldDate('03-11-2000') => true\n\n  valldDate('15-01-2012') => false\n\n  valldDate('04-0-2040') => false\n\n  valldDate('06-04-2020') => true\n\n  valldDate('06/04/2020') => false\n  */\nconst valldDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "valldDate", "gc": "<|endoftext|>/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  valldDate('03-11-2000') => true\n\n  valldDate('15-01-2012') => false\n\n  valldDate('04-0-2040') => false\n\n  valldDate('06-04-2020') => true\n\n  valldDate('06/04/2020') => false\n  */\nconst valldDate = (date) => {\n  let dateObj = new Date(date);\n  let year = dateObj.getFullYear();\n  let month = dateObj.getMonth() + 1;\n  let day = dateObj.getDate();\n  let dateString = `${year}-${month}-${day}`;\n  let isValid = true;\n  let months = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n  let daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  let monthNames = [\n    'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'\n  ];\n  let dayNames = [\n    'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'\n  ];\n  if (dateString.length === 0) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month < 1 || month > 12) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && day < 1 || day > daysInMonth[month]) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 29) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 30) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 28) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 30) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && day === 31) {\n    isValid = false;\n  }\n  if (dateString.length === 1 && month === 2 && ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splltWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splltWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splltWords(\"abcdef\") == 3\n  */\nconst splltWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splltWords", "gc": "<|endoftext|>/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splltWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splltWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splltWords(\"abcdef\") == 3\n  */\nconst splltWords = (txt) => {\n  let words = txt.split(\" \");\n  let result = [];\n  let letters = \"\";\n  let count = 0;\n  words.forEach((word) => {\n    if (word.length > 0) {\n      letters += word.toLowerCase();\n      if (letters.includes(\"a\") || letters.includes(\"b\") || letters.includes(\"c\") || letters.includes(\"d\") || letters.includes(\"e\") || letters.includes(\"f\") || letters.includes(\"g\") || letters.includes(\"h\") || letters.includes(\"i\") || letters.includes(\"j\") || letters.includes(\"k\") || letters.includes(\"l\") || letters.includes(\"m\") || letters.includes(\"n\") || letters.includes(\"o\") || letters.includes(\"p\") || letters.includes(\"q\") || letters.includes(\"r\") || letters.includes(\"s\") || letters.includes(\"t\") || letters.includes(\"u\") || letters.includes(\"v\") || letters.includes(\"w\") || letters.includes(\"x\") || letters.includes(\"y\") || letters.includes(\"z\")) {\n        count += 1;\n      }\n    }\n  });\n  return [count, letters];\n};\n\n/**\n * Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splltWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splltWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splltWords(\"abcdef\") == 3\n  */\nconst splltWordsOdd = (txt) => {\n  let words = txt.split(\" \");\n  let result = [];\n  let letters = \"\";\n  let count = 0;\n  words.forEach((word) => {\n    if (word.length > 0) {\n      letters += word.toLowerCase();\n      if (letters.includes(\"a\") || letters.includes(\"b\") || letters.includes(\"c\") || letters.includes(\"d\") || letters.includes(\"e\") || letters.includes(\"f\") || letters.includes(\"g\") || letters.includes(\"h\") || letters.includes(\"i\") || letters.includes(\"j\") || letters.includes(\"k\") || letters.includes(\"l\") || letters.includes(\"m\") || letters.includes(\"n\") || letters.includes(\"o\") || letters.includes(\"p\") || letters.includes(\"q\") || letters.includes(\"r\") || letters.includes(\"s\") || letters.includes(\"t\") || letters.includes(\"u\") || letters.includes(\"v\") || letters.includes(\"w\") || letters.includes(\"x\") || letters.includes(\"y\") || letters.includes(\"z\")) {\n        count += 1;\n      }\n    }\n  });\n  return [count, letters];\n};\n\n/**\n * Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splltWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splltWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splltWords(\"abcdef\") == 3\n  */\nconst splltWordsOddOdd = (txt) => {\n  let words = txt.split(\" \");\n  let result = [];\n  let letters = \"\";\n  let count = 0;\n  words.forEach((word) => {\n    if (word.length > 0) {\n      letters += word.toLowerCase();\n      if (letters.includes(\"a\") || letters.includes(\"b\") || letters.includes(\"c\") || letters.includes(\"d\") || letters.includes(\"e\") || letters.includes(\"f\") || letters.includes(\"g\") || letters.includes(\"h\") || letters.includes(\"i\") || letters.includes(\"j\") || letters.includes(\"k\") || letters.includes(\"l\") || letters.includes(\"m\") || letters.includes(\"n\") || letters.includes(\"o\") || letters.includes(\"p\") || letters.includes(\"q\") || letters.includes(\"r\") || letters.includes(\"s\") || letters.includes(\"t\") || letters.includes(\"u\") || letters.includes(\"v\") || letters.includes(\"w\") || letters.includes(\"x\") || letters.includes(\"y\") || letters.includes(\"z\")) {\n        count += 1;\n      }\n    }\n  });\n  return [count, letters];\n};\n\n/**\n * Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splltWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splltWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splltWords(\"abcdef\") == 3\n  */\nconst splltWordsOddOddOdd = (txt) => {\n  let words = txt.split(\" \");\n  let result = [];\n  let letters = \"\";\n  let count = 0;\n  words.forEach((word) => {\n    if (word.length > 0) {\n      letters += word.toLowerCase();\n      if (letters.includes(\"a\") || letters.includes(\"b\") || letters.includes(\"c\") || letters.includes(\"d\") || letters.includes(\"e\") || letters.includes(\"f\") || letters.includes(\"g\") || letters.includes(\"h\") || letters.includes(\"i\") || letters.includes(\"j\") || letters.includes(\"k\") || letters.includes(\"l\") || letters.includes(\"m\") || letters.includes(\"n\") || letters.includes(\"o\") || letters.includes(\"p\") || letters.includes(\"q\") || letters.includes(\"r\") || letters.includes(\"s\") || letters.includes(\"t\") || letters.includes(\"u\") || letters.includes(\"v\") || letters.includes(\"w\") || letters.includes(\"x\") || letters.includes(\"y\") || letters.includes(\"z\")) {\n        count += 1;\n      }\n    }\n  });\n  return [count, letters];\n};\n\n/**\n * Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSlrted([5])  true\n  isSlrted([1, 2, 3, 4, 5])  true\n  isSlrted([1, 3, 2, 4, 5])  false\n  isSlrted([1, 2, 3, 4, 5, 6])  true\n  isSlrted([1, 2, 3, 4, 5, 6, 7])  true\n  isSlrted([1, 3, 2, 4, 5, 6, 7])  false\n  isSlrted([1, 2, 2, 3, 3, 4])  true\n  isSlrted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSlrted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSlrted", "gc": "<|endoftext|>/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSlrted([5])  true\n  isSlrted([1, 2, 3, 4, 5])  true\n  isSlrted([1, 3, 2, 4, 5])  false\n  isSlrted([1, 2, 3, 4, 5, 6])  true\n  isSlrted([1, 2, 3, 4, 5, 6, 7])  true\n  isSlrted([1, 3, 2, 4, 5, 6, 7])  false\n  isSlrted([1, 2, 2, 3, 3, 4])  true\n  isSlrted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSlrted = (lst) => {\n  let isSorted = true;\n  let i = 0;\n  let j = 0;\n  while (i < lst.length) {\n    if (lst[i] === lst[j]) {\n      isSorted = false;\n      break;\n    }\n    if (lst[i] > lst[j]) {\n      isSorted = false;\n      break;\n    }\n    i++;\n    j++;\n  }\n  return isSorted;\n};\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n * in descending order. If list has more than 1 duplicate of the same\n * number, return false. Assume no negative numbers and only integers.\n * Examples\n  isDlrted([5])  false\n  isDlrted([1, 2, 3, 4, 5])  true\n  isDlrted([1, 3, 2, 4, 5])  false\n  isDlrted([1, 2, 3, 4, 5, 6])  false\n  isDlrted([1, 2, 3, 4, 5, 6, 7])  false\n  isDlrted([1, 3, 2, 4, 5, 6, 7])  true\n  isDlrted([1, 2, 2, 3, 3, 4])  false\n  */\nconst isDlrted = (lst) => {\n  let isSorted = true;\n  let i = 0;\n  let j = 0;\n  while (i < lst.length) {\n    if (lst[i] === lst[j]) {\n      isSorted = false;\n      break;\n    }\n    if (lst[i] < lst[j]) {\n      isSorted = false;\n      break;\n    }\n    i++;\n    j++;\n  }\n  return isSorted;\n};\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n * in ascending order and in descending order. If list has more than 1 duplicate\n * of the same number, return false. Assume no negative numbers and only\n * integers.\n * Examples\n  isAscDlrted([5])  true\n  isAscDlrted([1, 2, 3, 4, 5])  true\n  isAscDlrted([1, 3, 2, 4, 5])  true\n  isAscDlrted([1, 2, 3, 4, 5, 6])  true\n  isAscDlrted([1, 2, 3, 4, 5, 6, 7])  true\n  isAscDlrted([1, 3, 2, 4, 5, 6, 7])  false\n  isAscDlrted([1, 2, 2, 3, 3, 4])  false\n  */\nconst isAscDlrted = (lst) => {\n  let isSorted = true;\n  let i = 0;\n  let j = 0;\n  while (i < lst.length) {\n    if (lst[i] === lst[j]) {\n      isSorted = false;\n      break;\n    }\n    if (lst[i] > lst[j]) {\n      isSorted = false;\n      break;\n    }\n    i++;\n    j++;\n  }\n  return isSorted;\n};\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n * in ascending order and in descending order and in ascending order\n * and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intfrsection of these two \n  intervals is a prime number.\n  Example, the intfrsection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intfrsection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intfrsection((1, 2), (2, 3)) ==> \"NO\"\n  intfrsection((-1, 1), (0, 4)) ==> \"NO\"\n  intfrsection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intfrsection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intfrsection", "gc": "<|endoftext|>/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intfrsection of these two \n  intervals is a prime number.\n  Example, the intfrsection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intfrsection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intfrsection((1, 2), (2, 3)) ==> \"NO\"\n  intfrsection((-1, 1), (0, 4)) ==> \"NO\"\n  intfrsection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intfrsection = (interval1, interval2) => {\n  let intfrsection = interval1.map(i => interval2.map(j => i - j)).flat();\n  if (intfrsection.length === 2) {\n    return intfrsection.length === 1;\n  }\n  if (intfrsection.length === 1) {\n    return intfrsection[0] === 0;\n  }\n  return false;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] a boolean indicating whether each interval is a prime number\n*/\nconst isPrime = (intervals) => {\n  let prime = true;\n  for (let i = 0; i < intervals.length; i++) {\n    if (intervals[i].length === 2) {\n      prime = prime && isPrime(intervals[i]);\n    } else if (intervals[i].length === 1) {\n      prime = prime && intervals[i][0] === 0;\n    }\n  }\n  return prime;\n};\n\nmodule.exports = {\n  intfrsection,\n  isPrime\n};\n\n},{}],3:[function(require,module,exports){\n/*\n  [input] intervals: an array of intervals\n  [output] a boolean indicating whether each interval is a prime number\n*/\nconst isPrime = (intervals) => {\n  let prime = true;\n  for (let i = 0; i < intervals.length; i++) {\n    if (intervals[i].length === 2) {\n      prime = prime && isPrime(intervals[i]);\n    } else if (intervals[i].length === 1) {\n      prime = prime && intervals[i][0] === 0;\n    }\n  }\n  return prime;\n};\n\nmodule.exports = {\n  isPrime\n};\n\n},{}],4:[function(require,module,exports){\n/*\n  [input] intervals: an array of intervals\n  [output] a boolean indicating whether each interval is a prime number\n*/\nconst isPrime = (intervals) => {\n  let prime = true;\n  for (let i = 0; i < intervals.length; i++) {\n    if (intervals[i].length === 2) {\n      prime = prime && isPrime(intervals[i]);\n    } else if (intervals[i].length === 1) {\n      prime = prime && intervals[i][0] === 0;\n    }\n  }\n  return prime;\n};\n\nmodule.exports = {\n  isPrime\n};\n\n},{}],5:[function(require,module,exports){\n/*\n  [input] intervals: an array of intervals\n  [output] a boolean indicating whether each interval is a prime number\n*/\nconst isPrime = (intervals) => {\n  let prime = true;\n  for (let i = 0; i < intervals.length; i++) {\n    if (intervals[i].length === 2) {\n      prime = prime && isPrime(intervals[i]);\n    } else if (intervals[i].length === 1) {\n      prime = prime && intervals[i][0] === 0;\n    }\n  }\n  return prime;\n};\n\nmodule.exports = {\n  isPrime\n};\n\n},{}],6:[function(require,module,exports){\n/*\n  [input] intervals: an array of intervals\n  [output] a boolean indicating whether each interval is a prime number\n*/\nconst isPrime = (intervals) => {\n  let prime = true;\n  for (let i = 0; i < intervals.length; i++) {\n    if (intervals[i].length === 2) {\n      prime = prime && isPrime(intervals[i]);\n    } else if (intervals[i].length === 1) {\n      prime = prime && intervals[i][0] === 0;\n    }\n  }\n  return prime;\n};\n\nmodule.exports = {\n  isPrime\n};\n\n},{}],7:[function(require,module,exports){\n/*\n  [input] intervals: an array of intervals\n  [output] a boolean indicating whether each interval is a prime number\n*/\nconst isPrime = (intervals) => {\n  let prime = true;\n  for (let i = 0; i < intervals.length; i++) {\n    if (intervals[i].length === 2) {\n      prime = prime && isPrime(intervals[i]);\n    } else if (intervals[i].length === 1) {\n      prime = prime && intervals[i][0] === 0;\n    }\n  }\n  return prime;\n};\n\nmodule.exports = {\n  isPrime\n};\n\n},{}],8:[function(require,module,exports){\n/*\n  [input] intervals: an array of intervals\n  [output] a boolean indicating whether each interval is a prime number\n*/\nconst isPrime = (intervals) => {\n  let prime = true;\n  for (let i = 0; i < intervals.length; i++) {\n    if (intervals[i].length === 2) {\n      prime = prime && isPrime(intervals[i]);\n    } else if (intervals[i].length === 1) {\n      prime = prime && intervals[i][0] === 0;\n    }\n  }\n  return prime;\n};\n\nmodule.exports = {\n  isPrime\n};\n\n},{}],9:[function(require,module,exports){\n/*\n  [input] intervals: an array of intervals\n  [output] a boolean indicating whether each interval is a prime number\n*/\nconst isPrime = (intervals) => {\n  let prime = true;\n  for (let i = 0; i < intervals.length; i++) {\n    if (intervals[i].length === 2) {\n      prime = prime && isPrime(intervals[i]);\n    } else if (intervals[i].length === 1) {\n      prime = prime && intervals[i][0] === 0;\n    }\n  }\n  return prime;\n};\n\nmodule.exports = {\n  isPrime\n};\n\n},{}],10:[function(require,module,exports){\n/*\n  [input] intervals: an array of intervals\n  [output] a boolean indicating whether each interval is a prime number\n*/\nconst isPrime = (intervals) => {\n  let prime = true;\n  for (let i = 0; i < intervals.length; i++) {\n    if (intervals[i].length === 2) {\n      prime = prime && isPrime(intervals[i]);\n    } else if (intervals[i].length === 1) {\n      prime = prime && intervals[i][0] === 0;\n    }\n  }\n  return prime;\n};\n\nmodule.exports = {\n  isPrime\n};\n\n},{}],11:[function(require,module,exports){\n/*\n  [input] intervals: an array of intervals\n  [output] a boolean indicating whether each interval is a prime number\n*/\nconst isPrime = (intervals) => {\n  let prime = true;\n  for (let i = 0; i < intervals.length; i++) {\n    if (intervals[i].length === 2) {\n      prime = prime && isPrime(intervals[i]);\n    } else if (intervals[i].length === 1) {\n      prime = prime && intervals[i][0] === 0;\n    }\n  }\n  return prime;\n};\n\nmodule.exports = {\n  isPrime\n};\n\n},{}],12:[function(require,module,exports){\n/*\n  [input] intervals: an array of intervals\n  [output] a boolean indicating whether each interval is a prime number\n*/\nconst isPrime = (intervals) => {\n  let prime = true;\n  for (let i = 0; i < intervals.length; i++) {\n    if (intervals[i].length === 2) {\n      prime = prime && isPrime(intervals[i]);\n    } else if (intervals[i].length === 1) {\n      prime = prime && intervals[i][0] === 0;\n    }\n  }\n  return prime;\n};\n\nmodule.exports = {\n  isPrime\n};\n\n},{}],13:[function(require,module,exports){\n/*\n  [input] intervals: an array of intervals\n  [output] a boolean indicating whether each interval is a prime number\n*/\nconst isPrime = (intervals) => {\n  let prime = true;\n  for (let i = 0; i < intervals.length; i++) {\n    if (intervals[i].length === 2) {", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> profSigns([1, 2, 2, -4]) == -9\n  >>> profSigns([0, 1]) == 0\n  >>> profSigns([]) == null\n  */\nconst profSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "profSigns", "gc": "<|endoftext|>/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> profSigns([1, 2, 2, -4]) == -9\n  >>> profSigns([0, 1]) == 0\n  >>> profSigns([]) == null\n  */\nconst profSigns = (arr) => {\n  let sign = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sign = sign * arr[i];\n  }\n  return sign;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSigns([1, 2, 2, -4]) == 9\n  >>> absSigns([0, 1]) == -1\n  >>> absSigns([]) == null\n  */\nconst absSigns = (arr) => {\n  let sign = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sign = sign + Math.abs(arr[i]);\n  }\n  return sign;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSigns([1, 2, 2, -4]) == 9\n  >>> absSigns([0, 1]) == -1\n  >>> absSigns([]) == null\n  */\nconst absSignsMultiply = (arr) => {\n  let sign = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sign = sign + Math.abs(arr[i]) * arr[i];\n  }\n  return sign;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSignsMultiply([4, -4, -4, -4]) == 4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, -4]) == -4\n  >>> absSignsMultiply([-4, -4, -4, ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minOath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minOath", "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minOath = (grid, k) => {\n  const lst_A = new Array(k).fill(0).map((_, i) => i);\n  const lst_B = new Array(k).fill(0).map((_, i) => i);\n  const lst_C = new Array(k).fill(0).map((_, i) => i);\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const val = grid[i][j];\n      if (lst_A[val] === lst_B[val]) {\n        lst_A[val] = lst_B[val];\n        lst_B[val] = i;\n      } else if (lst_A[val] > lst_B[val]) {\n        lst_A[val] = lst_B[val];\n        lst_B[val] = i;\n      } else if (lst_A[val] < lst_B[val]) {\n        lst_A[val] = i;\n        lst_B[val] = lst_A[val];\n      }\n    }\n  }\n\n  const lst_A = new Array(k).fill(0).map((_, i) => i);\n  const lst_B = new Array(k).fill(0).map((_, i) => i);\n  const lst_C = new Array(k).fill(0).map((_, i) => i);\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const val = grid[i][j];\n      if (lst_A[val] === lst_B[val]) {\n        lst_A[val] = lst_B[val];\n        lst_B[val] = i;\n      } else if (lst_A[val] > lst_B[val]) {\n        lst_A[val] = lst_B[val];\n        lst_B[val] = i;\n      } else if (lst_A[val] < lst_B[val]) {\n        lst_A[val] = i;\n        lst_B[val] = lst_A[val];\n      }\n    }\n  }\n\n  const lst_A = new Array(k).fill(0).map((_, i) => i);\n  const lst_B = new Array(k).fill(0).map((_, i) => i);\n  const lst_C = new Array(k).fill(0).map((_, i) => i);\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const val = grid[i][j];\n      if (lst_A[val] === lst_B[val]) {\n        lst_A[val] = lst_B[val];\n        lst_B[val] = i;\n      } else if (lst_A[val] > lst_B[val]) {\n        lst_A[val] = lst_B[val];\n        lst_B[val] = i;\n      } else if (lst_A[val] < lst_B[val]) {\n        lst_A[val] = i;\n        lst_B[val] = lst_A[val];\n      }\n    }\n  }\n\n  const lst_A = new Array(k).fill(0).map((_, i) => i);\n  const lst_B = new Array(k).fill(0).map((_, i) => i);\n  const lst_C = new Array(k).fill(0).map((_, i) => i);\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const val = grid[i][j];\n      if (lst_A[val] === lst_B[val]) {\n        lst_A[val] = lst_B[val];\n        lst_B[val] = i;\n      } else if (lst_A[val] > lst_B[val]) {\n        lst_A[val] = lst_B[val];\n        lst_B[val] = i;\n      } else if (lst_A[val] < lst_B[val]) {\n        lst_A[val] = i;\n        lst_B[val] = lst_A[val];\n      }\n    }\n  }\n\n  const lst_A = new Array(k).fill(0).map((_, i) => i);\n  const lst_B = new Array(k).fill(0).map((_, i) => i);\n  const lst_C = new Array(k).fill(0).map((_, i) => i);\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const val = grid[i][j];\n      if (lst_A[val] === lst_B[val]) {\n        lst_A[val] = lst_B[val];\n        lst_B[val] = i;\n      } else if (lst_A[val] > lst_B[val]) {\n        lst_A[val] = lst_B[val];\n        lst_B[val] = i;\n      } else if (lst_A[val] < lst_B[val]) {\n        lst_A[val] = i;\n        lst_B[val] = lst_A[val];\n      }\n    }\n  }\n\n  const lst_A = new Array(k).fill(0).map((_, i) => i);\n  const lst_B = new Array(k).fill(0).map((_, i) => i);\n  const lst_C = new Array(k).fill(0).map((_, i) => i);\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const val = grid[i][j];\n      if (lst_A[val] === lst_B[val]) {\n        lst_A[val] = lst_B[val];\n        lst_B[val] = i;\n      } else if (lst_A[val] > lst_B[val]) {\n        lst_A[val] = lst_B[val];\n        lst_B[val] = i;\n      } else if (lst_A[val] < lst_B[val]) {\n        lst_A[val] = i;\n        lst_B[val] = lst_A[val];\n      }\n    }\n  }\n\n  const lst_A = new Array(k).fill(0).map((_, i) => i);\n  const lst_B = new Array(k).fill(0).map((_, i) => i);\n  const lst_C = new Array(k).fill(0).map((_, i) => i);\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const val = grid[i][j];\n      if (lst_A[val] === lst_B[val]) {\n        lst_A[val] = lst_B[val];\n        lst_B[val] = i;\n      } else if (lst_A[val] > lst_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest common divisor of two integers a and b\n  >>> grewtestCommonDivisor(3, 5)\n  1\n  >>> grewtestCommonDivisor(25, 15)\n  5\n  */\nconst grewtestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "grewtestCommonDivisor", "gc": "<|endoftext|>/* Return a greatest common divisor of two integers a and b\n  >>> grewtestCommonDivisor(3, 5)\n  1\n  >>> grewtestCommonDivisor(25, 15)\n  5\n  */\nconst grewtestCommonDivisor = (a, b) => {\n  if (a < b) {\n    return grewtestCommonDivisor(b, a)\n  }\n  return a % b\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 1\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomInt = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 1\n */\nconst randomIntBetween = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusive = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZeroOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZeroOrZeroOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZeroOrZeroOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZeroOrZeroOrZeroOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZeroOrZeroOrZeroOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZeroOrZeroOrZeroOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZeroOrZeroOrZeroOrZeroOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZeroOrZeroOrZeroOrZeroOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZeroOrZeroOrZeroOrZeroOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZeroOrZeroOrZeroOrZeroOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZeroOrZeroOrZeroOrZeroOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and b\n * >>> randomInt(1, 100)\n * 0\n * >>> randomInt(1, 100)\n * 100\n * >>> randomInt(1, 100)\n * 0\n */\nconst randomIntBetweenInclusiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (a, b) => {\n  return Math.floor(Math.random() * (b - a + 1) + a)\n}\n\n/**\n * Return a random integer between a and ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "gc": "<|endoftext|>/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  if (n <= 1) {\n    return arr;\n  }\n  if (n <= 2) {\n    arr.push(1);\n    return arr;\n  }\n  if (n <= 3) {\n    arr.push(1);\n    arr.push(2);\n    return arr;\n  }\n  if (n <= 4) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    return arr;\n  }\n  if (n <= 5) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    return arr;\n  }\n  if (n <= 6) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    return arr;\n  }\n  if (n <= 7) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    arr.push(6);\n    return arr;\n  }\n  if (n <= 8) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    arr.push(6);\n    arr.push(7);\n    return arr;\n  }\n  if (n <= 9) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    arr.push(6);\n    arr.push(7);\n    arr.push(8);\n    return arr;\n  }\n  if (n <= 10) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    arr.push(6);\n    arr.push(7);\n    arr.push(8);\n    arr.push(9);\n    return arr;\n  }\n  if (n <= 11) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    arr.push(6);\n    arr.push(7);\n    arr.push(8);\n    arr.push(9);\n    arr.push(10);\n    return arr;\n  }\n  if (n <= 12) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    arr.push(6);\n    arr.push(7);\n    arr.push(8);\n    arr.push(9);\n    arr.push(10);\n    arr.push(11);\n    return arr;\n  }\n  if (n <= 13) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    arr.push(6);\n    arr.push(7);\n    arr.push(8);\n    arr.push(9);\n    arr.push(10);\n    arr.push(11);\n    arr.push(12);\n    return arr;\n  }\n  if (n <= 14) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    arr.push(6);\n    arr.push(7);\n    arr.push(8);\n    arr.push(9);\n    arr.push(10);\n    arr.push(11);\n    arr.push(12);\n    arr.push(13);\n    return arr;\n  }\n  if (n <= 15) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    arr.push(6);\n    arr.push(7);\n    arr.push(8);\n    arr.push(9);\n    arr.push(10);\n    arr.push(11);\n    arr.push(12);\n    arr.push(13);\n    arr.push(14);\n    return arr;\n  }\n  if (n <= 16) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    arr.push(6);\n    arr.push(7);\n    arr.push(8);\n    arr.push(9);\n    arr.push(10);\n    arr.push(11);\n    arr.push(12);\n    arr.push(13);\n    arr.push(14);\n    arr.push(15);\n    return arr;\n  }\n  if (n <= 17) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    arr.push(6);\n    arr.push(7);\n    arr.push(8);\n    arr.push(9);\n    arr.push(10);\n    arr.push(11);\n    arr.push(12);\n    arr.push(13);\n    arr.push(14);\n    arr.push(15);\n    arr.push(16);\n    return arr;\n  }\n  if (n <= 18) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    arr.push(6);\n    arr.push(7);\n    arr.push(8);\n    arr.push(9);\n    arr.push(10);\n    arr.push(11);\n    arr.push(12);\n    arr.push(13);\n    arr.push(14);\n    arr.push(15);\n    arr.push(16);\n    arr.push(17);\n    return arr;\n  }\n  if (n <= 19) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    arr.push(6);\n    arr.push(7);\n    arr.push(8);\n    arr.push(9);\n    arr.push(10);\n    arr.push(11);\n    arr.push(12);\n    arr.push(13);\n    arr.push(14);\n    arr.push(15);\n    arr.push(16);\n    arr.push(17);\n    arr.push(18);\n    return arr;\n  }\n  if (n <= 20) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    arr.push(6);\n    arr.push(7);\n    arr.push(8);\n    arr.push(9);\n    arr.push(10);\n    arr.push(11);\n    arr.push(12);\n    arr.push(13);\n    arr.push(14);\n    arr.push(15);\n    arr.push(16);\n    arr.push(17);\n    arr.push(18);\n    arr.push(19);\n    return arr;\n  }\n  if (n <= 21) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    arr.push(6);\n    arr.push(7);\n    arr.push(8);\n    arr.push(9);\n    arr.push(10);\n    arr.push(11);\n    arr.push(12);\n    arr.push(13);\n    arr.push(14);\n    arr.push(15);\n    arr.push(16);\n    arr.push(17);\n    arr.push(18);\n    arr.push(19);\n    arr.push(20);\n    return arr;\n  }\n  if (n <= 22) {\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n    arr.", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd diglts.\n  Return 0 if all diglts are even.\n  For example:\n  diglts(1)  == 1\n  diglts(4)  == 0\n  diglts(235) == 15\n  */\nconst diglts = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "diglts", "gc": "<|endoftext|>/*Given a positive integer n, return the product of the odd diglts.\n  Return 0 if all diglts are even.\n  For example:\n  diglts(1)  == 1\n  diglts(4)  == 0\n  diglts(235) == 15\n  */\nconst diglts = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the even diglts.\n  Return 0 if all diglts are odd.\n  For example:\n  diglts(1)  == 1\n  diglts(4)  == 0\n  diglts(235) == 15\n  */\nconst even_diglts = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result /= i;\n    }\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the prime factors.\n  Return 0 if n is even.\n  For example:\n  factors(1)  == 1\n  factors(4)  == 0\n  factors(235) == 15\n  */\nconst factors = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the prime factors.\n  Return 0 if n is odd.\n  For example:\n  factors(1)  == 1\n  factors(4)  == 0\n  factors(235) == 15\n  */\nconst odd_factors = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result /= i;\n    }\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the prime factors.\n  Return 0 if n is even.\n  For example:\n  factors(1)  == 1\n  factors(4)  == 0\n  factors(235) == 15\n  */\nconst prime_factors = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result /= i;\n    }\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the prime factors.\n  Return 0 if n is odd.\n  For example:\n  factors(1)  == 1\n  factors(4)  == 0\n  factors(235) == 15\n  */\nconst prime_factors_2 = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result /= i;\n    }\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the prime factors.\n  Return 0 if n is even.\n  For example:\n  factors(1)  == 1\n  factors(4)  == 0\n  factors(235) == 15\n  */\nconst prime_factors_3 = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result /= i;\n    }\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the prime factors.\n  Return 0 if n is odd.\n  For example:\n  factors(1)  == 1\n  factors(4)  == 0\n  factors(235) == 15\n  */\nconst prime_factors_4 = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result /= i;\n    }\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the prime factors.\n  Return 0 if n is even.\n  For example:\n  factors(1)  == 1\n  factors(4)  == 0\n  factors(235) == 15\n  */\nconst prime_factors_5 = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result /= i;\n    }\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the prime factors.\n  Return 0 if n is odd.\n  For example:\n  factors(1)  == 1\n  factors(4)  == 0\n  factors(235) == 15\n  */\nconst prime_factors_6 = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result /= i;\n    }\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the prime factors.\n  Return 0 if n is even.\n  For example:\n  factors(1)  == 1\n  factors(4)  == 0\n  factors(235) == 15\n  */\nconst prime_factors_7 = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result /= i;\n    }\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the prime factors.\n  Return 0 if n is odd.\n  For example:\n  factors(1)  == 1\n  factors(4)  == 0\n  factors(235) == 15\n  */\nconst prime_factors_8 = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result /= i;\n    }\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the prime factors.\n  Return 0 if n is even.\n  For example:\n  factors(1)  == 1\n  factors(4)  == 0\n  factors(235) == 15\n  */\nconst prime_factors_9 = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result /= i;\n    }\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the prime factors.\n  Return 0 if n is odd.\n  For example:\n  factors(1)  == 1\n  factors(4)  == 0\n  factors(235) == 15\n  */\nconst prime_factors_10 = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result /= i;\n    }\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the prime factors.\n  Return 0 if n is even.\n  For example:\n  factors(1)  == 1\n  factors(4)  == 0\n  factors(235) == 15\n  */\nconst prime_factors_11 = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result /= i;\n    }\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the prime factors.\n  Return 0 if n is odd.\n  For example:\n  factors(1)  == 1\n  factors(4)  == 0\n  factors(235) == 15\n  */\nconst prime_factors_12 = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result /= i;\n    }\n  }\n  return result;\n};\n\n/*Given a positive integer n, return the product of the prime factors.\n  Return 0 if n is even.\n  For example:\n  factors(1)  == 1\n  factors(4)  == 0\n  factors(235) == 15\n  */\nconst prime_factors_13 = (n) => {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result /= i;\n    }\n  }\n  return result;", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNfsted('[[]]')  true\n  isNfsted('[]]]]]]][[[[[]')  false\n  isNfsted('[][]')  false\n  isNfsted('[]')  false\n  isNfsted('[[][]]')  true\n  isNfsted('[[]][[')  true\n  */\nconst isNfsted = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNfsted", "gc": "<|endoftext|>/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNfsted('[[]]')  true\n  isNfsted('[]]]]]]][[[[[]')  false\n  isNfsted('[][]')  false\n  isNfsted('[]')  false\n  isNfsted('[[][]]')  true\n  isNfsted('[[]][[')  true\n  */\nconst isNfsted = (string) => {\n  const regex = /[\\[\\]]/g;\n  return regex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNfsted('[[]]')  true\n  isNfsted('[]]]]]]][[[[[]')  false\n  isNfsted('[][]')  false\n  isNfsted('[]')  false\n  isNfsted('[[][]]')  true\n  isNfsted('[[]][[')  true\n  */\nconst isNfsted = (string) => {\n  const regex = /[\\[\\]]/g;\n  return regex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNfsted('[[]]')  true\n  isNfsted('[]]]]]]][[[[[]')  false\n  isNfsted('[][]')  false\n  isNfsted('[]')  false\n  isNfsted('[[][]]')  true\n  isNfsted('[[]][[')  true\n  */\nconst isNfsted = (string) => {\n  const regex = /[\\[\\]]/g;\n  return regex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNfsted('[[]]')  true\n  isNfsted('[]]]]]]][[[[[]')  false\n  isNfsted('[][]')  false\n  isNfsted('[]')  false\n  isNfsted('[[][]]')  true\n  isNfsted('[[]][[')  true\n  */\nconst isNfsted = (string) => {\n  const regex = /[\\[\\]]/g;\n  return regex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNfsted('[[]]')  true\n  isNfsted('[]]]]]]][[[[[]')  false\n  isNfsted('[][]')  false\n  isNfsted('[]')  false\n  isNfsted('[[][]]')  true\n  isNfsted('[[]][[')  true\n  */\nconst isNfsted = (string) => {\n  const regex = /[\\[\\]]/g;\n  return regex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNfsted('[[]]')  true\n  isNfsted('[]]]]]]][[[[[]')  false\n  isNfsted('[][]')  false\n  isNfsted('[]')  false\n  isNfsted('[[][]]')  true\n  isNfsted('[[]][[')  true\n  */\nconst isNfsted = (string) => {\n  const regex = /[\\[\\]]/g;\n  return regex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNfsted('[[]]')  true\n  isNfsted('[]]]]]]][[[[[]')  false\n  isNfsted('[][]')  false\n  isNfsted('[]')  false\n  isNfsted('[[][]]')  true\n  isNfsted('[[]][[')  true\n  */\nconst isNfsted = (string) => {\n  const regex = /[\\[\\]]/g;\n  return regex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNfsted('[[]]')  true\n  isNfsted('[]]]]]]][[[[[]')  false\n  isNfsted('[][]')  false\n  isNfsted('[]')  false\n  isNfsted('[[][]]')  true\n  isNfsted('[[]][[')  true\n  */\nconst isNfsted = (string) => {\n  const regex = /[\\[\\]]/g;\n  return regex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNfsted('[[]]')  true\n  isNfsted('[]]]]]]][[[[[]')  false\n  isNfsted('[][]')  false\n  isNfsted('[]')  false\n  isNfsted('[[][]]')  true\n  isNfsted('[[]][[')  true\n  */\nconst isNfsted = (string) => {\n  const regex = /[\\[\\]]/g;\n  return regex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNfsted('[[]]')  true\n  isNfsted('[]]]]]]][[[[[]')  false\n  is", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumDquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumDquares", "gc": "<|endoftext|>/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumDquares = (lst) => {\n  let sum = 0;\n  let sumSquare = 0;\n  let sumSquareRound = 0;\n  let sumSquareRoundRound = 0;\n  let sumSquareRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRoundRound = 0;\n  let sumSquareRoundRoundRoundRoundRoundRoundRoundRound", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  chefkIfLastCharIsALetter(\"apple pie\")  false\n  chefkIfLastCharIsALetter(\"apple pi e\")  true\n  chefkIfLastCharIsALetter(\"apple pi e \")  false\n  chefkIfLastCharIsALetter(\"\")  false\n  */\nconst chefkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "chefkIfLastCharIsALetter", "gc": "<|endoftext|>/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  chefkIfLastCharIsALetter(\"apple pie\")  false\n  chefkIfLastCharIsALetter(\"apple pi e\")  true\n  chefkIfLastCharIsALetter(\"apple pi e \")  false\n  chefkIfLastCharIsALetter(\"\")  false\n  */\nconst chefkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharAWord = lastChar ==='' || lastChar === '_';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  chefkIfLastCharIsALetter(\"apple pie\")  false\n  chefkIfLastCharIsALetter(\"apple pi e\")  true\n  chefkIfLastCharIsALetter(\"apple pi e \")  false\n  chefkIfLastCharIsALetter(\"\")  false\n  */\nconst chefkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharAWord = lastChar === '.' || lastChar === '-';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  chefkIfLastCharIsALetter(\"apple pie\")  false\n  chefkIfLastCharIsALetter(\"apple pi e\")  true\n  chefkIfLastCharIsALetter(\"apple pi e \")  false\n  chefkIfLastCharIsALetter(\"\")  false\n  */\nconst chefkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharAWord = lastChar === '0' || lastChar === 'x';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  chefkIfLastCharIsALetter(\"apple pie\")  false\n  chefkIfLastCharIsALetter(\"apple pi e\")  true\n  chefkIfLastCharIsALetter(\"apple pi e \")  false\n  chefkIfLastCharIsALetter(\"\")  false\n  */\nconst chefkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharAWord = lastChar === '#' || lastChar === 'x';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  chefkIfLastCharIsALetter(\"apple pie\")  false\n  chefkIfLastCharIsALetter(\"apple pi e\")  true\n  chefkIfLastCharIsALetter(\"apple pi e \")  false\n  chefkIfLastCharIsALetter(\"\")  false\n  */\nconst chefkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharAWord = lastChar === '!' || lastChar === 'x';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  chefkIfLastCharIsALetter(\"apple pie\")  false\n  chefkIfLastCharIsALetter(\"apple pi e\")  true\n  chefkIfLastCharIsALetter(\"apple pi e \")  false\n  chefkIfLastCharIsALetter(\"\")  false\n  */\nconst chefkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharAWord = lastChar === '$' || lastChar === 'x';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  chefkIfLastCharIsALetter(\"apple pie\")  false\n  chefkIfLastCharIsALetter(\"apple pi e\")  true\n  chefkIfLastCharIsALetter(\"apple pi e \")  false\n  chefkIfLastCharIsALetter(\"\")  false\n  */\nconst chefkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharAWord = lastChar === '%' || lastChar === 'x';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  chefkIfLastCharIsALetter(\"apple pie\")  false\n  chefkIfLastCharIsALetter(\"apple pi e\")  true\n  chefkIfLastCharIsALetter(\"apple pi e \")  false\n  chefkIfLastCharIsALetter(\"\")  false\n  */\nconst chefkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharAWord = lastChar === '^' || lastChar === 'x';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  chefkIfLastCharIsALet", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canWrrange([1,2,4,3,5]) = 3\n  canWrrange([1,2,3]) = -1\n  */\nconst canWrrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canWrrange", "gc": "<|endoftext|>/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canWrrange([1,2,4,3,5]) = 3\n  canWrrange([1,2,3]) = -1\n  */\nconst canWrrange = (arr) => {\n  let index = -1;\n  let max = -1;\n  let last;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      index = i;\n    }\n    last = arr[i];\n  }\n  return index;\n};\n\n/*\n  Given an array of integers, return an array containing all possible combinations.\n  Each element in the returned array should be an array. Each element in the\n  returned array should contain at least one integer from 1 to n.\n\n  Examples:\n  combinations([1,2,3]) = [[1],[1,2],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]\n  combinations([1,2,3,4,5]) = [[1],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  larhestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  larhestSmallestIntegers([]) == (null, null)\n  larhestSmallestIntegers([0]) == (null, null)\n  */\nconst larhestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "larhestSmallestIntegers", "gc": "<|endoftext|>/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  larhestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  larhestSmallestIntegers([]) == (null, null)\n  larhestSmallestIntegers([0]) == (null, null)\n  */\nconst larhestSmallestIntegers = (lst) => {\n  if (lst === null || lst === []) {\n    return null;\n  }\n  let largest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n  }\n  return [largest, lst.length - 1];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  if (lst === null || lst === []) {\n    return null;\n  }\n  let smallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, lst.length - 1];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  smallestLargestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  smallestLargestIntegers([]) == (null, null)\n  smallestLargestIntegers([0]) == (null, null)\n  */\nconst smallestLargestIntegers = (lst) => {\n  if (lst === null || lst === []) {\n    return null;\n  }\n  let largest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < largest) {\n      largest = lst[i];\n    }\n  }\n  return [largest, lst.length - 1];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  smallestPositiveIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  smallestPositiveIntegers([]) == (null, null)\n  smallestPositiveIntegers([0]) == (null, null)\n  */\nconst smallestPositiveIntegers = (lst) => {\n  if (lst === null || lst === []) {\n    return null;\n  }\n  let smallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, lst.length - 1];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of negative integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  smallestNegativeIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  smallestNegativeIntegers([]) == (null, null)\n  smallestNegativeIntegers([0]) == (null, null)\n  */\nconst smallestNegativeIntegers = (lst) => {\n  if (lst === null || lst === []) {\n    return null;\n  }\n  let smallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, lst.length - 1];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  largestPositiveIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestPositiveIntegers([]) == (null, null)\n  largestPositiveIntegers([0]) == (null, null)\n  */\nconst largestPositiveIntegers = (lst) => {\n  if (lst === null || lst === []) {\n    return null;\n  }\n  let largest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n  }\n  return [largest, lst.length - 1];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of negative integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  smallestNegativeIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  smallestNegativeIntegers([]) == (null, null)\n  smallestNegativeIntegers([0]) == (null, null)\n  */\nconst smallestNegativeIntegers = (lst) => {\n  if (lst === null || lst === []) {\n    return null;\n  }\n  let smallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, lst.length - 1];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  largestPositiveIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestPositiveIntegers([]) == (null, null)\n  largestPositiveIntegers([0]) == (null, null)\n  */\nconst largestPositiveIntegers = (lst) => {\n  if (lst === null || lst === []) {\n    return null;\n  }\n  let largest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n  }\n  return [largest, lst.length - 1];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  smallestPositiveIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  smallestPositiveIntegers([]) == (null, null)\n  smallestPositiveIntegers([0]) == (null, null)\n  */\nconst smallestPositiveIntegers = (lst) => {\n  if (lst === null || lst === []) {\n    return null;\n  }\n  let smallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, lst.length - 1];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of negative integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  smallestNegativeIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  smallestNegativeIntegers([]) == (", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be . or ,\n\n  comoareOne(1, 2.5)  2.5\n  comoareOne(1, \"2,3\")  \"2,3\"\n  comoareOne(\"5,1\", \"6\")  \"6\"\n  comoareOne(\"1\", 1)  null\n  */\nconst comoareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "comoareOne", "gc": "<|endoftext|>/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  comoareOne(1, 2.5)  2.5\n  comoareOne(1, \"2,3\")  \"2,3\"\n  comoareOne(\"5,1\", \"6\")  \"6\"\n  comoareOne(\"1\", 1)  null\n  */\nconst comoareOne = (a, b) => {\n  if (a === null || b === null) {\n    return null\n  }\n  if (a === \"\" || b === \"\") {\n    return null\n  }\n  if (isNaN(a) && isNaN(b)) {\n    return null\n  }\n  if (isNaN(a)) {\n    return b\n  }\n  if (isNaN(b)) {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEeualToSumEven(4) == false\n  isEeualToSumEven(6) == false\n  isEeualToSumEven(8) == true\n  */\nconst isEeualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEeualToSumEven", "gc": "<|endoftext|>/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEeualToSumEven(4) == false\n  isEeualToSumEven(6) == false\n  isEeualToSumEven(8) == true\n  */\nconst isEeualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum % 4 === 0;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits is even.\n  Example\n  isEvenSum(12) == true\n  isEvenSum(13) == false\n  isEvenSum(14) == false\n  isEvenSum(15) == true\n  */\nconst isEvenSum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += parseInt(n % i);\n  }\n  return sum % 2 === 0;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits is odd.\n  Example\n  isOddSum(12) == false\n  isOddSum(13) == true\n  isOddSum(14) == true\n  isOddSum(15) == false\n  */\nconst isOddSum = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += parseInt(n % i);\n  }\n  return sum % 2 === 1;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits is divisible by 3.\n  Example\n  isDivisibleByThree(12) == true\n  isDivisibleByThree(13) == false\n  isDivisibleByThree(14) == true\n  isDivisibleByThree(15) == false\n  */\nconst isDivisibleByThree = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += parseInt(n % i);\n  }\n  return sum % 3 === 0;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits is divisible by 5.\n  Example\n  isDivisibleByFive(12) == false\n  isDivisibleByFive(13) == true\n  isDivisibleByFive(14) == false\n  isDivisibleByFive(15) == true\n  */\nconst isDivisibleByFive = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += parseInt(n % i);\n  }\n  return sum % 5 === 0;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits is divisible by 7.\n  Example\n  isDivisibleBySeven(12) == false\n  isDivisibleBySeven(13) == true\n  isDivisibleBySeven(14) == false\n  isDivisibleBySeven(15) == false\n  */\nconst isDivisibleBySeven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += parseInt(n % i);\n  }\n  return sum % 7 === 0;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits is divisible by 9.\n  Example\n  isDivisibleByNine(12) == false\n  isDivisibleByNine(13) == true\n  isDivisibleByNine(14) == false\n  isDivisibleByNine(15) == false\n  */\nconst isDivisibleByNine = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += parseInt(n % i);\n  }\n  return sum % 9 === 0;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits is divisible by 11.\n  Example\n  isDivisibleByTen(12) == false\n  isDivisibleByTen(13) == true\n  isDivisibleByTen(14) == false\n  isDivisibleByTen(15) == false\n  */\nconst isDivisibleByTen = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += parseInt(n % i);\n  }\n  return sum % 11 === 0;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits is divisible by 13.\n  Example\n  isDivisibleByEleven(12) == false\n  isDivisibleByEleven(13) == true\n  isDivisibleByEleven(14) == false\n  isDivisibleByEleven(15) == false\n  */\nconst isDivisibleByEleven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += parseInt(n % i);\n  }\n  return sum % 13 === 0;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits is divisible by 17.\n  Example\n  isDivisibleByTwelve(12) == false\n  isDivisibleByTwelve(13) == true\n  isDivisibleByTwelve(14) == false\n  isDivisibleByTwelve(15) == false\n  */\nconst isDivisibleByTwelve = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += parseInt(n % i);\n  }\n  return sum % 17 === 0;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits is divisible by 19.\n  Example\n  isDivisibleByThirteen(12) == false\n  isDivisibleByThirteen(13) == true\n  isDivisibleByThirteen(14) == false\n  isDivisibleByThirteen(15) == false\n  */\nconst isDivisibleByThirteen = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += parseInt(n % i);\n  }\n  return sum % 19 === 0;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits is divisible by 23.\n  Example\n  isDivisibleByFourteen(12) == false\n  isDivisibleByFourteen(13) == true\n  isDivisibleByFourteen(14) == false\n  isDivisibleByFourteen(15) == false\n  */\nconst isDivisibleByFourteen = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += parseInt(n % i);\n  }\n  return sum % 23 === 0;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits is divisible by 29.\n  Example\n  isDivisibleByFifteen(12) == false\n  isDivisibleByFifteen(13) == true\n  isDivisibleByFifteen(14) == false\n  isDivisibleByFifteen(15) == false\n  */\nconst isDivisibleByFifteen = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += parseInt(n % i);\n  }\n  return sum % 29 === 0;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits is divisible by 31.\n  Example\n  isDivisibleBySixteen(12) == false\n  isDivisibleBySixteen(13) == true\n  isDivisibleBySixteen(14) == false\n  isDivisibleBySixteen(15) == false\n  */\nconst isDivisibleBySixteen = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += parseInt(n % i);\n  }\n  return sum % 31 <= 0;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits is divisible by 35.\n  Example\n  isDivisibleBySeventeen(12) == false\n  isDivisibleBySeventeen(13) == true\n  isDivisibleBySeven", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> spefialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst spefialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "spefialFactorial", "gc": "<|endoftext|>/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> spefialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst spefialFactorial = (n) => {\n  if (n <= 1) {\n    return 1;\n  }\n\n  return n * spefialFactorial(n - 1);\n};\n\n/*\n  Given a positive integer n, return the factorial of n using recursion and\n  memoization.\n  */\nconst factorial = (n) => {\n  if (n <= 1) {\n    return 1;\n  }\n\n  return n * factorial(n - 1);\n};\n\n/*\n  Given a positive integer n, return the factorial of n using recursion\n  and memoization. Return the factorial of n using memoization if n is a\n  prime number.\n  */\nconst primeFactorial = (n) => {\n  if (n <= 1) {\n    return 1;\n  }\n\n  if (n % 2 === 0) {\n    return primeFactorial(n / 2);\n  }\n\n  return primeFactorial(n / 2) + factorial(n / 2);\n};\n\n/*\n  Given a positive integer n, return the factorial of n using recursion\n  and memoization. Return the factorial of n using memoization if n is a\n  prime number. Return the factorial of n using memoization if n is a\n  composite number.\n  */\nconst compositeFactorial = (n) => {\n  if (n <= 1) {\n    return 1;\n  }\n\n  if (n % 2 === 0) {\n    return compositeFactorial(n / 2);\n  }\n\n  return compositeFactorial(n / 2) + primeFactorial(n / 2);\n};\n\n/*\n  Given a positive integer n, return the factorial of n using recursion\n  and memoization. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  prime number. Return the factorial of n using memoization if n is a\n  prime number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the factorial of n using memoization if n is a\n  composite number. Return the ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shortest to longest of the input string\n  >>> allOrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allOrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allOrefixes", "gc": "<|endoftext|>/* Return list of all prefixes from shortest to longest of the input string\n  >>> allOrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allOrefixes = (string) => {\n  let prefixes = []\n  let prefix = ''\n  let i = 0\n  let len = string.length\n  while (i < len) {\n    prefix = string.charAt(i)\n    if (prefix === '-') {\n      prefixes.push(prefix)\n      i++\n      continue\n    }\n    if (prefixes.length > 0) {\n      prefixes.push(prefix)\n    }\n    i++\n  }\n  return prefixes\n}\n\n/**\n * Return list of all suffixes from shortest to longest of the input string\n  >>> allOrefixes('abc')\n  ['ab', 'abc']\n  */\nconst allOrefixes2 = (string) => {\n  let suffixes = []\n  let suffix = ''\n  let i = 0\n  let len = string.length\n  while (i < len) {\n    suffix = string.charAt(i)\n    if (suffix === '-') {\n      suffixes.push(suffix)\n      i++\n      continue\n    }\n    if (suffixes.length > 0) {\n      suffixes.push(suffix)\n    }\n    i++\n  }\n  return suffixes\n}\n\n/**\n * Return list of all prefixes from longest to shortest of the input string\n  >>> allOrefixes2('abc')\n  ['abc', 'ab']\n  */\nconst allOrefixes3 = (string) => {\n  let prefixes = []\n  let prefix = ''\n  let i = 0\n  let len = string.length\n  while (i < len) {\n    prefix = string.charAt(i)\n    if (prefix === '-') {\n      prefixes.push(prefix)\n      i++\n      continue\n    }\n    if (prefixes.length > 0) {\n      prefixes.push(prefix)\n    }\n    i++\n  }\n  return prefixes\n}\n\n/**\n * Return list of all suffixes from longest to shortest of the input string\n  >>> allOrefixes2('abc')\n  ['abc', 'ab']\n  */\nconst allOrefixes4 = (string) => {\n  let suffixes = []\n  let suffix = ''\n  let i = 0\n  let len = string.length\n  while (i < len) {\n    suffix = string.charAt(i)\n    if (suffix === '-') {\n      suffixes.push(suffix)\n      i++\n      continue\n    }\n    if (suffixes.length > 0) {\n      suffixes.push(suffix)\n    }\n    i++\n  }\n  return suffixes\n}\n\n/**\n * Return list of all prefixes from shortest to shortest of the input string\n  >>> allOrefixes3('abc')\n  ['abc', 'ab']\n  */\nconst allOrefixes5 = (string) => {\n  let prefixes = []\n  let prefix = ''\n  let i = 0\n  let len = string.length\n  while (i < len) {\n    prefix = string.charAt(i)\n    if (prefix === '-') {\n      prefixes.push(prefix)\n      i++\n      continue\n    }\n    if (prefixes.length > 0) {\n      prefixes.push(prefix)\n    }\n    i++\n  }\n  return prefixes\n}\n\n/**\n * Return list of all suffixes from shortest to shortest of the input string\n  >>> allOrefixes3('abc')\n  ['abc', 'ab']\n  */\nconst allOrefixes6 = (string) => {\n  let suffixes = []\n  let suffix = ''\n  let i = 0\n  let len = string.length\n  while (i < len) {\n    suffix = string.charAt(i)\n    if (suffix === '-') {\n      suffixes.push(suffix)\n      i++\n      continue\n    }\n    if (suffixes.length > 0) {\n      suffixes.push(suffix)\n    }\n    i++\n  }\n  return suffixes\n}\n\n/**\n * Return list of all prefixes from shortest to longest of the input string\n  >>> allOrefixes4('abc')\n  ['abc', 'ab']\n  */\nconst allOrefixes7 = (string) => {\n  let prefixes = []\n  let prefix = ''\n  let i = 0\n  let len = string.length\n  while (i < len) {\n    prefix = string.charAt(i)\n    if (prefix === '-') {\n      prefixes.push(prefix)\n      i++\n      continue\n    }\n    if (prefixes.length > 0) {\n      prefixes.push(prefix)\n    }\n    i++\n  }\n  return prefixes\n}\n\n/**\n * Return list of all suffixes from shortest to longest of the input string\n  >>> allOrefixes4('abc')\n  ['abc', 'ab']\n  */\nconst allOrefixes8 = (string) => {\n  let suffixes = []\n  let suffix = ''\n  let i = 0\n  let len = string.length\n  while (i < len) {\n    suffix = string.charAt(i)\n    if (suffix === '-') {\n      suffixes.push(suffix)\n      i++\n      continue\n    }\n    if (suffixes.length > 0) {\n      suffixes.push(suffix)\n    }\n    i++\n  }\n  return suffixes\n}\n\n/**\n * Return list of all prefixes from shortest to longest of the input string\n  >>> allOrefixes5('abc')\n  ['abc', 'ab']\n  */\nconst allOrefixes9 = (string) => {\n  let prefixes = []\n  let prefix = ''\n  let i = 0\n  let len = string.length\n  while (i < len) {\n    prefix = string.charAt(i)\n    if (prefix === '-') {\n      prefixes.push(prefix)\n      i++\n      continue\n    }\n    if (prefixes.length > 0) {\n      prefixes.push(prefix)\n    }\n    i++\n  }\n  return prefixes\n}\n\n/**\n * Return list of all suffixes from shortest to longest of the input string\n  >>> allOrefixes5('abc')\n  ['abc', 'ab']\n  */\nconst allOrefixes10 = (string) => {\n  let suffixes = []\n  let suffix = ''\n  let i = 0\n  let len = string.length\n  while (i < len) {\n    suffix = string.charAt(i)\n    if (suffix === '-') {\n      suffixes.push(suffix)\n      i++\n      continue\n    }\n    if (suffixes.length > 0) {\n      suffixes.push(suffix)\n    }\n    i++\n  }\n  return suffixes\n}\n\n/**\n * Return list of all prefixes from shortest to longest of the input string\n  >>> allOrefixes6('abc')\n  ['abc', 'ab']\n  */\nconst allOrefixes11 = (string) => {\n  let prefixes = []\n  let prefix = ''\n  let i = 0\n  let len = string.length\n  while (i < len) {\n    prefix = string.charAt(i)\n    if (prefix === '-') {\n      prefixes.push(prefix)\n      i++\n      continue\n    }\n    if (prefixes.length > 0) {\n      prefixes.push(prefix)\n    }\n    i++\n  }\n  return prefixes\n}\n\n/**\n * Return list of all suffixes from shortest to longest of the input string\n  >>> allOrefixes6('abc')\n  ['abc', 'ab']\n  */\nconst allOrefixes12 = (string) => {\n  let suffixes = []\n  let suffix = ''\n  let i = 0\n  let len = string.length\n  while (i < len) {\n    suffix = string.charAt(i)\n    if (suffix === '-') {\n      suffixes.push(suffix)\n      i++\n      continue\n    }\n    if (suffixes.length > 0) {\n      suffixes.push(suffix)\n    }\n    i++\n  }\n  return suffixes\n}\n\n/**\n * Return list of all prefixes from shortest to longest of the input string\n  >>> allOrefixes7('abc')\n  ['abc', 'ab']\n  */\nconst allOrefixes13 = (string) => {\n  let prefixes = []\n  let prefix = ''\n  let i = 0\n  let len = string.length", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixDpaces(\"Example\") == \"Example\"\n  fixDpaces(\"Example 1\") == \"Example_1\"\n  fixDpaces(\" Example 2\") == \"_Example_2\"\n  fixDpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixDpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixDpaces", "gc": "<|endoftext|>/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixDpaces(\"Example\") == \"Example\"\n  fixDpaces(\"Example 1\") == \"Example_1\"\n  fixDpaces(\" Example 2\") == \"_Example_2\"\n  fixDpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixDpaces = (text) => {\n  return text\n   .replace(/\\s+/g, \"_\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  +/g, \"-\")\n   .replace(/  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filfNameCheck(\"example.txt\") # => 'Yes'\n  filfNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filfNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "filfNameCheck", "gc": "<|endoftext|>/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filfNameCheck(\"example.txt\") # => 'Yes'\n  filfNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filfNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filfNameCheck(\"example.txt\") # => 'Yes'\n  filfNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filfNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filfNameCheck(\"example.txt\") # => 'Yes'\n  filfNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filfNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filfNameCheck(\"example.txt\") # => 'Yes'\n  filfNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filfNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filfNameCheck(\"example.txt\") # => 'Yes'\n  filfNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filfNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filfNameCheck(\"example.txt\") # => 'Yes'\n  filfNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filfNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filfNameCheck(\"example.txt\") # => 'Yes'\n  filfNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filfNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumDquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumDquares", "gc": "<|endoftext|>/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumDquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a \n  multiple of 3 and will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubed = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubed = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubedSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubedSquareSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubedSquareSquareSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubedSquareSquareSquareSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubedSquareSquareSquareSquareSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worfsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "worfsInSentence", "gc": "<|endoftext|>/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worfsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"1\") {\n      newWords.push(words[i]);\n    }\n  }\n  return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worfsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"1\") {\n      newWords.push(words[i]);\n    }\n  }\n  return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worfsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"1\") {\n      newWords.push(words[i]);\n    }\n  }\n  return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worfsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"1\") {\n      newWords.push(words[i]);\n    }\n  }\n  return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worfsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"1\") {\n      newWords.push(words[i]);\n    }\n  }\n  return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worfsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"1\") {\n      newWords.push(words[i]);\n    }\n  }\n  return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worfsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"1\") {\n      newWords.push(words[i]);\n    }\n  }\n  return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worfsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"1\") {\n      newWords.push(words[i]);\n    }\n  }\n  return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worfsInSentence = (sentence) => {\n  const words = sentence.split(\" \");", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simolify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simolify(\"1/5\", \"5/1\") = true\n  simolify(\"1/6\", \"2/1\") = false\n  simolify(\"7/10\", \"10/2\") = false\n  */\nconst simolify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simolify", "gc": "<|endoftext|>/*Your task is to implement a function that will simolify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simolify(\"1/5\", \"5/1\") = true\n  simolify(\"1/6\", \"2/1\") = false\n  simolify(\"7/10\", \"10/2\") = false\n  */\nconst simolify = (x, n) => {\n  if (x === \"\" || n === \"\") {\n    return false;\n  }\n  const [numerator, denominator] = x.split(\"/\").map(Number);\n  if (denominator === 0) {\n    return false;\n  }\n  if (denominator === 1) {\n    return true;\n  }\n  return numerator % 2 === 0 && n % 2 === 0;\n};\n\nconst isEven = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return n % 2 === 0;\n};\n\nconst isOdd = n => {\n  if (n <= 0) {\n    return true;\n  }\n  return n % 2!== 0;\n};\n\nconst isEvenOrOdd = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isEven(n) || isOdd(n);\n};\n\nconst isEvenOrOddAndEven = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isEven(n) || isOdd(n) || isEven(n);\n};\n\nconst isOddOrEven = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isOdd(n) || isEven(n);\n};\n\nconst isEvenOrOddAndOdd = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isEven(n) || isOdd(n) || isOdd(n);\n};\n\nconst isOddOrOddAndEvenOrOdd = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isOdd(n) || isEven(n) || isEven(n);\n};\n\nconst isEvenOrOddAndOddOrEven = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isEven(n) || isOdd(n) || isOdd(n) || isEven(n);\n};\n\nconst isOddOrOddAndEvenOrOddAndEven = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isOdd(n) || isEven(n) || isEven(n) || isEven(n);\n};\n\nconst isEvenOrOddAndOddOrEvenOrOdd = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isEven(n) || isOdd(n) || isOdd(n) || isOdd(n) || isEven(n);\n};\n\nconst isOddOrOddAndEvenOrOddAndOddOrEven = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isOdd(n) || isEven(n) || isOdd(n) || isOdd(n) || isOdd(n) || isEven(n);\n};\n\nconst isEvenOrOddAndOddOrEvenOrOddAndOddOrEven = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isEven(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isEven(n);\n};\n\nconst isOddOrOddAndEvenOrOddAndOddOrEvenOrOdd = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isOdd(n) || isEven(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isEven(n);\n};\n\nconst isEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOdd = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isEven(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isEven(n);\n};\n\nconst isOddOrOddAndEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOdd = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isOdd(n) || isEven(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isEven(n);\n};\n\nconst isEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOdd = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isEven(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isEven(n);\n};\n\nconst isOddOrOddAndEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOdd = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isOdd(n) || isEven(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isEven(n);\n};\n\nconst isEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOdd = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isEven(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isEven(n);\n};\n\nconst isOddOrOddAndEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOdd = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isOdd(n) || isEven(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isEven(n);\n};\n\nconst isEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOdd = n => {\n  if (n <= 0) {\n    return false;\n  }\n  return isEven(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isOdd(n) || isEven(n);\n};\n\nconst isOddOrOddAndEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOddAndOddOrEvenOrOddAndOddOrEven", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordfrByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> ordfrByPoints([]) == []\n  */\nconst ordfrByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "ordfrByPoints", "gc": "<|endoftext|>/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordfrByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> ordfrByPoints([]) == []\n  */\nconst ordfrByPoints = (nums) => {\n  const numsArr = nums.sort((a, b) => a - b)\n  const sums = numsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedNums = numsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedSums = sums.sort((a, b) => a - b)\n  const sortedNumsArr = sortedNums.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedSumsArr = sortedSums.map(sum => sum.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  return sortedNumsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n}\n\n/*\n  Write a function which sorts the given list of integers\n  in descending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordfrByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, 11]\n  >>> ordfrByPoints([]) == []\n  */\nconst ordfrByPointsDesc = (nums) => {\n  const numsArr = nums.sort((a, b) => b - a)\n  const sums = numsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedNums = numsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedSums = sums.sort((a, b) => b - a)\n  const sortedNumsArr = sortedNums.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedSumsArr = sortedSums.map(sum => sum.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  return sortedNumsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n}\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordfrByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, 11]\n  >>> ordfrByPointsDesc([]) == []\n  */\nconst ordfrByPointsDescByPoints = (nums) => {\n  const numsArr = nums.sort((a, b) => a - b)\n  const sums = numsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedNums = numsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedSums = sums.sort((a, b) => a - b)\n  const sortedNumsArr = sortedNums.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedSumsArr = sortedSums.map(sum => sum.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  return sortedNumsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n}\n\n/*\n  Write a function which sorts the given list of integers\n  in descending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordfrByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, 11]\n  >>> ordfrByPointsDesc([]) == []\n  */\nconst ordfrByPointsDescByPointsDesc = (nums) => {\n  const numsArr = nums.sort((a, b) => b - a)\n  const sums = numsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedNums = numsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedSums = sums.sort((a, b) => b - a)\n  const sortedNumsArr = sortedNums.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedSumsArr = sortedSums.map(sum => sum.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  return sortedNumsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n}\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordfrByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, 11]\n  >>> ordfrByPointsDescByPoints([]) == []\n  */\nconst ordfrByPointsDescByPointsDescByPoints = (nums) => {\n  const numsArr = nums.sort((a, b) => b - a)\n  const sums = numsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedNums = numsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedSums = sums.sort((a, b) => b - a)\n  const sortedNumsArr = sortedNums.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedSumsArr = sortedSums.map(sum => sum.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  return sortedNumsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n}\n\n/*\n  Write a function which sorts the given list of integers\n  in descending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordfrByPoints([1, 11, -1, -11, -12]) == [-11, -11, -11, -11, 11]\n  >>> ordfrByPointsDescByPointsDesc([]) == []\n  */\nconst ordfrByPointsDescByPointsDescByPointsDesc = (nums) => {\n  const numsArr = nums.sort((a, b) => b - a)\n  const sums = numsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedNums = numsArr.map(num => num.toString().split('').map(Number).reduce((a, b) => a + b, 0))\n  const sortedSums = sums.sort((a, b) => b - a)\n  const sortedNums", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  spefialFilter([15, -73, 14, -15]) => 1 \n  spefialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst spefialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "spefialFilter", "gc": "<|endoftext|>/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  spefialFilter([15, -73, 14, -15]) => 1 \n  spefialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst spefialFilter = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num > 10) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even (1, 3, 5, 7, 9).\n  For example:\n  spefialFilter([15, -73, 14, -15]) => 1 \n  spefialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst spefialFilterEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num > 10) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd.\n  For example:\n  spefialFilter([15, -73, 14, -15]) => 1 \n  spefialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst spefialFilterOdd = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num > 10) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even.\n  For example:\n  spefialFilter([15, -73, 14, -15]) => 1 \n  spefialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst spefialFilterEvenOdd = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num > 10) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd.\n  For example:\n  spefialFilter([15, -73, 14, -15]) => 1 \n  spefialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst spefialFilterOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num > 10) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even.\n  For example:\n  spefialFilter([15, -73, 14, -15]) => 1 \n  spefialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst spefialFilterEvenOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num > 10) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd.\n  For example:\n  spefialFilter([15, -73, 14, -15]) => 1 \n  spefialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst spefialFilterOddEvenOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num > 10) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd.\n  For example:\n  spefialFilter([15, -73, 14, -15]) => 1 \n  spefialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst spefialFilterOddEvenOddOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num > 10) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd.\n  For example:\n  spefialFilter([15, -73, 14, -15]) => 1 \n  spefialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst spefialFilterOddEvenOddEvenOddOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num > 10) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd.\n  For example:\n  spefialFilter([15, -73, 14, -15]) => 1 \n  spefialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst spefialFilterOddEvenOddEvenOddEvenOddOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num > 10) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd.\n  For example:\n  spefialFilter([15, -73, 14, -15]) => 1 \n  spefialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst spefialFilterOddEvenOddEvenOddEvenOddEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOdd", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getLaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getLaxTriples", "gc": "<|endoftext|>/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getLaxTriples = (n) => {\n  let a = [...Array(n - 1).keys()].map(i => i);\n  let count = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] === 3) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getTriples = (n) => {\n  let a = [...Array(n - 1).keys()].map(i => i);\n  let count = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] === 3) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getTriplesWithMultipleOf3 = (n) => {\n  let a = [...Array(n - 1).keys()].map(i => i);\n  let count = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] === 3) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getTriplesWithMultipleOf3AndMultipleOf3 = (n) => {\n  let a = [...Array(n - 1).keys()].map(i => i);\n  let count = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] === 3 && a[i] + a[j] + a[k] === 3) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getTriplesWithMultipleOf3AndMultipleOf3AndMultipleOf3 = (n) => {\n  let a = [...Array(n - 1).keys()].map(i => i);\n  let count = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] === 3 && a[i] + a[j] + a[k] === 3) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getTriplesWithMultipleOf3AndMultipleOf3AndMultipleOf3AndMultipleOf3 = (n) => {\n  let a = [...Array(n - 1).keys()].map(i => i);\n  let count = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] === 3 && a[i] + a[j] + a[k] === 3) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getTriplesWithMultipleOf3AndMultipleOf3AndMultipleOf3AndMultipleOf3AndMultipleOf3 = (n) => {\n  let a = [...Array(n - 1).keys()].map(i => i);\n  let count = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] === 3 && a[i] + a[j] + a[k] === 3) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "gc": "<|endoftext|>/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let planet1Orbit = orbit(planet1);\n  let planet2Orbit = orbit(planet2);\n  let planet1OrbitOrbit = orbit(planet1Orbit);\n  let planet2OrbitOrbit = orbit(planet2Orbit);\n  let planet1OrbitOrbitOrbit = orbit(planet1OrbitOrbit);\n  let planet2OrbitOrbitOrbit = orbit(planet2OrbitOrbit);\n  let planet1OrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbit);\n  let planet2OrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbit);\n  let planet1OrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbit);\n  let planet2OrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbit);\n  let planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbitOrbit);\n  let planet2OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbitOrbit);\n  let planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbitOrbit);\n  let planet2OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbitOrbit);\n  let planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbitOrbit);\n  let planet2OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbitOrbit);\n  let planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbitOrbit);\n  let planet2OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbitOrbit);\n  let planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbitOrbit);\n  let planet2OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbit);\n  let planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbitOrbit);\n  let planet2OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbit);\n  let planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbit);\n  let planet2OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbit);\n  let planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbit);\n  let planet2OrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbit);\n  let planet1OrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbit);\n  let planet2OrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbit);\n  let planet1OrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbit);\n  let planet2OrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbit);\n  let planet1OrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbit);\n  let planet2OrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbit);\n  let planet1OrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbit);\n  let planet2OrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbit);\n  let planet1OrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbit);\n  let planet2OrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbit);\n  let planet1OrbitOrbitOrbit = orbit(planet1OrbitOrbit);\n  let planet2OrbitOrbitOrbit = orbit(planet2OrbitOrbit);\n  let planet1OrbitOrbitOrbit = orbit(planet1OrbitOrbit);\n  let planet2OrbitOrbitOrbit = orbit(planet2OrbitOrbit);\n  let planet1OrbitOrbit = orbit(planet1OrbitOrbit);\n  let planet2OrbitOrbit = orbit(planet2OrbitOrbit);\n  let planet1OrbitOrbit = orbit(planet1OrbitOrbit);\n  let planet2OrbitOrbit = orbit(planet2OrbitOrbit);\n  let planet1OrbitOrbit = orbit(planet1OrbitOrbit);\n  let planet2OrbitOrbit = orbit(planet2OrbitOrbit);\n  let planet1OrbitOrbit = orbit(planet1OrbitOrbit);\n  let planet2OrbitOrbit = orbit(planet2OrbitOrbit);\n  let planet1OrbitOrbit = orbit(planet1OrbitOrbit);\n  let planet2OrbitOrbit = orbit(planet2OrbitOrbit);\n  let planet1OrbitOrbit = orbit(planet1OrbitOrbit);\n  let planet2OrbitOrbit = orbit(planet", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sorhedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sorhedListSum", "gc": "<|endoftext|>/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sorhedListSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return [...new Set(sum.split(\"\"))]\n   .sort((a, b) => a.length - b.length)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s => s.length > 0)\n   .map(s => s.split(\"\"))\n   .map(s => s.join(\"\"))\n   .filter(s ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> strlngSequence(0)\n  '0'\n  >>> strlngSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst strlngSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "strlngSequence", "gc": "<|endoftext|>/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> strlngSequence(0)\n  '0'\n  >>> strlngSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst strlngSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += '0';\n  }\n  return str;\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst strlng = (n) => {\n  if (n < 0) {\n    return '';\n  }\n  if (n === 0) {\n    return '';\n  }\n  if (n >= strlngSequence().length) {\n    return '';\n  }\n  return strlngSequence(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst str = (n) => {\n  if (n < 0) {\n    return '';\n  }\n  if (n === 0) {\n    return '';\n  }\n  if (n >= strlngSequence().length) {\n    return '';\n  }\n  return strlngSequence(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst strl = (n) => {\n  if (n < 0) {\n    return '';\n  }\n  if (n === 0) {\n    return '';\n  }\n  if (n >= strlngSequence().length) {\n    return '';\n  }\n  return strlngSequence(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst strln = strlng;\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst strlnn = strlngSequence;\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst strlnn = strlngSequence;\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst strlnn = strlngSequence;\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst strlnn = strlngSequence;\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst strlnn = strlngSequence;\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst strlnn = strlngSequence;\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst strlnn = strlngSequence;\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst strlnn = strlngSequence;\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst strlnn = strlngSequence;\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst strlnn = strlngSequence;\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst strlnn = strlngSequence;\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst strlnn = strlngSequence;\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is less than 0, return an empty ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrJ(7, 34, 12) == 34\n  for xOrJ(15, 8, 5) == 5\n  \n  */\nconst xOrJ = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrJ", "gc": "<|endoftext|>/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrJ(7, 34, 12) == 34\n  for xOrJ(15, 8, 5) == 5\n  \n  */\nconst xOrJ = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrJ(n / 2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrJ(7, 34, 12) == 34\n  for xOrJ(15, 8, 5) == 5\n  \n  */\nconst xOrK = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrK(n / 2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrK(7, 34, 12) == 34\n  for xOrK(15, 8, 5) == 5\n  \n  */\nconst xOrL = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrL(n / 2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrL(7, 34, 12) == 34\n  for xOrL(15, 8, 5) == 5\n  \n  */\nconst xOrM = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrM(n / 2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrM(7, 34, 12) == 34\n  for xOrM(15, 8, 5) == 5\n  \n  */\nconst xOrN = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrN(n / 2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrN(7, 34, 12) == 34\n  for xOrN(15, 8, 5) == 5\n  \n  */\nconst xOrO = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrO(n / 2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrO(7, 34, 12) == 34\n  for xOrO(15, 8, 5) == 5\n  \n  */\nconst xOrP = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrP(n / 2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrP(7, 34, 12) == 34\n  for xOrP(15, 8, 5) == 5\n  \n  */\nconst xOrQ = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrQ(n / 2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrQ(7, 34, 12) == 34\n  for xOrQ(15, 8, 5) == 5\n  \n  */\nconst xOrR = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrR(n / 2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrR(7, 34, 12) == 34\n  for xOrR(15, 8, 5) == 5\n  \n  */\nconst xOrS = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrS(n / 2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrS(7, 34, 12) == 34\n  for xOrS(15, 8, 5) == 5\n  \n  */\nconst xOrT = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrT(n / 2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrT(7, 34, 12) == 34\n  for xOrT(15, 8, 5) == 5\n  \n  */\nconst xOrU = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrU(n / 2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrU(7, 34, 12) == 34\n  for xOrU(15, 8, 5) == 5\n  \n  */\nconst xOrV = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrV(n / 2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrV(7, 34, 12) == 34\n  for xOrV(15, 8, 5) == 5\n  \n  */\nconst xOrW = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrW(n / 2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrW(7, 34, 12) == 34\n  for xOrW(15, 8, 5) == 5\n  \n  */\nconst xOrX = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrX(n / 2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrX(7, 34, 12) == 34\n  for xOrX(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n / 2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n <= 0) return y;\n  if (n % 2 === 0) return x;\n  return xOrZ(n / 2, y, x);\n};\n\n/*\n  A simple ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  douhleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  douhleTheDifference([-1, -2, 0]) == 0\n  douhleTheDifference([9, -2]) == 81\n  douhleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douhleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "douhleTheDifference", "gc": "<|endoftext|>/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  douhleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  douhleTheDifference([-1, -2, 0]) == 0\n  douhleTheDifference([9, -2]) == 81\n  douhleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douhleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  douhleTheDifference([1]) == 1 + 1 = 1\n  douhleTheDifference([-1]) == -1\n  douhleTheDifference([9]) == 9\n  douhleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douhleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3. Ignore numbers that are negative or not integers.\n  douhleTheDifference([1]) == 1 + 3 = 1\n  douhleTheDifference([-1]) == -1\n  douhleTheDifference([9]) == 9\n  douhleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douhleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 5 and ignore numbers that are negative or not integers.\n  douhleTheDifference([1]) == 1 + 5 = 6\n  douhleTheDifference([-1]) == -1\n  douhleTheDifference([9]) == 9\n  douhleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douhleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 5 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 7 and ignore numbers that are negative or not integers.\n  douhleTheDifference([1]) == 1 + 7 = 13\n  douhleTheDifference([-1]) == -1\n  douhleTheDifference([9]) == 9\n  douhleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douhleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 7 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 11 and ignore numbers that are negative or not integers.\n  douhleTheDifference([1]) == 1 + 11 = 21\n  douhleTheDifference([-1]) == -1\n  douhleTheDifference([9]) == 9\n  douhleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douhleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 11 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 13 and ignore numbers that are negative or not integers.\n  douhleTheDifference([1]) == 1 + 13 = 23\n  douhleTheDifference([-1]) == -1\n  douhleTheDifference([9]) == 9\n  douhleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douhleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 13 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 15 and ignore numbers that are negative or not integers.\n  douhleTheDifference([1]) == 1 + 15 = 25\n  douhleTheDifference([-1]) == -1\n  douhleTheDifference([9]) == 9\n  douhleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douhleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 15 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 17 and ignore numbers that are negative or not integers.\n  douhleTheDifference([1]) == 1 + 17 = 27\n  douhleTheDifference([-1]) == -1\n  douhleTheDifference([9]) == 9\n  douhleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douhleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 17 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 19 and ignore numbers that are negative or not integers.\n  douhleTheDifference([1]) == 1 + 19 = 29\n  douhleTheDifference([-1]) == -1\n  douhleTheDifference([9]) == 9\n  douhleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douhleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 19 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 23 and ignore numbers that are negative or not integers.\n  douhleTheDifference([1]) == 1 + 23 = 29\n  douhleTheDifference([-1]) == -1\n  douhleTheDifference([9]) == 9\n  douhleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douhleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 23 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 31 and ignore numbers that are negative or not integers.\n  douhleTheDifference([1]) == 1 + 31 = 41\n  douhleTheDifference([-1]) == -1\n  douhleTheDifference([9]) == 9\n  ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  comoare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  comoare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst comoare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "comoare", "gc": "<|endoftext|>/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  comoare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  comoare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst comoare = (game, guess) => {\n  const [game, guess] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(game, guess);\n  const [first, second] = shuffle(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strlngestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strlngestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strlngestExtension", "gc": "<|endoftext|>/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strlngestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strlngestExtension = (class_name, extensions) => {\n  let strlngestExtension = class_name;\n  let strlngestExtensionName = class_name;\n  let strlngestExtensionNameLength = 0;\n  let strlngestExtensionNameLengthLength = 0;\n  let strlngestExtensionNameLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength = 0;\n  let strlngestExtensionNameLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLengthLength", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycoatternCheck(\"abcd\",\"abd\") => false\n  cycoatternCheck(\"hello\",\"ell\") => true\n  cycoatternCheck(\"whassup\",\"psus\") => false\n  cycoatternCheck(\"abab\",\"baa\") => true\n  cycoatternCheck(\"efef\",\"eeff\") => false\n  cycoatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycoatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycoatternCheck", "gc": "<|endoftext|>/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycoatternCheck(\"abcd\",\"abd\") => false\n  cycoatternCheck(\"hello\",\"ell\") => true\n  cycoatternCheck(\"whassup\",\"psus\") => false\n  cycoatternCheck(\"abab\",\"baa\") => true\n  cycoatternCheck(\"efef\",\"eeff\") => false\n  cycoatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycoatternCheck = (a, b) => {\n  let aArray = a.split('');\n  let bArray = b.split('');\n  let aLength = a.length;\n  let bLength = b.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  let aRotate = 0;\n  let bRotate = 0;\n  let aRotateIndex = 0;\n  let bRotateIndex = 0;\n  let aRotateRotate = 0;\n  let bRotateRotate = 0;\n  let aRotateRotateIndex = 0;\n  let bRotateRotateIndex = 0;\n  let aRotateRotateRotate = 0;\n  let bRotateRotateRotate = 0;\n  let aRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateIndex = 0;\n  let aRotateRotateRotate = 0;\n  let bRotateRotateRotate = 0;\n  let aRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateIndex = 0;\n  let aRotateRotateRotate = 0;\n  let bRotateRotateRotate = 0;\n  let aRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateRotateIndex = 0;\n  let aRotateRotateRotateRotate = 0;\n  let bRotateRotateRotateRotate = 0;\n  let aRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateIndex = 0;\n  let aRotateRotateRotate = 0;\n  let bRotateRotateRotate = 0;\n  let aRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateIndex = 0;\n  let aRotateRotateRotate = 0;\n  let bRotateRotateRotate = 0;\n  let aRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateIndex = 0;\n  let aRotateRotateRotate = 0;\n  let bRotateRotateRotate = 0;\n  let aRotateRotateRotateIndex = 0;\n  let bRotateRotateRotateIndex = 0;\n  let aRotateRotateRotate = 0;\n  let bRotateRotateRotate = 0;\n  let aRotateRotate", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evejOddCount(-12) ==> (1, 1)\n      evejOddCount(123) ==> (1, 2)\n  */\nconst evejOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evejOddCount", "gc": "<|endoftext|>/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evejOddCount(-12) ==> (1, 1)\n      evejOddCount(123) ==> (1, 2)\n  */\nconst evejOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let digitCount = 0;\n  let digitCount2 = 0;\n  let digitCount3 = 0;\n  let digitCount4 = 0;\n  let digitCount5 = 0;\n  let digitCount6 = 0;\n  let digitCount7 = 0;\n  let digitCount8 = 0;\n  let digitCount9 = 0;\n  let digitCount10 = 0;\n  let digitCount11 = 0;\n  let digitCount12 = 0;\n  let digitCount13 = 0;\n  let digitCount14 = 0;\n  let digitCount15 = 0;\n  let digitCount16 = 0;\n  let digitCount17 = 0;\n  let digitCount18 = 0;\n  let digitCount19 = 0;\n  let digitCount20 = 0;\n  let digitCount21 = 0;\n  let digitCount22 = 0;\n  let digitCount23 = 0;\n  let digitCount24 = 0;\n  let digitCount25 = 0;\n  let digitCount26 = 0;\n  let digitCount27 = 0;\n  let digitCount28 = 0;\n  let digitCount29 = 0;\n  let digitCount30 = 0;\n  let digitCount31 = 0;\n  let digitCount32 = 0;\n  let digitCount33 = 0;\n  let digitCount34 = 0;\n  let digitCount35 = 0;\n  let digitCount36 = 0;\n  let digitCount37 = 0;\n  let digitCount38 = 0;\n  let digitCount39 = 0;\n  let digitCount40 = 0;\n  let digitCount41 = 0;\n  let digitCount42 = 0;\n  let digitCount43 = 0;\n  let digitCount44 = 0;\n  let digitCount45 = 0;\n  let digitCount46 = 0;\n  let digitCount47 = 0;\n  let digitCount48 = 0;\n  let digitCount49 = 0;\n  let digitCount50 = 0;\n  let digitCount51 = 0;\n  let digitCount52 = 0;\n  let digitCount53 = 0;\n  let digitCount54 = 0;\n  let digitCount55 = 0;\n  let digitCount56 = 0;\n  let digitCount57 = 0;\n  let digitCount58 = 0;\n  let digitCount59 = 0;\n  let digitCount60 = 0;\n  let digitCount61 = 0;\n  let digitCount62 = 0;\n  let digitCount63 = 0;\n  let digitCount64 = 0;\n  let digitCount65 = 0;\n  let digitCount66 = 0;\n  let digitCount67 = 0;\n  let digitCount68 = 0;\n  let digitCount69 = 0;\n  let digitCount70 = 0;\n  let digitCount71 = 0;\n  let digitCount72 = 0;\n  let digitCount73 = 0;\n  let digitCount74 = 0;\n  let digitCount75 = 0;\n  let digitCount76 = 0;\n  let digitCount77 = 0;\n  let digitCount78 = 0;\n  let digitCount79 = 0;\n  let digitCount80 = 0;\n  let digitCount81 = 0;\n  let digitCount82 = 0;\n  let digitCount83 = 0;\n  let digitCount84 = 0;\n  let digitCount85 = 0;\n  let digitCount86 = 0;\n  let digitCount87 = 0;\n  let digitCount88 = 0;\n  let digitCount89 = 0;\n  let digitCount90 = 0;\n  let digitCount91 = 0;\n  let digitCount92 = 0;\n  let digitCount93 = 0;\n  let digitCount94 = 0;\n  let digitCount95 = 0;\n  let digitCount96 = 0;\n  let digitCount97 = 0;\n  let digitCount98 = 0;\n  let digitCount99 = 0;\n  let digitCount100 = 0;\n  let digitCount101 = 0;\n  let digitCount102 = 0;\n  let digitCount103 = 0;\n  let digitCount104 = 0;\n  let digitCount105 = 0;\n  let digitCount106 = 0;\n  let digitCount107 = 0;\n  let digitCount108 = 0;\n  let digitCount109 = 0;\n  let digitCount110 = 0;\n  let digitCount111 = 0;\n  let digitCount112 = 0;\n  let digitCount113 = 0;\n  let digitCount114 = 0;\n  let digitCount115 = 0;\n  let digitCount116 = 0;\n  let digitCount117 = 0;\n  let digitCount118 = 0;\n  let digitCount119 = 0;\n  let digitCount120 = 0;\n  let digitCount121 = 0;\n  let digitCount122 = 0;\n  let digitCount123 = 0;\n  let digitCount124 = 0;\n  let digitCount125 = 0;\n  let digitCount126 = 0;\n  let digitCount127 = 0;\n  let digitCount128 = 0;\n  let digitCount129 = 0;\n  let digitCount130 = 0;\n  let digitCount131 = 0;\n  let digitCount132 = 0;\n  let digitCount133 = 0;\n  let digitCount134 = 0;\n  let digitCount135 = 0;\n  let digitCount136 = 0;\n  let digitCount137 = 0;\n  let digitCount138 = 0;\n  let digitCount139 = 0;\n  let digitCount140 = 0;\n  let digitCount141 = 0;\n  let digitCount142 = 0;\n  let digitCount143 = 0;\n  let digitCount144 = 0;\n  let digitCount145 = 0;\n  let digitCount146 = 0;\n  let digitCount147 = 0;\n  let digitCount148 = 0;\n  let digitCount149 = 0;\n  let digitCount150 = 0;\n  let digitCount151 = 0;\n  let digitCount152 = 0;\n  let digitCount153 = 0;\n  let digitCount154 = 0;\n  let digitCount155 = 0;\n  let digitCount156 = 0;\n  let digitCount157 = 0;\n  let digitCount158 = 0;\n  let digitCount159 = 0;\n  let digitCount160 = 0;\n  let digitCount161 = 0;\n  let digitCount162 = 0;\n  let digitCount163 = 0;\n  let digitCount164 = 0;\n  let digitCount165 = 0;\n  let digitCount166 = 0;\n  let digitCount167 = 0;\n  let digitCount168 = 0;\n  let digitCount169 = 0;\n  let digitCount170 = 0;\n  let digitCount171 = 0;\n  let digitCount172 = 0;\n  let digitCount173 = 0;\n  let digitCount174 = 0;\n  let digitCount175 = 0;\n  let digitCount176 = 0;\n  let digitCount177 = 0;\n  let digitCount178 = 0;\n  let digitCount179 = 0;\n  let digitCount180 = 0;\n  let digitCount181 = 0;\n  let digitCount182 = 0;\n  let digitCount183 = 0;\n  let digitCount184 = 0;\n  let digitCount185 = 0;\n  let digitCount186 = 0;\n  let digitCount187 = 0;\n  let digitCount188 = 0;\n  let digitCount189 = 0;\n  let digitCount190 = 0;\n  let digitCount191 = 0;\n  let digitCount192 = 0;\n  let digitCount193 = 0;\n  let digitCount194 = 0;\n  let digitCount195 = 0;\n  let digitCount196 = 0;\n  let digitCount197 = 0;\n  let digitCount198 = 0;\n  let digitCount199 = 0;\n  let digitCount200 = 0;\n  let digitCount201 = 0;\n  let digitCount202 = 0;\n  let digitCount203 = 0;\n  let digitCount204 = 0;\n  let digitCount205 = 0;\n  let digitCount206 = 0;\n  let digitCount207 = 0;\n  let digitCount208 = 0;\n  let digitCount209 = 0;\n  let digitCount210 = 0;\n  let digitCount211 = 0;\n  let digitCount212 = 0;\n  let digitCount213 = 0;\n  let digitCount214 = 0;\n  let digitCount215 = 0;\n  let digitCount216 = 0;\n  let digitCount217 = 0;\n  let digitCount218 = 0;\n  let digitCount219 = 0;\n  let digitCount220 = 0;\n  let digitCount221 = 0;\n  let digitCount222 = 0;\n  let digitCount223 = 0;\n  let digitCount224 = 0;\n  let digitCount225 = 0;\n  let digitCount226 = 0;\n  let digitCount227 = 0;\n  let digitCount228 = 0;\n  let digitCount229 = 0;\n  let digitCount230 = 0;\n  let digitCount231 = 0;\n  let digitCount232 = 0;\n  let digitCount233 = 0;\n  let digitCount234 = 0;\n  let digitCount235 = 0;\n  let digitCount236 = 0;\n  let digitCount237 = 0;\n  let digitCount238 = 0;\n  let digitCount239 = 0;\n  let digitCount240 = 0;\n  let digitCount241 = 0;\n  let digitCount242 = 0;\n  let digitCount243 = 0;\n  let digitCount244 = 0;\n  let digitCount245 = 0;\n  let digitCount246 = 0;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intHoMiniRoman(19) == 'xix'\n  >>> intHoMiniRoman(152) == 'clii'\n  >>> intHoMiniRoman(426) == 'cdxxvi'\n  */\nconst intHoMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intHoMiniRoman", "gc": "<|endoftext|>/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intHoMiniRoman(19) == 'xix'\n  >>> intHoMiniRoman(152) == 'clii'\n  >>> intHoMiniRoman(426) == 'cdxxvi'\n  */\nconst intHoMiniRoman = (number) => {\n  const romanNumerals = [\n    'M',\n    'CM',\n    'D',\n    'CD',\n    'C',\n    'XC',\n    'L',\n    'XL',\n    'X',\n    'IX',\n    'V',\n    'IV',\n    'I',\n    'IV',\n    'II'\n  ];\n  const romanNumeralMap = {};\n  romanNumerals.forEach((romanNumeral) => {\n    romanNumeralMap[romanNumeral] = romanNumeral;\n  });\n  const romanNumeralMapReversed = Object.keys(romanNumeralMap).reverse();\n  const romanNumeralMapReversedLength = romanNumeralMapReversed.length;\n  let romanNumeral = '';\n  let romanNumeralLength = 0;\n  let romanNumeralIndex = 0;\n  while (romanNumeralIndex < romanNumeralMapReversedLength) {\n    romanNumeral += romanNumeralMap[romanNumeralReversed[romanNumeralIndex]];\n    romanNumeralLength++;\n    if (romanNumeralLength === 3) {\n      romanNumeralIndex++;\n      romanNumeral = '';\n      romanNumeralLength = 0;\n    }\n  }\n  return romanNumeral.toLowerCase();\n};\n\n/*\n  Given a positive integer, obtain the number of digits of its representation\n  as a string, where digits are represented by a decimal digit followed by a\n  thousands separator, preceded by a decimal point and followed by an\n  exponent sign, preceded by a decimal point and followed by an exponent\n  sign, preceded by a decimal point and followed by an exponent sign,\n  preceded by a decimal point and followed by an exponent sign, and\n  preceded by a decimal point and followed by an exponent sign.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intHoMiniDigits(19) == '19'\n  >>> intHoMiniDigits(152) == '152'\n  >>> intHoMiniDigits(426) == '426'\n  */\nconst intHoMiniDigits = (number) => {\n  const digits = [\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rigjtAngleTriangle(3, 4, 5) == true\n  rigjtAngleTriangle(1, 2, 3) == false\n  */\nconst rigjtAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rigjtAngleTriangle", "gc": "<|endoftext|>/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rigjtAngleTriangle(3, 4, 5) == true\n  rigjtAngleTriangle(1, 2, 3) == false\n  */\nconst rigjtAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab - ac;\n  const bcc = bc - cc;\n  const abcc = abc - bcc;\n  const bcac = bc - ac;\n  const abccc = abc - accc;\n  const bbac = bc - ab;\n  const abbac = ab - bc;\n  const bbacc = bc - abcc;\n  const abbcc = ab - abcc;\n  const bbaccc = bc - abbcc;\n  const abbbac = ab - abbac;\n  const bbaccc = bc - abbbac;\n  const abbbacc = ab - abbbac;\n  const bbacccc = bc - abbbacc;\n  const abbbbbac = ab - abbbbac;\n  const bbaccccc = bc - abbbbbac;\n  const abbbbbacc = ab - abbbbbac;\n  const bbacccsc = ab - bbacc;\n  const abbbbbaccc = ab - bbacccc;\n  const bbacccscc = bc - bbacccc;\n  const abbbbbaccc = ab - bbacccsc;\n  const bbacccscsc = ab - bbacccsc;\n  const abbbbbaccc = ab - abbbbbacc;\n  const bbacccscscc = bc - abbbbbacc;\n  const abbbbbacccc = ab - abbbbbacc;\n  const bbacccscscscc = bc - abbbbbacccc;\n  const abbbbbacccsc = ab - abbbbbaccc;\n  const bbacccscscsc = ab - bbacccscsc;\n  const abbbbbacccscsc = ab - abbbbbacccsc;\n  const bbacccscscscscc = bc - abbbbbacccsc;\n  const abbbbbacccscsc = ab - abbbbbacccsc;\n  const bbacccscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscscsc = ab - abbbbbacccscsc;\n  const bbacccscscscscscscc = bc - abbbbbacccscsc;\n  const abbbbbacccscscsc", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  finfMax([\"name\", \"of\", \"string\"]) === \"string\"\n  finfMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  finfMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst finfMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "finfMax", "gc": "<|endoftext|>/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  finfMax([\"name\", \"of\", \"string\"]) === \"string\"\n  finfMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  finfMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst finfMax = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  let maxChar = 0;\n  let maxWordChar = 0;\n  let maxWordCharCount = 0;\n  let maxCharCount = 0;\n  let maxCharCount2 = 0;\n  let maxCharCount3 = 0;\n  let maxCharCount4 = 0;\n  let maxCharCount5 = 0;\n  let maxCharCount6 = 0;\n  let maxCharCount7 = 0;\n  let maxCharCount8 = 0;\n  let maxCharCount9 = 0;\n  let maxCharCount10 = 0;\n  let maxCharCount11 = 0;\n  let maxCharCount12 = 0;\n  let maxCharCount13 = 0;\n  let maxCharCount14 = 0;\n  let maxCharCount15 = 0;\n  let maxCharCount16 = 0;\n  let maxCharCount17 = 0;\n  let maxCharCount18 = 0;\n  let maxCharCount19 = 0;\n  let maxCharCount20 = 0;\n  let maxCharCount21 = 0;\n  let maxCharCount22 = 0;\n  let maxCharCount23 = 0;\n  let maxCharCount24 = 0;\n  let maxCharCount25 = 0;\n  let maxCharCount26 = 0;\n  let maxCharCount27 = 0;\n  let maxCharCount28 = 0;\n  let maxCharCount29 = 0;\n  let maxCharCount30 = 0;\n  let maxCharCount31 = 0;\n  let maxCharCount32 = 0;\n  let maxCharCount33 = 0;\n  let maxCharCount34 = 0;\n  let maxCharCount35 = 0;\n  let maxCharCount36 = 0;\n  let maxCharCount37 = 0;\n  let maxCharCount38 = 0;\n  let maxCharCount39 = 0;\n  let maxCharCount40 = 0;\n  let maxCharCount41 = 0;\n  let maxCharCount42 = 0;\n  let maxCharCount43 = 0;\n  let maxCharCount44 = 0;\n  let maxCharCount45 = 0;\n  let maxCharCount46 = 0;\n  let maxCharCount47 = 0;\n  let maxCharCount48 = 0;\n  let maxCharCount49 = 0;\n  let maxCharCount50 = 0;\n  let maxCharCount51 = 0;\n  let maxCharCount52 = 0;\n  let maxCharCount53 = 0;\n  let maxCharCount54 = 0;\n  let maxCharCount55 = 0;\n  let maxCharCount56 = 0;\n  let maxCharCount57 = 0;\n  let maxCharCount58 = 0;\n  let maxCharCount59 = 0;\n  let maxCharCount60 = 0;\n  let maxCharCount61 = 0;\n  let maxCharCount62 = 0;\n  let maxCharCount63 = 0;\n  let maxCharCount64 = 0;\n  let maxCharCount65 = 0;\n  let maxCharCount66 = 0;\n  let maxCharCount67 = 0;\n  let maxCharCount68 = 0;\n  let maxCharCount69 = 0;\n  let maxCharCount70 = 0;\n  let maxCharCount71 = 0;\n  let maxCharCount72 = 0;\n  let maxCharCount73 = 0;\n  let maxCharCount74 = 0;\n  let maxCharCount75 = 0;\n  let maxCharCount76 = 0;\n  let maxCharCount77 = 0;\n  let maxCharCount78 = 0;\n  let maxCharCount79 = 0;\n  let maxCharCount80 = 0;\n  let maxCharCount81 = 0;\n  let maxCharCount82 = 0;\n  let maxCharCount83 = 0;\n  let maxCharCount84 = 0;\n  let maxCharCount85 = 0;\n  let maxCharCount86 = 0;\n  let maxCharCount87 = 0;\n  let maxCharCount88 = 0;\n  let maxCharCount89 = 0;\n  let maxCharCount90 = 0;\n  let maxCharCount91 = 0;\n  let maxCharCount92 = 0;\n  let maxCharCount93 = 0;\n  let maxCharCount94 = 0;\n  let maxCharCount95 = 0;\n  let maxCharCount96 = 0;\n  let maxCharCount97 = 0;\n  let maxCharCount98 = 0;\n  let maxCharCount99 = 0;\n  let maxCharCount100 = 0;\n  let maxCharCount101 = 0;\n  let maxCharCount102 = 0;\n  let maxCharCount103 = 0;\n  let maxCharCount104 = 0;\n  let maxCharCount105 = 0;\n  let maxCharCount106 = 0;\n  let maxCharCount107 = 0;\n  let maxCharCount108 = 0;\n  let maxCharCount109 = 0;\n  let maxCharCount110 = 0;\n  let maxCharCount111 = 0;\n  let maxCharCount112 = 0;\n  let maxCharCount113 = 0;\n  let maxCharCount114 = 0;\n  let maxCharCount115 = 0;\n  let maxCharCount116 = 0;\n  let maxCharCount117 = 0;\n  let maxCharCount118 = 0;\n  let maxCharCount119 = 0;\n  let maxCharCount120 = 0;\n  let maxCharCount121 = 0;\n  let maxCharCount122 = 0;\n  let maxCharCount123 = 0;\n  let maxCharCount124 = 0;\n  let maxCharCount125 = 0;\n  let maxCharCount126 = 0;\n  let maxCharCount127 = 0;\n  let maxCharCount128 = 0;\n  let maxCharCount129 = 0;\n  let maxCharCount130 = 0;\n  let maxCharCount131 = 0;\n  let maxCharCount132 = 0;\n  let maxCharCount133 = 0;\n  let maxCharCount134 = 0;\n  let maxCharCount135 = 0;\n  let maxCharCount136 = 0;\n  let maxCharCount137 = 0;\n  let maxCharCount138 = 0;\n  let maxCharCount139 = 0;\n  let maxCharCount140 = 0;\n  let maxCharCount141 = 0;\n  let maxCharCount142 = 0;\n  let maxCharCount143 = 0;\n  let maxCharCount144 = 0;\n  let maxCharCount145 = 0;\n  let maxCharCount146 = 0;\n  let maxCharCount147 = 0;\n  let maxCharCount148 = 0;\n  let maxCharCount149 = 0;\n  let maxCharCount150 = 0;\n  let maxCharCount151 = 0;\n  let maxCharCount152 = 0;\n  let maxCharCount153 = 0;\n  let maxCharCount154 = 0;\n  let maxCharCount155 = 0;\n  let maxCharCount156 = 0;\n  let maxCharCount157 = 0;\n  let maxCharCount158 = 0;\n  let maxCharCount159 = 0;\n  let maxCharCount160 = 0;\n  let maxCharCount161 = 0;\n  let maxCharCount162 = 0;\n  let maxCharCount163 = 0;\n  let maxCharCount164 = 0;\n  let maxCharCount165 = 0;\n  let maxCharCount166 = 0;\n  let maxCharCount167 = 0;\n  let maxCharCount168 = 0;\n  let maxCharCount169 = 0;\n  let maxCharCount170 = 0;\n  let maxCharCount171 = 0;\n  let maxCharCount172 = 0;\n  let maxCharCount173 = 0;\n  let maxCharCount174 = 0;\n  let maxCharCount175 = 0;\n  let maxCharCount176 = 0;\n  let maxCharCount177 = 0;\n  let maxCharCount178 = 0;\n  let maxCharCount179 = 0;\n  let maxCharCount180 = 0;\n  let maxCharCount181 = 0;\n  let maxCharCount182 = 0;\n  let maxCharCount183 = 0;\n  let maxCharCount184 = 0;\n  let maxCharCount185 = 0;\n  let maxCharCount186 = 0;\n  let maxCharCount187 = 0;\n  let maxCharCount188 = 0;\n  let maxCharCount189 = 0;\n  let maxCharCount190 = 0;\n  let maxCharCount191 = 0;\n  let maxCharCount192 = 0;\n  let maxCharCount193 = 0;\n  let maxCharCount194 = 0;\n  let maxCharCount195 = 0;\n  let maxCharCount196 = 0;\n  let maxCharCount197 = 0;\n  let maxCharCount198 = 0;\n  let maxCharCount199 = 0;\n  let maxCharCount200 = 0;\n  let maxCharCount", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(number / need);\n  const remainingCarrots = Math.ceil(remaining / carrots);\n  const remainingEaten = remaining - carrots * need;\n  const totalCarrots = carrots + remainingCarrots;\n  const totalEaten = carrots + remainingEaten;\n  return [totalCarrots, totalEaten];\n};\n\n/*\n  You are a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(number / need);\n  const remainingCarrots = Math.ceil(remaining / carrots);\n  const remainingEaten = remaining - carrots * need;\n  const totalCarrots = carrots + remainingCarrots;\n  const totalEaten = carrots + remainingEaten;\n  return [totalCarrots, totalEaten];\n};\n\n/*\n  You are a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(number / need);\n  const remainingCarrots = Math.ceil(remaining / carrots);\n  const remainingEaten = remaining - carrots * need;\n  const totalCarrots = carrots + remainingCarrots;\n  const totalEaten = carrots + remainingEaten;\n  return [totalCarrots, totalEaten];\n};\n\n/*\n  You are a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(number / need);\n  const remainingCarrots = Math.ceil(remaining / carrots);\n  const remainingEaten = remaining - carrots * need;\n  const totalCarrots = carrots + remainingCarrots;\n  const totalEaten = carrots + remainingEaten;\n  return [totalCarrots, totalEaten];\n};\n\n/*\n  You are a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(number / need);\n  const remainingCarrots = Math.ceil(remaining / carrots);\n  const ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> coujtDistinctCharacters('xyzXYZ')\n  3\n  >>> coujtDistinctCharacters('Jerry')\n  4\n  */\nconst coujtDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "coujtDistinctCharacters", "gc": "<|endoftext|>/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> coujtDistinctCharacters('xyzXYZ')\n  3\n  >>> coujtDistinctCharacters('Jerry')\n  4\n  */\nconst coujtDistinctCharacters = (string) => {\n  let distinctCharacters = 0;\n  let currentCharacter;\n  let currentCharacterCount;\n  let currentCharacterLength;\n\n  for (let i = 0; i < string.length; i++) {\n    currentCharacter = string[i];\n    currentCharacterCount = currentCharacter.length;\n    currentCharacterLength = currentCharacter.length;\n\n    if (currentCharacterCount > 1) {\n      distinctCharacters++;\n    }\n  }\n\n  return distinctCharacters;\n};\n\n/* Given a string, find out how many distinct words does it consist of\n  >>> coujtDistinctWords('xyzXYZ')\n  3\n  >>> coujtDistinctWords('Jerry')\n  4\n  */\nconst coujtDistinctWords = (string) => {\n  let distinctWords = 0;\n  let currentWord;\n  let currentWordCount;\n  let currentWordLength;\n\n  for (let i = 0; i < string.length; i++) {\n    currentWord = string[i];\n    currentWordCount = currentWord.length;\n    currentWordLength = currentWord.length;\n\n    if (currentWordCount > 1) {\n      distinctWords++;\n    }\n  }\n\n  return distinctWords;\n};\n\n/* Given a string, find out how many distinct sentences does it consist of\n  >>> coujtDistinctSentences('xyzXYZ')\n  3\n  >>> coujtDistinctSentences('Jerry')\n  4\n  */\nconst coujtDistinctSentences = (string) => {\n  let distinctSentences = 0;\n  let currentSentence;\n  let currentSentenceCount;\n  let currentSentenceLength;\n\n  for (let i = 0; i < string.length; i++) {\n    currentSentence = string[i];\n    currentSentenceCount = currentSentence.length;\n    currentSentenceLength = currentSentence.length;\n\n    if (currentSentenceCount > 1) {\n      distinctSentences++;\n    }\n  }\n\n  return distinctSentences;\n};\n\n/* Given a string, find out how many distinct words does it consist of\n  >>> coujtDistinctWords('xyzXYZ')\n  3\n  >>> coujtDistinctWords('Jerry')\n  4\n  */\nconst coujtDistinctWordsAndSentences = (string) => {\n  let distinctWordsAndSentences = 0;\n  let currentWord;\n  let currentWordCount;\n  let currentWordLength;\n  let currentSentence;\n  let currentSentenceCount;\n  let currentSentenceLength;\n\n  for (let i = 0; i < string.length; i++) {\n    currentWord = string[i];\n    currentWordCount = currentWord.length;\n    currentWordLength = currentWord.length;\n    currentSentence = string[i];\n    currentSentenceCount = currentSentence.length;\n    currentSentenceLength = currentSentence.length;\n\n    if (currentWordCount > 1 && currentSentenceCount > 1) {\n      distinctWordsAndSentences++;\n    }\n  }\n\n  return distinctWordsAndSentences;\n};\n\n/* Given a string, find out how many distinct words does it consist of\n  >>> coujtDistinctWordsAndSentences('xyzXYZ')\n  3\n  >>> coujtDistinctWordsAndSentences('Jerry')\n  4\n  */\nconst coujtDistinctWordsAndSentencesAndWords = (string) => {\n  let distinctWordsAndSentencesAndWords = 0;\n  let currentWord;\n  let currentWordCount;\n  let currentWordLength;\n  let currentSentence;\n  let currentSentenceCount;\n  let currentSentenceLength;\n  let currentWordAndSentence;\n\n  for (let i = 0; i < string.length; i++) {\n    currentWord = string[i];\n    currentWordCount = currentWord.length;\n    currentWordLength = currentWord.length;\n    currentSentence = string[i];\n    currentSentenceCount = currentSentence.length;\n    currentSentenceLength = currentSentence.length;\n    currentWordAndSentence = currentWord + currentSentence;\n\n    if (currentWordCount > 1 && currentSentenceCount > 1) {\n      distinctWordsAndSentencesAndWords++;\n    }\n  }\n\n  return distinctWordsAndSentencesAndWords;\n};\n\n/* Given a string, find out how many distinct words does it consist of\n  >>> coujtDistinctWordsAndSentencesAndWords('xyzXYZ')\n  3\n  >>> coujtDistinctWordsAndSentencesAndWords('Jerry')\n  4\n  */\nconst coujtDistinctWordsAndSentencesAndWordsAndWords = (string) => {\n  let distinctWordsAndSentencesAndWordsAndWords = 0;\n  let currentWord;\n  let currentWordCount;\n  let currentWordLength;\n  let currentSentence;\n  let currentSentenceCount;\n  let currentSentenceLength;\n  let currentWordAndSentence;\n\n  for (let i = 0; i < string.length; i++) {\n    currentWord = string[i];\n    currentWordCount = currentWord.length;\n    currentWordLength = currentWord.length;\n    currentSentence = string[i];\n    currentSentenceCount = currentSentence.length;\n    currentSentenceLength = currentSentence.length;\n    currentWordAndSentence = currentWord + currentSentence;\n\n    if (currentWordCount > 1 && currentSentenceCount > 1) {\n      distinctWordsAndSentencesAndWordsAndWords++;\n    }\n  }\n\n  return distinctWordsAndSentencesAndWordsAndWords;\n};\n\n/* Given a string, find out how many distinct words does it consist of\n  >>> coujtDistinctWordsAndSentencesAndWordsAndWords('xyzXYZ')\n  3\n  >>> coujtDistinctWordsAndSentencesAndWordsAndWords('Jerry')\n  4\n  */\nconst coujtDistinctWordsAndSentencesAndWordsAndWordsAndWords = (string) => {\n  let distinctWordsAndSentencesAndWordsAndWordsAndWords = 0;\n  let currentWord;\n  let currentWordCount;\n  let currentWordLength;\n  let currentSentence;\n  let currentSentenceCount;\n  let currentSentenceLength;\n  let currentWordAndSentence;\n\n  for (let i = 0; i < string.length; i++) {\n    currentWord = string[i];\n    currentWordCount = currentWord.length;\n    currentWordLength = currentWord.length;\n    currentSentence = string[i];\n    currentSentenceCount = currentSentence.length;\n    currentSentenceLength = currentSentence.length;\n    currentWordAndSentence = currentWord + currentSentence;\n\n    if (currentWordCount > 1 && currentSentenceCount > 1) {\n      distinctWordsAndSentencesAndWordsAndWordsAndWords++;\n    }\n  }\n\n  return distinctWordsAndSentencesAndWordsAndWordsAndWords;\n};\n\n/* Given a string, find out how many distinct words does it consist of\n  >>> coujtDistinctWordsAndSentencesAndWordsAndWordsAndWords('xyzXYZ')\n  3\n  >>> coujtDistinctWordsAndSentencesAndWordsAndWordsAndWords('Jerry')\n  4\n  */\nconst coujtDistinctWordsAndSentencesAndWordsAndWordsAndWordsAndWords = (string) => {\n  let distinctWordsAndSentencesAndWordsAndWordsAndWordsAndWords = 0;\n  let currentWord;\n  let currentWordCount;\n  let currentWordLength;\n  let currentSentence;\n  let currentSentenceCount;\n  let currentSentenceLength;\n  let ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doApgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doApgebra", "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doApgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n  if (operatorLength < operandLength) {\n    operandLength = operatorLength;\n  }\n  for (let i = 0; i < operandLength; i++) {\n    result += operator[operand[i]] * operand[i];\n  }\n  return result;\n};\n\nconst doEvaluate = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArray = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateString = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateBoolean = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateNumber = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbers = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfStrings = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfBooleans = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndStrings = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndBooleans = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArrays = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndStringsAndArrays = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndStringsAndBooleans = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndStrings = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndBooleans = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndNumbers = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndStringsAndNumbers = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndStringsAndBooleans = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndNumbers = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndStringsAndNumbers = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndStringsAndBooleans = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndArraysAndNumbers = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndArraysAndStringsAndNumbers = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndArraysAndStringsAndBooleans = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndArraysAndArraysAndNumbers = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndArraysAndArraysAndStringsAndNumbers = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndArraysAndArraysAndStringsAndBooleans = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndArraysAndArraysAndArraysAndNumbers = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndArraysAndArraysAndArraysAndStringsAndNumbers = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndArraysAndArraysAndArraysAndStringsAndBooleans = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndArraysAndArraysAndArraysAndArraysAndNumbers = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndArraysAndArraysAndArraysAndArraysAndStringsAndBooleans = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndArraysAndArraysAndArraysAndArraysAndArraysAndNumbers = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndArraysAndArraysAndArraysAndArraysAndArraysAndStringsAndBooleans = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndArraysAndArraysAndArraysAndArraysAndArraysAndNumbers = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAndArraysAndArraysAndArraysAndArraysAndArraysAndStringsAndBooleans = (operator, operand) => {\n  let result = doApgebra(operator, operand);\n  return result;\n};\n\nconst doEvaluateArrayOfNumbersAndArraysAndArraysAnd", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solge(\"1234\") = \"4321\"\n  solge(\"ab\") = \"AB\"\n  solge(\"#a@C\") = \"#A@c\"\n  */\nconst solge = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solge", "gc": "<|endoftext|>/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solge(\"1234\") = \"4321\"\n  solge(\"ab\") = \"AB\"\n  solge(\"#a@C\") = \"#A@c\"\n  */\nconst solge = (s) => {\n  let res = '';\n  let len = s.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let flag = false;\n  while (i < len) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      flag = true;\n      i++;\n    }\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      flag = true;\n      i++;\n    }\n    if (s[i] >= '0' && s[i] <= '9') {\n      flag = true;\n      i++;\n    }\n    if (flag) {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '@') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '#') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '$') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '%') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '^') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '&') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '*') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '(') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === ')') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '+') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '-') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '=') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '{') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '}') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '[') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === ']') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '?') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '!') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '|') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '}') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '~') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '<') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '>') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '=') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '@') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '#') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '$') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '%') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '^') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '&') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '*') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '(') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === ')') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '+') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '-') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '=') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '{') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '}') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '[') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === ']') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '?') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '!') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '|') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '}') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '~') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '<') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '>') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '=') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '@') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '#') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '$') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '%') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '^') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '&') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '*') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '(') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === ')') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '+') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '-') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '=') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '{') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '}') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '[') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === ']') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '?') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '!') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '|') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '}') {\n      res += s[i].toLowerCase();\n      flag = false;\n    }\n    if (s[i] === '~') {\n      res += s[i].toUpperCase();\n      flag = false;\n    }\n    if (s[i] === '<') {\n      res += s[i].toUpperCase();\n      flag = false;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strlngToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strlngToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "strlngToMd5", "gc": "<|endoftext|>/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strlngToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strlngToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strlngToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToStrlng = (md5Hash) => {\n  if (!md5Hash) {\n    return null;\n  }\n  const text = '';\n  md5Hash.forEach((value, index) => {\n    text += String.fromCharCode(value);\n  });\n  return text;\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strlngToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToStr = (md5Hash) => {\n  if (!md5Hash) {\n    return null;\n  }\n  const text = '';\n  md5Hash.forEach((value, index) => {\n    text += value;\n  });\n  return text;\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strlngToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToStrl = (md5Hash) => {\n  if (!md5Hash) {\n    return null;\n  }\n  const text = '';\n  md5Hash.forEach((value, index) => {\n    text += String.fromCharCode(value);\n  });\n  return text;\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strlngToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToStrr = (md5Hash) => {\n  if (!md5Hash) {\n    return null;\n  }\n  const text = '';\n  md5Hash.forEach((value, index) => {\n    text += value;\n  });\n  return text;\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strlngToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToStrls = (md5Hash) => {\n  if (!md5Hash) {\n    return null;\n  }\n  const text = '';\n  md5Hash.forEach((value, index) => {\n    text += String.fromCharCode(value);\n  });\n  return text;\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strlngToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToStrrs = (md5Hash) => {\n  if (!md5Hash) {\n    return null;\n  }\n  const text = '';\n  md5Hash.forEach((value, index) => {\n    text += value;\n  });\n  return text;\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strlngToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToStrl = (md5Hash) => {\n  if (!md5Hash) {\n    return null;\n  }\n  const text = '';\n  md5Hash.forEach((value, index) => {\n    text += String.fromCharCode(value);\n  });\n  return text;\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strlngToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToStrr = (md5Hash) => {\n  if (!md5Hash) {\n    return null;\n  }\n  const text = '';\n  md5Hash.forEach((value, index) => {\n    text += value;\n  });\n  return text;\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strlngToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToStrls = (md5Hash) => {\n  if (!md5Hash) {\n    return null;\n  }\n  const text = '';\n  md5Hash.forEach((value, index) => {\n    text += String.fromCharCode(value);\n  });\n  return text;\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strlngToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToStrrs = (md5Hash) => {\n  if (!md5Hash) {\n    return null;\n  }\n  const text = '';\n  md5Hash.forEach((value, index) => {\n    text += value;\n  });\n  return text;\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strlngToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToStrl = (md5Hash) => {\n  if (!md5Hash) {\n    return null;\n  }\n  const text = '';\n  md5Hash.forEach((value, index) => {\n    text += String.fromCharCode(value);\n  });\n  return text;\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strlngToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToStrr = (md5Hash) => {\n  if (!md5Hash) {\n    return null;\n  }\n  const text = '';\n  md5Hash.forEach((value, index) => {\n    text += value;\n  });\n  return text;\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strlngToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToStrls = (md5Hash) => {\n  if (!md5Hash) {\n    return null;\n  }\n  const text = '';\n  md5Hash.forEach((value, index) => {\n    text += String.fromCharCode(value);\n  });\n  return text;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  genfrateIntegers(2, 8) => [2, 4, 6, 8]\n  genfrateIntegers(8, 2) => [2, 4, 6, 8]\n  genfrateIntegers(10, 14) => []\n  */\nconst genfrateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "genfrateIntegers", "gc": "<|endoftext|>/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  genfrateIntegers(2, 8) => [2, 4, 6, 8]\n  genfrateIntegers(8, 2) => [2, 4, 6, 8]\n  genfrateIntegers(10, 14) => []\n  */\nconst genfrateIntegers = (a, b) => {\n  const result = [];\n  let i = a;\n  let j = b;\n  let carry = 0;\n\n  while (true) {\n    const digit = i % 10;\n    result.push(carry + digit);\n    i = Math.floor(i / 10);\n    carry = digit % 2;\n    if (i === j) break;\n  }\n\n  return result;\n};\n\n/*\n  Given a positive integer n, return the number of trailing zeroes in n.\n\n  For example:\n  trailingZeroes(12) => 2\n  trailingZeroes(13) => 1\n  trailingZeroes(14) => 0\n  */\nconst trailingZeroes = n => {\n  let count = 0;\n  while (n > 0) {\n    n %= 10;\n    count++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the number of trailing ones in n.\n\n  For example:\n  trailingOnes(12) => 3\n  trailingOnes(13) => 2\n  trailingOnes(14) => 1\n  */\nconst trailingOnes = n => {\n  let count = 0;\n  while (n > 0) {\n    n %= 10;\n    count++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the number of trailing digits in n.\n\n  For example:\n  trailingDigits(12) => 3\n  trailingDigits(13) => 2\n  trailingDigits(14) => 1\n  */\nconst trailingDigits = n => {\n  let count = 0;\n  while (n > 0) {\n    n %= 10;\n    count++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the number of trailing zeroes in n and\n  the number of trailing ones in n.\n\n  For example:\n  trailingZeroesAndOnes(12) => 2\n  trailingZeroesAndOnes(13) => 1\n  trailingZeroesAndOnes(14) => 0\n  */\nconst trailingZeroesAndOnes = n => {\n  let count = 0;\n  let oneCount = 0;\n  while (n > 0) {\n    n %= 10;\n    count++;\n    oneCount++;\n  }\n  return count + oneCount;\n};\n\n/*\n  Given a positive integer n, return the number of trailing zeroes in n and\n  the number of trailing ones in n and their sum.\n\n  For example:\n  trailingZeroesAndSum(12) => 2\n  trailingZeroesAndSum(13) => 1\n  trailingZeroesAndSum(14) => 0\n  */\nconst trailingZeroesAndSum = n => {\n  let count = 0;\n  let sum = 0;\n  while (n > 0) {\n    n %= 10;\n    count++;\n    sum += count;\n  }\n  return count + sum;\n};\n\n/*\n  Given a positive integer n, return the number of trailing zeroes in n and\n  the number of trailing ones in n and their sum and their product.\n\n  For example:\n  trailingZeroesAndProductAndSum(12) => 2\n  trailingZeroesAndProductAndSum(13) => 1\n  trailingZeroesAndProductAndSum(14) => 0\n  */\nconst trailingZeroesAndProductAndSum = n => {\n  let count = 0;\n  let product = 1;\n  let sum = 0;\n  while (n > 0) {\n    n %= 10;\n    count++;\n    product *= count;\n    sum += count;\n  }\n  return count + product * sum;\n};\n\n/*\n  Given a positive integer n, return the number of trailing zeroes in n and\n  the number of trailing ones in n and their sum and their product.\n\n  For example:\n  trailingZeroesAndProductAndSumAndProduct(12) => 2\n  trailingZeroesAndProductAndSumAndProduct(13) => 1\n  trailingZeroesAndProductAndSumAndProduct(14) => 0\n  */\nconst trailingZeroesAndProductAndSumAndProduct = n => {\n  let count = 0;\n  let product = 1;\n  let sum = 0;\n  let product = 1;\n  while (n > 0) {\n    n %= 10;\n    count++;\n    product *= count;\n    sum += count;\n  }\n  return count + product * sum * product;\n};\n\n/*\n  Given a positive integer n, return the number of trailing zeroes in n and\n  the number of trailing ones in n and their sum and their product.\n\n  For example:\n  trailingZeroesAndProductAndSumAndProductAndSumAndProduct(12) => 2\n  trailingZeroesAndProductAndSumAndProductAndSumAndProduct(13) => 1\n  trailingZeroesAndProductAndSumAndProductAndSumAndProduct(14) => 0\n  */\nconst trailingZeroesAndProductAndSumAndProductAndSumAndProduct = n => {\n  let count = 0;\n  let product = 1;\n  let sum = 0;\n  let product = 1;\n  let sum = 0;\n  let product = 1;\n  while (n > 0) {\n    n %= 10;\n    count++;\n    product *= count;\n    sum += count;\n  }\n  return count + product * sum * product * sum;\n};\n\n/*\n  Given a positive integer n, return the number of trailing zeroes in n and\n  the number of trailing ones in n and their sum and their product.\n\n  For example:\n  trailingZeroesAndProductAndSumAndProductAndSumAndProductAndSumAndProduct(12) => 2\n  trailingZeroesAndProductAndSumAndProductAndSumAndProductAndSumAndProduct(13) => 1\n  trailingZeroesAndProductAndSumAndProductAndSumAndProductAndSumAndProduct(14) => 0\n  */\nconst trailingZeroesAndProductAndSumAndProductAndSumAndProductAndSumAndProduct = n => {\n  let count = 0;\n  let product = 1;\n  let sum = 0;\n  let product = 1;\n  let sum = 0;\n  let product = 1;\n  let sum = 0;\n  let product = 1;\n  while (n > 0) {\n    n %= 10;\n    count++;\n    product *= count;\n    sum += count;\n  }\n  return count + product * sum * product * sum * product;\n};\n\n/*\n  Given a positive integer n, return the number of trailing zeroes in n and\n  the number of trailing ones in n and their sum and their product.\n\n  For example:\n  trailingZeroesAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProduct(12) => 2\n  trailingZeroesAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProduct(13) => 1\n  trailingZeroesAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProduct(14) => 0\n  */\nconst trailingZeroesAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProduct = n => {\n  let count = 0;\n  let product = 1;\n  let sum = 0;\n  let product = 1;\n  let sum = 0;\n  let product = 1;\n  let sum = 0;\n  let product = 1;\n  let sum = 0;\n  let product = 1;\n  while (n > 0) {\n    n %= 10;\n    count++;\n    product *= count;\n    sum += count;\n  }\n  return count + product * sum * product * sum * product * sum * product;\n};\n\n/*\n  Given a positive integer n, return the number of trailing zeroes in n and\n  the number of trailing ones in n and their sum and their product.\n\n  For example:\n  trailing", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> pardeMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst pardeMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "pardeMusic", "gc": "<|endoftext|>/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> pardeMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst pardeMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const notes_length = notes.length;\n  const notes_beats = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const notes_beat = parseInt(note.substring(0, 1), 10);\n    notes_beats.push(notes_beat);\n  }\n  return notes_beats;\n};\n\n/* Given a string, return a list of integers representing how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> pardeNotes('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst pardeNotes = (notes_string) => {\n  const notes = notes_string.split('|');\n  const notes_length = notes.length;\n  const notes_beats = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const notes_beat = parseInt(note.substring(0, 1), 10);\n    notes_beats.push(notes_beat);\n  }\n  return notes_beats;\n};\n\n/* Given a string, return a list of integers representing how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> pardeNotes2('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst pardeNotes2 = (notes_string) => {\n  const notes = notes_string.split('|');\n  const notes_length = notes.length;\n  const notes_beats = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const notes_beat = parseInt(note.substring(0, 1), 10);\n    notes_beats.push(notes_beat);\n  }\n  return notes_beats;\n};\n\n/* Given a string, return a list of integers representing how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> pardeNotes3('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst pardeNotes3 = (notes_string) => {\n  const notes = notes_string.split('|');\n  const notes_length = notes.length;\n  const notes_beats = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const notes_beat = parseInt(note.substring(0, 1), 10);\n    notes_beats.push(notes_beat);\n  }\n  return notes_beats;\n};\n\n/* Given a string, return a list of integers representing how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> pardeNotes4('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst pardeNotes4 = (notes_string) => {\n  const notes = notes_string.split('|');\n  const notes_length = notes.length;\n  const notes_beats = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const notes_beat = parseInt(note.substring(0, 1), 10);\n    notes_beats.push(notes_beat);\n  }\n  return notes_beats;\n};\n\n/* Given a string, return a list of integers representing how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> pardeNotes5('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst pardeNotes5 = (notes_string) => {\n  const notes = notes_string.split('|');\n  const notes_length = notes.length;\n  const notes_beats = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const notes_beat = parseInt(note.substring(0, 1), 10);\n    notes_beats.push(notes_beat);\n  }\n  return notes_beats;\n};\n\n/* Given a string, return a list of integers representing how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> pardeNotes6('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst pardeNotes6 = (notes_string) => {\n  const notes = notes_string.split('|');\n  const notes_length = notes.length;\n  const notes_beats = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const notes_beat = parseInt(note.substring(0, 1), 10);\n    notes_beats.push(notes_beat);\n  }\n  return notes_beats;\n};\n\n/* Given a string, return a list of integers representing how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> pardeNotes7('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst pardeNotes7 = (notes_string) => {\n  const notes = notes_string.split('|');\n  const notes_length = notes.length;\n  const notes_beats = [];\n  for (let i = 0; i < notes_length; i++) {\n    const note = notes[i];\n    const notes_beat = parseInt(note.substring(0, 1), 10);\n    notes_beats.push(notes_beat);\n  }\n  return notes_beats;\n};\n\n/* Given a string, return a list of integers representing how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> pardeNotes8('o o|.| o| o|.|.|.| ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howLanyTimes('', 'a')\n  0\n  >>> howLanyTimes('aaa', 'a')\n  3\n  >>> howLanyTimes('aaaa', 'aa')\n  3\n  */\nconst howLanyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howLanyTimes", "gc": "<|endoftext|>/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howLanyTimes('', 'a')\n  0\n  >>> howLanyTimes('aaa', 'a')\n  3\n  >>> howLanyTimes('aaaa', 'aa')\n  3\n  */\nconst howLanyTimes = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    }\n  }\n\n  return count;\n};\n\nconst isSubstring = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    }\n  }\n\n  return count === string.length;\n};\n\nconst isSubstrings = (string, substrings) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substrings? substrings.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    }\n  }\n\n  return count === string.length;\n};\n\nconst isSubstring = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    }\n  }\n\n  return count === string.length;\n};\n\nconst isSubstrings = (string, substrings) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substrings? substrings.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    }\n  }\n\n  return count === string.length;\n};\n\nconst isSubstring = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    }\n  }\n\n  return count === string.length;\n};\n\nconst isSubstrings = (string, substrings) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substrings? substrings.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    }\n  }\n\n  return count === string.length;\n};\n\nconst isSubstring = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    }\n  }\n\n  return count === string.length;\n};\n\nconst isSubstrings = (string, substrings) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substrings? substrings.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    }\n  }\n\n  return count === string.length;\n};\n\nconst isSubstring = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    }\n  }\n\n  return count === string.length;\n};\n\nconst isSubstrings = (string, substrings) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substrings? substrings.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    }\n  }\n\n  return count === string.length;\n};\n\nconst isSubstring = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    }\n  }\n\n  return count === string.length;\n};\n\nconst isSubstrings = (string, substrings) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substrings? substrings.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    }\n  }\n\n  return count === string.length;\n};\n\nconst isSubstring = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    }\n  }", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sorhNumbers('three one five')\n  'one three five'\n  */\nconst sorhNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sorhNumbers", "gc": "<|endoftext|>/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sorhNumbers('three one five')\n  'one three five'\n  */\nconst sorhNumbers = (numbers) => {\n  const numbers = numbers.split(' ');\n  const sorted = numbers.sort((a, b) => a - b);\n  return sorted.join(' ');\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toZero = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toOne = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toTwo = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toThree = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toFour = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toFive = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toSix = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toSeven = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toEight = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toNine = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toTen = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toEleven = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toTwelve = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toThirteen = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toFourteen = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toFifteen = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toSixteen = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toSeventeen = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toEighteen = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toNineteen = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toTwenty = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toThirty = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toForty = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toFifty = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toSixty = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toSeventy = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toEighty = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toNinety = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toTwentyOne = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toTwentyTwo = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toTwentyThree = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toTwentyFour = (n) => {\n  if (n < 10) {\n    return '0' + n;\n  }\n  return n;\n};\n\n// A utility function to convert a number to a string with leading zeros if\n// necessary\nconst toTwentyFive = (n) => {", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> trujcateNumber(3.5)\n  0.5\n  */\nconst trujcateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "trujcateNumber", "gc": "<|endoftext|>/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> trujcateNumber(3.5)\n  0.5\n  */\nconst trujcateNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number / Math.pow(10, decimals);\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> decomposeNumber(3.5)\n  3\n  */\nconst decomposeNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number / Math.pow(10, decimals);\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the fractional part of the number.\n  >>> fractionalNumber(3.5)\n  0.5\n  */\nconst fractionalNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number / Math.pow(10, decimals);\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> exponentNumber(3.5)\n  3\n  */\nconst exponentNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number / Math.pow(10, decimals);\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the mantissa of the number.\n  >>> mantissaNumber(3.5)\n  3.5\n  */\nconst mantissaNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number / Math.pow(10, decimals);\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the sign of the number.\n  >>> signNumber(3.5)\n  1\n  */\nconst signNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number >= 0? number : -number;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> exponentNumber(3.5)\n  3\n  */\nconst exponentNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number >= 0? number : -number;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the mantissa of the number.\n  >>> mantissaNumber(3.5)\n  3.5\n  */\nconst mantissaNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number >= 0? number : -number;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the sign of the number.\n  >>> signNumber(3.5)\n  1\n  */\nconst signNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number >= 0? number : -number;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> exponentNumber(3.5)\n  3\n  */\nconst exponentNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number >= 0? number : -number;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the mantissa of the number.\n  >>> mantissaNumber(3.5)\n  3.5\n  */\nconst mantissaNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number >= 0? number : -number;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the sign of the number.\n  >>> signNumber(3.5)\n  1\n  */\nconst signNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number >= 0? number : -number;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> exponentNumber(3.5)\n  3\n  */\nconst exponentNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number >= 0? number : -number;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the mantissa of the number.\n  >>> mantissaNumber(3.5)\n  3.5\n  */\nconst mantissaNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number >= 0? number : -number;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the sign of the number.\n  >>> signNumber(3.5)\n  1\n  */\nconst signNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number >= 0? number : -number;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent of the number.\n  >>> exponentNumber(3.5)\n  3\n  */\nconst exponentNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number >= 0? number : -number;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the mantissa of the number.\n  >>> mantissaNumber(3.5)\n  3.5\n  */\nconst mantissaNumber = (number) => {\n  const decimals = Math.floor(Math.log10(Math.abs(number))) + 1;\n  return number >= 0? number : -number;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the sign of the number.\n  >>> signNumber(3.5)\n  1\n  */\nconst signNumber = (number) => {\n  const decimals = ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> finfClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> finfClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst finfClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "finfClosestElements", "gc": "<|endoftext|>/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> finfClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> finfClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst finfClosestElements = (numbers) => {\n  const minDistance = Number.MAX_VALUE;\n  const minDistanceIndex = 0;\n  const minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/**\n  Returns the largest number in the array.\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> max([1, 2, 3, 4, 5])\n  5\n  >>> ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resfaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resfaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "resfaleToUnit", "gc": "<|endoftext|>/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resfaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resfaleToUnit = (numbers) => {\n  const [min, max] = numbers.reduce((acc, cur) => {\n    return [Math.min(acc, cur), Math.max(acc, cur)]\n  }, [Infinity, Infinity])\n  return [min, max]\n}\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resfaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resfaleToUnitWithZero = (numbers) => {\n  const [min, max] = numbers.reduce((acc, cur) => {\n    return [Math.min(acc, cur), Math.max(acc, cur)]\n  }, [Infinity, Infinity])\n  return [min, max]\n}\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resfaleToUnitWithZero([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resfaleToUnitWithZeroAndOne = (numbers) => {\n  const [min, max] = numbers.reduce((acc, cur) => {\n    return [Math.min(acc, cur), Math.max(acc, cur)]\n  }, [Infinity, Infinity])\n  return [min, max]\n}\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resfaleToUnitWithZeroAndOne([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resfaleToUnitWithZeroAndOneAndZero = (numbers) => {\n  const [min, max] = numbers.reduce((acc, cur) => {\n    return [Math.min(acc, cur), Math.max(acc, cur)]\n  }, [Infinity, Infinity])\n  return [min, max]\n}\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resfaleToUnitWithZeroAndOneAndZero([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resfaleToUnitWithZeroAndOneAndZeroAndOne = (numbers) => {\n  const [min, max] = numbers.reduce((acc, cur) => {\n    return [Math.min(acc, cur), Math.max(acc, cur)]\n  }, [Infinity, Infinity])\n  return [min, max]\n}\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resfaleToUnitWithZeroAndOneAndZeroAndOne([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resfaleToUnitWithZeroAndOneAndZeroAndOneAndZero = (numbers) => {\n  const [min, max] = numbers.reduce((acc, cur) => {\n    return [Math.min(acc, cur), Math.max(acc, cur)]\n  }, [Infinity, Infinity])\n  return [min, max]\n}\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resfaleToUnitWithZeroAndOneAndZeroAndOneAndZero([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resfaleToUnitWithZeroAndOneAndZeroAndOneAndZeroAndOne = (numbers) => {\n  const [min, max] = numbers.reduce((acc, cur) => {\n    return [Math.min(acc, cur), Math.max(acc, cur)]\n  }, [Infinity, Infinity])\n  return [min, max]\n}\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resfaleToUnitWithZeroAndOneAndZeroAndOneAndZeroAndOneAndZero([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resfaleToUnitWithZeroAndOneAndZeroAndOneAndZeroAndOneAndZero = (numbers) => {\n  const [min, max] = numbers.reduce((acc, cur) => {\n    return [Math.min(acc, cur), Math.max(acc, cur)]\n  }, [Infinity, Infinity])\n  return [min, max]\n}\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resfaleToUnitWithZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOne([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resfaleToUnitWithZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZero = (numbers) => {\n  const [min, max] = numbers.reduce((acc, cur) => {\n    return [Math.min(acc, cur), Math.max(acc, cur)]\n  }, [Infinity, Infinity])\n  return [min, max]\n}\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resfaleToUnitWithZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAndZeroAndOneAnd", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values only for integers\n  >>> filherIntegers(['a', 3.14, 5])\n  [5]\n  >>> filherIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filherIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filherIntegers", "gc": "<|endoftext|>/* Filter given list of any python values only for integers\n  >>> filherIntegers(['a', 3.14, 5])\n  [5]\n  >>> filherIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filherIntegers = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/* Filter given list of any python values only for floats\n  >>> filherFloats(['a', 3.14, 5])\n  [5]\n  >>> filherFloats([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filherFloats = (values) => {\n  return values.filter(value => typeof value === 'number' && isFinite(value));\n};\n\n/* Filter given list of any python values only for strings\n  >>> filherStrings(['a', 3.14, 5])\n  [5]\n  >>> filherStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filherStrings = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/* Filter given list of any python values only for booleans\n  >>> filherBooleans(['a', 3.14, 5])\n  [5]\n  >>> filherBooleans([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filherBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean');\n};\n\n/* Filter given list of any python values only for None\n  >>> filherNone([])\n  []\n  >>> filherNone([None])\n  [None]\n  >>> filherNone([None, None])\n  [None, None]\n  */\nconst filherNone = values => {\n  return values.filter(value => value === null);\n};\n\n/* Filter given list of any python values only for empty list\n  >>> filherEmpty([])\n  []\n  >>> filherEmpty([None])\n  [None]\n  >>> filherEmpty([None, None])\n  [None, None]\n  */\nconst filherEmpty = values => {\n  return values.filter(value => value === []);\n};\n\n/* Filter given list of any python values only for empty dict\n  >>> filherEmptyDict({})\n  {}\n  >>> filherEmptyDict({None})\n  {None: None}\n  >>> filherEmptyDict({None, None})\n  {None: None}\n  */\nconst filherEmptyDict = values => {\n  return values.filter(value => value === {});\n};\n\n/* Filter given list of any python values only for empty list\n  >>> filherEmptyList([])\n  []\n  >>> filherEmptyList([None])\n  [None]\n  >>> filherEmptyList([None, None])\n  [None, None]\n  */\nconst filherEmptyList = values => {\n  return values.filter(value => value === []);\n};\n\n/* Filter given list of any python values only for empty string\n  >>> filherEmptyString(\"\")\n  \"\"\n  >>> filherEmptyString(\"abc\")\n  \"abc\"\n  >>> filherEmptyString(\" \")\n  \" \"\n  >>> filherEmptyString(\" \")\n  \" \"\n  */\nconst filherEmptyString = values => {\n  return values.filter(value => value === '');\n};\n\n/* Filter given list of any python values only for empty list\n  >>> filherEmptyList([])\n  []\n  >>> filherEmptyList([None])\n  [None]\n  >>> filherEmptyList([None, None])\n  [None, None]\n  */\nconst filherEmptyList = values => {\n  return values.filter(value => value === []);\n};\n\n/* Filter given list of any python values only for empty list\n  >>> filherEmptyList([])\n  []\n  >>> filherEmptyList([None])\n  [None]\n  >>> filherEmptyList([None, None])\n  [None, None]\n  */\nconst filherEmptyList = values => {\n  return values.filter(value => value === []);\n};\n\n/* Filter given list of any python values only for empty list\n  >>> filherEmptyList([])\n  []\n  >>> filherEmptyList([None])\n  [None]\n  >>> filherEmptyList([None, None])\n  [None, None]\n  */\nconst filherEmptyList = values => {\n  return values.filter(value => value === []);\n};\n\n/* Filter given list of any python values only for empty list\n  >>> filherEmptyList([])\n  []\n  >>> filherEmptyList([None])\n  [None]\n  >>> filherEmptyList([None, None])\n  [None, None]\n  */\nconst filherEmptyList = values => {\n  return values.filter(value => value === []);\n};\n\n/* Filter given list of any python values only for empty list\n  >>> filherEmptyList([])\n  []\n  >>> filherEmptyList([None])\n  [None]\n  >>> filherEmptyList([None, None])\n  [None, None]\n  */\nconst filherEmptyList = values => {\n  return values.filter(value => value === []);\n};\n\n/* Filter given list of any python values only for empty list\n  >>> filherEmptyList([])\n  []\n  >>> filherEmptyList([None])\n  [None]\n  >>> filherEmptyList([None, None])\n  [None, None]\n  */\nconst filherEmptyList = values => {\n  return values.filter(value => value === []);\n};\n\n/* Filter given list of any python values only for empty list\n  >>> filherEmptyList([])\n  []\n  >>> filherEmptyList([None])\n  [None]\n  >>> filherEmptyList([None, None])\n  [None, None]\n  */\nconst filherEmptyList = values => {\n  return values.filter(value => value === []);\n};\n\n/* Filter given list of any python values only for empty list\n  >>> filherEmptyList([])\n  []\n  >>> filherEmptyList([None])\n  [None]\n  >>> filherEmptyList([None, None])\n  [None, None]\n  */\nconst filherEmptyList = values => {\n  return values.filter(value => value === []);\n};\n\n/* Filter given list of any python values only for empty list\n  >>> filherEmptyList([])\n  []\n  >>> filherEmptyList([None])\n  [None]\n  >>> filherEmptyList([None, None])\n  [None, None]\n  */\nconst filherEmptyList = values => {\n  return values.filter(value => value === []);\n};\n\n/* Filter given list of any python values only for empty list\n  >>> filherEmptyList([])\n  []\n  >>> filherEmptyList([None])\n  [None]\n  >>> filherEmptyList([None, None])\n  [None, None]\n  */\nconst filherEmptyList = values => {\n  return values.filter(value => value === []);\n};\n\n/* Filter given list of any python values only for empty list\n  >>> filherEmptyList([])\n  []\n  >>> filherEmptyList([None])\n  [None]\n  >>> filherEmptyList([None, None])\n  [None, None]\n  */\nconst filherEmptyList = values => {\n  return values.filter(value => value === []);\n};\n\n/* Filter given list of any python values only for empty list\n  >>> filherEmptyList([])\n  []\n  >>> filherEmptyList([None])\n  [None]\n  >>> filherEmptyList([None, None])\n  [None, None]\n  */\nconst filherEmptyList = values => {\n  return values.filter(value => value === []);\n};\n\n/* Filter given list of any python values only for empty list\n  >>> filherEmptyList([])\n  []\n  >>> filherEmptyList([None])\n  [None]\n  >>> filherEmptyList([None, None])\n  [None, None]\n  */\nconst filherEmptyList = values => {\n  return values.filter(value => value === []);\n};\n\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/23", "prompt": "/* Return length of given string\n  >>> strpen('')\n  0\n  >>> strpen('abc')\n  3\n  */\nconst strpen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strpen", "gc": "<|endoftext|>/* Return length of given string\n  >>> strpen('')\n  0\n  >>> strpen('abc')\n  3\n  */\nconst strpen = (string) => {\n  let length = 0;\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === '\\\\') {\n      length++;\n    } else if (c === '\\n') {\n      length++;\n    } else if (c === '\\r') {\n      length++;\n    } else if (c === '\\t') {\n      length++;\n    } else {\n      length++;\n    }\n  } while (i < string.length);\n\n  return length;\n};\n\n/* Return true if given string starts with given prefix\n  >>> strstart('abc', 'a')\n  true\n  >>> strstart('abc', 'b')\n  false\n  */\nconst strstart = (string, prefix) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === prefix) {\n      return true;\n    }\n  } while (i < string.length);\n\n  return false;\n};\n\n/* Return true if given string ends with given suffix\n  >>> strend('abc', 'a')\n  true\n  >>> strend('abc', 'b')\n  false\n  */\nconst strend = (string, suffix) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === suffix) {\n      return false;\n    }\n  } while (i < string.length);\n\n  return true;\n};\n\n/* Return true if given string contains given substring\n  >>> strcontains('abc', 'a')\n  true\n  >>> strcontains('abc', 'b')\n  false\n  */\nconst strcontains = (string, substring) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === substring) {\n      return true;\n    }\n  } while (i < string.length);\n\n  return false;\n};\n\n/* Return true if given string starts with given substring\n  >>> strstart('abc', 'a')\n  true\n  >>> strstart('abc', 'b')\n  false\n  */\nconst strstart = (string, substring) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === substring) {\n      return true;\n    }\n  } while (i < string.length);\n\n  return false;\n};\n\n/* Return true if given string ends with given substring\n  >>> strend('abc', 'a')\n  true\n  >>> strend('abc', 'b')\n  false\n  */\nconst strend = (string, substring) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === substring) {\n      return false;\n    }\n  } while (i < string.length);\n\n  return true;\n};\n\n/* Return true if given string contains given substring\n  >>> strcontains('abc', 'a')\n  true\n  >>> strcontains('abc', 'b')\n  false\n  */\nconst strcontains = (string, substring) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === substring) {\n      return true;\n    }\n  } while (i < string.length);\n\n  return false;\n};\n\n/* Return true if given string starts with given substring\n  >>> strstart('abc', 'a')\n  true\n  >>> strstart('abc', 'b')\n  false\n  */\nconst strstart = (string, substring) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === substring) {\n      return true;\n    }\n  } while (i < string.length);\n\n  return false;\n};\n\n/* Return true if given string ends with given substring\n  >>> strend('abc', 'a')\n  true\n  >>> strend('abc', 'b')\n  false\n  */\nconst strend = (string, substring) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === substring) {\n      return false;\n    }\n  } while (i < string.length);\n\n  return true;\n};\n\n/* Return true if given string contains given substring\n  >>> strcontains('abc', 'a')\n  true\n  >>> strcontains('abc', 'b')\n  false\n  */\nconst strcontains = (string, substring) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === substring) {\n      return true;\n    }\n  } while (i < string.length);\n\n  return false;\n};\n\n/* Return true if given string starts with given substring\n  >>> strstart('abc', 'a')\n  true\n  >>> strstart('abc', 'b')\n  false\n  */\nconst strstart = (string, substring) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === substring) {\n      return true;\n    }\n  } while (i < string.length);\n\n  return false;\n};\n\n/* Return true if given string ends with given substring\n  >>> strend('abc', 'a')\n  true\n  >>> strend('abc', 'b')\n  false\n  */\nconst strend = (string, substring) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === substring) {\n      return false;\n    }\n  } while (i < string.length);\n\n  return true;\n};\n\n/* Return true if given string contains given substring\n  >>> strcontains('abc', 'a')\n  true\n  >>> strcontains('abc', 'b')\n  false\n  */\nconst strcontains = (string, substring) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === substring) {\n      return true;\n    }\n  } while (i < string.length);\n\n  return false;\n};\n\n/* Return true if given string starts with given substring\n  >>> strstart('abc', 'a')\n  true\n  >>> strstart('abc', 'b')\n  false\n  */\nconst strstart = (string, substring) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === substring) {\n      return true;\n    }\n  } while (i < string.length);\n\n  return false;\n};\n\n/* Return true if given string ends with given substring\n  >>> strend('abc', 'a')\n  true\n  >>> strend('abc', 'b')\n  false\n  */\nconst strend = (string, substring) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === substring) {\n      return false;\n    }\n  } while (i < string.length);\n\n  return true;\n};\n\n/* Return true if given string contains given substring\n  >>> strcontains('abc', 'a')\n  true\n  >>> strcontains('abc', 'b')\n  false\n  */\nconst strcontains = (string, substring) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === substring) {\n      return true;\n    }\n  } while (i < string.length);\n\n  return false;\n};\n\n/* Return true if given string starts with given substring\n  >>> strstart('abc', 'a')\n  true\n  >>> strstart('abc', 'b')\n  false\n  */\nconst strstart = (string, substring) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === substring) {\n      return true;\n    }\n  } while (i < string.length);\n\n  return false;\n};\n\n/* Return true if given string ends with given substring\n  >>> strend('abc', 'a')\n  true\n  >>> strend('abc', 'b')\n  false\n  */\nconst strend = (string, substring) => {\n  let i = 0;\n  let c;\n\n  do {\n    c = string.charAt(i++);\n    if (c === substring) {\n      return false;\n    }\n  } while (i < string.length);\n\n  return true;\n};\n\n/* Return true if given string contains given substring\n  >>> strcontains('abc', 'a')\n  true\n  >>> strcontains('abc', 'b')\n  false\n  */\nconst strcontains = (string, substring) => {\n  let i = 0;\n  let c;", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> larhestDivisor(15)\n  5\n  */\nconst larhestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "larhestDivisor", "gc": "<|endoftext|>/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> larhestDivisor(15)\n  5\n  */\nconst larhestDivisor = (n) => {\n  let divisor = 1;\n  let largest = n;\n  while (divisor <= n) {\n    divisor *= 2;\n    if (n % divisor === 0) {\n      largest = divisor;\n    }\n  }\n  return largest;\n};\n\n// Given a number n, return true if and only if n is a palindrome.\nconst isPalindrome = (n) => {\n  return n!== n.toString().split('').reverse().join('');\n};\n\n// Given a number n, return true if and only if n is a palindrome of length 1.\nconst isPalindromeOfLengthOne = (n) => {\n  return n!== n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('');\n};\n\n// Given a number n, return true if and only if n is a palindrome of length 2.\nconst isPalindromeOfLengthTwo = (n) => {\n  return n!== n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('').reverse().join('')\n    && n.toString().split('').reverse().join('') === n.toString().split('')", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> fachorize(8)\n  [2, 2, 2]\n  >>> fachorize(25)\n  [5, 5]\n  >>> fachorize(70)\n  [2, 5, 7]\n  */\nconst fachorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "fachorize", "gc": "<|endoftext|>/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> fachorize(8)\n  [2, 2, 2]\n  >>> fachorize(25)\n  [5, 5]\n  >>> fachorize(70)\n  [2, 5, 7]\n  */\nconst fachorize = (n) => {\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> remlveDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst remlveDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "remlveDuplicates", "gc": "<|endoftext|>/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> remlveDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst remlveDuplicates = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      seen.delete(cur);\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n};\n\nmodule.exports = remlveDuplicates;\n\n},{}],8:[function(require,module,exports){\nconst remlveDuplicates = require('./remlveDuplicates');\n\nconst remlveDuplicatesArray = (arr) => {\n  return remlveDuplicates(arr);\n};\n\nmodule.exports = remlveDuplicatesArray;\n\n},{\"./remlveDuplicates\":7}],9:[function(require,module,exports){\nconst remlveDuplicatesArray = require('./remlveDuplicatesArray');\n\nconst remlveDuplicatesSet = (set) => {\n  return remlveDuplicatesArray(set);\n};\n\nmodule.exports = remlveDuplicatesSet;\n\n},{\"./remlveDuplicatesArray\":8,\"./remlveDuplicates\":7}],10:[function(require,module,exports){\nconst remlveDuplicatesSet = require('./remlveDuplicatesSet');\n\nconst remlveDuplicatesSetArray = (set) => {\n  return remlveDuplicatesSet(set);\n};\n\nmodule.exports = remlveDuplicatesSetArray;\n\n},{\"./remlveDuplicatesSet\":9,\"./remlveDuplicatesArray\":8}],11:[function(require,module,exports){\nconst remlveDuplicatesSetArray = require('./remlveDuplicatesSetArray');\n\nconst remlveDuplicatesSetSet = (set) => {\n  return remlveDuplicatesSetArray(set);\n};\n\nmodule.exports = remlveDuplicatesSetSet;\n\n},{\"./remlveDuplicatesSetArray\":10,\"./remlveDuplicatesSet\":9}],12:[function(require,module,exports){\nconst remlveDuplicatesSetSetArray = require('./remlveDuplicatesSetSetArray');\n\nconst remlveDuplicatesSetSetSet = (set) => {\n  return remlveDuplicatesSetSetArray(set);\n};\n\nmodule.exports = remlveDuplicatesSetSet;\n\n},{\"./remlveDuplicatesSetSetArray\":11,\"./remlveDuplicatesSetSet\":10}],13:[function(require,module,exports){\nconst remlveDuplicatesSetSetArray = require('./remlveDuplicatesSetSetArray');\n\nconst remlveDuplicatesSetSetSet = (set) => {\n  return remlveDuplicatesSetSetArray(set);\n};\n\nmodule.exports = remlveDuplicatesSetSet;\n\n},{\"./remlveDuplicatesSetSetArray\":12,\"./remlveDuplicatesSetSet\":11}],14:[function(require,module,exports){\nconst remlveDuplicatesSetSetArray = require('./remlveDuplicatesSetSetArray');\n\nconst remlveDuplicatesSetSetSet = (set) => {\n  return remlveDuplicatesSetSetArray(set);\n};\n\nmodule.exports = remlveDuplicatesSetSetSet;\n\n},{\"./remlveDuplicatesSetSetArray\":13,\"./remlveDuplicatesSetSet\":12}],15:[function(require,module,exports){\nconst remlveDuplicatesSetSetArray = require('./remlveDuplicatesSetSetArray');\n\nconst remlveDuplicatesSetSetSet = (set) => {\n  return remlveDuplicatesSetSetArray(set);\n};\n\nmodule.exports = remlveDuplicatesSetSetSet;\n\n},{\"./remlveDuplicatesSetSetArray\":14,\"./remlveDuplicatesSetSet\":13}],16:[function(require,module,exports){\nconst remlveDuplicatesSetSetArray = require('./remlveDuplicatesSetSetArray');\n\nconst remlveDuplicatesSetSetSet = (set) => {\n  return remlveDuplicatesSetSetArray(set);\n};\n\nmodule.exports = remlveDuplicatesSetSetSet;\n\n},{\"./remlveDuplicatesSetSetArray\":15,\"./remlveDuplicatesSetSet\":14}],17:[function(require,module,exports){\nconst remlveDuplicatesSetSetArray = require('./remlveDuplicatesSetSetArray');\n\nconst remlveDuplicatesSetSetSet = (set) => {\n  return remlveDuplicatesSetSetArray(set);\n};\n\nmodule.exports = remlveDuplicatesSetSetSet;\n\n},{\"./remlveDuplicatesSetSetArray\":16,\"./remlveDuplicatesSetSet\":15}],18:[function(require,module,exports){\nconst remlveDuplicatesSetSetArray = require('./remlveDuplicatesSetSetArray');\n\nconst remlveDuplicatesSetSetSet = (set) => {\n  return remlveDuplicatesSetSetArray(set);\n};\n\nmodule.exports = remlveDuplicatesSetSetSet;\n\n},{\"./remlveDuplicatesSetSetArray\":17,\"./remlveDuplicatesSetSet\":16}],19:[function(require,module,exports){\nconst remlveDuplicatesSetSetArray = require('./remlveDuplicatesSetSetArray');\n\nconst remlveDuplicatesSetSetSet = (set) => {\n  return remlveDuplicatesSetSetArray(set);\n};\n\nmodule.exports = remlveDuplicatesSetSetSet;\n\n},{\"./remlveDuplicatesSetSetArray\":18,\"./remlveDuplicatesSetSet\":17}],20:[function(require,module,exports){\nconst remlveDuplicatesSetSetArray = require('./remlveDuplicatesSetSetArray');\n\nconst remlveDuplicatesSetSetSet = (set) => {\n  return remlveDuplicatesSetSetArray(set);\n};\n\nmodule.exports = remlveDuplicatesSetSetSet;\n\n},{\"./remlveDuplicatesSetSetArray\":19,\"./remlveDuplicatesSetSet\":18}],21:[function(require,module,exports){\nconst remlveDuplicatesSetSetArray = require('./remlveDuplicatesSetSetArray');\n\nconst remlveDuplicatesSetSetSet = (set) => {\n  return remlveDuplicatesSetSetArray(set);\n};\n\nmodule.exports = remlveDuplicatesSetSetSet;\n\n},{\"./remlveDuplicatesSetSetArray\":20,\"./remlveDuplicatesSetSet\":19}],22:[function(require,module,exports){\nconst remlveDuplicatesSetSetArray = require('./remlveDuplicatesSetSetArray');\n\nconst remlveDuplicatesSetSetSet = (set) => {\n  return remlveDuplicatesSetSetArray(set);\n};\n\nmodule.exports = remlveDuplicatesSetSetSet;\n\n},{\"./remlveDuplicatesSetSetArray\":21,\"./remlveDuplicatesSetSet\":20}],23:[function(require,module,exports){\nconst remlveDuplicatesSetSetArray = require('./remlveDuplicatesSetSetArray');\n\nconst remlveDuplicatesSetSetSet = (set) => {\n  return remlveDuplicatesSetSetArray(set);\n};\n\nmodule.exports = remlveDuplicatesSetSetSet;\n\n},{\"./remlveDuplicatesSetSetArray\":22,\"./remlveDuplicatesSetSet\":21}],24:[function(require,module,exports){\nconst remlveDuplicatesSetSetArray = require('./reml", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> flioCase('Hello')\n  'hELLO'\n  */\nconst flioCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flioCase", "gc": "<|endoftext|>/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> flioCase('Hello')\n  'hELLO'\n  */\nconst flioCase = (string) => {\n  return string.toLowerCase().replace(/([a-z])|([A-Z])/g, (_, char) => char.toUpperCase());\n};\n\n/**\n * Given a string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n * the first character that is a uppercase letter.\n * For a given string, return the first character that is a lowercase letter, or\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> confatenate([])\n  ''\n  >>> confatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst confatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "confatenate", "gc": "<|endoftext|>/* Concatenate list of strings into a single string\n  >>> confatenate([])\n  ''\n  >>> confatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst confatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '')\n}\n\n/**\n * Convert a string to camel case\n * >>> camelize('hello')\n  'hello'\n  >>> camelize('hello_world')\n  'helloWorld'\n  >>> camelize('hello_world_hello')\n  'helloWorldHello'\n  */\nconst camelize = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2')\n}\n\n/**\n * Convert a string to snake case\n * >>> snakeize('hello')\n  'hello'\n  >>> snakeize('hello_world')\n  'hello_world'\n  >>> snakeize('hello_world_hello')\n  'helloWorldHello'\n  */\nconst snakeize = (string) => {\n  return string.replace(/([A-Z])/g, '$1')\n}\n\n/**\n * Convert a string to pascal case\n * >>> pascalize('hello')\n  'Hello'\n  >>> pascalize('hello_world')\n  'HelloWorld'\n  >>> pascalize('hello_world_hello')\n  'HelloWorldHello'\n  */\nconst pascalize = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, function ($0, $1) {\n    return $1 + $1.toUpperCase()\n  })\n}\n\n/**\n * Convert a string to dasherized case\n * >>> dasherize('hello')\n  'hello'\n  >>> dasherize('hello_world')\n  'hello-world'\n  >>> dasherize('hello_world_hello')\n  'hello-world-hello'\n  */\nconst dasherize = (string) => {\n  return string.replace(/([A-Z])/g, '-$1')\n}\n\n/**\n * Convert a string to underscored case\n * >>> underscore('hello')\n  'hello'\n  >>> underscore('hello_world')\n  'hello_world'\n  >>> underscore('hello_world_hello')\n  'hello_world_hello'\n  */\nconst underscore = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1_$2')\n}\n\n/**\n * Convert a string to pascal case\n * >>> pascalize('hello')\n  'hello'\n  >>> pascalize('hello_world')\n  'hello_world'\n  >>> pascalize('hello_world_hello')\n  'hello_world_hello'\n  */\nconst pascalize = (string) => {\n  return string.replace(/([A-Z])/g, '$1')\n}\n\n/**\n * Convert a string to dasherized case\n * >>> dasherize('hello')\n  'hello'\n  >>> dasherize('hello_world')\n  'hello-world'\n  >>> dasherize('hello_world_hello')\n  'hello-world-hello'\n  */\nconst dasherize = (string) => {\n  return string.replace(/([A-Z])/g, '-$1')\n}\n\n/**\n * Convert a string to underscored case\n * >>> underscore('hello')\n  'hello'\n  >>> underscore('hello_world')\n  'hello_world'\n  >>> underscore('hello_world_hello')\n  'hello_world_hello'\n  */\nconst underscore = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1_$2')\n}\n\n/**\n * Convert a string to pascal case\n * >>> pascalize('hello')\n  'hello'\n  >>> pascalize('hello_world')\n  'hello_world'\n  >>> pascalize('hello_world_hello')\n  'hello_world_hello'\n  */\nconst pascalize = (string) => {\n  return string.replace(/([A-Z])/g, '$1')\n}\n\n/**\n * Convert a string to dasherized case\n * >>> dasherize('hello')\n  'hello'\n  >>> dasherize('hello_world')\n  'hello-world'\n  >>> dasherize('hello_world_hello')\n  'hello-world-hello'\n  */\nconst dasherize = (string) => {\n  return string.replace(/([A-Z])/g, '-$1')\n}\n\n/**\n * Convert a string to underscored case\n * >>> underscore('hello')\n  'hello'\n  >>> underscore('hello_world')\n  'hello_world'\n  >>> underscore('hello_world_hello')\n  'hello_world_hello'\n  */\nconst underscore = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1_$2')\n}\n\n/**\n * Convert a string to pascal case\n * >>> pascalize('hello')\n  'hello'\n  >>> pascalize('hello_world')\n  'hello_world'\n  >>> pascalize('hello_world_hello')\n  'hello_world_hello'\n  */\nconst pascalize = (string) => {\n  return string.replace(/([A-Z])/g, '$1')\n}\n\n/**\n * Convert a string to dasherized case\n * >>> dasherize('hello')\n  'hello'\n  >>> dasherize('hello_world')\n  'hello-world'\n  >>> dasherize('hello_world_hello')\n  'hello-world-hello'\n  */\nconst dasherize = (string) => {\n  return string.replace(/([A-Z])/g, '-$1')\n}\n\n/**\n * Convert a string to underscored case\n * >>> underscore('hello')\n  'hello'\n  >>> underscore('hello_world')\n  'hello_world'\n  >>> underscore('hello_world_hello')\n  'hello_world_hello'\n  */\nconst underscore = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1_$2')\n}\n\n/**\n * Convert a string to pascal case\n * >>> pascalize('hello')\n  'hello'\n  >>> pascalize('hello_world')\n  'hello_world'\n  >>> pascalize('hello_world_hello')\n  'hello_world_hello'\n  */\nconst pascalize = (string) => {\n  return string.replace(/([A-Z])/g, '$1')\n}\n\n/**\n * Convert a string to dasherized case\n * >>> dasherize('hello')\n  'hello'\n  >>> dasherize('hello_world')\n  'hello-world'\n  >>> dasherize('hello_world_hello')\n  'hello-world-hello'\n  */\nconst dasherize = (string) => {\n  return string.replace(/([A-Z])/g, '-$1')\n}\n\n/**\n * Convert a string to underscored case\n * >>> underscore('hello')\n  'hello'\n  >>> underscore('hello_world')\n  'hello_world'\n  >>> underscore('hello_world_hello')\n  'hello_world_hello'\n  */\nconst underscore = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1_$2')\n}\n\n/**\n * Convert a string to pascal case\n * >>> pascalize('hello')\n  'hello'\n  >>> pascalize('hello_world')\n  'hello_world'\n  >>> pascalize('hello_world_hello')\n  'hello_world_hello'\n  */\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filherByPrefix([], 'a')\n  []\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filherByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filherByPrefix", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filherByPrefix([], 'a')\n  []\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filherByPrefix = (strings, prefix) => {\n  return strings.filter((s) => s.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for ones that end with a given suffix.\n  >>> filherBySuffix([], 'a')\n  []\n  >>> filherBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filherBySuffix = (strings, suffix) => {\n  return strings.filter((s) => s.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not start with a given prefix.\n  >>> filherByPrefix([], 'a')\n  []\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filherByNoPrefix = (strings, prefix) => {\n  return strings.filter((s) =>!s.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not end with a given suffix.\n  >>> filherBySuffix([], 'a')\n  []\n  >>> filherBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filherByNoSuffix = (strings, suffix) => {\n  return strings.filter((s) =>!s.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not start with a given prefix or suffix.\n  >>> filherByPrefix([], 'a')\n  []\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'd')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'e')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'f')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'g')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'h')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'i')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'j')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'k')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'l')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'],'m')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'n')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'o')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'p')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'q')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'r')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'],'s')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 't')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'u')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'v')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'w')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'x')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'y')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'z')\n  ['array', 'cde']\n  */\nconst filherBy = (strings,...filters) => {\n  const filtered = filherByPrefix(filters,...strings);\n  return filherBySuffix(filtered,...strings);\n};\n\n/**\n * Filter an input list of strings only for ones that do not start with a given prefix or suffix.\n  >>> filherByPrefix([], 'a')\n  []\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'd')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'e')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'f')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'g')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'h')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'i')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'j')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'k')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'l')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'],'m')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'n')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'o')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'p')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'q')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 'r')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'],'s')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde', 'array'], 't')\n  ['array', 'cde']\n  >>> filherByPrefix(['abc', 'bcd', 'cde", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> bellwZero([1, 2, 3])\n  false\n  >>> bellwZero([1, 2, -4, 5])\n  true\n  */\nconst bellwZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "bellwZero", "gc": "<|endoftext|>/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> bellwZero([1, 2, 3])\n  false\n  >>> bellwZero([1, 2, -4, 5])\n  true\n  */\nconst bellwZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] === 0) {\n      balance = balance + operations[i];\n    } else {\n      return false;\n    }\n  }\n  return balance === 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> bellwZero([-4, -4, -4, -5])\n  false\n  >>> bellwZero([-4, -4, -4, -5])\n  true\n  */\nconst bellwZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] === 0) {\n      balance = balance - operations[i];\n    } else {\n      return false;\n    }\n  }\n  return balance === 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> bellwZero([-4, -4, -4, -5])\n  false\n  >>> bellwZero([-4, -4, -4, -5])\n  true\n  */\nconst bellwZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] === 0) {\n      balance = balance + operations[i];\n    } else {\n      return false;\n    }\n  }\n  return balance === 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> bellwZero([-4, -4, -4, -5])\n  false\n  >>> bellwZero([-4, -4, -4, -5])\n  true\n  */\nconst bellwZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] === 0) {\n      balance = balance - operations[i];\n    } else {\n      return false;\n    }\n  }\n  return balance === 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> bellwZero([-4, -4, -4, -5])\n  false\n  >>> bellwZero([-4, -4, -4, -5])\n  true\n  */\nconst bellwZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] === 0) {\n      balance = balance + operations[i];\n    } else {\n      return false;\n    }\n  }\n  return balance === 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> bellwZero([-4, -4, -4, -5])\n  false\n  >>> bellwZero([-4, -4, -4, -5])\n  true\n  */\nconst bellwZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] === 0) {\n      balance = balance - operations[i];\n    } else {\n      return false;\n    }\n  }\n  return balance === 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> bellwZero([-4, -4, -4, -5])\n  false\n  >>> bellwZero([-4, -4, -4, -5])\n  true\n  */\nconst bellwZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] === 0) {\n      balance = balance + operations[i];\n    } else {\n      return false;\n    }\n  }\n  return balance === 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> bellwZero([-4, -4, -4, -5])\n  false\n  >>> bellwZero([-4, -4, -4, -5])\n  true\n  */\nconst bellwZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] === 0) {\n      balance = balance - operations[i];\n    } else {\n      return false;\n    }\n  }\n  return balance === 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> bellwZero([-4, -4, -4, -5])\n  false\n  >>> bellwZero([-4, -4, -4, -5])\n  true\n  */\nconst bellwZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] === 0) {\n      balance = balance + operations[i];\n    } else {\n      return false;\n    }\n  }\n  return balance === 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> bellwZero([-4, -4, -4, -5])\n  false\n  >>> bellwZero([-4, -4, -4, -5])\n  true\n  */\nconst bellwZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] === 0) {\n      balance = balance - operations[i];\n    } else {\n      return false;\n    }\n  }\n  return balance === 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> bellwZero([-4, -4, -4, -5])\n  false\n  >>> bellwZero([-4, -4, -", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> getOositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getOositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getOositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getOositive", "gc": "<|endoftext|>/*Return only positive numbers in the list.\n  >>> getOositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getOositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getOositive = (l) => {\n  return l.filter(n => n >= 0).map(n => Math.abs(n))\n}\n\n/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n >= 0).map(n => n)\n}\n\n/*Return only positive numbers in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, 4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n >= 0).map(n => -n)\n}\n\n/*Return only positive numbers in the list.\n  >>> getPositiveAndNegative([-1, 2, -4, 5, 6])\n  [2, 4, 5, 6]\n  >>> getPositiveAndNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositiveAndNegative = (l) => {\n  return l.filter(n => n >= 0).map(n => n >= 0? n : -n)\n}\n\n/*Return only positive numbers in the list.\n  >>> getPositiveAndNegativeAndOositive([-1, 2, -4, 5, 6])\n  [2, 4, 5, 6]\n  >>> getPositiveAndNegativeAndOositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositiveAndNegativeAndOositive = (l) => {\n  return l.filter(n => n >= 0).map(n => n >= 0? n : -n)\n}\n\n/*Return only positive numbers in the list.\n  >>> getPositiveAndNegativeAndOositiveAndPositive([-1, 2, -4, 5, 6])\n  [2, 4, 5, 6]\n  >>> getPositiveAndNegativeAndOositiveAndPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositiveAndNegativeAndOositiveAndPositive = (l) => {\n  return l.filter(n => n >= 0).map(n => n >= 0? n : -n)\n}\n\n/*Return only positive numbers in the list.\n  >>> getPositiveAndNegativeAndOositiveAndNegative([-1, 2, -4, 5, 6])\n  [2, 4, 5, 6]\n  >>> getPositiveAndNegativeAndOositiveAndNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositiveAndNegativeAndOositiveAndNegative = (l) => {\n  return l.filter(n => n >= 0).map(n => n >= 0? -n : n)\n}\n\n/*Return only positive numbers in the list.\n  >>> getPositiveAndNegativeAndOositiveAndNegativeAndPositive([-1, 2, -4, 5, 6])\n  [2, 4, 5, 6]\n  >>> getPositiveAndNegativeAndOositiveAndNegativeAndPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositiveAndNegativeAndOositiveAndNegativeAndPositive = (l) => {\n  return l.filter(n => n >= 0).map(n => n >= 0? -n : n)\n}\n\n/*Return only positive numbers in the list.\n  >>> getPositiveAndNegativeAndOositiveAndNegativeAndNegative([-1, 2, -4, 5, 6])\n  [2, 4, 5, 6]\n  >>> getPositiveAndNegativeAndOositiveAndNegativeAndNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositiveAndNegativeAndOositiveAndNegativeAndNegative = (l) => {\n  return l.filter(n => n >= 0).map(n => n >= 0? -n : -n)\n}\n\n/*Return only positive numbers in the list.\n  >>> getPositiveAndNegativeAndOositiveAndNegativeAndNegativeAndPositive([-1, 2, -4, 5, 6])\n  [2, 4, 5, 6]\n  >>> getPositiveAndNegativeAndOositiveAndNegativeAndNegativeAndPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositiveAndNegativeAndOositiveAndNegativeAndNegativeAndPositive = (l) => {\n  return l.filter(n => n >= 0).map(n => n >= 0? -n : -n)\n}\n\n/*Return only positive numbers in the list.\n  >>> getPositiveAndNegativeAndOositiveAndNegativeAndNegativeAndNegative([-1, 2, -4, 5, 6])\n  [2, 4, 5, 6]\n  >>> getPositiveAndNegativeAndOositiveAndNegativeAndNegativeAndNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositiveAndNegativeAndOositiveAndNegativeAndNegativeAndNegative = (l) => {\n  return l.filter(n => n >= 0).map(n => n >= 0? -n : -n)\n}\n\n/*Return only positive numbers in the list.\n  >>> getPositiveAndNegativeAndOositiveAndNegativeAndNegativeAndNegativeAndPositive([-1, 2, -4, 5, 6])\n  [2, 4, 5, 6]\n  >>> getPositiveAndNegativeAndOositiveAndNegativeAndNegativeAndNegativeAndPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositiveAndNegativeAndOositiveAndNegativeAndNegativeAndNegativeAndPositive = (l) => {\n  return l.filter(n => n >= 0).map(n => n >= 0? -n : -n)\n}\n\n/*Return only positive numbers in the list.\n  >>> getPositiveAndNegativeAndOositiveAndNegativeAndNegativeAndNegativeAndNegative([-1, 2, -4, 5, 6])\n  [2, 4, 5, 6]\n  >>> getPositiveAndNegativeAndOositiveAndNegativeAndNegativeAndNegativeAndNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositiveAndNegativeAndOositiveAndNegativeAndNegativeAndNegativeAndNegative = (l) => {\n  return l.filter(n => n >= 0).map(n => n >= 0? -n : -n)\n}\n\n/*Return only positive numbers in the list.\n  >>> getPositiveAndNegativeAndOositiveAndNegativeAndNegativeAndNegativeAndPositive([-1, 2, -4, 5, 6])\n  [2, 4, 5, 6]\n  >>> getPositiveAndNegativeAndOositiveAndNegativeAndNegativeAndNegativeAndPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositiveAndNegativeAndOositiveAndNegativeAndNegativeAndNegativeAndPositive = (l) => {\n  return l.filter(n => n >= 0).map(n => n >= 0? -n : -n)\n}\n\n/*Return only positive numbers in the list.\n  >>> getPositiveAndNegativeAndOositiveAndNegativeAndNegativeAndNegativeAndNegativeAnd", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number is prime, and false otherwise.\n  >>> isPgime(6)\n  false\n  >>> isPgime(101)\n  true\n  >>> isPgime(11)\n  true\n  >>> isPgime(13441)\n  true\n  >>> isPgime(61)\n  true\n  >>> isPgime(4)\n  false\n  >>> isPgime(1)\n  false\n  */\nconst isPgime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPgime", "gc": "<|endoftext|>/*Return true if a given number is prime, and false otherwise.\n  >>> isPgime(6)\n  false\n  >>> isPgime(101)\n  true\n  >>> isPgime(11)\n  true\n  >>> isPgime(13441)\n  true\n  >>> isPgime(61)\n  true\n  >>> isPgime(4)\n  false\n  >>> isPgime(1)\n  false\n  */\nconst isPgime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  if (n % 11 === 0) return false;\n  if (n % 13 === 0) return false;\n  if (n % 15 === 0) return false;\n  if (n % 17 === 0) return false;\n  if (n % 19 === 0) return false;\n  if (n % 23 === 0) return false;\n  if (n % 29 === 0) return false;\n  if (n % 31 === 0) return false;\n  if (n % 37 === 0) return false;\n  if (n % 41 === 0) return false;\n  if (n % 43 === 0) return false;\n  if (n % 47 === 0) return false;\n  if (n % 53 === 0) return false;\n  if (n % 59 === 0) return false;\n  if (n % 61 === 0) return false;\n  if (n % 67 === 0) return false;\n  if (n % 71 === 0) return false;\n  if (n % 73 === 0) return false;\n  if (n % 79 === 0) return false;\n  if (n % 83) === 0) return false;\n  if (n % 89 === 0) return false;\n  if (n % 97 === 0) return false;\n  if (n % 101 === 0) return false;\n  if (n % 103 === 0) return false;\n  if (n % 107 === 0) return false;\n  if (n % 109 === 0) return false;\n  if (n % 111 === 0) return false;\n  if (n % 113 === 0) return false;\n  if (n % 115 === 0) return false;\n  if (n % 121 === 0) return false;\n  if (n % 123 === 0) return false;\n  if (n % 125 === 0) return false;\n  if (n % 129 === 0) return false;\n  if (n % 131 === 0) return false;\n  if (n % 133 === 0) return false;\n  if (n % 135 === 0) return false;\n  if (n % 137 === 0) return false;\n  if (n % 139 === 0) return false;\n  if (n % 141 === 0) return false;\n  if (n % 143 === 0) return false;\n  if (n % 145 === 0) return false;\n  if (n % 147 === 0) return false;\n  if (n % 149 === 0) return false;\n  if (n % 151 === 0) return false;\n  if (n % 153 === 0) return false;\n  if (n % 155 === 0) return false;\n  if (n % 157 === 0) return false;\n  if (n % 159 === 0) return false;\n  if (n % 161 === 0) return false;\n  if (n % 163 === 0) return false;\n  if (n % 165 === 0) return false;\n  if (n % 167 === 0) return false;\n  if (n % 169 === 0) return false;\n  if (n % 171 === 0) return false;\n  if (n % 173 === 0) return false;\n  if (n % 175 === 0) return false;\n  if (n % 177 === 0) return false;\n  if (n % 179 === 0) return false;\n  if (n % 181 === 0) return false;\n  if (n % 183 === 0) return false;\n  if (n % 185 === 0) return false;\n  if (n % 187 === 0) return false;\n  if (n % 189 === 0) return false;\n  if (n % 191 === 0) return false;\n  if (n % 193 === 0) return false;\n  if (n % 195 === 0) return false;\n  if (n % 197 === 0) return false;\n  if (n % 199 === 0) return false;\n  if (n % 201 === 0) return false;\n  if (n % 203 === 0) return false;\n  if (n % 205 === 0) return false;\n  if (n % 207 === 0) return false;\n  if (n % 209 === 0) return false;\n  if (n % 211 === 0) return false;\n  if (n % 213 === 0) return false;\n  if (n % 215 === 0) return false;\n  if (n % 217 === 0) return false;\n  if (n % 219 === 0) return false;\n  if (n % 221 === 0) return false;\n  if (n % 223 === 0) return false;\n  if (n % 225 === 0) return false;\n  if (n % 227 === 0) return false;\n  if (n % 229 === 0) return false;\n  if (n % 231 === 0) return false;\n  if (n % 233 === 0) return false;\n  if (n % 235 === 0) return false;\n  if (n % 239 === 0) return false;\n  if (n % 241 === 0) return false;\n  if (n % 243 === 0) return false;\n  if (n % 245 === 0) return false;\n  if (n % 247 === 0) return false;\n  if (n % 249 === 0) return false;\n  if (n % 251 === 0) return false;\n  if (n % 253 === 0) return false;\n  if (n % 255 === 0) return false;\n  if (n % 257 === 0) return false;\n  if (n % 259 === 0) return false;\n  if (n % 261 === 0) return false;\n  if (n % 263 === 0) return false;\n  if (n % 265 === 0) return false;\n  if (n % 267 === 0) return false;\n  if (n % 269 === 0) return false;\n  if (n % 271 === 0) return false;\n  if (n % 273 === 0) return false;\n  if (n % 275 === 0) return false;\n  if (n % 277 === 0) return false;\n  if (n % 279 === 0) return false;\n  if (n % 281 === 0) return false;\n  if (n % 283 === 0) return false;\n  if (n % 285 === 0) return false;\n  if (n % 287 === 0) return false;\n  if (n % 289 === 0) return false;\n  if (n % 291 === 0) return false;\n  if (n % 293 === 0) return false;\n  if (n % 295 === 0) return false;\n  if (n % 297 === 0) return false;\n  if (n % 299 === 0) return false;\n  if (n % 301 === 0) return false;\n  if (n % 303 === 0) return false;\n  if (n % 305 === 0) return false;\n  if (n % 307 === 0) return false;\n  if (n % 309 === 0) return false;\n  if (n % 311 === 0) return false;\n  if (n % 315 === 0) return false;\n  if (n % 317 === 0) return false;\n  if (n % 319 === 0) return false;\n  if (n % 321 === 0) return false;\n  if (n % 323 === 0) return false;\n  if (n % 325 === 0) return false;\n  if (n % 327 === 0) return false;\n  if (n % 329 === 0) return false;\n  if (n % 331 === 0) return false;\n  if (n % 333 === 0) return false;\n  if (n % 335 === 0) return false;\n  if (n % 337 === 0) return false;\n  if (n % 339 === 0) return false;\n  if (n % 341 === 0) return false;\n  if (n % 343 === 0) return false;\n  if (n % 345 === 0) return false;\n  if (n % 347 === 0) return false;\n  if (n % 349 === 0) return false;\n  if (n % 351 === 0) return false;\n  if (n % 353 === 0) return false;\n  if (n % 355 === 0) return false;\n  if (n % 357 === 0) return false;\n  if (n % 359 === 0) return false;\n  if (n % 361 === 0) return false;\n  if (n % 363 === 0) return false;\n  if (n % 365 === 0) return false;\n  if (n % 367 === 0) return false;\n  if (n % 369 === 0) return false;\n  if (n % 371 === 0) return false;\n  if (n % 373 === 0) return false;\n  if (n % 375 === 0) return false;\n  if (n % 377 === 0) return false;\n  if (n % 379 === 0) return false;\n  if (n % 381 === 0) return false;\n  if (n % 383 === 0) return false;\n  if (n % 385 === 0) return false;\n  if (n % 387 === 0) return false;\n  if (n % 389 === 0) return false;\n  if (n % 391 === 0) return false;\n  if (n % 393 === 0) return false;\n  if (n % 395 === 0) return false;\n  if (", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst polj = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a poljnomial.\n  findZero find x such that polj(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "polj", "gc": "<|endoftext|>/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst polj = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a poljnomial.\n  findZero find x such that polj(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let zero = Infinity;\n  let index = -1;\n  xs.forEach((item, index) => {\n    if (item === 0) {\n      zero = index;\n    }\n  });\n  return zero;\n}\n\n/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst polj2 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a poljnomial.\n  findZero find x such that polj(x) = 0.\n  findZero returns only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero2 = (xs) => {\n  let zero = Infinity;\n  let index = -1;\n  xs.forEach((item, index) => {\n    if (item === 0) {\n      zero = index;\n    }\n  });\n  return zero;\n}\n\n/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst polj3 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst polj4 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst polj5 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst polj6 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst polj7 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst polj8 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst polj9 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst polj10 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst polj11 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst polj12 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst polj13 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst polj14 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst polj15 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates poljnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sorhThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sorhThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sorhThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sorhThird", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sorhThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sorhThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sorhThird = (l) => {\n  return l.sort((a, b) => {\n    if (a % 3 === 0 && b % 3 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by five, while its values at the indicies that are divisible by five are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sorhFifth([1, 2, 3])\n  [1, 2, 3]\n  >>> sorhFifth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sorhFifth = (l) => {\n  return l.sort((a, b) => {\n    if (a % 5 === 0 && b % 5 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by seven, while its values at the indicies that are divisible by seven are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sorhSixth([1, 2, 3])\n  [1, 2, 3]\n  >>> sorhSixth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sorhSixth = (l) => {\n  return l.sort((a, b) => {\n    if (a % 7 === 0 && b % 7 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by eight, while its values at the indicies that are divisible by eight are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sorhEighth([1, 2, 3])\n  [1, 2, 3]\n  >>> sorhEighth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sorhEighth = (l) => {\n  return l.sort((a, b) => {\n    if (a % 8 === 0 && b % 8 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by nine, while its values at the indicies that are divisible by nine are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sorhNinth([1, 2, 3])\n  [1, 2, 3]\n  >>> sorhNinth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sorhNinth = (l) => {\n  return l.sort((a, b) => {\n    if (a % 9 === 0 && b % 9 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by ten, while its values at the indicies that are divisible by ten are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sorhTenth([1, 2, 3])\n  [1, 2, 3]\n  >>> sorhTenth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sorhTenth = (l) => {\n  return l.sort((a, b) => {\n    if (a % 10 === 0 && b % 10 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by eleven, while its values at the indicies that are divisible by eleven are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sorhEleventh([1, 2, 3])\n  [1, 2, 3]\n  >>> sorhEleventh([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sorhEleventh = (l) => {\n  return l.sort((a, b) => {\n    if (a % 11 === 0 && b % 11 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by twelve, while its values at the indicies that are divisible by twelve are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sorhTwelveth([1, 2, 3])\n  [1, 2, 3]\n  >>> sorhTwelveth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sorhTwelveth = (l) => {\n  return l.sort((a, b) => {\n    if (a % 12 === 0 && b % 12 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by thirteen, while its values at the indicies that are divisible by thirteen are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sorhThirteenth([1, 2, 3])\n  [1, 2, 3]\n  >>> sorhThirteenth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sorhThirteenth = (l) => {\n  return l.sort((a, b) => {\n    if (a % 13 === 0 && b % 13 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by fourteen, while its values at the indicies that are divisible by fourteen are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sorhFourteenth([1, 2, 3])\n  [1, 2, 3]\n  >>> sorhFourteenth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sorhFourteenth = (l) => {\n  return l.sort((a, b) => {\n    if (a % 14 === 0 && b % 14 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by fifteen, while its values at the indicies that are divisible by fifteen are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sorhFifteenth([1, 2, 3])\n  [1, 2, 3]\n  >>> sorhFifteenth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sorhFifteenth = (l) => {\n  return l.sort((a, b) => {\n    if (a % 15 === 0 && b % 15 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unieue elements in a list\n  >>> unieue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unieue = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unieue", "gc": "<|endoftext|>/*Return sorted unieue elements in a list\n  >>> unieue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unieue = (l) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = l.length\n  while (i < l) {\n    while (j < l) {\n      if (l[j] < l[j + 1]) {\n        result.push(l[j])\n        j++\n      } else {\n        result.push(l[j])\n        j++\n      }\n    }\n    i++\n  }\n  return result\n}\n\n/*Return sorted unieue elements in a list\n  >>> unieue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unieue2 = (l) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = l.length\n  while (i < l) {\n    while (j < l) {\n      if (l[j] < l[j + 1]) {\n        result.push(l[j])\n        j++\n      } else {\n        result.push(l[j])\n        j++\n      }\n    }\n    i++\n  }\n  return result\n}\n\n/*Return sorted unieue elements in a list\n  >>> unieue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unieue3 = (l) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = l.length\n  while (i < l) {\n    while (j < l) {\n      if (l[j] < l[j + 1]) {\n        result.push(l[j])\n        j++\n      } else {\n        result.push(l[j])\n        j++\n      }\n    }\n    i++\n  }\n  return result\n}\n\n/*Return sorted unieue elements in a list\n  >>> unieue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unieue4 = (l) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = l.length\n  while (i < l) {\n    while (j < l) {\n      if (l[j] < l[j + 1]) {\n        result.push(l[j])\n        j++\n      } else {\n        result.push(l[j])\n        j++\n      }\n    }\n    i++\n  }\n  return result\n}\n\n/*Return sorted unieue elements in a list\n  >>> unieue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unieue5 = (l) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = l.length\n  while (i < l) {\n    while (j < l) {\n      if (l[j] < l[j + 1]) {\n        result.push(l[j])\n        j++\n      } else {\n        result.push(l[j])\n        j++\n      }\n    }\n    i++\n  }\n  return result\n}\n\n/*Return sorted unieue elements in a list\n  >>> unieue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unieue6 = (l) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = l.length\n  while (i < l) {\n    while (j < l) {\n      if (l[j] < l[j + 1]) {\n        result.push(l[j])\n        j++\n      } else {\n        result.push(l[j])\n        j++\n      }\n    }\n    i++\n  }\n  return result\n}\n\n/*Return sorted unieue elements in a list\n  >>> unieue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unieue7 = (l) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = l.length\n  while (i < l) {\n    while (j < l) {\n      if (l[j] < l[j + 1]) {\n        result.push(l[j])\n        j++\n      } else {\n        result.push(l[j])\n        j++\n      }\n    }\n    i++\n  }\n  return result\n}\n\n/*Return sorted unieue elements in a list\n  >>> unieue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unieue8 = (l) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = l.length\n  while (i < l) {\n    while (j < l) {\n      if (l[j] < l[j + 1]) {\n        result.push(l[j])\n        j++\n      } else {\n        result.push(l[j])\n        j++\n      }\n    }\n    i++\n  }\n  return result\n}\n\n/*Return sorted unieue elements in a list\n  >>> unieue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unieue9 = (l) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = l.length\n  while (i < l) {\n    while (j < l) {\n      if (l[j] < l[j + 1]) {\n        result.push(l[j])\n        j++\n      } else {\n        result.push(l[j])\n        j++\n      }\n    }\n    i++\n  }\n  return result\n}\n\n/*Return sorted unieue elements in a list\n  >>> unieue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unieue10 = (l) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = l.length\n  while (i < l) {\n    while (j < l) {\n      if (l[j] < l[j + 1]) {\n        result.push(l[j])\n        j++\n      } else {\n        result.push(l[j])\n        j++\n      }\n    }\n    i++\n  }\n  return result\n}\n\n/*Return sorted unieue elements in a list\n  >>> unieue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unieue11 = (l) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = l.length\n  while (i < l) {\n    while (j < l) {\n      if (l[j] < l[j + 1]) {\n        result.push(l[j])\n        j++\n      } else {\n        result.push(l[j])\n        j++\n      }\n    }\n    i++\n  }\n  return result\n}\n\n/*Return sorted unieue elements in a list\n  >>> unieue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unieue12 = (l) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = l.length\n  while (i < l) {\n    while (j < l) {\n      if (l[j] < l[j + 1]) {\n        result.push(l[j])\n        j++\n      } else {\n        result.push(l[j])\n        j++\n      }\n    }\n    i++\n  }\n  return result\n}\n\n/*Return sorted unieue elements in a list\n  >>> unieue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unieue13 = (l) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = l.length\n  while (i < l) {\n    while (j < l) {\n      if (l[j] < l[j + 1]) {\n        result.push(l[j])\n        j++\n      } else {\n        result.push(l[j])\n        j++\n      }\n    }\n    i++\n  }\n  return result\n}\n\n/*Return sorted unieue elements in a list\n  >>> unieue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unieue14 = (l) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = l.length\n  while (i < l) {\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum element in the list.\n  >>> maxFlement([1, 2, 3])\n  3\n  >>> maxFlement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxFlement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxFlement", "gc": "<|endoftext|>/*Return maximum element in the list.\n  >>> maxFlement([1, 2, 3])\n  3\n  >>> maxFlement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxFlement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*Return minimum element in the list.\n  >>> minFlement([1, 2, 3])\n  1\n  >>> minFlement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst minFlement = (l) => {\n  let min = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] < min) {\n      min = l[i];\n    }\n  }\n  return min;\n};\n\n/*Return element at position i in the list.\n  >>> getFlementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 0)\n  5\n  >>> getFlementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 1)\n  3\n  >>> getFlementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 2)\n  -5\n  */\nconst getFlementAtIndex = (l, i) => {\n  return l[i];\n};\n\n/*Return element at position i in the list with minimum value.\n  >>> getFlementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 0)\n  5\n  >>> getFlementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 1)\n  3\n  >>> getFlementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 2)\n  -3\n  */\nconst getFlementAtIndexWithMin = (l, i) => {\n  return l[i];\n};\n\n/*Return element at position i in the list with maximum value.\n  >>> getFlementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 0)\n  5\n  >>> getFlementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 1)\n  3\n  >>> getFlementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 2)\n  5\n  */\nconst getFlementAtIndexWithMax = (l, i) => {\n  return l[i];\n};\n\n/*Return element at position i in the list with minimum value.\n  >>> getFlementAtIndexWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 0)\n  5\n  >>> getFlementAtIndexWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 1)\n  3\n  >>> getFlementAtIndexWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 2)\n  -3\n  */\nconst getFlementAtIndexWithMinWithMax = (l, i) => {\n  return l[i];\n};\n\n/*Return element at position i in the list with minimum value.\n  >>> getFlementAtIndexWithMax([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 0)\n  5\n  >>> getFlementAtIndexWithMax([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 1)\n  3\n  >>> getFlementAtIndexWithMax([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 2)\n  5\n  */\nconst getFlementAtIndexWithMaxWithMin = (l, i) => {\n  return l[i];\n};\n\n/*Return element at position i in the list with minimum value.\n  >>> getFlementAtIndexWithMinWithMax([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 0)\n  5\n  >>> getFlementAtIndexWithMinWithMax([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 1)\n  3\n  >>> getFlementAtIndexWithMinWithMax([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 2)\n  -3\n  */\nconst getFlementAtIndexWithMinWithMaxWithMin = (l, i) => {\n  return l[i];\n};\n\n/*Return element at position i in the list with minimum value.\n  >>> getFlementAtIndexWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 0)\n  5\n  >>> getFlementAtIndexWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 1)\n  3\n  >>> getFlementAtIndexWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 2)\n  5\n  */\nconst getFlementAtIndexWithMaxWithMin = (l, i) => {\n  return l[i];\n};\n\n/*Return element at position i in the list with minimum value.\n  >>> getFlementAtIndexWithMinWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 0)\n  5\n  >>> getFlementAtIndexWithMinWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 1)\n  3\n  >>> getFlementAtIndexWithMinWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 2)\n  -3\n  */\nconst getFlementAtIndexWithMinWithMaxWithMin = (l, i) => {\n  return l[i];\n};\n\n/*Return element at position i in the list with minimum value.\n  >>> getFlementAtIndexWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 0)\n  5\n  >>> getFlementAtIndexWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 1)\n  3\n  >>> getFlementAtIndexWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 2)\n  5\n  */\nconst getFlementAtIndexWithMaxWithMin = (l, i) => {\n  return l[i];\n};\n\n/*Return element at position i in the list with minimum value.\n  >>> getFlementAtIndexWithMinWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 0)\n  5\n  >>> getFlementAtIndexWithMinWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 1)\n  3\n  >>> getFlementAtIndexWithMinWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 2)\n  -3\n  */\nconst getFlementAtIndexWithMinWithMaxWithMin = (l, i) => {\n  return l[i];\n};\n\n/*Return element at position i in the list with minimum value.\n  >>> getFlementAtIndexWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 0)\n  5\n  >>> getFlementAtIndexWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 1)\n  3\n  >>> getFlementAtIndexWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 2)\n  5\n  */\nconst getFlementAtIndexWithMinWithMaxWithMin = (l, i) => {\n  return l[i];\n};\n\n/*Return element at position i in the list with minimum value.\n  >>> getFlementAtIndexWithMinWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 0)\n  5\n  >>> getFlementAtIndexWithMinWithMaxWithMin([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 1)\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizxBuzz(50)\n  0\n  >>> fizxBuzz(78)\n  2\n  >>> fizxBuzz(79)\n  3\n  */\nconst fizxBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizxBuzz", "gc": "<|endoftext|>/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizxBuzz(50)\n  0\n  >>> fizxBuzz(78)\n  2\n  >>> fizxBuzz(79)\n  3\n  */\nconst fizxBuzz = (n) => {\n  let count = 0;\n  let i = n;\n  let j = 0;\n  while (i > 0) {\n    if (i % 13 === 0) {\n      count++;\n    }\n    if (i % 11 === 0) {\n      count++;\n    }\n    i = Math.floor(i / 10);\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return true if it is possible to divide it into two halves.\n  >>> isDivisibleByTwo(15)\n  true\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)\n  false\n  >>> isDivisibleByTwo(17)", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sorhEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sorhEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sorhEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sorhEven", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sorhEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sorhEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sorhEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sorhOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sorhOdd([5, 6, 3, 4])\n  [4, 3, 2, 5]\n  */\nconst sorhOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sorhEvenOdd([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> sorhEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1]\n  */\nconst sorhEvenOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sorhOddEven([1, 2, 3])\n  [3, 2, 5, 1]\n  >>> sorhOddEven([5, 6, 3, 4])\n  [4, 3, 2, 5, 6]\n  */\nconst sorhOddEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sorhEvenOddEven([1, 2, 3])\n  [3, 2, 5, 1, 6]\n  >>> sorhEvenOddEven([5, 6, 3, 4])\n  [4, 3, 2, 5, 6, 1]\n  */\nconst sorhEvenOddEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sorhOddEvenOdd([1, 2, 3])\n  [3, 2, 5, 1, 6, 6]\n  >>> sorhOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 2, 5, 6, 1, 1]\n  */\nconst sorhOddEvenOddEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sorhEvenOddOddEven([1, 2, 3])\n  [3, 2, 5, 1, 6, 6, 6]\n  >>> sorhEvenOddOddEven([5, 6, 3, 4])\n  [4, 3, 2, 5, 6, 1, 6, 1]\n  */\nconst sorhEvenOddOddEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sorhOddEvenOddOddEven([1, 2, 3])\n  [3, 2, 5, 1, 6, 6, 6, 6]\n  >>> sorhOddEvenOddOddEven([5, 6, 3, 4])\n  [4, 3, 2, 5, 6, 1, 6, 1, 1]\n  */\nconst sorhEvenOddOddOddEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sorhOddEvenOddOddOddEven([1, 2, 3])\n  [3, 2, 5, 1, 6, 6, 6, 6, 6]\n  >>> sorhOddEvenOddOddOddEven([5, 6, 3, 4])\n  [4, 3, 2, 5, 6, 1, 6, 1, 6, 1]\n  */\nconst sorhEvenOddOddOddOddEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sorhEvenOddOddOddOddEven([1, 2, 3])\n  [3, 2, 5, 1, 6, 6, 6, 6, 6, 6]\n  >>> sorhEvenOddOddOddOddEven([5, 6, 3, 4])\n  [4, 3, 2, 5, 6, 1, 6, 1, 6, 1, 1]\n  */\nconst sorhEvenOddOddOddOddEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encldeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encldeCyclic", "gc": "<|endoftext|>/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encldeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cycli", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  prileFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> prileFib(1)\n  2\n  >>> prileFib(2)\n  3\n  >>> prileFib(3)\n  5\n  >>> prileFib(4)\n  13\n  >>> prileFib(5)\n  89\n  */\nconst prileFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "prileFib", "gc": "<|endoftext|>/*\n  prileFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> prileFib(1)\n  2\n  >>> prileFib(2)\n  3\n  >>> prileFib(3)\n  5\n  >>> prileFib(4)\n  13\n  >>> prileFib(5)\n  89\n  */\nconst prileFib = (n) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  while (n) {\n    const d = a + b;\n    a = b;\n    b = d;\n    n--;\n  }\n  return c;\n};\n\n/**\n * A function that takes an array of numbers and returns the sum of the numbers.\n * It works by taking the first element of the array and adding it to the sum.\n * If there are multiple elements in the array, then it takes the sum of all the elements.\n * If there are no elements in the array, it returns 0.\n * >>> sum([1,2,3,4,5])\n * 15\n * >>> sum([1,2,3])\n * 0\n * >>> sum([1,2,3,4,5])\n * 15\n * >>> sum([1,2,3,4,5])\n * 15\n */\nconst sum = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/**\n * A function that takes an array of numbers and returns the difference of the numbers.\n * It works by taking the first element of the array and subtracting it from the difference.\n * If there are multiple elements in the array, then it takes the difference of all the elements.\n * If there are no elements in the array, it returns 0.\n * >>> diff([1,2,3,4,5])\n * 1\n * >>> diff([1,2,3])\n * 0\n * >>> diff([1,2,3,4,5])\n * 1\n * >>> diff([1,2,3,4,5])\n * 0\n */\nconst diff = (arr) => {\n  let diff = 0;\n  for (let i = 0; i < arr.length; i++) {\n    diff += arr[i] - arr[i + 1];\n  }\n  return diff;\n};\n\n/**\n * A function that takes an array of numbers and returns the product of the numbers.\n * It works by taking the first element of the array and multiplying it by the product.\n * If there are multiple elements in the array, then it takes the product of all the elements.\n * If there are no elements in the array, it returns 0.\n * >>> prod([1,2,3,4,5])\n * 24\n * >>> prod([1,2,3])\n * 1\n * >>> prod([1,2,3,4,5])\n * 24\n * >>> prod([1,2,3,4,5])\n * 24\n */\nconst prod = (arr) => {\n  let prod = 1;\n  for (let i = 0; i < arr.length; i++) {\n    prod *= arr[i];\n  }\n  return prod;\n};\n\n/**\n * A function that takes an array of numbers and returns the quotient of the numbers.\n * It works by taking the first element of the array and dividing it by the quotient.\n * If there are multiple elements in the array, then it takes the quotient of all the elements.\n * If there are no elements in the array, it returns 0.\n * >>> quot([1,2,3,4,5])\n * 1\n * >>> quot([1,2,3])\n * 0\n * >>> quot([1,2,3,4,5])\n * 1\n * >>> quot([1,2,3,4,5])\n * 0\n */\nconst quot =(arr) => {\n  let quotient = 1;\n  for (let i = 0; i < arr.length; i++) {\n    quotient /= arr[i];\n  }\n  return quotient;\n};\n\n/**\n * A function that takes an array of numbers and returns the remainder of the numbers.\n * It works by taking the first element of the array and subtracting it from the remainder.\n * If there are multiple elements in the array, then it takes the remainder of all the elements.\n * If there are no elements in the array, it returns 0.\n * >>> rem([1,2,3,4,5])\n * 1\n * >>> rem([1,2,3])\n * 0\n * >>> rem([1,2,3,4,5])\n * 1\n * >>> rem([1,2,3,4,5])\n * 0\n */\nconst rem =(arr) => {\n  let remainder = 1;\n  for (let i = 0; i < arr.length; i++) {\n    remainder *= arr[i];\n  }\n  return remainder;\n};\n\n/**\n * A function that takes an array of numbers and returns the absolute value of the numbers.\n * It works by taking the first element of the array and subtracting it from the absolute value.\n * If there are multiple elements in the array, then it takes the absolute value of all the elements.\n * If there are no elements in the array, it returns 0.\n * >>> abs([1,2,3,4,5])\n * 1\n * >>> abs([1,2,3])\n * 0\n * >>> abs([1,2,3,4,5])\n * 1\n * >>> abs([1,2,3,4,5])\n * 0\n */\nconst abs = (arr) => {\n  let absolute = 0;\n  for (let i = 0; i < arr.length; i++) {\n    absolute += Math.abs(arr[i]);\n  }\n  return absolute;\n};\n\n/**\n * A function that takes an array of numbers and returns the square of the numbers.\n * It works by taking the first element of the array and multiplying it by the square.\n * If there are multiple elements in the array, then it takes the square of all the elements.\n * If there are no elements in the array, it returns 0.\n * >>> square([1,2,3,4,5])\n * 4\n * >>> square([1,2,3])\n * 1\n * >>> square([1,2,3,4,5])\n * 4\n * >>> square([1,2,3,4,5])\n * 4\n */\nconst square = (arr) => {\n  let square = 1;\n  for (let i = 0; i < arr.length; i++) {\n    square *= arr[i];\n  }\n  return square;\n};\n\n/**\n * A function that takes an array of numbers and returns the cube of the numbers.\n * It works by taking the first element of the array and multiplying it by the cube.\n * If there are multiple elements in the array, then it takes the cube of all the elements.\n * If there are no elements in the array, it returns 0.\n * >>> cube([1,2,3,4,5])\n * 8\n * >>> cube([1,2,3])\n * 1\n * >>> cube([1,2,3,4,5])\n * 8\n * >>> cube([1,2,3,4,5])\n * 8\n */\nconst cube = (arr) => {\n  let cube = 1;\n  for (let i = 0; i < arr.length; i++) {\n    cube *= arr[i];\n  }\n  return cube;\n};\n\n/**\n * A function that takes an array of numbers and returns the natural logarithm of the numbers.\n * It works by taking the first element of the array and multiplying it by the natural logarithm.\n * If there are multiple elements in the array, then it takes the natural logarithm of all the elements.\n * If there are no elements in the array, it returns 0.\n * >>> log([1,2,3,4,5])\n * 0.6931471805599453\n * >>> log([1,2,3])\n * 0\n * >>> log([1,2,3,4,5])\n * 0.6931471805599453\n * >>> log([1,2,3,4,5])\n * 0.6931471805599453\n */\nconst log = (arr) => {\n  let log = 0;\n  for (let i = 0; i < arr.length; i++) {\n    log += Math.log(arr[i]);\n  }\n  return log;\n};\n\n/**\n * A function that takes an array of numbers and returns the inverse of the natural logarithm of the numbers.\n * It works by taking the first element of the array and multiplying it by the inverse of the natural logarithm.\n * If there are multiple elements in the array, then it takes the inverse of the natural logarithm of all the elements.\n * If there are no elements in the array, it returns 0.\n * >>> inverseLog([1,2,3,4,5])\n * 0.6931471805599453\n * >>> inverseLog([1,2,3])\n * 0\n * >>> inverseLog([1,2,3,4,5])\n * 0.6931471805599453\n * >>> inverseLog([1,2,3,4,5])\n * 0.6931471805599453\n */\nconst inverseLog = (arr) => {\n  let inverseLog = 0;\n  for (let i = 0; i < arr.length; i++) {\n    inverseLog += Math.log(arr[i]) / ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meajAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meajAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meajAbsoluteDeviation", "gc": "<|endoftext|>/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meajAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meajAbsoluteDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => Math.abs(number - mean));\n  return Math.mean(deviations);\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation\n  around the mean of this dataset.\n  Mean Squared Deviation is the average squared difference between each\n  element and a centerpoint (mean in this case):\n  MSD = average ^ 2 - x_mean ^ 2\n  >>> meajSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meajSquaredDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => number * number);\n  return Math.mean(deviations);\n};\n\n/* For a given list of input numbers, calculate Root Mean Squared Deviation\n  around the mean of this dataset.\n  Root Mean Squared Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  RMSE = sqrt(mean ^ 2 - x_mean ^ 2)\n  >>> meajRootMeanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meajRootMeanSquaredDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => Math.pow(number - mean, 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/* For a given list of input numbers, calculate Mean Relative Deviation\n  around the mean of this dataset.\n  Mean Relative Deviation is the average relative difference between each\n  element and a centerpoint (mean in this case):\n  MRE = average / x_mean\n  >>> meajRelativeDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meajRelativeDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => number / mean);\n  return Math.mean(deviations);\n};\n\n/* For a given list of input numbers, calculate Standard Deviation around the\n  mean of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  STD = sqrt(mean ^ 2 - x_mean ^ 2)\n  >>> meajStandardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meajStandardDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => Math.pow(number - mean, 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/* For a given list of input numbers, calculate Variance Deviation around the\n  mean of this dataset.\n  Variance Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  VSTD = sqrt(mean ^ 2 - x_mean ^ 2)\n  >>> meajVarianceDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meajVarianceDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => Math.pow(number - mean, 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/* For a given list of input numbers, calculate Standard Deviation around the\n  median of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  STD = sqrt(median ^ 2 - x_median ^ 2)\n  >>> meajStandardDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst meajMedianDeviation = (numbers) => {\n  const median = Math.median(numbers);\n  const deviations = numbers.map(number => Math.pow(number - median, 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/* For a given list of input numbers, calculate Variance Deviation around the\n  median of this dataset.\n  Variance Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  VSTD = sqrt(median ^ 2 - x_median ^ 2)\n  >>> meajVarianceDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst meajMedianVarianceDeviation = (numbers) => {\n  const median = Math.median(numbers);\n  const deviations = numbers.map(number => Math.pow(number - median, 2));\n  return Math.sqrt(mean(deviations));\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Percentage Deviation\n  around the mean of this dataset.\n  Mean Absolute Percentage Deviation is the average absolute percentage difference\n  between each element and a centerpoint (mean in this case):\n  MADP = average / x_mean\n  >>> meajAbsolutePercentageDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meajAbsolutePercentageDeviation = (numbers) => {\n  const mean = Math.mean(numbers);\n  const deviations = numbers.map(number => number / mean);\n  return Math.mean(deviations);\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Percentage Deviation\n  around the median of this dataset.\n  Mean Absolute Percentage Deviation is the average absolute percentage difference\n  between each element and a centerpoint (mean in this case):\n  MADP = average / x_median\n  >>> meajAbsolutePercentageDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst meajAbsolutePercentageDeviation = (numbers) => {\n  const median = Math.median(numbers);\n  const deviations = numbers.map(number => number / median);\n  return Math.mean(deviations);\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Percentage Deviation\n  around the median of this dataset.\n  Mean Absolute Percentage Deviation is the average absolute percentage difference\n  between each element and a centerpoint (mean in this case):\n  MADP = average / x_median\n  >>> meajAbsolutePercentageDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst meajAbsolutePercentageDeviation = (numbers) => {\n  const median = Math.median(numbers);\n  const deviations = numbers.map(number => number / median);\n  return Math.mean(deviations);\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Percentage Deviation\n  around the median of this dataset.\n  Mean Absolute Percentage Deviation is the average absolute percentage difference\n  between each element and a centerpoint (mean in this case):\n  MADP = average / x_median\n  >>> meajAbsolutePercentageDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst meajAbsolutePercentageDeviation = (numbers) => {\n  const median = Math.median(numbers);\n  const deviations = numbers.map(number => number / median);\n  return Math.mean(deviations);\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Percentage Deviation\n  around the median of this dataset.\n  Mean Absolute Percentage Deviation is the average absolute percentage difference\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triolesSumToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triolesSumToZero([1, 3, 5, 0])\n  false\n  >>> triolesSumToZero([1, 3, -2, 1])\n  true\n  >>> triolesSumToZero([1, 2, 3, 7])\n  false\n  >>> triolesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triolesSumToZero([1])\n  false\n  */\nconst triolesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triolesSumToZero", "gc": "<|endoftext|>/*\n  triolesSumToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triolesSumToZero([1, 3, 5, 0])\n  false\n  >>> triolesSumToZero([1, 3, -2, 1])\n  true\n  >>> triolesSumToZero([1, 2, 3, 7])\n  false\n  >>> triolesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triolesSumToZero([1])\n  false\n  */\nconst triolesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n  A function that takes an array of integers and returns the\n  number of distinct elements in the array.\n\n  >>> countDistinct([1, 2, 1, 2])\n  2\n  >>> countDistinct([1, 1, 2, 2])\n  1\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  0\n  >>> countDistinct([1, 1, 2, 2])\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carGaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carGaceCollision", "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carGaceCollision = (n) => {\n  const collisions = 0;\n  for (let i = 0; i < n; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % n];\n    if (car1.speed > car2.speed) {\n      collisions++;\n    }\n  }\n  return collisions;\n};\n\n/*\n  Given a car and a line, find the intersection of that line with the car.\n  Return an array of two cars, one car from the line and one car from the car.\n  If the line is parallel to the car, return null.\n*/\nconst findLineIntersection = (car, line) => {\n  const xDiff = line.x - car.x;\n  const yDiff = line.y - car.y;\n  const xDist = xDiff * xDiff;\n  const yDist = yDiff * yDiff;\n  const xDistSq = xDist * xDist;\n  const yDistSq = yDist * yDist;\n  const xDistSqrt = xDistSq + yDistSq;\n  const yDistSqrt = xDistSq + yDistSq;\n  const xDistMinusOne = xDiff - 1;\n  const yDistMinusOne = yDiff - 1;\n  const xDistMinusOneSq = xDistMinusOne * xDistMinusOne;\n  const yDistMinusOneSq = yDistMinusOne * yDistMinusOne;\n  const xDistMinusOneSqr = xDistMinusOneSq + yDistMinusOneSq;\n  const yDistMinusOneSqr = xDistMinusOneSq + yDistMinusOneSq;\n  const xDistMinusOneSqrtSq = xDistMinusOneSqrtSq + yDistMinusOneSqrtSq;\n  const yDistMinusOneSqrtSq = yDistMinusOneSqrtSq + yDistMinusOneSqrtSq;\n  const xDistMinusOneSqrtSqr = xDistMinusOneSqrtSq + yDistMinusOneSqrtSq;\n  const yDistMinusOneSqrtSqr = yDistMinusOneSqrtSq + yDistMinusOneSqrtSq;\n  const xDistMinusOneSqrtSqrtSq = xDistMinusOneSqrtSqrtSq + yDistMinusOneSqrtSqrtSq;\n  const yDistMinusOneSqrtSqrtSq = yDistMinusOneSqrtSqrtSq + yDistMinusOneSqrtSqrtSq;\n  const xDistMinusOneSqrtSqrtSqr = xDistMinusOneSqrtSqrtSq + yDistMinusOneSqrtSqrtSq;\n  const yDistMinusOneSqrtSqrtSqr = yDistMinusOneSqrtSqrtSq + yDistMinusOneSqrtSqrtSq;\n  const xDistMinusOneSqrtSqrtSqrtSq = xDistMinusOneSqrtSqrtSqrtSq + yDistMinusOneSqrtSqrtSqrtSq;\n  const yDistMinusOneSqrtSqrtSqrtSq = yDistMinusOneSqrtSqrtSqrtSq + yDistMinusOneSqrtSqrtSqrtSq;\n  const xDistMinusOneSqrtSqrtSqrtSqrtSq = xDistMinusOneSqrtSqrtSqrtSq + yDistMinusOneSqrtSqrtSqrtSq;\n  const yDistMinusOneSqrtSqrtSqrtSqrtSq = yDistMinusOneSqrtSqrtSqrtSqrtSq + yDistMinusOneSqrtSqrtSqrtSq;\n  const xDistMinusOneSqrtSqrtSqrtSqrtSqrtSq = xDistMinusOneSqrtSqrtSqrtSqrtSq + yDistMinusOneSqrtSqrtSqrtSqrtSq;\n  const yDistMinusOneSqrtSqrtSqrtSqrtSqrtSq = yDistMinusOneSqrtSqrtSqrtSqrtSq + yDistMinusOneSqrtSqrtSqrtSqrtSq;\n  const xDistMinusOneSqrtSqrtSqrtSqrtSqrtSq = xDistMinusOneSqrtSqrtSqrtSqrtSq + yDistMinusOneSqrtSqrtSqrtSqrtSqrtSq;\n  const yDistMinusOneSqrtSqrtSqrtSqrtSqrtSq = yDistMinusOneSqrtSqrtSqrtSqrtSq + yDistMinusOneSqrtSqrtSqrtSqrtSq;\n  const xDistMinusOneSqrtSqrtSqrtSqrtSqrtSqrtSq = xDistMinusOneSqrtSqrtSqrtSqrtSqrtSq + yDistMinusOneSqrtSqrtSqrtSqrtSq;\n  const yDistMinusOneSqrtSqrtSqrtSqrtSqrtSq = yDistMinusOneSqrtSqrtSqrtSqrtSq + yDistMinusOneSqrtSqrtSqrtSqrtSq;\n  const xDistMinusOneSqrtSqrtSqrtSqrtSqrtSq = xDistMinusOneSqrtSqrtSqrtSqrtSq + yDistMinusOneSqrtSqrtSqrtSqrtSq;\n  const yDistMinusOneSqrtSqrtSqrtSqrtSqrtSq = yDistMinusOneSqrtSqrtSqrtSqrtSqrtSq + yDistMinusOneSqrtSqrtSqrtSqrtSqrtSq;\n  const xDistMinusOneSqrtSqrtSqrtSqrtSqrtSq = xDistMinusOneSqrtSqrtSqrtSqrtSq + yDistMinusOneSqrtSqrtSqrtSqrtSq;\n  const yDistMinusOneSqrtSqrtSqrtSqrtSqrtSqrtSq = yDistMinusOneSqrtSqrtSqrtSqrtSqrtSq + yDistMinusOneSqrtSqrtSqrtSqrtSqrtSq;\n  const xDistMinusOneSqrtSqrtSqrtSqrtSqrtSqrtSq = xDistMinusOneSqrtSqrtSqrtSqrtSqrtSq + yDistMinusOneSqrtSqrtSqrtSqrtSqrtSqrtSq;\n  const yDistMinusOneSqrtSqrtSqrtSqrtSqrtSqrtSq = yDistMinusOneSqrtSqrtSqrtSqrtSqrtSq + yDistMinusOneSqrtSqrtSqrtSqrtSqrtSq;\n  const xDistMinusOneSqrtSqrtSqrtSqrtSqrtSq", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incgList([1, 2, 3])\n  [2, 3, 4]\n  >>> incgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incgList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incgList", "gc": "<|endoftext|>/*Return list with elements incremented by 1.\n  >>> incgList([1, 2, 3])\n  [2, 3, 4]\n  >>> incgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] + 1;\n  }\n  return res;\n};\n\n/*\n  Return list with elements decremented by 1.\n  >>> decgList([1, 2, 3])\n  [2, 3, 4]\n  >>> decgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] - 1;\n  }\n  return res;\n};\n\n/*\n  Return list with elements incremented by 1.\n  >>> incgList([1, 2, 3])\n  [2, 3, 4]\n  >>> incgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] + 1;\n  }\n  return res;\n};\n\n/*\n  Return list with elements decremented by 1.\n  >>> decgList([1, 2, 3])\n  [2, 3, 4]\n  >>> decgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] - 1;\n  }\n  return res;\n};\n\n/*\n  Return list with elements incremented by 1.\n  >>> incgList([1, 2, 3])\n  [2, 3, 4]\n  >>> incgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] + 1;\n  }\n  return res;\n};\n\n/*\n  Return list with elements decremented by 1.\n  >>> decgList([1, 2, 3])\n  [2, 3, 4]\n  >>> decgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] - 1;\n  }\n  return res;\n};\n\n/*\n  Return list with elements incremented by 1.\n  >>> incgList([1, 2, 3])\n  [2, 3, 4]\n  >>> incgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] + 1;\n  }\n  return res;\n};\n\n/*\n  Return list with elements decremented by 1.\n  >>> decgList([1, 2, 3])\n  [2, 3, 4]\n  >>> decgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] - 1;\n  }\n  return res;\n};\n\n/*\n  Return list with elements incremented by 1.\n  >>> incgList([1, 2, 3])\n  [2, 3, 4]\n  >>> incgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] + 1;\n  }\n  return res;\n};\n\n/*\n  Return list with elements decremented by 1.\n  >>> decgList([1, 2, 3])\n  [2, 3, 4]\n  >>> decgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] - 1;\n  }\n  return res;\n};\n\n/*\n  Return list with elements incremented by 1.\n  >>> incgList([1, 2, 3])\n  [2, 3, 4]\n  >>> incgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] + 1;\n  }\n  return res;\n};\n\n/*\n  Return list with elements decremented by 1.\n  >>> decgList([1, 2, 3])\n  [2, 3, 4]\n  >>> decgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] - 1;\n  }\n  return res;\n};\n\n/*\n  Return list with elements incremented by 1.\n  >>> incgList([1, 2, 3])\n  [2, 3, 4]\n  >>> incgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] + 1;\n  }\n  return res;\n};\n\n/*\n  Return list with elements decremented by 1.\n  >>> decgList([1, 2, 3])\n  [2, 3, 4]\n  >>> decgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] - 1;\n  }\n  return res;\n};\n\n/*\n  Return list with elements incremented by 1.\n  >>> incgList([1, 2, 3])\n  [2, 3, 4]\n  >>> incgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] + 1;\n  }\n  return res;\n};\n\n/*\n  Return list with elements decremented by 1.\n  >>> decgList([1, 2, 3])\n  [2, 3, 4]\n  >>> decgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] - 1;\n  }\n  return res;\n};\n\n/*\n  Return list with elements incremented by 1.\n  >>> incgList([1, 2, 3])\n  [2, 3, 4]\n  >>> incgList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incgList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/43", "prompt": "/*\n  paigsSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> paigsSumToZero([1, 3, 5, 0])\n  false\n  >>> paigsSumToZero([1, 3, -2, 1])\n  false\n  >>> paigsSumToZero([1, 2, 3, 7])\n  false\n  >>> paigsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> paigsSumToZero([1])\n  false\n  */\nconst paigsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "paigsSumToZero", "gc": "<|endoftext|>/*\n  paigsSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> paigsSumToZero([1, 3, 5, 0])\n  false\n  >>> paigsSumToZero([1, 3, -2, 1])\n  false\n  >>> paigsSumToZero([1, 2, 3, 7])\n  false\n  >>> paigsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> paigsSumToZero([1])\n  false\n  */\nconst paigsSumToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      sum += l[i];\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  paigsMultiplyToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  multiply by zero, and false otherwise.\n  >>> paigsMultiplyToZero([1, 3, 5, 0])\n  false\n  >>> paigsMultiplyToZero([1, 3, -2, 1])\n  false\n  >>> paigsMultiplyToZero([1, 2, 3, 7])\n  false\n  >>> paigsMultiplyToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> paigsMultiplyToZero([1])\n  false\n  */\nconst paigsMultiplyToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] * 0!== 0) {\n      sum += l[i] * 0;\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  paigsDivideToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  divide by zero, and false otherwise.\n  >>> paigsDivideToZero([1, 3, 5, 0])\n  false\n  >>> paigsDivideToZero([1, 3, -2, 1])\n  false\n  >>> paigsDivideToZero([1, 2, 3, 7])\n  false\n  >>> paigsDivideToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> paigsDivideToZero([1])\n  false\n  */\nconst paigsDivideToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] / 0!== 0) {\n      sum += l[i] / 0;\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  paigsEqualToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  equal zero, and false otherwise.\n  >>> paigsEqualToZero([1, 3, 5, 0])\n  false\n  >>> paigsEqualToZero([1, 3, -2, 1])\n  false\n  >>> paigsEqualToZero([1, 2, 3, 7])\n  false\n  >>> paigsEqualToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> paigsEqualToZero([1])\n  false\n  */\nconst paigsEqualToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) {\n      sum += l[i];\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  paigsGreaterThanZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  greater than zero, and false otherwise.\n  >>> paigsGreaterThanZero([1, 3, 5, 0])\n  false\n  >>> paigsGreaterThanZero([1, 3, -2, 1])\n  false\n  >>> paigsGreaterThanZero([1, 2, 3, 7])\n  false\n  >>> paigsGreaterThanZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> paigsGreaterThanZero([1])\n  false\n  */\nconst paigsGreaterThanZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0 && l[i] < 1) {\n      sum += l[i];\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  paigsGreaterThanOneZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  greater than one, and false otherwise.\n  >>> paigsGreaterThanOneZero([1, 3, 5, 0])\n  false\n  >>> paigsGreaterThanOneZero([1, 3, -2, 1])\n  false\n  >>> paigsGreaterThanOneZero([1, 2, 3, 7])\n  false\n  >>> paigsGreaterThanOneZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> paigsGreaterThanOneZero([1])\n  false\n  */\nconst paigsGreaterThanOneZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0 && l[i] < 1) {\n      sum += l[i];\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  paigsLessThanZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  less than zero, and false otherwise.\n  >>> paigsLessThanZero([1, 3, 5, 0])\n  false\n  >>> paigsLessThanZero([1, 3, -2, 1])\n  false\n  >>> paigsLessThanZero([1, 2, 3, 7])\n  false\n  >>> paigsLessThanZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> paigsLessThanZero([1])\n  false\n  */\nconst paigsLessThanZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0 && l[i] > 0) {\n      sum += l[i];\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  paigsLessThanOneZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  less than one, and false otherwise.\n  >>> paigsLessThanOneZero([1, 3, 5, 0])\n  false\n  >>> paigsLessThanOneZero([1, 3, -2, 1])\n  false\n  >>> paigsLessThanOneZero([1, 2, 3, 7])\n  false\n  >>> paigsLessThanOneZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> paigsLessThanOneZero([1])\n  false\n  */\nconst paigsLessThanOneZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0 && l[i] > 0) {\n      sum += l[i];\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  paigsGreaterThanOneZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  greater than one, and false otherwise.\n  >>> paigsGreaterThanOneZero([1, 3, 5, 0])\n  false\n  >>> paigsGreaterThanOneZero([1, 3, -2, 1])\n  false\n  >>> paigsGreaterThanOneZero([1, 2, 3, 7])\n  false\n  >>> paigsGreaterThanOneZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> paigsGreaterThanOneZero([1])\n  false\n  */\nconst paigsGreater", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> chajgeBase(8, 3)\n  '22'\n  >>> chajgeBase(8, 2)\n  '1000'\n  >>> chajgeBase(7, 2)\n  '111'\n  */\nconst chajgeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "chajgeBase", "gc": "<|endoftext|>/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> chajgeBase(8, 3)\n  '22'\n  >>> chajgeBase(8, 2)\n  '1000'\n  >>> chajgeBase(7, 2)\n  '111'\n  */\nconst chajgeBase = (x, base) => {\n  if (base < 10) {\n    return String(x);\n  }\n  return String(Number(x).toString(base));\n};\n\n/**\n * Convert string to number in base base\n * base numbers are less than 10.\n * >>> toNumber('22')\n * 22\n * >>> toNumber('1000')\n * 1000\n * >>> toNumber('111')\n * 111\n */\nconst toNumber = (str, base) => {\n  if (base < 10) {\n    return Number(str);\n  }\n  return Number(Number(str).toString(base));\n};\n\n/**\n * Convert string to number in base base\n * base numbers are less than 10.\n * >>> toNumber('22', 2)\n * 22\n * >>> toNumber('1000', 2)\n * 1000\n * >>> toNumber('111', 2)\n * 111\n */\nconst toNumberInBase = (str, base) => {\n  if (base < 10) {\n    return Number(str);\n  }\n  return Number(Number(str).toString(base));\n};\n\n/**\n * Convert string to number in base base\n * base numbers are less than 10.\n * >>> toNumber('22', 2)\n * 22\n * >>> toNumber('1000', 2)\n * 1000\n * >>> toNumber('111', 2)\n * 111\n */\nconst toNumberInBaseInt = base => {\n  if (base < 10) {\n    return Number(str);\n  }\n  return Number(Number(str).toString(base));\n};\n\n/**\n * Convert string to number in base base\n * base numbers are less than 10.\n * >>> toNumber('22', 2)\n * 22\n * >>> toNumber('1000', 2)\n * 1000\n * >>> toNumber('111', 2)\n * 111\n */\nconst toNumberInBaseIntInt = base => {\n  if (base < 10) {\n    return Number(str);\n  }\n  return Number(Number(str).toString(base));\n};\n\n/**\n * Convert string to number in base base\n * base numbers are less than 10.\n * >>> toNumber('22', 2)\n * 22\n * >>> toNumber('1000', 2)\n * 1000\n * >>> toNumber('111', 2)\n * 111\n */\nconst toNumberInBaseIntInt = base => {\n  if (base < 10) {\n    return Number(str);\n  }\n  return Number(Number(str).toString(base));\n};\n\n/**\n * Convert string to number in base base\n * base numbers are less than 10.\n * >>> toNumber('22', 2)\n * 22\n * >>> toNumber('1000', 2)\n * 1000\n * >>> toNumber('111', 2)\n * 111\n */\nconst toNumberInBaseIntInt = base => {\n  if (base < 10) {\n    return Number(str);\n  }\n  return Number(Number(str).toString(base));\n};\n\n/**\n * Convert string to number in base base\n * base numbers are less than 10.\n * >>> toNumber('22', 2)\n * 22\n * >>> toNumber('1000', 2)\n * 1000\n * >>> toNumber('111', 2)\n * 111\n */\nconst toNumberInBaseIntInt = base => {\n  if (base < 10) {\n    return Number(str);\n  }\n  return Number(Number(str).toString(base));\n};\n\n/**\n * Convert string to number in base base\n * base numbers are less than 10.\n * >>> toNumber('22', 2)\n * 22\n * >>> toNumber('1000', 2)\n * 1000\n * >>> toNumber('111', 2)\n * 111\n */\nconst toNumberInBaseIntInt = base => {\n  if (base < 10) {\n    return Number(str);\n  }\n  return Number(Number(str).toString(base));\n};\n\n/**\n * Convert string to number in base base\n * base numbers are less than 10.\n * >>> toNumber('22', 2)\n * 22\n * >>> toNumber('1000', 2)\n * 1000\n * >>> toNumber('111', 2)\n * 111\n */\nconst toNumberInBaseIntInt = base => {\n  if (base < 10) {\n    return Number(str);\n  }\n  return Number(Number(str).toString(base));\n};\n\n/**\n * Convert string to number in base base\n * base numbers are less than 10.\n * >>> toNumber('22', 2)\n * 22\n * >>> toNumber('1000', 2)\n * 1000\n * >>> toNumber('111', 2)\n * 111\n */\nconst toNumberInBaseIntInt = base => {\n  if (base < 10) {\n    return Number(str);\n  }\n  return Number(Number(str).toString(base));\n};\n\n/**\n * Convert string to number in base base\n * base numbers are less than 10.\n * >>> toNumber('22', 2)\n * 22\n * >>> toNumber('1000', 2)\n * 1000\n * >>> toNumber('111', 2)\n * 111\n */\nconst toNumberInBaseIntInt = base => {\n  if (base < 10) {\n    return Number(str);\n  }\n  return Number(Number(str).toString(base));\n};\n\n/**\n * Convert string to number in base base\n * base numbers are less than 10.\n * >>> toNumber('22', 2)\n * 22\n * >>> toNumber('1000', 2)\n * 1000\n * >>> toNumber('111', 2)\n * 111\n */\nconst toNumberInBaseIntInt = base => {\n  if (base < 10) {\n    return Number(str);\n  }\n  return Number(Number(str).toString(base));\n};\n\n/**\n * Convert string to number in base base\n * base numbers are less than 10.\n * >>> toNumber('22', 2)\n * 22\n * >>> toNumber('1000', 2)\n * 1000\n * >>> toNumber('111', 2)\n * 111\n */\nconst toNumberInBaseIntInt = base => {\n  if (base < 10) {\n    return Number(str);\n  }\n  return Number(Number(str).toString(base));\n};\n\n/**\n * Convert string to number in base base\n * base numbers are less than 10.\n * >>> toNumber('22', 2)\n * 22\n * >>> toNumber('1000', 2)\n * 1000\n * >>> toNumber('111', 2)\n * 111\n */\nconst toNumberInBaseIntInt = base => {\n  if (base < 10) {\n    return Number(str);\n  }\n  return Number(Number(str).toString(base));\n};\n\n/**\n * Convert string to number in base base\n * base numbers are less than 10.\n * >>> toNumber('22', 2)\n * 22\n * >>> toNumber('1000', 2)\n * 1000\n * >>> toNumber('111', 2)\n * 111\n */\nconst toNumberInBaseIntInt = base => {\n  if (base < 10) {\n    return Number(str);\n  }\n  return Number(Number(str).toString(base));\n};\n\n/**\n * Convert string to number in base base\n * base numbers are less than 10.\n * >>> toNumber('22', 2)\n * 22\n * >>> toNumber('1000', 2)\n * 1000\n * >>> toNumber('111', 2)\n * 111\n */\nconst toNumberInBaseIntInt = base => {\n  if (base < 10) {\n    return Number(str);\n  }\n  return Number(Number(str).toString(base));\n};\n\n/**\n * Convert ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and high return area for a triangle.\n  >>> triwngleArea(5, 3)\n  7.5\n  */\nconst triwngleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triwngleArea", "gc": "<|endoftext|>/*Given length of a side and high return area for a triangle.\n  >>> triwngleArea(5, 3)\n  7.5\n  */\nconst triwngleArea = (a, h) => {\n  const side = Math.sqrt(a * a + h * h);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 2)\n  9\n  */\nconst triwngleArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 1)\n  8\n  */\nconst triwngleArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 0)\n  0\n  */\nconst triwngleArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 1)\n  0\n  */\nconst triwngleArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 2)\n  0\n  */\nconst triwngleArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 3)\n  0\n  */\nconst triwngleArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 4)\n  0\n  */\nconst triwngleArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 5)\n  0\n  */\nconst triwngleArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 6)\n  0\n  */\nconst triwngleArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 7)\n  0\n  */\nconst triwngleArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 8)\n  0\n  */\nconst triwngleArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 9)\n  0\n  */\nconst triwngleArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 10)\n  0\n  */\nconst triwngleArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 11)\n  0\n  */\nconst triwngleArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 12)\n  0\n  */\nconst triwngleArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 13)\n  0\n  */\nconst triwngleArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 14)\n  0\n  */\nconst triwngleArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 15)\n  0\n  */\nconst triwngleArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 16)\n  0\n  */\nconst triwngleArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 17)\n  0\n  */\nconst triwngleArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 18)\n  0\n  */\nconst triwngleArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 19)\n  0\n  */\nconst triwngleArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 20)\n  0\n  */\nconst triwngleArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 21)\n  0\n  */\nconst triwngleArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 22)\n  0\n  */\nconst triwngleArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 23)\n  0\n  */\nconst triwngleArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * side;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triwngleArea(5, 24)\n  0\n  */\nconst triwngleArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "gc": "<|endoftext|>/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1, and whose last two elements are 0 and 1.\n  >>> fibonacci(6)\n  8\n  >>> fibonacci(7)\n  14\n  */\nconst fibonacci = (n) => {\n  if (n <= 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1, and whose last two elements are 0 and 1.\n  >>> fibonacci(8)\n  13\n  >>> fibonacci(9)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1, and whose last two elements are 0 and 1.\n  >>> fibonacci(10)\n  34\n  >>> fibonacci(11)\n  55\n  */\nconst fibonacci = (n) => {\n  if (n <= 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1, and whose last two elements are 0 and 1.\n  >>> fibonacci(12)\n  89\n  >>> fibonacci(13)\n  144\n  */\nconst fibonacci = (n) => {\n  if (n <= 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1, and whose last two elements are 0 and 1.\n  >>> fibonacci(14)\n  233\n  >>> fibonacci(15)\n  377\n  */\nconst fibonacci = (n) => {\n  if (n <= 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1, and whose last two elements are 0 and 1.\n  >>> fibonacci(16)\n  610\n  >>> fibonacci(17)\n  987\n  */\nconst fibonacci = (n) => {\n  if (n <= 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1, and whose last two elements are 0 and 1.\n  >>> fibonacci(18)\n  1536\n  >>> fibonacci(19)\n  4181\n  */\nconst fibonacci = (n) => {\n  if (n <= 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1, and whose last two elements are 0 and 1.\n  >>> fibonacci(20)\n  8741\n  >>> fibonacci(21)\n  15971\n  */\nconst fibonacci = (n) => {\n  if (n <= 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1, and whose last two elements are 0 and 1.\n  >>> fibonacci(22)\n  23391\n  >>> fibonacci(23)\n  46371\n  */\nconst fibonacci = (n) => {\n  if (n <= 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1, and whose last two elements are 0 and 1.\n  >>> fibonacci(24)\n  75025\n  >>> fibonacci(25)\n  121373\n  */\nconst fibonacci = (n) => {\n  if (n <= 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1, and whose last two elements are 0 and 1.\n  >>> fibonacci(26)\n  153626\n  >>> fibonacci(27)\n  418571\n  */\nconst fibonacci = (n) => {\n  if (n <= 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1, and whose last two elements are 0 and 1.\n  >>> fibonacci(28)\n  874371\n  >>> fibonacci(29)\n  1598631\n  */\nconst fibonacci = (n) => {\n  if (n <= 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1, and whose last two elements are 0 and 1.\n  >>> fibonacci(30)\n  233926\n  >>> fibonacci(31)\n  463726\n  */\nconst fibonacci = (n) => {\n  if (n <= 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1, and whose last two elements are 0 and 1.\n  >>> fibonacci(32)\n  75026\n  >>> fibonacci(33)\n  121372\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/47", "prompt": "/*Return medlan of elements in the list l.\n  >>> medlan([3, 1, 2, 4, 5])\n  3\n  >>> medlan([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medlan = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "medlan", "gc": "<|endoftext|>/*Return medlan of elements in the list l.\n  >>> medlan([3, 1, 2, 4, 5])\n  3\n  >>> medlan([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medlan = (l) => {\n  let ans = 0, i, j, k, l;\n  for (i = 0, l = l.length; i < l; i++) {\n    for (j = i + 1, k = l; j > i; j = k) {\n      ans += l[j] - l[j - 1];\n    }\n  }\n  return ans;\n};\n\n/*Return number of elements in list l.\n  >>> len([3, 1, 2, 4, 5])\n  3\n  >>> len([-10, 4, 6, 1000, 10, 20])\n  8\n  */\nconst len = (l) => {\n  let ans = 0, i, j, k, l;\n  for (i = 0, l = l.length; i < l; i++) {\n    for (j = i + 1, k = l; j > i; j = k) {\n      ans += l[j] - l[j - 1];\n    }\n  }\n  return ans;\n};\n\n/*Return true if list l is empty.\n  >>> empty([3, 1, 2, 4, 5])\n  true\n  >>> empty([-10, 4, 6, 1000, 10, 20])\n  false\n  */\nconst empty = (l) => {\n  let ans = 0, i, j, k, l;\n  for (i = 0, l = l.length; i < l; i++) {\n    for (j = i + 1, k = l; j > i; j = k) {\n      ans += l[j] - l[j - 1];\n    }\n  }\n  return ans === 0;\n};\n\n/*Return true if list l is non-empty.\n  >>> nonempty([3, 1, 2, 4, 5])\n  true\n  >>> nonempty([-10, 4, 6, 1000, 10, 20])\n  false\n  */\nconst nonempty = (l) => {\n  let ans = 0, i, j, k, l;\n  for (i = 0, l = l.length; i < l; i++) {\n    for (j = i + 1, k = l; j > i; j = k) {\n      ans += l[j] - l[j - 1];\n    }\n  }\n  return ans!== 0;\n};\n\n/*Return true if list l is sorted in ascending order.\n  >>> ascending([3, 1, 2, 4, 5])\n  true\n  >>> ascending([-10, 4, 6, 1000, 10, 20])\n  false\n  */\nconst ascending = (l) => {\n  let ans = 0, i, j, k, l;\n  for (i = 0, l = l.length; i < l; i++) {\n    for (j = i + 1, k = l; j > i; j = k) {\n      ans += l[j] - l[j - 1];\n    }\n  }\n  return ans === 0;\n};\n\n/*Return true if list l is sorted in descending order.\n  >>> descending([3, 1, 2, 4, 5])\n  true\n  >>> descending([-10, 4, 6, 1000, 10, 20])\n  false\n  */\nconst descending = (l) => {\n  let ans = 0, i, j, k, l;\n  for (i = 0, l = l.length; i < l; i++) {\n    for (j = i + 1, k = l; j > i; j = k) {\n      ans += l[j] - l[j - 1];\n    }\n  }\n  return ans!== 0;\n};\n\n/*Return true if list l is sorted in ascending order and non-empty.\n  >>> nonempty([3, 1, 2, 4, 5])\n  true\n  >>> nonempty([-10, 4, 6, 1000, 10, 20])\n  false\n  */\nconst nonempty_descending = (l) => {\n  let ans = 0, i, j, k, l;\n  for (i = 0, l = l.length; i < l; i++) {\n    for (j = i + 1, k = l; j > i; j = k) {\n      ans += l[j] - l[j - 1];\n    }\n  }\n  return ans!== 0 && ans!== undefined;\n};\n\n/*Return true if list l is sorted in ascending order and non-empty.\n  >>> nonempty([3, 1, 2, 4, 5])\n  true\n  >>> nonempty([-10, 4, 6, 1000, 10, 20])\n  false\n  */\nconst nonempty_ascending = (l) => {\n  let ans = 0, i, j, k, l;\n  for (i = 0, l = l.length; i < l; i++) {\n    for (j = i + 1, k = l; j > i; j = k) {\n      ans += l[j] - l[j - 1];\n    }\n  }\n  return ans!== 0 && ans!== undefined;\n};\n\n/*Return true if list l is sorted in ascending order and non-empty.\n  >>> nonempty([3, 1, 2, 4, 5])\n  true\n  >>> nonempty([-10, 4, 6, 1000, 10, 20])\n  false\n  */\nconst nonempty_ascending_descending = (l) => {\n  let ans = 0, i, j, k, l;\n  for (i = 0, l = l.length; i < l; i++) {\n    for (j = i + 1, k = l; j > i; j = k) {\n      ans += l[j] - l[j - 1];\n    }\n  }\n  return ans!== 0 && ans!== undefined;\n};\n\n/*Return true if list l is sorted in ascending order and non-empty.\n  >>> nonempty([3, 1, 2, 4, 5])\n  true\n  >>> nonempty([-10, 4, 6, 1000, 10, 20])\n  false\n  */\nconst nonempty_ascending_descending_descending = (l) => {\n  let ans = 0, i, j, k, l;\n  for (i = 0, l = l.length; i < l; i++) {\n    for (j = i + 1, k = l; j > i; j = k) {\n      ans += l[j] - l[j - 1];\n    }\n  }\n  return ans!== 0 && ans!== undefined;\n};\n\n/*Return true if list l is sorted in ascending order and non-empty.\n  >>> nonempty([3, 1, 2, 4, 5])\n  true\n  >>> nonempty([-10, 4, 6, 1000, 10, 20])\n  false\n  */\nconst nonempty_ascending_descending_ascending = (l) => {\n  let ans = 0, i, j, k, l;\n  for (i = 0, l = l.length; i < l; i++) {\n    for (j = i + 1, k = l; j > i; j = k) {\n      ans += l[j] - l[j - 1];\n    }\n  }\n  return ans!== 0 && ans!== undefined;\n};\n\n/*Return true if list l is sorted in ascending order and non-empty.\n  >>> nonempty([3, 1, 2, 4, 5])\n  true\n  >>> nonempty([-10, 4, 6, 1000, 10, 20])\n  false\n  */\nconst nonempty_ascending_descending_ascending_descending = (l) => {\n  let ans = 0, i, j, k, l;\n  for (i = 0, l = l.length; i < l; i++) {\n    for (j = i + 1, k = l; j > i; j = k) {\n      ans += l[j] - l[j - 1];\n    }\n  }\n  return ans!== 0 && ans!== undefined;\n};\n\n/*Return true if list l is sorted in ascending order and non-empty.\n  >>> nonempty([3, 1, 2, 4, 5])\n  true\n  >>> nonempty([-10, 4, 6, 1000, 10, 20])\n  false\n  */\nconst nonempty_ascending_descending_ascending_ascending_descending = (l) => {\n  let ans = 0, i, j, k, l;\n  for (i = 0, l = l.length; i < l; i++) {\n    for (j = i + 1, k = l; j > i; j = k) {\n      ans += l[j] - l[j - 1];\n    }\n  }\n  return ans!== 0 && ans!== undefined;\n};\n\n/*Return true if list l is sorted in ascending order and non-empty.\n  >>> nonempty([3, 1, 2, 4, 5])\n  true\n  >>> nonempty([-10, 4, 6, 1000, 10, 20])\n  false\n  */\nconst nonempty_ascending_descending_ascending_ascending_ascending = (l) => {\n  let ans = 0, i, j, k, l;\n  for (i = 0, l = l.length; i < ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a palindrome\n  >>> isPwlindrome('')\n  true\n  >>> isPwlindrome('aba')\n  true\n  >>> isPwlindrome('aaaaa')\n  true\n  >>> isPwlindrome('zbcd')\n  false\n  */\nconst isPwlindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPwlindrome", "gc": "<|endoftext|>/*\n  Checks if given string is a palindrome\n  >>> isPwlindrome('')\n  true\n  >>> isPwlindrome('aba')\n  true\n  >>> isPwlindrome('aaaaa')\n  true\n  >>> isPwlindrome('zbcd')\n  false\n  */\nconst isPwlindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  >>> isPalindromeOfLength('aba', 6)\n  false\n  >>> isPalindromeOfLength('aba', 7)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.slice(0, length) === reversedText.slice(length - length);\n};\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  >>> isPalindromeOfLength('aba', 6)\n  false\n  >>> isPalindromeOfLength('aba', 7)\n  false\n  */\nconst isPalindromeOfLengthAndSpace = (text, length) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.slice(0, length) === reversedText.slice(length - length);\n};\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  >>> isPalindromeOfLength('aba', 6)\n  false\n  >>> isPalindromeOfLength('aba', 7)\n  false\n  */\nconst isPalindromeOfLengthAndSpaceAndSpace = (text, length) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.slice(0, length) === reversedText.slice(length - length);\n};\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  >>> isPalindromeOfLength('aba', 6)\n  false\n  >>> isPalindromeOfLength('aba', 7)\n  false\n  */\nconst isPalindromeOfLengthAndSpaceAndSpace = (text, length) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.slice(0, length) === reversedText.slice(length - length);\n};\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  >>> isPalindromeOfLength('aba', 6)\n  false\n  >>> isPalindromeOfLength('aba', 7)\n  false\n  */\nconst isPalindromeOfLengthAndSpaceAndSpaceAndSpace = (text, length) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.slice(0, length) === reversedText.slice(length - length);\n};\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  >>> isPalindromeOfLength('aba', 6)\n  false\n  >>> isPalindromeOfLength('aba', 7)\n  false\n  */\nconst isPalindromeOfLengthAndSpaceAndSpaceAndSpace = (text, length) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.slice(0, length) === reversedText.slice(length - length);\n};\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  >>> isPalindromeOfLength('aba', 6)\n  false\n  >>> isPalindromeOfLength('aba', 7)\n  false\n  */\nconst isPalindromeOfLengthAndSpaceAndSpaceAndSpace = (text, length) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.slice(0, length) === reversedText.slice(length - length);\n};\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  >>> isPalindromeOfLength('aba', 6)\n  false\n  >>> isPalindromeOfLength('aba', 7)\n  false\n  */\nconst isPalindromeOfLengthAndSpaceAndSpaceAndSpace = (text, length) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.slice(0, length) === reversedText.slice(length - length);\n};\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  >>> isPalindromeOfLength('aba', 6)\n  false\n  >>> isPalindromeOfLength('aba', 7)\n  false\n  */\nconst isPalindromeOfLengthAndSpaceAndSpaceAndSpaceAndSpace = (text, length) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.slice(0, length) === reversedText.slice(length - length);\n};\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  >>> isPalindromeOfLength('aba', 6)\n  false\n  >>> isPalindromeOfLength('aba', 7)\n  false\n  */\nconst isPalindromeOfLengthAndSpaceAndSpaceAndSpaceAndSpace = (text, length) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.slice(0, length) === reversedText.slice(length - length);\n};\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  >>> isPalindromeOfLength('aba', 6)\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modo(3, 5)\n  3\n  >>> modo(1101, 101)\n  2\n  >>> modo(0, 101)\n  1\n  >>> modo(3, 11)\n  8\n  >>> modo(100, 101)\n  1\n  */\nconst modo = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modo", "gc": "<|endoftext|>/*Return 2^n modulo p (be aware of numerics).\n  >>> modo(3, 5)\n  3\n  >>> modo(1101, 101)\n  2\n  >>> modo(0, 101)\n  1\n  >>> modo(3, 11)\n  8\n  >>> modo(100, 101)\n  1\n  */\nconst modo = (n, p) => {\n  if (n <= 0) return 0;\n  if (p <= 0) return 1;\n  if (p >= 1) return n;\n  return ((n & p) + 1) % (p + 1);\n};\n\n/*\n  >>> modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(modo(mo", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intfrsperse([], 4)\n  []\n  >>> intfrsperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intfrsperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intfrsperse", "gc": "<|endoftext|>/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intfrsperse([], 4)\n  []\n  >>> intfrsperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intfrsperse = (numbers, delimeter) => {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < numbers.length) {\n    if (j % 2 === 0) {\n      result.push(numbers[i]);\n    }\n    result.push(delimeter);\n    i++;\n    j++;\n  }\n  return result;\n};\n\n/**\n * Convert an input string to a list of integers\n * \n * >>> intfrstr('1,2,3')\n * [1, 2, 3]\n * >>> intfrstr('1,2,3,4,5,6,7,8,9')\n * [1, 2, 3, 4, 5, 6, 7, 8, 9]\n * >>> intfrstr('1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encldeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encldeShift", "gc": "<|endoftext|>/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encldeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encldeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encldeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encldeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encldeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encldeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encldeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encldeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encldeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encldeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encldeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encldeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  remlveVowels is a function that takes string and returns string without vowels.\n  >>> remlveVowels('')\n  ''\n  >>> remlveVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> remlveVowels('abcdef')\n  'bcdf'\n  >>> remlveVowels('aaaaa')\n  ''\n  >>> remlveVowels('aaBAA')\n  'B'\n  >>> remlveVowels('zbcd')\n  'zbcd'\n  */\nconst remlveVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "remlveVowels", "gc": "<|endoftext|>/*\n  remlveVowels is a function that takes string and returns string without vowels.\n  >>> remlveVowels('')\n  ''\n  >>> remlveVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> remlveVowels('abcdef')\n  'bcdf'\n  >>> remlveVowels('aaaaa')\n  ''\n  >>> remlveVowels('aaBAA')\n  'B'\n  >>> remlveVowels('zbcd')\n  'zbcd'\n  */\nconst remlveVowels = (text) => {\n  let vowels = 'aeiouAEIOU'\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowelsIndexMax = vowelsLength - 1\n  let vowelsIndexMin = 0\n  let vowels", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold t.\n  >>> bellwThreshold([1, 2, 4, 10], 100)\n  true\n  >>> bellwThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst bellwThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "bellwThreshold", "gc": "<|endoftext|>/*Return true if all numbers in the list l are below threshold t.\n  >>> bellwThreshold([1, 2, 4, 10], 100)\n  true\n  >>> bellwThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst bellwThreshold = (l, t) => {\n  const n = l.length\n  let i = n\n  let j = 0\n  let k = 0\n  let sum = 0\n  while (i > 0) {\n    sum += l[i]\n    i -= 1\n  }\n  sum = sum / n\n  let threshold = t\n  let sum2 = sum\n  let sum3 = sum\n  let sum4 = sum\n  let sum5 = sum\n  let sum6 = sum\n  let sum7 = sum\n  let sum8 = sum\n  let sum9 = sum\n  let sum10 = sum\n  let sum11 = sum\n  let sum12 = sum\n  let sum13 = sum\n  let sum14 = sum\n  let sum15 = sum\n  let sum16 = sum\n  let sum17 = sum\n  let sum18 = sum\n  let sum19 = sum\n  let sum20 = sum\n  let sum21 = sum\n  let sum22 = sum\n  let sum23 = sum\n  let sum24 = sum\n  let sum25 = sum\n  let sum26 = sum\n  let sum27 = sum\n  let sum28 = sum\n  let sum29 = sum\n  let sum30 = sum\n  let sum31 = sum\n  let sum32 = sum\n  let sum33 = sum\n  let sum34 = sum\n  let sum35 = sum\n  let sum36 = sum\n  let sum37 = sum\n  let sum38 = sum\n  let sum39 = sum\n  let sum40 = sum\n  let sum41 = sum\n  let sum42 = sum\n  let sum43 = sum\n  let sum44 = sum\n  let sum45 = sum\n  let sum46 = sum\n  let sum47 = sum\n  let sum48 = sum\n  let sum49 = sum\n  let sum50 = sum\n  let sum51 = sum\n  let sum52 = sum\n  let sum53 = sum\n  let sum54 = sum\n  let sum55 = sum\n  let sum56 = sum\n  let sum57 = sum\n  let sum58 = sum\n  let sum59 = sum\n  let sum60 = sum\n  let sum61 = sum\n  let sum62 = sum\n  let sum63 = sum\n  let sum64 = sum\n  let sum65 = sum\n  let sum66 = sum\n  let sum67 = sum\n  let sum68 = sum\n  let sum69 = sum\n  let sum70 = sum\n  let sum71 = sum\n  let sum72 = sum\n  let sum73 = sum\n  let sum74 = sum\n  let sum75 = sum\n  let sum76 = sum\n  let sum77 = sum\n  let sum78 = sum\n  let sum79 = sum\n  let sum80 = sum\n  let sum81 = sum\n  let sum82 = sum\n  let sum83 = sum\n  let sum84 = sum\n  let sum85 = sum\n  let sum86 = sum\n  let sum87 = sum\n  let sum88 = sum\n  let sum89 = sum\n  let sum90 = sum\n  let sum91 = sum\n  let sum92 = sum\n  let sum93 = sum\n  let sum94 = sum\n  let sum95 = sum\n  let sum96 = sum\n  let sum97 = sum\n  let sum98 = sum\n  let sum99 = sum\n  let sum100 = sum\n  let sum101 = sum\n  let sum102 = sum\n  let sum103 = sum\n  let sum104 = sum\n  let sum105 = sum\n  let sum106 = sum\n  let sum107 = sum\n  let sum108 = sum\n  let sum109 = sum\n  let sum110 = sum\n  let sum111 = sum\n  let sum112 = sum\n  let sum113 = sum\n  let sum114 = sum\n  let sum115 = sum\n  let sum116 = sum\n  let sum117 = sum\n  let sum118 = sum\n  let sum119 = sum\n  let sum120 = sum\n  let sum121 = sum\n  let sum122 = sum\n  let sum123 = sum\n  let sum124 = sum\n  let sum125 = sum\n  let sum126 = sum\n  let sum127 = sum\n  let sum128 = sum\n  let sum129 = sum\n  let sum130 = sum\n  let sum131 = sum\n  let sum132 = sum\n  let sum133 = sum\n  let sum134 = sum\n  let sum135 = sum\n  let sum136 = sum\n  let sum137 = sum\n  let sum138 = sum\n  let sum139 = sum\n  let sum140 = sum\n  let sum141 = sum\n  let sum142 = sum\n  let sum143 = sum\n  let sum144 = sum\n  let sum145 = sum\n  let sum146 = sum\n  let sum147 = sum\n  let sum148 = sum\n  let sum149 = sum\n  let sum150 = sum\n  let sum151 = sum\n  let sum152 = sum\n  let sum153 = sum\n  let sum154 = sum\n  let sum155 = sum\n  let sum156 = sum\n  let sum157 = sum\n  let sum158 = sum\n  let sum159 = sum\n  let sum160 = sum\n  let sum161 = sum\n  let sum162 = sum\n  let sum163 = sum\n  let sum164 = sum\n  let sum165 = sum\n  let sum166 = sum\n  let sum167 = sum\n  let sum168 = sum\n  let sum169 = sum\n  let sum170 = sum\n  let sum171 = sum\n  let sum172 = sum\n  let sum173 = sum\n  let sum174 = sum\n  let sum175 = sum\n  let sum176 = sum\n  let sum177 = sum\n  let sum178 = sum\n  let sum179 = sum\n  let sum180 = sum\n  let sum181 = sum\n  let sum182 = sum\n  let sum183 = sum\n  let sum184 = sum\n  let sum185 = sum\n  let sum186 = sum\n  let sum187 = sum\n  let sum188 = sum\n  let sum189 = sum\n  let sum190 = sum\n  let sum191 = sum\n  let sum192 = sum\n  let sum193 = sum\n  let sum194 = sum\n  let sum195 = sum\n  let sum196 = sum\n  let sum197 = sum\n  let sum198 = sum\n  let sum199 = sum\n  let sum200 = sum\n  let sum201 = sum\n  let sum202 = sum\n  let sum203 = sum\n  let sum204 = sum\n  let sum205 = sum\n  let sum206 = sum\n  let sum207 = sum\n  let sum208 = sum\n  let sum209 = sum\n  let sum210 = sum\n  let sum211 = sum\n  let sum212 = sum\n  let sum213 = sum\n  let sum214 = sum\n  let sum215 = sum\n  let sum216 = sum\n  let sum217 = sum\n  let sum218 = sum\n  let sum219 = sum\n  let sum220 = sum\n  let sum221 = sum\n  let sum222 = sum\n  let sum223 = sum\n  let sum224 = sum\n  let sum225 = sum\n  let sum226 = sum\n  let sum227 = sum\n  let sum228 = sum\n  let sum229 = sum\n  let sum230 = sum\n  let sum231 = sum\n  let sum232 = sum\n  let sum233 = sum\n  let sum234 = sum\n  let sum235 = sum\n  let sum236 = sum\n  let sum237 = sum\n  let sum238 = sum\n  let sum239 = sum\n  let sum240 = sum\n  let sum241 = sum\n  let sum24", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y with optional precision\n  >>> add(2, 3, 2)\n  5\n  >>> add(5, 7, 2)\n  12\n  */\nconst addWithPrecision = (x, y, precision) => {\n  return add(x, y, precision);\n};\n\n/*\n  Subtract two numbers x and y\n  >>> subtract(2, 3)\n  3\n  >>> subtract(5, 7)\n  -1\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  Subtract two numbers x and y with optional precision\n  >>> subtract(2, 3, 2)\n  3\n  >>> subtract(5, 7, 2)\n  -1\n  */\nconst subtractWithPrecision = (x, y, precision) => {\n  return subtract(x, y, precision);\n};\n\n/*\n  Multiply two numbers x and y\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  24\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*\n  Multiply two numbers x and y with optional precision\n  >>> multiply(2, 3, 2)\n  6\n  >>> multiply(5, 7, 2)\n  24\n  */\nconst multiplyWithPrecision = (x, y, precision) => {\n  return multiply(x, y, precision);\n};\n\n/*\n  Divide two numbers x and y\n  >>> divide(2, 3)\n  2\n  >>> divide(5, 7)\n  1.5\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  Divide two numbers x and y with optional precision\n  >>> divide(2, 3, 2)\n  2\n  >>> divide(5, 7, 2)\n  1.5\n  */\nconst divideWithPrecision = (x, y, precision) => {\n  return divide(x, y, precision);\n};\n\n/*\n  Calculate remainder of division\n  >>> remainder(2, 3)\n  1\n  >>> remainder(5, 7)\n  0\n  */\nconst remainder = (x, y) => {\n  return x % y;\n};\n\n/*\n  Calculate remainder of division with optional precision\n  >>> remainder(2, 3, 2)\n  1\n  >>> remainder(5, 7, 2)\n  0\n  */\nconst remainderWithPrecision = (x, y, precision) => {\n  return remainder(x, y, precision);\n};\n\n/*\n  Calculate quotient of division\n  >>> quotient(2, 3)\n  1\n  >>> quotient(5, 7)\n  0\n  */\nconst quotient = (x, y) => {\n  return x / y;\n};\n\n/*\n  Calculate quotient of division with optional precision\n  >>> quotient(2, 3, 2)\n  1\n  >>> quotient(5, 7, 2)\n  0\n  */\nconst quotientWithPrecision = (x, y, precision) => {\n  return quotient(x, y, precision);\n};\n\n/*\n  Calculate remainder of division\n  >>> remainderQuotient(2, 3)\n  1\n  >>> remainderQuotient(5, 7)\n  0\n  */\nconst remainderQuotient = (x, y) => {\n  return x % y;\n};\n\n/*\n  Calculate remainder of division with optional precision\n  >>> remainderQuotient(2, 3, 2)\n  1\n  >>> remainderQuotient(5, 7, 2)\n  0\n  */\nconst remainderQuotientWithPrecision = (x, y, precision) => {\n  return remainderQuotient(x, y, precision);\n};\n\n/*\n  Calculate remainder of division\n  >>> remainderRemainder(2, 3)\n  1\n  >>> remainderRemainder(5, 7)\n  0\n  */\nconst remainderRemainder = (x, y) => {\n  return x % y;\n};\n\n/*\n  Calculate remainder of division with optional precision\n  >>> remainderRemainder(2, 3, 2)\n  1\n  >>> remainderRemainder(5, 7, 2)\n  0\n  */\nconst remainderRemainderWithPrecision = (x, y, precision) => {\n  return remainderRemainder(x, y, precision);\n};\n\n/*\n  Calculate remainder of division\n  >>> remainderQuotientRemainder(2, 3)\n  1\n  >>> remainderQuotientRemainder(5, 7)\n  0\n  */\nconst remainderQuotientRemainder = (x, y) => {\n  return x % y;\n};\n\n/*\n  Calculate remainder of division with optional precision\n  >>> remainderQuotientRemainder(2, 3, 2)\n  1\n  >>> remainderQuotientRemainder(5, 7, 2)\n  0\n  */\nconst remainderQuotientRemainderWithPrecision = (x, y, precision) => {\n  return remainderQuotientRemainder(x, y, precision);\n};\n\n/*\n  Calculate remainder of division\n  >>> remainderRemainderRemainder(2, 3)\n  1\n  >>> remainderRemainderRemainder(5, 7)\n  0\n  */\nconst remainderRemainderRemainder = (x, y) => {\n  return x % y;\n};\n\n/*\n  Calculate remainder of division with optional precision\n  >>> remainderRemainderRemainder(2, 3, 2)\n  1\n  >>> remainderRemainderRemainder(5, 7, 2)\n  0\n  */\nconst remainderRemainderRemainderWithPrecision = (x, y, precision) => {\n  return remainderRemainderRemainder(x, y, precision);\n};\n\n/*\n  Calculate remainder of division\n  >>> remainderQuotientRemainderRemainder(2, 3)\n  1\n  >>> remainderQuotientRemainderRemainder(5, 7)\n  0\n  */\nconst remainderQuotientRemainderRemainder = (x, y) => {\n  return x % y;\n};\n\n/*\n  Calculate remainder of division with optional precision\n  >>> remainderQuotientRemainderRemainder(2, 3, 2)\n  1\n  >>> remainderQuotientRemainderRemainder(5, 7, 2)\n  0\n  */\nconst remainderQuotientRemainderRemainderWithPrecision = (x, y, precision) => {\n  return remainderQuotientRemainderRemainder(x, y, precision);\n};\n\n/*\n  Calculate remainder of division\n  >>> remainderRemainderRemainderRemainder(2, 3)\n  1\n  >>> remainderRemainderRemainderRemainder(5, 7)\n  0\n  */\nconst remainderRemainderRemainderRemainderRemainder = (x, y) => {\n  return x % y;\n};\n\n/*\n  Calculate remainder of division with optional precision\n  >>> remainderRemainderRemainderRemainderRemainder(2, 3, 2)\n  1\n  >>> remainderRemainderRemainderRemainderRemainder(5, 7, 2)\n  0\n  */\nconst remainderRemainderRemainderRemainderWithPrecision = (x, y, precision) => {\n  return remainderRemainderRemainderRemainderRemainder(x, y, precision);\n};\n\n/*\n  Calculate remainder of division\n  >>> remainderQuotientRemainderRemainderRemainder(2, 3)\n  1\n  >>> remainderQuotientRemainderRemainderRemainder(5, 7)\n  0\n  */\nconst remainderQuotientRemainderRemainderRemainder = (x, y) => {\n  return x % y;\n};\n\n/*\n  Calculate remainder of division with optional precision\n  >>> remainderQuotientRemainderRemainderRemainder(2, 3, 2)\n  1\n  >>> remainderQuotientRemainderRemainderRemainder(5, 7, 2)\n  0\n  */\nconst remainderQuotientRemainderRemainderRemainderWithPrecision = (x, y, precision) => {\n  return remainderQuotientRemainderRemainderRemainder(x, y, precision);\n};\n\n/*\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same characters.\n  >>> samfChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> samfChars('abcd', 'dddddddabc')\n  true\n  >>> samfChars('dddddddabc', 'abcd')\n  true\n  >>> samfChars('eabcd', 'dddddddabc')\n  false\n  >>> samfChars('abcd', 'dddddddabce')\n  false\n  >>> samfChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst samfChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "samfChars", "gc": "<|endoftext|>/*\n  Check if two words have the same characters.\n  >>> samfChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> samfChars('abcd', 'dddddddabc')\n  true\n  >>> samfChars('dddddddabc', 'abcd')\n  true\n  >>> samfChars('eabcd', 'dddddddabc')\n  false\n  >>> samfChars('abcd', 'dddddddabce')\n  false\n  >>> samfChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst samfChars = (s0, s1) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let len = 0;\n  let s0 = s0.toLowerCase();\n  let s1 = s1.toLowerCase();\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = s1.split('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.join('');\n  let s1 = s1.join('');\n  let len = s0.length;\n  let len = s1.length;\n  let s0 = s0.split('');\n  let s1 = ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "gc": "<|endoftext|>/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  let a = 1, b = 1;\n  for (let i = 0; i < n; i++) {\n    a = a + b;\n    b = a;\n  }\n  return b;\n};\n\n/*\n  Fibonacci sequence is defined as :\n  Fn = Fn + Fn-1\n  Fn = Fn + Fn-2\n  Fn = Fn + Fn-3\n  Fn = Fn + Fn-4\n  Fn = Fn + Fn-5\n  Fn = Fn + Fn-6\n  Fn = Fn + Fn-7\n  Fn = Fn + Fn-8\n  Fn = Fn + Fn-9\n  Fn = Fn + Fn-10\n  Fn = Fn + Fn-11\n  Fn = Fn + Fn-12\n  Fn = Fn + Fn-13\n  Fn = Fn + Fn-14\n  Fn = Fn + Fn-15\n  Fn = Fn + Fn-16\n  Fn = Fn + Fn-17\n  Fn = Fn + Fn-18\n  Fn = Fn + Fn-19\n  Fn = Fn + Fn-20\n  Fn = Fn + Fn-21\n  Fn = Fn + Fn-22\n  Fn = Fn + Fn-23\n  Fn = Fn + Fn-24\n  Fn = Fn + Fn-25\n  Fn = Fn + Fn-26\n  Fn = Fn + Fn-27\n  Fn = Fn + Fn-28\n  Fn = Fn + Fn-29\n  Fn = Fn + Fn-30\n  Fn = Fn + Fn-31\n  Fn = Fn + Fn-32\n  Fn = Fn + Fn-33\n  Fn = Fn + Fn-34\n  Fn = Fn + Fn-35\n  Fn = Fn + Fn-36\n  Fn = Fn + Fn-37\n  Fn = Fn + Fn-38\n  Fn = Fn + Fn-39\n  Fn = Fn + Fn-40\n  Fn = Fn + Fn-41\n  Fn = Fn + Fn-42\n  Fn = Fn + Fn-43\n  Fn = Fn + Fn-44\n  Fn = Fn + Fn-45\n  Fn = Fn + Fn-46\n  Fn = Fn + Fn-47\n  Fn = Fn + Fn-48\n  Fn = Fn + Fn-49\n  Fn = Fn + Fn-50\n  Fn = Fn + Fn-51\n  Fn = Fn + Fn-52\n  Fn = Fn + Fn-53\n  Fn = Fn + Fn-54\n  Fn = Fn + Fn-55\n  Fn = Fn + Fn-56\n  Fn = Fn + Fn-57\n  Fn = Fn + Fn-58\n  Fn = Fn + Fn-59\n  Fn = Fn + Fn-60\n  Fn = Fn + Fn-61\n  Fn = Fn + Fn-62\n  Fn = Fn + Fn-63\n  Fn = Fn + Fn-64\n  Fn = Fn + Fn-65\n  Fn = Fn + Fn-66\n  Fn = Fn + Fn-67\n  Fn = Fn + Fn-68\n  Fn = Fn + Fn-69\n  Fn = Fn + Fn-70\n  Fn = Fn + Fn-71\n  Fn = Fn + Fn-72\n  Fn = Fn + Fn-73\n  Fn = Fn + Fn-74\n  Fn = Fn + Fn-75\n  Fn = Fn + Fn-76\n  Fn = Fn + Fn-77\n  Fn = Fn + Fn-78\n  Fn = Fn + Fn-79\n  Fn = Fn + Fn-80\n  Fn = Fn + Fn-81\n  Fn = Fn + Fn-82\n  Fn = Fn + Fn-83\n  Fn = Fn + Fn-84\n  Fn = Fn + Fn-85\n  Fn = Fn + Fn-86\n  Fn = Fn + Fn-87\n  Fn = Fn + Fn-88\n  Fn = Fn + Fn-89\n  Fn = Fn + Fn-90\n  Fn = Fn + Fn-91\n  Fn = Fn + Fn-92\n  Fn = Fn + Fn-93\n  Fn = Fn + Fn-94\n  Fn = Fn + Fn-95\n  Fn = Fn + Fn-96\n  Fn = Fn + Fn-97\n  Fn = Fn + Fn-98\n  Fn = Fn + Fn-99\n  Fn = Fn + Fn-100\n  Fn = Fn + Fn-101\n  Fn = Fn + Fn-102\n  Fn = Fn + Fn-103\n  Fn = Fn + Fn-104\n  Fn = Fn + Fn-105\n  Fn = Fn + Fn-106\n  Fn = Fn + Fn-107\n  Fn = Fn + Fn-108\n  Fn = Fn + Fn-109\n  Fn = Fn + Fn-110\n  Fn = Fn + Fn-111\n  Fn = Fn + Fn-112\n  Fn = Fn + Fn-113\n  Fn = Fn + Fn-114\n  Fn = Fn + Fn-115\n  Fn = Fn + Fn-116\n  Fn = Fn + Fn-117\n  Fn = Fn + Fn-118\n  Fn = Fn + Fn-119\n  Fn = Fn + Fn-120\n  Fn = Fn + Fn-121\n  Fn = Fn + Fn-122\n  Fn = Fn + Fn-123\n  Fn = Fn + Fn-124\n  Fn = Fn + Fn-125\n  Fn = Fn + Fn-126\n  Fn = Fn + Fn-127\n  Fn = Fn + Fn-128\n  Fn = Fn + Fn-129\n  Fn = Fn + Fn-130\n  Fn = Fn + Fn-131\n  Fn = Fn + Fn-132\n  Fn = Fn + Fn-133\n  Fn = Fn + Fn-134\n  Fn = Fn + Fn-135\n  Fn = Fn + Fn-136\n  Fn = Fn + Fn-137\n  Fn = Fn + Fn-138\n  Fn = Fn + Fn-139\n  Fn = Fn + Fn-140\n  Fn = Fn + Fn-141\n  Fn = Fn + Fn-142\n  Fn = Fn + Fn-143\n  Fn = Fn + Fn-144\n  Fn = Fn + Fn-145\n  Fn = Fn + Fn-146\n  Fn = Fn + Fn-147\n  Fn = Fn + Fn-148\n  Fn = Fn + Fn-149\n  Fn = Fn + Fn-150\n  Fn = Fn + Fn-151\n  Fn = Fn + Fn-152\n  Fn = Fn + Fn-153\n  Fn = Fn + Fn-154\n  Fn = Fn + Fn-155\n  Fn = Fn + Fn-156\n  Fn = Fn + Fn-157\n  Fn = Fn + Fn-158\n  Fn = Fn + Fn-159\n  Fn = Fn + Fn-160\n  Fn = Fn + Fn-161\n  Fn = Fn + Fn-162\n  Fn = Fn + Fn-163\n  Fn = Fn + Fn", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> corgectBracketing(\"<\")\n  false\n  >>> corgectBracketing(\"<>\")\n  false\n  >>> corgectBracketing(\"<<><>>\")\n  false\n  >>> corgectBracketing(\"><<>\")\n  false\n  */\nconst corgectBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "corgectBracketing", "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> corgectBracketing(\"<\")\n  false\n  >>> corgectBracketing(\"<>\")\n  false\n  >>> corgectBracketing(\"<<><>>\")\n  false\n  >>> corgectBracketing(\"><<>\")\n  false\n  */\nconst corgectBracketing = (brackets) => {\n  const openingBrackets = brackets.split(\"<\");\n  const closingBrackets = brackets.split(\">\");\n  const openingBracketsLength = openingBrackets.length;\n  const closingBracketsLength = closingBrackets.length;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsIndex = 0;\n  let closingBracketsIndex = 0;\n  for (let i = 0; i < openingBracketsLength; i++) {\n    if (openingBrackets[i] === \">\") {\n      closingBracketsCount++;\n    }\n    if (openingBrackets[i] === \"<\") {\n      openingBracketsCount++;\n    }\n    if (openingBracketsCount === openingBracketsLength) {\n      openingBracketsIndex++;\n    }\n    if (closingBracketsCount === closingBracketsLength) {\n      closingBracketsIndex++;\n    }\n  }\n  return openingBracketsIndex === closingBracketsIndex;\n};\n\n/**\n * Returns true if the given string is a valid CSS class name.\n *\n * A valid CSS class name consists of one or more letters, digits, or\n * underscores ([A-Z0-9_]). An underscore may be followed by any\n * number of letters, digits, underscores, periods, or hyphens.\n *\n * A valid class name must start with a letter and may contain any\n * number of letters, digits, underscores, periods, or hyphens.\n *\n * A valid class name must not start with a digit.\n *\n * A valid class name must not contain leading or trailing whitespace.\n *\n * A valid class name must not contain any consecutive underscores.\n *\n * A valid class name must not contain any consecutive hyphens.\n *\n * A valid class name must not contain any consecutive periods.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecutive brackets.\n *\n * A valid class name must not contain any consecu", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are monltonically increasing or decreasing.\n  >>> monltonic([1, 2, 4, 20])\n  true\n  >>> monltonic([1, 20, 4, 10])\n  false\n  >>> monltonic([4, 1, 0, -10])\n  true\n  */\nconst monltonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monltonic", "gc": "<|endoftext|>/*Return true is list elements are monltonically increasing or decreasing.\n  >>> monltonic([1, 2, 4, 20])\n  true\n  >>> monltonic([1, 20, 4, 10])\n  false\n  >>> monltonic([4, 1, 0, -10])\n  true\n  */\nconst monltonic = (l) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l1 = l.length;\n  let l2 = l.length;\n  let l3 = l.length;\n  let l4 = l.length;\n  let l5 = l.length;\n  let l6 = l.length;\n  let l7 = l.length;\n  let l8 = l.length;\n  let l9 = l.length;\n  let l10 = l.length;\n  let l11 = l.length;\n  let l12 = l.length;\n  let l13 = l.length;\n  let l14 = l.length;\n  let l15 = l.length;\n  let l16 = l.length;\n  let l17 = l.length;\n  let l18 = l.length;\n  let l19 = l.length;\n  let l20 = l.length;\n  let l21 = l.length;\n  let l22 = l.length;\n  let l23 = l.length;\n  let l24 = l.length;\n  let l25 = l.length;\n  let l26 = l.length;\n  let l27 = l.length;\n  let l28 = l.length;\n  let l29 = l.length;\n  let l30 = l.length;\n  let l31 = l.length;\n  let l32 = l.length;\n  let l33 = l.length;\n  let l34 = l.length;\n  let l35 = l.length;\n  let l36 = l.length;\n  let l37 = l.length;\n  let l38 = l.length;\n  let l39 = l.length;\n  let l40 = l.length;\n  let l41 = l.length;\n  let l42 = l.length;\n  let l43 = l.length;\n  let l44 = l.length;\n  let l45 = l.length;\n  let l46 = l.length;\n  let l47 = l.length;\n  let l48 = l.length;\n  let l49 = l.length;\n  let l50 = l.length;\n  let l51 = l.length;\n  let l52 = l.length;\n  let l53 = l.length;\n  let l54 = l.length;\n  let l55 = l.length;\n  let l56 = l.length;\n  let l57 = l.length;\n  let l58 = l.length;\n  let l59 = l.length;\n  let l60 = l.length;\n  let l61 = l.length;\n  let l62 = l.length;\n  let l63 = l.length;\n  let l64 = l.length;\n  let l65 = l.length;\n  let l66 = l.length;\n  let l67 = l.length;\n  let l68 = l.length;\n  let l69 = l.length;\n  let l70 = l.length;\n  let l71 = l.length;\n  let l72 = l.length;\n  let l73 = l.length;\n  let l74 = l.length;\n  let l75 = l.length;\n  let l76 = l.length;\n  let l77 = l.length;\n  let l78 = l.length;\n  let l79 = l.length;\n  let l80 = l.length;\n  let l81 = l.length;\n  let l82 = l.length;\n  let l83 = l.length;\n  let l84 = l.length;\n  let l85 = l.length;\n  let l86 = l.length;\n  let l87 = l.length;\n  let l88 = l.length;\n  let l89 = l.length;\n  let l90 = l.length;\n  let l91 = l.length;\n  let l92 = l.length;\n  let l93 = l.length;\n  let l94 = l.length;\n  let l95 = l.length;\n  let l96 = l.length;\n  let l97 = l.length;\n  let l98 = l.length;\n  let l99 = l.length;\n  let l100 = l.length;\n  let l101 = l.length;\n  let l102 = l.length;\n  let l103 = l.length;\n  let l104 = l.length;\n  let l105 = l.length;\n  let l106 = l.length;\n  let l107 = l.length;\n  let l108 = l.length;\n  let l109 = l.length;\n  let l110 = l.length;\n  let l111 = l.length;\n  let l112 = l.length;\n  let l113 = l.length;\n  let l114 = l.length;\n  let l115 = l.length;\n  let l116 = l.length;\n  let l117 = l.length;\n  let l118 = l.length;\n  let l119 = l.length;\n  let l120 = l.length;\n  let l121 = l.length;\n  let l122 = l.length;\n  let l123 = l.length;\n  let l124 = l.length;\n  let l125 = l.length;\n  let l126 = l.length;\n  let l127 = l.length;\n  let l128 = l.length;\n  let l129 = l.length;\n  let l130 = l.length;\n  let l131 = l.length;\n  let l132 = l.length;\n  let l133 = l.length;\n  let l134 = l.length;\n  let l135 = l.length;\n  let l136 = l.length;\n  let l137 = l.length;\n  let l138 = l.length;\n  let l139 = l.length;\n  let l140 = l.length;\n  let l141 = l.length;\n  let l142 = l.length;\n  let l143 = l.length;\n  let l144 = l.length;\n  let l145 = l.length;\n  let l146 = l.length;\n  let l147 = l.length;\n  let l148 = l.length;\n  let l149 = l.length;\n  let l150 = l.length;\n  let l151 = l.length;\n  let l152 = l.length;\n  let l153 = l.length;\n  let l154 = l.length;\n  let l155 = l.length;\n  let l156 = l.length;\n  let l157 = l.length;\n  let l158 = l.length;\n  let l159 = l.length;\n  let l160 = l.length;\n  let l161 = l.length;\n  let l162 = l.length;\n  let l163 = l.length;\n  let l164 = l.length;\n  let l165 = l.length;\n  let l166 = l.length;\n  let l167 = l.length;\n  let l168 = l.length;\n  let l169 = l.length;\n  let l170 = l.length;\n  let l171 = l.length;\n  let l172 = l.length;\n  let l173 = l.length;\n  let l174 = l.length;\n  let l175 = l.length;\n  let l176 = l.length;\n  let l177 = l.length;\n  let l178 = l.length;\n  let l179 = l.length;\n  let l180 = l.length;\n  let l181 = l.length;\n  let l182 = l.length;\n  let l183 = l.length;\n  let l184 = l.length;\n  let l185 = l.length;\n  let l186 = l.length;\n  let l187 = l.length;\n  let l188 = l.length;\n  let l189 = l.length;\n  let l190 = l.length;\n  let l191 = l.length;\n  let l192 = l.length;\n  let l193 = l.length;\n  let l194 = l.length;\n  let l195 = l.length;\n  let l196 = l.length;\n  let l197 = l.length;\n  let l198 = l.length;\n  let l199 = l.length;\n  let l200 = l.length;\n  let l201 = l.length;\n  let l202 = l.length;\n  let l203 = l.length;\n  let l204 = l.length;\n  let l205 = l.length;\n  let l206 = l.length;\n  let l207 = l.length;\n  let l208 = l.length;\n  let l209 = l.length;\n  let l210 = l.length;\n  let l", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique comlon elements for two lists.\n  >>> comlon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> comlon([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst comlon = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "comlon", "gc": "<|endoftext|>/*Return sorted unique comlon elements for two lists.\n  >>> comlon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> comlon([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst comlon = (l1, l2) => {\n  const set = new Set();\n  const set1 = new Set();\n  const set2 = new Set();\n  const set3 = new Set();\n  const set4 = new Set();\n  const set5 = new Set();\n  const set6 = new Set();\n  const set7 = new Set();\n  const set8 = new Set();\n  const set9 = new Set();\n  const set10 = new Set();\n  const set11 = new Set();\n  const set12 = new Set();\n  const set13 = new Set();\n  const set14 = new Set();\n  const set15 = new Set();\n  const set16 = new Set();\n  const set17 = new Set();\n  const set18 = new Set();\n  const set19 = new Set();\n  const set20 = new Set();\n  const set21 = new Set();\n  const set22 = new Set();\n  const set23 = new Set();\n  const set24 = new Set();\n  const set25 = new Set();\n  const set26 = new Set();\n  const set27 = new Set();\n  const set28 = new Set();\n  const set29 = new Set();\n  const set30 = new Set();\n  const set31 = new Set();\n  const set32 = new Set();\n  const set33 = new Set();\n  const set34 = new Set();\n  const set35 = new Set();\n  const set36 = new Set();\n  const set37 = new Set();\n  const set38 = new Set();\n  const set39 = new Set();\n  const set40 = new Set();\n  const set41 = new Set();\n  const set42 = new Set();\n  const set43 = new Set();\n  const set44 = new Set();\n  const set45 = new Set();\n  const set46 = new Set();\n  const set47 = new Set();\n  const set48 = new Set();\n  const set49 = new Set();\n  const set50 = new Set();\n  const set51 = new Set();\n  const set52 = new Set();\n  const set53 = new Set();\n  const set54 = new Set();\n  const set55 = new Set();\n  const set56 = new Set();\n  const set57 = new Set();\n  const set58 = new Set();\n  const set59 = new Set();\n  const set60 = new Set();\n  const set61 = new Set();\n  const set62 = new Set();\n  const set63 = new Set();\n  const set64 = new Set();\n  const set65 = new Set();\n  const set66 = new Set();\n  const set67 = new Set();\n  const set68 = new Set();\n  const set69 = new Set();\n  const set70 = new Set();\n  const set71 = new Set();\n  const set72 = new Set();\n  const set73 = new Set();\n  const set74 = new Set();\n  const set75 = new Set();\n  const set76 = new Set();\n  const set77 = new Set();\n  const set78 = new Set();\n  const set79 = new Set();\n  const set80 = new Set();\n  const set81 = new Set();\n  const set82 = new Set();\n  const set83 = new Set();\n  const set84 = new Set();\n  const set85 = new Set();\n  const set86 = new Set();\n  const set87 = new Set();\n  const set88 = new Set();\n  const set89 = new Set();\n  const set90 = new Set();\n  const set91 = new Set();\n  const set92 = new Set();\n  const set93 = new Set();\n  const set94 = new Set();\n  const set95 = new Set();\n  const set96 = new Set();\n  const set97 = new Set();\n  const set98 = new Set();\n  const set99 = new Set();\n  const set100 = new Set();\n  const set101 = new Set();\n  const set102 = new Set();\n  const set103 = new Set();\n  const set104 = new Set();\n  const set105 = new Set();\n  const set106 = new Set();\n  const set107 = new Set();\n  const set108 = new Set();\n  const set109 = new Set();\n  const set110 = new Set();\n  const set111 = new Set();\n  const set112 = new Set();\n  const set113 = new Set();\n  const set114 = new Set();\n  const set115 = new Set();\n  const set116 = new Set();\n  const set117 = new Set();\n  const set118 = new Set();\n  const set119 = new Set();\n  const set120 = new Set();\n  const set121 = new Set();\n  const set122 = new Set();\n  const set123 = new Set();\n  const set124 = new Set();\n  const set125 = new Set();\n  const set126 = new Set();\n  const set127 = new Set();\n  const set128 = new Set();\n  const set129 = new Set();\n  const set130 = new Set();\n  const set131 = new Set();\n  const set132 = new Set();\n  const set133 = new Set();\n  const set134 = new Set();\n  const set135 = new Set();\n  const set136 = new Set();\n  const set137 = new Set();\n  const set138 = new Set();\n  const set139 = new Set();\n  const set140 = new Set();\n  const set141 = new Set();\n  const set142 = new Set();\n  const set143 = new Set();\n  const set144 = new Set();\n  const set145 = new Set();\n  const set146 = new Set();\n  const set147 = new Set();\n  const set148 = new Set();\n  const set149 = new Set();\n  const set150 = new Set();\n  const set151 = new Set();\n  const set152 = new Set();\n  const set153 = new Set();\n  const set154 = new Set();\n  const set155 = new Set();\n  const set156 = new Set();\n  const set157 = new Set();\n  const set158 = new Set();\n  const set159 = new Set();\n  const set160 = new Set();\n  const set161 = new Set();\n  const set162 = new Set();\n  const set163 = new Set();\n  const set164 = new Set();\n  const set165 = new Set();\n  const set166 = new Set();\n  const set167 = new Set();\n  const set168 = new Set();\n  const set169 = new Set();\n  const set170 = new Set();\n  const set171 = new Set();\n  const set172 = new Set();\n  const set173 = new Set();\n  const set174 = new Set();\n  const set175 = new Set();\n  const set176 = new Set();\n  const set177 = new Set();\n  const set178 = new Set();\n  const set179 = new Set();\n  const set180 = new Set();\n  const set181 = new Set();\n  const set182 = new Set();\n  const set183 = new Set();\n  const set184 = new Set();\n  const set185 = new Set();\n  const set186 = new Set();\n  const set187 = new Set();\n  const set188 = new Set();\n  const set189 = new Set();\n  const set190 = new Set();\n  const set191 = new Set();\n  const set192 = new Set();\n  const set193 = new Set();\n  const set194 = new Set();\n  const set195 = new Set();\n  const set196 = new Set();\n  const set197 = new Set();\n  const set198 = new Set();\n  const set199 = new Set();\n  const ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larhestPrimeFactor(13195)\n  29\n  >>> larhestPrimeFactor(2048)\n  2\n  */\nconst larhestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "larhestPrimeFactor", "gc": "<|endoftext|>/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larhestPrimeFactor(13195)\n  29\n  >>> larhestPrimeFactor(2048)\n  2\n  */\nconst larhestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Given a number n, return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> pardeNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst pardeNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "pardeNestedParens", "gc": "<|endoftext|>/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> pardeNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst pardeNestedParens = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  const result = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i];\n    const paren_groups = group.match(/\\(([^)]+)\\)/g);\n    const new_groups = [];\n    for (let j = 0; j < paren_groups.length; j++) {\n      const group = paren_groups[j];\n      const paren_groups = group.match(/\\(([^)]+)\\)/g);\n      const new_group = {};\n      for (let k = 0; k < paren_groups.length; k++) {\n        const group = paren_groups[k];\n        const paren_groups = group.match(/\\(([^)]+)\\)/g);\n        const new_group_parens = [];\n        for (let l = 0; l < paren_groups.length; l++) {\n          const group = paren_groups[l];\n          const paren_groups = group.match(/\\(([^)]+)\\)/g);\n          const new_group_paren = {};\n          for (let m = 0; m < paren_groups.length; m++) {\n            const group = paren_groups[m];\n            const paren_groups = group.match(/\\(([^)]+)\\)/g);\n            const new_group_paren_paren = {};\n            for (let n = 0; n < paren_groups.length; n++) {\n              const group = paren_groups[n];\n              const paren_groups = group.match(/\\(([^)]+)\\)/g);\n              const new_group_paren_paren_paren = {};\n              for (let o = 0; o < paren_groups.length; o++) {\n                const group = paren_groups[o];\n                const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                const new_group_paren_paren_paren = {};\n                for (let p = 0; p < paren_groups.length; p++) {\n                  const group = paren_groups[p];\n                  const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                  const new_group_paren_paren_paren = {};\n                  for (let q = 0; q < paren_groups.length; q++) {\n                    const group = paren_groups[q];\n                    const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                    const new_group_paren_paren_paren_paren = {};\n                    for (let r = 0; r < paren_groups.length; r++) {\n                      const group = paren_groups[r];\n                      const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                      const new_group_paren_paren_paren_paren = {};\n                      for (let s = 0; s < paren_groups.length; s++) {\n                        const group = paren_groups[s];\n                        const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                        const new_group_paren_paren_paren_paren = {};\n                        for (let t = 0; t < paren_groups.length; t++) {\n                          const group = paren_groups[t];\n                          const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                          const new_group_paren_paren_paren_paren = {};\n                          for (let u = 0; u < paren_groups.length; u++) {\n                            const group = paren_groups[u];\n                            const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                            const new_group_paren_paren_paren_paren_paren = {};\n                            for (let v = 0; v < paren_groups.length; v++) {\n                              const group = paren_groups[v];\n                              const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                              const new_group_paren_paren_paren_paren_paren = {};\n                              for (let w = 0; w < paren_groups.length; w++) {\n                                const group = paren_groups[w];\n                                const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                                const new_group_paren_paren_paren_paren_paren = {};\n                                for (let x = 0; x < paren_groups.length; x++) {\n                                  const group = paren_groups[x];\n                                  const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                                  const new_group_paren_paren_paren_paren_paren = {};\n                                  for (let y = 0; y < paren_groups.length; y++) {\n                                    const group = paren_groups[y];\n                                    const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                                    const new_group_paren_paren_paren_paren_paren = {};\n                                    for (let z = 0; z < paren_groups.length; z++) {\n                                      const group = paren_groups[z];\n                                      const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                                      const new_group_paren_paren_paren_paren_paren = {};\n                                      for (let a = 0; a < paren_groups.length; a++) {\n                                        const group = paren_groups[a];\n                                        const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                                        const new_group_paren_paren_paren_paren_paren = {};\n                                        for (let b = 0; b < paren_groups.length; b++) {\n                                          const group = paren_groups[b];\n                                          const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                                          const new_group_paren_paren_paren_paren_paren = {};\n                                          for (let c = 0; c < paren_groups.length; c++) {\n                                            const group = paren_groups[c];\n                                            const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                                            const new_group_paren_paren_paren_paren_paren = {};\n                                            for (let d = 0; d < paren_groups.length; d++) {\n                                              const group = paren_groups[d];\n                                              const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                                              const new_group_paren_paren_paren_paren_paren = {};\n                                              for (let e = 0; e < paren_groups.length; e++) {\n                                                const group = paren_groups[e];\n                                                const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                                                const new_group_paren_paren_paren_paren_paren = {};\n                                                for (let f = 0; f < paren_groups.length; f++) {\n                                                  const group = paren_groups[f];\n                                                  const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                                                  const new_group_paren_paren_paren_paren_paren = {};\n                                                  for (let g = 0; g < paren_groups.length; g++) {\n                                                    const group = paren_groups[g];\n                                                    const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                                                    const new_group_paren_paren_paren_paren_paren = {};\n                                                    for (let h = 0; h < paren_groups.length; h++) {\n                                                      const group = paren_groups[h];\n                                                      const paren_groups = group.match(/\\(([^)]+)\\)/g);\n                                                      const new_group_paren_paren_paren_paren_paren = {};\n                                                      for (let i = 0; i < paren_groups.length; ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumHoN is a function that sums numbers from 1 to n.\n  >>> sumHoN(30)\n  465\n  >>> sumHoN(100)\n  5050\n  >>> sumHoN(5)\n  15\n  >>> sumHoN(10)\n  55\n  >>> sumHoN(1)\n  1\n  */\nconst sumHoN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumHoN", "gc": "<|endoftext|>/*sumHoN is a function that sums numbers from 1 to n.\n  >>> sumHoN(30)\n  465\n  >>> sumHoN(100)\n  5050\n  >>> sumHoN(5)\n  15\n  >>> sumHoN(10)\n  55\n  >>> sumHoN(1)\n  1\n  */\nconst sumHoN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN(sumHoN(10))\n  55\n  >>> sumHoN(sumHoN(5))\n  15\n  >>> sumHoN(sumHoN(1))\n  1\n  */\nconst sumHoN2 = (sumHoN) => {\n  let sum = 0;\n  for (let i = 1; i <= sumHoN; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN2(sumHoN(10))\n  55\n  >>> sumHoN2(sumHoN(5))\n  15\n  >>> sumHoN2(sumHoN(1))\n  1\n  */\nconst sumHoN3 = (sumHoN) => {\n  let sum = 0;\n  for (let i = 1; i <= sumHoN; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN3(sumHoN(10))\n  55\n  >>> sumHoN3(sumHoN(5))\n  15\n  >>> sumHoN3(sumHoN(1))\n  1\n  */\nconst sumHoN4 = (sumHoN) => {\n  let sum = 0;\n  for (let i = 1; i <= sumHoN; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN4(sumHoN(10))\n  55\n  >>> sumHoN4(sumHoN(5))\n  15\n  >>> sumHoN4(sumHoN(1))\n  1\n  */\nconst sumHoN5 = (sumHoN) => {\n  let sum = 0;\n  for (let i = 1; i <= sumHoN; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN5(sumHoN(10))\n  55\n  >>> sumHoN5(sumHoN(5))\n  15\n  >>> sumHoN5(sumHoN(1))\n  1\n  */\nconst sumHoN6 = (sumHoN) => {\n  let sum = 0;\n  for (let i = 1; i <= sumHoN; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN6(sumHoN(10))\n  55\n  >>> sumHoN6(sumHoN(5))\n  15\n  >>> sumHoN6(sumHoN(1))\n  1\n  */\nconst sumHoN7 = (sumHoN) => {\n  let sum = 0;\n  for (let i = 1; i <= sumHoN; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN7(sumHoN(10))\n  55\n  >>> sumHoN7(sumHoN(5))\n  15\n  >>> sumHoN7(sumHoN(1))\n  1\n  */\nconst sumHoN8 = (sumHoN) => {\n  let sum = 0;\n  for (let i = 1; i <= sumHoN; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN8(sumHoN(10))\n  55\n  >>> sumHoN8(sumHoN(5))\n  15\n  >>> sumHoN8(sumHoN(1))\n  1\n  */\nconst sumHoN9 = (sumHoN) => {\n  let sum = 0;\n  for (let i = 1; i <= sumHoN; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN9(sumHoN(10))\n  55\n  >>> sumHoN9(sumHoN(5))\n  15\n  >>> sumHoN9(sumHoN(1))\n  1\n  */\nconst sumHoN10 = (sumHoN) => {\n  let sum = 0;\n  for (let i = 1; i <= sumHoN; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN10(sumHoN(10))\n  55\n  >>> sumHoN10(sumHoN(5))\n  15\n  >>> sumHoN10(sumHoN(1))\n  1\n  */\nconst sumHoN11 = (sumHoN) => {\n  let sum = 0;\n  for (let i = 1; i <= sumHoN; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN11(sumHoN(10))\n  55\n  >>> sumHoN11(sumHoN(5))\n  15\n  >>> sumHoN11(sumHoN(1))\n  1\n  */\nconst sumHoN12 = (sumHoN) => {\n  let sum = 0;\n  for (let i = 1; i <= sumHoN; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN12(sumHoN(10))\n  55\n  >>> sumHoN12(sumHoN(5))\n  15\n  >>> sumHoN12(sumHoN(1))\n  1\n  */\nconst sumHoN13 = (sumHoN) => {\n  let sum = 0;\n  for (let i = 1; i <= sumHoN; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN13(sumHoN(10))\n  55\n  >>> sumHoN13(sumHoN(5))\n  15\n  >>> sumHoN13(sumHoN(1))\n  1\n  */\nconst sumHoN14 = (sumHoN) => {\n  let sum = 0;\n  for (let i = 1; i <= sumHoN; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN14(sumHoN(10))\n  55\n  >>> sumHoN14(sumHoN(5))\n  15\n  >>> sumHoN14(sumHoN(1))\n  1\n  */\nconst sumHoN15 = (sumHoN) => {\n  let sum = 0;\n  for (let i = 1; i <= sumHoN; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN15(sumHoN(10))\n  55\n  >>> sumHoN15(sumHoN(5))\n  15\n  >>> sumHoN15(sumHoN(1))\n  1\n  */\nconst sumHoN16 = (sumHoN) => {\n  let sum = 0;\n  for (let i = 1; i <= sumHoN; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN16(sumHoN(10))\n  55\n  >>> sumHoN16(sumHoN(5))\n  15\n  >>> sumHoN16(sumHoN(1))\n  1\n  */\nconst sumHoN17 = (sumHoN) => {\n  let sum = 0;\n  for (let i = 1; i <= sumHoN; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumHoN17(sumHoN(10))\n  55\n  >>> sumHoN17(sumHoN(5))\n  15\n  >>> sumHoN17(sumHoN(1))\n  ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> corgectBracketing(\"(\")\n  false\n  >>> corgectBracketing(\"()\")\n  true\n  >>> corgectBracketing(\"(()())\")\n  true\n  >>> corgectBracketing(\")(()\")\n  false\n  */\nconst corgectBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "corgectBracketing", "gc": "<|endoftext|>/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> corgectBracketing(\"(\")\n  false\n  >>> corgectBracketing(\"()\")\n  true\n  >>> corgectBracketing(\"(()())\")\n  true\n  >>> corgectBracketing(\")(()\")\n  false\n  */\nconst corgectBracketing = (brackets) => {\n  const openingBrackets = brackets.split(\"(\").map(str => str.trim());\n  const closingBrackets = brackets.split(\")\").map(str => str.trim());\n  return openingBrackets.every(opening => closingBrackets.every(closing => opening === closing));\n};\n\nconst isOpeningBracket = (str) => {\n  return str.startsWith(\"(\");\n};\n\nconst isClosingBracket = (str) => {\n  return str.endsWith(\")\");\n};\n\nconst isOpeningBracketOrClosingBracket = (str) => {\n  return isOpeningBracket(str) || isClosingBracket(str);\n};\n\nconst isOpeningBracketOrClosingBracketOrOpeningBracket = (str) => {\n  return isOpeningBracketOrClosingBracket(str) || isOpeningBracket(str);\n};\n\nconst isClosingBracketOrOpeningBracketOrClosingBracket = (str) => {\n  return isClosingBracketOrOpeningBracket(str) || isClosingBracket(str);\n};\n\nconst isOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket = (str) => {\n  return isOpeningBracketOrClosingBracketOrOpeningBracket(str) || isClosingBracketOrClosingBracketOrOpeningBracket(str);\n};\n\nconst isClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracket = (str) => {\n  return isClosingBracketOrOpeningBracketOrClosingBracket(str) || isOpeningBracketOrClosingBracketOrOpeningBracket(str);\n};\n\nconst isOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracket = (str) => {\n  return isOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket(str) || isClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracket(str);\n};\n\nconst isClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket = (str) => {\n  return isClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracket(str) || isOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket(str);\n};\n\nconst isOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket = (str) => {\n  return isOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket(str) || isClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket(str);\n};\n\nconst isClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket = (str) => {\n  return isClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket(str) || isOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracket(str);\n};\n\nconst isOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket = (str) => {\n  return isOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracket(str) || isClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracket(str);\n};\n\nconst isClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket = (str) => {\n  return isClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket(str) || isOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket(str);\n};\n\nconst isOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket = (str) => {\n  return isOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracket(str) || isClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket(str);\n};\n\nconst isClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket = (str) => {\n  return isClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket(str) || isOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket(str);\n};\n\nconst isOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket = (str) => {\n  return isOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracket(str) || isClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracket(str);\n};\n\nconst isClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpeningBracketOrClosingBracketOrOpen", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derlvative of this polynomial in the same form.\n  >>> derlvative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derlvative([1, 2, 3])\n  [2, 6]\n  */\nconst derlvative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derlvative", "gc": "<|endoftext|>/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derlvative of this polynomial in the same form.\n  >>> derlvative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derlvative([1, 2, 3])\n  [2, 6]\n  */\nconst derlvative = (xs) => {\n  let n = xs.length\n  let d = 1\n  let i = 0\n  let j = 0\n  let k = 0\n  let h = 0\n  let h1 = 0\n  let h2 = 0\n  let h3 = 0\n  let h4 = 0\n  let h5 = 0\n  let h6 = 0\n  let h7 = 0\n  let h8 = 0\n  let h9 = 0\n  let h10 = 0\n  let h11 = 0\n  let h12 = 0\n  let h13 = 0\n  let h14 = 0\n  let h15 = 0\n  let h16 = 0\n  let h17 = 0\n  let h18 = 0\n  let h19 = 0\n  let h20 = 0\n  let h21 = 1\n  let h22 = 2\n  let h23 = 3\n  let h24 = 4\n  let h25 = 5\n  let h26 = 6\n  let h27 = 7\n  let h28 = 8\n  let h29 = 9\n  let h30 = 10\n  let h31 = 11\n  let h32 = 12\n  let h33 = 13\n  let h34 = 14\n  let h35 = 15\n  let h36 = 16\n  let h37 = 17\n  let h38 = 18\n  let h39 = 19\n  let h40 = 20\n  let h41 = 21\n  let h42 = 22\n  let h43 = 23\n  let h44 = 24\n  let h45 = 25\n  let h46 = 26\n  let h47 = 27\n  let h48 = 28\n  let h49 = 29\n  let h50 = 30\n  let h51 = 31\n  let h52 = 32\n  let h53 = 33\n  let h54 = 34\n  let h55 = 35\n  let h56 = 36\n  let h57 = 37\n  let h58 = 38\n  let h59 = 39\n  let h60 = 40\n  let h61 = 41\n  let h62 = 42\n  let h63 = 43\n  let h64 = 44\n  let h65 = 45\n  let h66 = 46\n  let h67 = 47\n  let h68 = 48\n  let h69 = 49\n  let h70 = 50\n  let h71 = 51\n  let h72 = 52\n  let h73 = 53\n  let h74 = 54\n  let h75 = 55\n  let h76 = 56\n  let h77 = 57\n  let h78 = 58\n  let h79 = 59\n  let h80 = 60\n  let h81 = 61\n  let h82 = 62\n  let h83 = 63\n  let h84 = 64\n  let h85 = 65\n  let h86 = 66\n  let h87 = 67\n  let h88 = 68\n  let h89 = 69\n  let h90 = 70\n  let h91 = 71\n  let h92 = 72\n  let h93 = 73\n  let h94 = 74\n  let h95 = 75\n  let h96 = 76\n  let h97 = 77\n  let h98 = 78\n  let h99 = 79\n  let h100 = 80\n  let h101 = 81\n  let h102 = 82\n  let h103 = 83\n  let h104 = 84\n  let h105 = 85\n  let h106 = 86\n  let h107 = 87\n  let h108 = 88\n  let h109 = 89\n  let h110 = 90\n  let h111 = 91\n  let h112 = 92\n  let h113 = 93\n  let h114 = 94\n  let h115 = 95\n  let h116 = 96\n  let h117 = 97\n  let h118 = 98\n  let h119 = 99\n  let h120 = 100\n  let h121 = 101\n  let h122 = 102\n  let h123 = 103\n  let h124 = 104\n  let h125 = 105\n  let h126 = 106\n  let h127 = 107\n  let h128 = 108\n  let h129 = 109\n  let h130 = 110\n  let h131 = 111\n  let h132 = 112\n  let h133 = 113\n  let h134 = 114\n  let h135 = 115\n  let h136 = 116\n  let h137 = 117\n  let h138 = 118\n  let h139 = 119\n  let h140 = 120\n  let h141 = 121\n  let h142 = 122\n  let h143 = 123\n  let h144 = 124\n  let h145 = 125\n  let h146 = 126\n  let h147 = 127\n  let h148 = 128\n  let h149 = 129\n  let h150 = 130\n  let h151 = 131\n  let h152 = 132\n  let h153 = 133\n  let h154 = 134\n  let h155 = 135\n  let h156 = 136\n  let h157 = 137\n  let h158 = 138\n  let h159 = 139\n  let h160 = 140\n  let h161 = 141\n  let h162 = 142\n  let h163 = 143\n  let h164 = 144\n  let h165 = 145\n  let h166 = 146\n  let h167 = 147\n  let h168 = 148\n  let h169 = 149\n  let h170 = 150\n  let h171 = 151\n  let h172 = 152\n  let h173 = 153\n  let h174 = 154\n  let h175 = 155\n  let h176 = 156\n  let h177 = 157\n  let h178 = 158\n  let h179 = 159\n  let h180 = 160\n  let h181 = 161\n  let h182 = 162\n  let h183 = 163\n  let h184 = 164\n  let h185 = 165\n  let h186 = 166\n  let h187 = 167\n  let h188 = 168\n  let h189 = 169\n  let h190 = 170\n  let h191 = 171\n  let h192 = 172\n  let h193 = 173\n  let h194 = 174\n  let h195 = 175\n  let h196 = 176\n  let h197 = 177\n  let h198 = 178\n  let h199 = 179\n  let h200 = 180\n  let h201 = 181\n  let h202 = 182\n  let h203 = 183\n  let h204 = 184\n  let h205 = 185\n  let h206 = 186\n  let h207 = 187\n  let h208 = 188\n  let h209 = 189\n  let h210 = 190\n  let h211 = 191\n  let h212 = 192\n  let h213 = 193\n  let h214 = 194\n  let h215 = 195\n  let h216 = 196\n  let h217 = 197\n  let h218 = 198\n  let h219 = 199\n  let h220 = 200\n  let h221 = 201\n  let h222 = 202\n  let h223 = 203\n  let h224 = 204\n  let h225 = 205\n  let h226 = 206\n  let h227 = 207\n  let h228 = 208\n  let h229 = 209\n  let h230 = 210\n  let h231 = 211\n  let h232 = 212\n  let h233 = 213\n  let h234 = 214\n  let h235 = 215\n  let h236 = 216\n  let h237 = 217\n  let h238 = 218\n  let h239 = 219\n  let h240 = 220\n  let h241 = 221\n  let h242 = 222\n  let h243 = ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibvib(0) == 0\n  fibvib(1) == 0\n  fibvib(2) == 1\n  fibvib(n) == fibvib(n-1) + fibvib(n-2) + fibvib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibvib number sequence.\n  >>> fibvib(1)\n  0\n  >>> fibvib(5)\n  4\n  >>> fibvib(8)\n  24\n  */\nconst fibvib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibvib", "gc": "<|endoftext|>/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibvib(0) == 0\n  fibvib(1) == 0\n  fibvib(2) == 1\n  fibvib(n) == fibvib(n-1) + fibvib(n-2) + fibvib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibvib number sequence.\n  >>> fibvib(1)\n  0\n  >>> fibvib(5)\n  4\n  >>> fibvib(8)\n  24\n  */\nconst fibvib = (n) => {\n  if (n < 2) return 0;\n  return fibvib(n-1) + fibvib(n-2) + fibvib(n-3);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts at 1 and ends at n.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(5)\n  13\n  >>> fibonacci(8)\n  34\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts at 1 and ends at n.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(5)\n  13\n  >>> fibonacci(8)\n  34\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts at 1 and ends at n.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(5)\n  13\n  >>> fibonacci(8)\n  34\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts at 1 and ends at n.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(5)\n  13\n  >>> fibonacci(8)\n  34\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts at 1 and ends at n.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(5)\n  13\n  >>> fibonacci(8)\n  34\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts at 1 and ends at n.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(5)\n  13\n  >>> fibonacci(8)\n  34\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts at 1 and ends at n.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(5)\n  13\n  >>> fibonacci(8)\n  34\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts at 1 and ends at n.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(5)\n  13\n  >>> fibonacci(8)\n  34\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts at 1 and ends at n.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(5)\n  13\n  >>> fibonacci(8)\n  34\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts at 1 and ends at n.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(5)\n  13\n  >>> fibonacci(8)\n  34\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts at 1 and ends at n.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(5)\n  13\n  >>> fibonacci(8)\n  34\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts at 1 and ends at n.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(5)\n  13\n  >>> fibonacci(8)\n  34\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts at 1 and ends at n.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(5)\n  13\n  >>> fibonacci(8)\n  34\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts at 1 and ends at n.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(5)\n  13\n  >>> fibonacci(8)\n  34\n  */\nconst fibonacci = (n) => {\n  if (n < 2) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts at 1 and ends at n.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(5)\n  13\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowflsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowflsCount(\"abcde\")\n  2\n  >>> vowflsCount(\"ACEDY\")\n  3\n  */\nconst vowflsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowflsCount", "gc": "<|endoftext|>/*Write a function vowflsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowflsCount(\"abcde\")\n  2\n  >>> vowflsCount(\"ACEDY\")\n  3\n  */\nconst vowflsCount = (s) => {\n  let vowelCount = 0;\n  let vowelIndex = 0;\n  let vowelChar = s.charAt(0);\n  let vowelCharIndex = 0;\n  let vowelCharLength = vowelChar.length;\n\n  while (vowelCharIndex < vowelCharLength) {\n    if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 2)) {\n      vowelCount++;\n      vowelIndex += 2;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 3)) {\n      vowelCount++;\n      vowelIndex += 3;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 4)) {\n      vowelCount++;\n      vowelIndex += 4;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 5)) {\n      vowelCount++;\n      vowelIndex += 5;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 6)) {\n      vowelCount++;\n      vowelIndex += 6;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 7)) {\n      vowelCount++;\n      vowelIndex += 7;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 8)) {\n      vowelCount++;\n      vowelIndex += 8;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 9)) {\n      vowelCount++;\n      vowelIndex += 9;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 10)) {\n      vowelCount++;\n      vowelIndex += 10;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 11)) {\n      vowelCount++;\n      vowelIndex += 11;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 12)) {\n      vowelCount++;\n      vowelIndex += 12;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 13)) {\n      vowelCount++;\n      vowelIndex += 13;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 14)) {\n      vowelCount++;\n      vowelIndex += 14;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 15)) {\n      vowelCount++;\n      vowelIndex += 15;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 16)) {\n      vowelCount++;\n      vowelIndex += 16;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 17)) {\n      vowelCount++;\n      vowelIndex += 17;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 18)) {\n      vowelCount++;\n      vowelIndex += 18;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 19)) {\n      vowelCount++;\n      vowelIndex += 19;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 20)) {\n      vowelCount++;\n      vowelIndex += 20;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 21)) {\n      vowelCount++;\n      vowelIndex += 21;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 22)) {\n      vowelCount++;\n      vowelIndex += 22;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 23)) {\n      vowelCount++;\n      vowelIndex += 23;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 24)) {\n      vowelCount++;\n      vowelIndex += 24;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 25)) {\n      vowelCount++;\n      vowelIndex += 25;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 26)) {\n      vowelCount++;\n      vowelIndex += 26;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 27)) {\n      vowelCount++;\n      vowelIndex += 27;\n    } else if (vowelChar.charCodeAt(vowelCharIndex) === vowelChar.charCodeAt(vowelCharIndex + 1) && vowelChar.charCodeAt(vowelCharIndex + 1) === vowelChar.charCodeAt(vowelCharIndex + 28)) {\n      vowelCount++;\n      vowelIndex += 28;\n    } else if (", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> cirfularShift(12, 1)\n  \"21\"\n  >>> cirfularShift(12, 2)\n  \"12\"\n  */\nconst cirfularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "cirfularShift", "gc": "<|endoftext|>/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> cirfularShift(12, 1)\n  \"21\"\n  >>> cirfularShift(12, 2)\n  \"12\"\n  */\nconst cirfularShift = (x, shift) => {\n  const digits = x.toString().split('')\n  const reversed = digits.reverse()\n  return reversed.slice(shift, digits.length).join('')\n}\n\n/*\n  Convert a number to a string by rounding its decimal places to the nearest\n  integer.\n  >>> toInt(3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587006606315588174881520920962829254091715364367892590360011330530548820466521384146951941511609433057270365759591953092186117381932611793105118548074462379962749567351885752724891227938183011949129833673362440656643086021394946395224737190702179860943702770539217176293176752384674818467669405132000568127145263560827785771342757789609173637178721468440901224953430146549585371050792279689258923542019956112129021960864034418159813629774771309960518707211349999998372978049951059731732816096318595024459455346908302642522308253344685035261931188171010003137838752886587533208381420617177669147303598253490428755468731159562863882353787593751957781857780532171226806613001927876611195909216420198938095257201065485863276687835121223726227113448428529009407770775672256892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632766878351212237262271134484285290094077707756722568925892354201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859502445945534690830264252230825334468503526193118817101000313783875288658753320838142061717766914730359825349042875546873115956286388235378759375195778185778053217122680661300192787661119590921642019893809525720106548586327668783512122372622711344842852900940777077567225689258923542019956112129021960864034418159813629774771309960518707211349999998372978049951059731732816096318595024459455346908302642522308253344685035261931188171010003137838752886587533208381420617177669147303598253490428755468731159562863882353787593751957781857780532171226806613001927876611195909216420198938095257201065485863276687835121223726227113448428529009407770775672256892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632766878351212237262271134484285290094077707756722568925892354201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859502445945534690830264252230825334468503526193118817101000313783875288658753320838142061717766914730359825349042875546873115956286388235378759375195778185778053217122680661300192787661119590921642019893809525720106548586327668783512122372622711344842852900940777077567225689258923542019956112129021960864034418159813629774771309960518707211349999998372978049951059731732816096318595024459455346908302642522308253344685035261931188171010003137838752886587533208381420617177669147303598253490428755468731159562863882353787593751957781857780532", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digltSum(\"\") => 0\n      digltSum(\"abAB\") => 131\n      digltSum(\"abcCd\") => 67\n      digltSum(\"helloE\") => 69\n      digltSum(\"woArBld\") => 131\n      digltSum(\"aAaaaXa\") => 153\n  */\nconst digltSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digltSum", "gc": "<|endoftext|>/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digltSum(\"\") => 0\n      digltSum(\"abAB\") => 131\n      digltSum(\"abcCd\") => 67\n      digltSum(\"helloE\") => 69\n      digltSum(\"woArBld\") => 131\n      digltSum(\"aAaaaXa\") => 153\n  */\nconst digltSum = (s) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  frultDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  frultDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  frultDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  frultDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst frultDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "frultDistribution", "gc": "<|endoftext|>/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  frultDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  frultDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  frultDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  frultDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst frultDistribution = (s, n) => {\n  let totalApples = 0, totalOranges = 0, totalMango = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i].includes(\"apples\")) {\n      totalApples += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"oranges\")) {\n      totalOranges += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"mango\")) {\n      totalMango += parseInt(fruits[i].split(\" \")[0]);\n    }\n  }\n  return totalApples - totalOranges - totalMango;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  frultDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  frultDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  frultDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  frultDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst frultDistribution = (s, n) => {\n  let totalApples = 0, totalOranges = 0, totalMango = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i].includes(\"apples\")) {\n      totalApples += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"oranges\")) {\n      totalOranges += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"mango\")) {\n      totalMango += parseInt(fruits[i].split(\" \")[0]);\n    }\n  }\n  return totalApples - totalOranges - totalMango;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  frultDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  frultDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  frultDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  frultDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst frultDistribution = (s, n) => {\n  let totalApples = 0, totalOranges = 0, totalMango = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i].includes(\"apples\")) {\n      totalApples += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"oranges\")) {\n      totalOranges += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"mango\")) {\n      totalMango += parseInt(fruits[i].split(\" \")[0]);\n    }\n  }\n  return totalApples - totalOranges - totalMango;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  frultDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  frultDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  frultDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  frultDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst frultDistribution = (s, n) => {\n  let totalApples = 0, totalOranges = 0, totalMango = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i].includes(\"apples\")) {\n      totalApples += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"oranges\")) {\n      totalOranges += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"mango\")) {\n      totalMango += parseInt(fruits[i].split(\" \")[0]);\n    }\n  }\n  return totalApples - totalOranges - totalMango;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  frultDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  frultDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  frultDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  frultDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst frultDistribution = (s, n) => {\n  let totalApples = 0, totalOranges = 0, totalMango = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i].includes(\"apples\")) {\n      totalApples += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"oranges\")) {\n      totalOranges += parseInt(fruits[i].split(\" \")[0]);\n    } else if (fruits[i].includes(\"mango\")) {\n      totalMango += parseInt(fruits[i].split(\" \")[0]);\n    }\n  }\n  return totalApples - totalOranges - totalMango;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  frultDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to plufk one of the nodes and return it.\n  The plufked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plufked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst plufk = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "plufk", "gc": "<|endoftext|>/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to plufk one of the nodes and return it.\n  The plufked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plufked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst plufk = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let result = [];\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      result.push(arr[i]);\n      i++;\n    } else {\n      j++;\n    }\n  }\n  while (j < len) {\n    if (arr[j] % 2 === 0) {\n      result.push(arr[j]);\n      j++;\n    } else {\n      k++;\n    }\n  }\n  return result;\n};\n\n// Given an array representing a tree with non-negative integer nodes,\n// your task is to return the minimum node in the tree that has non-negative integer children.\n// The minimum node in the tree should have the smallest value.\n// If multiple nodes with the same smallest value are found return the node that has smallest index.\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n//     Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n//     Example 3:\n//     Input: []\n//     Output: []\n//     Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n//     1 <= node.children.length <= 10000\n//     0 <= node.children[i].value <= 10^9\n//     0 <= node.children[i].children.length <= 10^9\n//     0 <= node.children[i].children[i].value <= 10^9\n//     0 <= node.children[i].children[i].children.length <= 10^9\n//     0 <= node.children[i].children[i].children[i].value <= 10^9\n//     0 <= node.children[i].children[i].children[i].children.length <= 10^9\n//     0 <= node.children[i].children[i].children[i].children[i].children[i].value <= 10^9\n//     0 <= node.children[i].children[i].children[i].children[i].children[i].children[i].children[i].value <= 10^9\n//     0 <= node.children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].value <= 10^9\n//     0 <= node.children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].children[i].", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      seagch([4, 1, 2, 2, 3, 1])) == 2\n      seagch([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      seagch([5, 5, 4, 4, 4])) == -1\n  */\nconst seagch = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "seagch", "gc": "<|endoftext|>/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      seagch([4, 1, 2, 2, 3, 1])) == 2\n      seagch([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      seagch([5, 5, 4, 4, 4])) == -1\n  */\nconst seagch = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      seagch([4, 1, 2, 2, 3, 1])) == 3\n      seagch([1, 2, 2, 3, 3, 3, 4, 4, 4])) == -1\n      seagch([5, 5, 4, 4, 4])) == -1\n  */\nconst seagch = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      seagch([4, 1, 2, 2, 3, 1])) == 3\n      seagch([1, 2, 2, 3, 3, 3, 4, 4, 4])) == -1\n      seagch([5, 5, 4, 4, 4])) == -1\n  */\nconst seagch = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      seagch([4, 1, 2, 2, 3, 1])) == 3\n      seagch([1, 2, 2, 3, 3, 3, 4, 4, 4])) == -1\n      seagch([5, 5, 4, 4, 4])) == -1\n  */\nconst seagch = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      seagch([4, 1, 2, 2, 3, 1])) == 3\n      seagch([1, 2, 2, 3, 3, 3, 4, 4, 4])) == -1\n      seagch([5, 5, 4, 4, 4])) == -1\n  */\nconst seagch = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      seagch([4, 1, 2, 2, 3, 1])) == 3\n      seagch([1, 2, 2, 3, 3, 3, 4, 4, 4])) == -1\n      seagch([5, 5, 4, 4, 4])) == -1\n  */\nconst seagch = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      seagch([4, 1, 2, 2, 3, 1])) == 3\n      seagch([1, 2, 2, 3, 3, 3, 4, 4, 4])) == -1\n      seagch([5, 5, 4, 4, 4])) == -1\n  */\nconst seagch = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      seagch([4, 1, 2, 2, 3, 1])) == 3\n      seagch([1, 2, 2, 3, 3, 3, 4, 4, 4])) == -1\n      seagch([5, 5, 4, 4, 4])) == -1\n  */\nconst seagch = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      seagch([4, 1, 2, 2, 3, 1])) == 3\n      seagch([1, 2, 2, 3, 3, 3, 4, 4, 4])) == -1\n      seagch([5, 5, 4, 4, 4])) == -1\n  */\nconst seagch = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      seagch([4, 1, 2, 2, 3, 1])) == 3\n      seagch([1, 2, 2, 3, 3, 3, 4, 4, 4])) == -1\n      seagch([5, 5, 4, 4, 4])) == -1\n  */\nconst seagch = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      seagch([4, 1, 2, 2, 3, 1])) == 3\n      seagch([1, 2, 2, 3, 3, 3, 4, 4, 4])) == -1\n      seagch([5, 5, 4, 4, 4])) == -1\n  */\nconst seagch = (lst) => {\n  let max = 0;\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that contain given substring\n  >>> filherBySubstring([], 'a')\n  []\n  >>> filherBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filherBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filherBySubstring", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that contain given substring\n  >>> filherBySubstring([], 'a')\n  []\n  >>> filherBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filherBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an input list of strings only keeping first occurrence of substring\n  >>> filherFirstOfSubstring([], 'a')\n  []\n  >>> filherFirstOfSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filherFirstOfSubstring = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring));\n};\n\n/* Filter an input list of strings only keeping last occurrence of substring\n  >>> filherLastOfSubstring([], 'a')\n  []\n  >>> filherLastOfSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filherLastOfSubstring = (strings, substring) => {\n  return strings.filter(string => string.endsWith(substring));\n};\n\n/* Filter an input list of strings only keeping first occurrence of substring\n  >>> filherFirstOfLastSubstring([], 'a')\n  []\n  >>> filherFirstOfLastSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filherFirstOfLastSubstring = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring) && string.endsWith(substring));\n};\n\n/* Filter an input list of strings only keeping last occurrence of substring\n  >>> filherLastOfLastSubstring([], 'a')\n  []\n  >>> filherLastOfLastSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filherLastOfLastSubstring = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring) && string.endsWith(substring));\n};\n\n/* Filter an input list of strings only keeping first occurrence of substring\n  >>> filherFirstOfFirstSubstring([], 'a')\n  []\n  >>> filherFirstOfFirstSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filherFirstOfFirstSubstring = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring) && string.endsWith(substring));\n};\n\n/* Filter an input list of strings only keeping last occurrence of substring\n  >>> filherLastOfFirstSubstring([], 'a')\n  []\n  >>> filherLastOfFirstSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filherLastOfFirstSubstring = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring) && string.endsWith(substring));\n};\n\n/* Filter an input list of strings only keeping first occurrence of substring\n  >>> filherFirstOfLastSubstring([], 'a')\n  []\n  >>> filherFirstOfLastSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filherFirstOfFirstSubstring = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring) && string.endsWith(substring));\n};\n\n/* Filter an input list of strings only keeping last occurrence of substring\n  >>> filherLastOfLastSubstring([], 'a')\n  []\n  >>> filherLastOfLastSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filherLastOfLastSubstring = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring) && string.endsWith(substring));\n};\n\n/* Filter an input list of strings only keeping first occurrence of substring\n  >>> filherFirstOfFirstSubstring([], 'a')\n  []\n  >>> filherFirstOfFirstSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filherFirstOfLastSubstring = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring) && string.endsWith(substring));\n};\n\n/* Filter an input list of strings only keeping last occurrence of substring\n  >>> filherLastOfFirstSubstring([], 'a')\n  []\n  >>> filherLastOfFirstSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filherLastOfFirstSubstring = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring) && string.endsWith(substring));\n};\n\n/* Filter an input list of strings only keeping first occurrence of substring\n  >>> filherFirstOfLastSubstring([], 'a')\n  []\n  >>> filherFirstOfLastSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filherFirstOfFirstSubstring = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring) && string.endsWith(substring));\n};\n\n/* Filter an input list of strings only keeping last occurrence of substring\n  >>> filherLastOfFirstSubstring([], 'a')\n  []\n  >>> filherLastOfFirstSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filherLastOfLastSubstring = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring) && string.endsWith(substring));\n};\n\n/* Filter an input list of strings only keeping first occurrence of substring\n  >>> filherFirstOfFirstSubstring([], 'a')\n  []\n  >>> filherFirstOfFirstSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  */\nconst filherFirstOfLastSubstring = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring) && string.endsWith(substring));\n};\n\n/* Filter an input list of strings only keeping last occurrence of substring\n  >>> filherLastOfFirstSubstring([], 'a')\n  []\n  >>> filherLastOfFirstSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filherLastOfFirstSubstring = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring) && string.endsWith(substring));\n};\n\n/* Filter an input list of strings only keeping first occurrence of substring\n  >>> filherFirstOfLastSubstring([], 'a')\n  []\n  >>> filherFirstOfLastSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filherFirstOfFirstSubstring = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring) && string.endsWith(substring));\n};\n\n/* Filter an input list of strings only keeping last occurrence of substring\n  >>> filherLastOfFirstSubstring([], 'a')\n  []\n  >>> filherLastOfFirstSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filherLastOfLastSubstring = (strings, substring) => {\n  return strings.filter(string => string.startsWith(substring) && string.endsWith(substring", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strwngeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strwngeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strwngeSortList([]) == []\n  */\nconst strwngeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strwngeSortList", "gc": "<|endoftext|>/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strwngeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strwngeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strwngeSortList([]) == []\n  */\nconst strwngeSortList = (lst) => {\n  let sortedArr = []\n  let minVal = lst[0]\n  let maxVal = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < minVal) {\n      minVal = lst[i]\n    }\n    if (lst[i] > maxVal) {\n      maxVal = lst[i]\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < minVal) {\n      sortedArr.push(minVal)\n      minVal = lst[i]\n    }\n    if (lst[i] > maxVal) {\n      sortedArr.push(maxVal)\n      maxVal = lst[i]\n    }\n  }\n  return sortedArr\n}\n\n/*\n  Given array of integers, return array of sorted integers in ascending order.\n  Sort is done by comparing each element with its next element.\n\n  Examples:\n  sortArray([5, 1, 3, 2]) == [2, 1, 5, 3]\n  sortArray([5, 1, 3, 2]) == [3, 1, 5, 2]\n  sortArray([]) == []\n  */\nconst sortArray = (arr) => {\n  let sortedArr = []\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i]\n    sortedArr.push(temp)\n  }\n  return sortedArr\n}\n\n/*\n  Given array of integers, return array of sorted integers in descending order.\n  Sort is done by comparing each element with its previous element.\n\n  Examples:\n  sortArrayDesc([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortArrayDesc([5, 1, 3, 2]) == [2, 1, 5, 3]\n  sortArrayDesc([]) == []\n  */\nconst sortArrayDesc = (arr) => {\n  let sortedArr = []\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i]\n    sortedArr.push(temp)\n  }\n  return sortedArr\n}\n\n/*\n  Given array of integers, return array of sorted integers in ascending order.\n  Sort is done by comparing each element with its next element.\n\n  Examples:\n  sortArrayAsc([5, 1, 3, 2]) == [2, 1, 5, 3]\n  sortArrayAsc([5, 1, 3, 2]) == [3, 1, 5, 2]\n  sortArrayAsc([]) == []\n  */\nconst sortArrayAsc = (arr) => {\n  let sortedArr = []\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i]\n    sortedArr.push(temp)\n  }\n  return sortedArr\n}\n\n/*\n  Given array of integers, return array of sorted integers in descending order.\n  Sort is done by comparing each element with its previous element.\n\n  Examples:\n  sortArrayDescAsc([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortArrayDescAsc([5, 1, 3, 2]) == [2, 1, 5, 3]\n  sortArrayDescAsc([]) == []\n  */\nconst sortArrayDescAsc = (arr) => {\n  let sortedArr = []\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i]\n    sortedArr.push(temp)\n  }\n  return sortedArr\n}\n\n/*\n  Given array of integers, return array of sorted integers in ascending order.\n  Sort is done by comparing each element with its next element.\n\n  Examples:\n  sortArrayAscDesc([5, 1, 3, 2]) == [2, 1, 5, 3]\n  sortArrayAscDesc([5, 1, 3, 2]) == [3, 1, 5, 2]\n  sortArrayAscDesc([]) == []\n  */\nconst sortArrayAscDesc = (arr) => {\n  let sortedArr = []\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i]\n    sortedArr.push(temp)\n  }\n  return sortedArr\n}\n\n/*\n  Given array of integers, return array of sorted integers in descending order.\n  Sort is done by comparing each element with its previous element.\n\n  Examples:\n  sortArrayDescDescAsc([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortArrayDescDescAsc([5, 1, 3, 2]) == [2, 1, 5, 3]\n  sortArrayDescDescAsc([]) == []\n  */\nconst sortArrayDescDescAsc = (arr) => {\n  let sortedArr = []\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i]\n    sortedArr.push(temp)\n  }\n  return sortedArr\n}\n\n/*\n  Given array of integers, return array of sorted integers in ascending order.\n  Sort is done by comparing each element with its next element.\n\n  Examples:\n  sortArrayAscDesc([5, 1, 3, 2]) == [2, 1, 5, 3]\n  sortArrayAscDesc([5, 1, 3, 2]) == [3, 1, 5, 2]\n  sortArrayAscDesc([]) == []\n  */\nconst sortArrayAscDescDesc = (arr) => {\n  let sortedArr = []\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i]\n    sortedArr.push(temp)\n  }\n  return sortedArr\n}\n\n/*\n  Given array of integers, return array of sorted integers in descending order.\n  Sort is done by comparing each element with its previous element.\n\n  Examples:\n  sortArrayDescDescAsc([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortArrayDescDescAsc([5, 1, 3, 2]) == [2, 1, 5, 3]\n  sortArrayDescDescAsc([]) == []\n  */\nconst sortArrayDescDescAsc = (arr) => {\n  let sortedArr = []\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i]\n    sortedArr.push(temp)\n  }\n  return sortedArr\n}\n\n/*\n  Given array of integers, return array of sorted integers in ascending order.\n  Sort is done by comparing each element with its next element.\n\n  Examples:\n  sortArrayDescDescAsc([5, 1, 3, 2]) == [2, 1, 5, 3]\n  sortArrayDescDescAsc([5, 1, 3, 2]) == [3, 1, 5, 2]\n  sortArrayDescDescAsc([]) == []\n  */\nconst sortArrayDescDescDesc = (arr) => {\n  let sortedArr = []\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i]\n    sortedArr.push(temp)\n  }\n  return sortedArr\n}\n\n/*\n  Given array of integers, return array of sorted integers in ascending order.\n  Sort is done by comparing each element with its previous element.\n\n  Examples:\n  sortArrayDescDescDescAsc([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortArrayDescDescDescAsc([5, 1, 3, 2]) == [2, 1, 5, 3]\n  sortArrayDescDescDescAsc([]) == []\n  */\nconst sortArrayDescDescDescAsc = (arr) => {\n  let sortedArr = []\n  for (let i = 0; i < arr.length; i++) {\n    let temp = arr[i]\n    sortedArr.push(temp)\n  }\n  return sortedArr\n}\n\n/*\n  Given array of integers, return array of sorted integers in ascending order.\n  Sort is done by comparing each element with its next element.\n\n  Examples:\n  sortArrayDescDescDescDescAsc([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortArrayDescDescDescDescAsc([5, 1, 3, 2]) == [2, 1, 5, 3]\n  sortArrayDescDescDescDescAsc([]) == []\n  */\nconst sortArrayDescDescDescDesc", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triwngleArea(3, 4, 5) == 6.00\n  triwngleArea(1, 2, 10) == -1\n  */\nconst triwngleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triwngleArea", "gc": "<|endoftext|>/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triwngleArea(3, 4, 5) == 6.00\n  triwngleArea(1, 2, 10) == -1\n  */\nconst triwngleArea = (a, b, c) => {\n  const ab = a + b;\n  const ac = a + c;\n  const bc = b + c;\n  const abc = ab + c;\n  const bcd = bc + d;\n  const abcd = abc + d;\n  const bcdd = bcd + d;\n  const abcde = abcd + e;\n  const bcdde = bcdd + e;\n  const abcdfd = abcde + f;\n  const bcddfd = bcdde + f;\n  const abcdfde = abcdfd + g;\n  const bcddfde = bcddfd + g;\n  const abcdfdfd = abcdfde + h;\n  const bcddfdfd = bcddfde + h;\n  const abcdfdfde = abcdfdfd + i;\n  const bcddfdfde = bcddfdfd + i;\n  const abcdfdfdfd = abcdfdfde + j;\n  const bcddfdfdfd = bcddfdfde + j;\n  const abcdfdfdfde = abcdfdfdfd + k;\n  const bcddfdfdfde = bcddfdfde + k;\n  const abcdfdfdfdfd = abcdfdfdfd + l;\n  const bcddfdfdfdfd = bcddfdfdfde + l;\n  const abcdfdfdfdfde = abcdfdfdfdfd + m;\n  const bcddfdfdfdfde = bcddfdfdfde + m;\n  const abcdfdfdfdfdfd = abcdfdfdfdfd + n;\n  const bcddfdfdfdfdfd = bcddfdfdfdfde + n;\n  const abcdfdfdfdfdfde = abcdfdfdfdfdfd + o;\n  const bcddfdfdfdfdfde = bcddfdfdfdfde + o;\n  const abcdfdfdfdfdfd = abcdfdfdfdfd + p;\n  const bcddfdfdfdfdfd = bcddfdfdfdfdfde + p;\n  const abcdfdfdfdfdfdfde = abcdfdfdfdfdfd + q;\n  const bcddfdfdfdfdfdfde = bcddfdfdfdfdfde + q;\n  const abcdfdfdfdfdfdfd = abcdfdfdfdfdfd + r;\n  const bcddfdfdfdfdfdfd = bcddfdfdfdfdfde + r;\n  const abcdfdfdfdfdfdfde = abcdfdfdfdfdfdfd + s;\n  const bcddfdfdfdfdfdfde = bcddfdfdfdfdfde + s;\n  const abcdfdfdfdfdfdfd = abcdfdfdfdfdfd + t;\n  const bcddfdfdfdfdfdfd = bcddfdfdfdfdfdfde + t;\n  const abcdfdfdfdfdfdfde = abcdfdfdfdfdfdfd + u;\n  const bcddfdfdfdfdfdfde = bcddfdfdfdfdfdfde + u;\n  const abcdfdfdfdfdfdfdfd = abcdfdfdfdfdfdfd + v;\n  const bcddfdfdfdfdfdfdfd = bcddfdfdfdfdfdfde + v;\n  const abcdfdfdfdfdfdfdfde = abcdfdfdfdfdfdfd + w;\n  const bcddfdfdfdfdfdfde = bcddfdfdfdfdfdfde + w;\n  const abcdfdfdfdfdfdfdfd = abcdfdfdfdfdfdfdfd + x;\n  const bcddfdfdfdfdfdfdfd = bcddfdfdfdfdfdfdfde + x;\n  const abcdfdfdfdfdfdfdfde = abcdfdfdfdfdfdfdfd + y;\n  const bcddfdfdfdfdfdfdfde = bcddfdfdfdfdfdfde + y;\n  const abcdfdfdfdfdfdfdfd = abcdfdfdfdfdfdfdfd + z;\n  const bcddfdfdfdfdfdfdfd = bcddfdfdfdfdfdfdfde + z;\n  const abcdfdfdfdfdfdfdfde = abcdfdfdfdfdfdfdfdfd + 0;\n  const bcddfdfdfdfdfdfdfdfde = bcddfdfdfdfdfdfdfdfde + 0;\n  const abcdfdfdfdfdfdfdfdfd = abcdfdfdfdfdfdfdfd + 1;\n  const bcddfdfdfdfdfdfdfd = bcddfdfdfdfdfdfdfde + 1;\n  const abcdfdfdfdfdfdfdfde = abcdfdfdfdfdfdfdfdfd + 2;\n  const bcddfdfdfdfdfdfdfdfde = bcddfdfdfdfdfdfdfdfde + 2;\n  const abcdfdfdfdfdfdfdfdfd = abcdfdfdfdfdfdfdfdfd + 3;\n  const bcddfdfdfdfdfdfdfd = bcddfdfdfdfdfdfdfdfde + 3;\n  const abcdfdfdfdfdfdfdfde = abcdfdfdfdfdfdfdfdfd + 4;\n  const bcddfdfdfdfdfdfdfdfde = bcddfdfdfdfdfdfdfde + 4;\n  const abcdfdfdfdfdfdfdfdfd = abcdfdfdfdfdfdfdfdfd + 5;\n  const bcddfdfdfdfdfdfdfdfd = bcddfdfdfdfdfdfdfdfde + 5;\n  const abcdfdfdfdfdfdfdfdfde = abcdfdfdfdfdfdfdfdfd + 6;\n  const bcddfdfdfdfdfdfdfdfde = bcddfdfdfdfdfdfdfde + 6;\n  const abcdfdfdfdfdfdfdfdfd = abcdfdfdfdfdfdfdfdfd + 7;\n  const bcddfdfdfdfdfdfdfdfd = bcddfdfdfdfdfdfdfdfde + 7;\n  const abcdfdfdfdfdfdfdfdfde = abcdfdfdfdfdfdfdfdfd + 8;\n  const bcddfdfdfdfdfdfdfdfde = bcddfdfdfdfdfdfdfdfde + 8;\n  const abcdfdfdfdfdfdfdfdfdfd = abcdfdfdfdfdfdfdfdfdfd + 9;\n  const bcddfdfdfdfdfdfdfdfdfd = bcddfdfdfdfdfdfdfdfdfde + 9;\n  const abcdfdfdfdfdfdfdfdfde = abcdfdfdfdfdfdfdfdfd + 10;\n  const bcddfdfdfdfdfdfdfdfde = bcddfdfdfdfdfdfdfdfde + 10;\n  const abcdfdfdfdfdfdfdfdfd = abcdfdfdfdfdfdfdfdfdfd + 11;\n  const bcddfdfdfdfdfdfdfdfdfd = bcddfdfdfdfdfdfdfdfdfde + 11;\n  const abcdfdfdfdfdfdfdfdfde = abcdfdfdfdfdfdfdfdfdfd + 12;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  wilpItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  wilpItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  wilpItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  wilpItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst wilpItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "wilpItFly", "gc": "<|endoftext|>/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  wilpItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  wilpItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  wilpItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  wilpItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst wilpItFly = (q, w) => {\n  const len = q.length;\n  const maxWeight = w || 0;\n  const maxWeightSum = maxWeight * maxWeight;\n  const maxWeightSumSq = maxWeightSum * maxWeightSum;\n  const maxWeightSumSqSq = maxWeightSumSq * maxWeightSumSq;\n  const maxWeightSumSqSqSq = maxWeightSumSqSq * maxWeightSumSqSq;\n  const maxWeightSumSqSqSqSq = maxWeightSumSqSqSq * maxWeightSumSqSqSq;\n  const maxWeightSumSqSqSqSqSq = maxWeightSumSqSqSqSq * maxWeightSumSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSq = maxWeightSumSqSqSqSqSq * maxWeightSumSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSq = maxWeightSumSqSqSqSqSq * maxWeightSumSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSqSq * maxWeightSumSqSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSq * maxWeightSumSqSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSqSq * maxWeightSumSqSqSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSqSqSq * maxWeightSumSqSqSqSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSqSqSq * maxWeightSumSqSqSqSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSqSqSqSqSq * maxWeightSumSqSqSqSqSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSqSqSq * maxWeightSumSqSqSqSqSqSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSqSqSqSqSqSq * maxWeightSumSqSqSqSqSqSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSqSqSqSqSqSq * maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSqSqSqSq * maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSq * maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSqSqSqSqSqSq * maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSq * maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSq * maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSq * maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSqSqSq * maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSq;\n  const maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSq = maxWeightSumSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSqSq", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smaplestChange([1,2,3,5,4,7,9,6]) == 4\n  smaplestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smaplestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smaplestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smaplestChange", "gc": "<|endoftext|>/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smaplestChange([1,2,3,5,4,7,9,6]) == 4\n  smaplestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smaplestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smaplestChange = (arr) => {\n  let len = arr.length;\n  let count = 0;\n  let min = 1;\n  let max = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > arr[len - 1]) {\n      max = i;\n    }\n    if (arr[i] < arr[len - 1]) {\n      min = i;\n    }\n  }\n  for (let i = min; i <= max; i++) {\n    if (arr[i] === arr[len - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smaplestChange([1,2,3,5,4,7,9,6]) == 4\n  smaplestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smaplestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smaplestChangeReverse = (arr) => {\n  let len = arr.length;\n  let count = 0;\n  let min = 1;\n  let max = 0;\n  for (let i = len - 1; i >= 0; i--) {\n    if (arr[i] > arr[i - 1]) {\n      max = i;\n    }\n    if (arr[i] < arr[i - 1]) {\n      min = i;\n    }\n  }\n  for (let i = min; i <= max; i++) {\n    if (arr[i] === arr[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smaplestChange([1,2,3,5,4,7,9,6]) == 4\n  smaplestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smaplestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smaplestChangeReverseReverse = (arr) => {\n  let len = arr.length;\n  let count = 0;\n  let min = 1;\n  let max = 0;\n  for (let i = len - 1; i >= 0; i--) {\n    if (arr[i] > arr[i - 1]) {\n      max = i;\n    }\n    if (arr[i] < arr[i - 1]) {\n      min = i;\n    }\n  }\n  for (let i = min; i <= max; i++) {\n    if (arr[i] === arr[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smaplestChange([1,2,3,5,4,7,9,6]) == 4\n  smaplestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smaplestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smaplestChangeReverseReverseReverse = (arr) => {\n  let len = arr.length;\n  let count = 0;\n  let min = 1;\n  let max = 0;\n  for (let i = len - 1; i >= 0; i--) {\n    if (arr[i] > arr[i - 1]) {\n      max = i;\n    }\n    if (arr[i] < arr[i - 1]) {\n      min = i;\n    }\n  }\n  for (let i = min; i <= max; i++) {\n    if (arr[i] === arr[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smaplestChange([1,2,3,5,4,7,9,6]) == 4\n  smaplestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smaplestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smaplestChangeReverseReverseReverseReverse = (arr) => {\n  let len = arr.length;\n  let count = 0;\n  let min = 1;\n  let max = 0;\n  for (let i = len - 1; i >= 0; i--) {\n    if (arr[i] > arr[i - 1]) {\n      max = i;\n    }\n    if (arr[i] < arr[i - 1]) {\n      min = i;\n    }\n  }\n  for (let i = min; i <= max; i++) {\n    if (arr[i] === arr[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smaplestChange([1,2,3,5,4,7,9,6]) == 4\n  smaplestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smaplestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smaplestChangeReverseReverseReverseReverse = (arr) => {\n  let len = arr.length;\n  let count = 0;\n  let min = 1;\n  let max = 0;\n  for (let i = len - 1; i >= 0; i--) {\n    if (arr[i] > arr[i - 1]) {\n      max = i;\n    }\n    if (arr[i] < arr[i - 1]) {\n      min = i;\n    }\n  }\n  for (let i = min; i <= max; i++) {\n    if (arr[i] === arr[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smaplestChange([1,2,3,5,4,7,9,6]) == 4\n  smaplestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smaplestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smaplestChangeReverseReverseReverseReverseReverse = (arr) => {\n  let len = arr.length;\n  let count = 0;\n  let min = 1;\n  let max = 0;\n  for (let i = len - 1; i >= 0; i--) {\n    if (arr[i] > arr[i - 1]) {\n      max = i;\n    }\n    if (arr[i] < arr[i - 1]) {\n      min = i;\n    }\n  }\n  for (let i = min; i <= max; i++) {\n    if (arr[i] === arr[i - 1]) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smaplestChange([1,2,3,5,4,7,9,6]) == 4\n  smaplestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smaplestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smaplestChangeReverseReverseReverseReverseReverseReverse = (arr) => {\n  let len = arr.length;\n  let count = 0;\n  let min = 1;\n  let max = 0;\n  for (let i = len - 1; i >= 0; i--) {\n    if (arr[i] > arr[i - 1]) {\n      max = i;\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totwlMatch([], [])  []\n  totwlMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totwlMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totwlMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totwlMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totwlMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totwlMatch", "gc": "<|endoftext|>/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totwlMatch([], [])  []\n  totwlMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totwlMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totwlMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totwlMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totwlMatch = (lst1, lst2) => {\n  let total = 0;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] === lst2[i]) {\n      total++;\n    }\n  }\n  return lst1.filter(x => x!== lst2[lst2.length - total]);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list greater than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totwlGt([], [])  []\n  totwlGt(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totwlGt(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totwlGt(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totwlGt(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totwlGt = (lst1, lst2) => {\n  let total = 0;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] === lst2[i]) {\n      total++;\n    }\n  }\n  return lst1.filter(x => x!== lst2[total]);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list equal the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totwlEq([], [])  []\n  totwlEq(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totwlEq(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totwlEq(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totwlEq(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totwlEq = (lst1, lst2) => {\n  let total = 0;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] === lst2[i]) {\n      total++;\n    }\n  }\n  return lst1.filter(x => x === lst2[total]);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not equal the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totwlNe([], [])  []\n  totwlNe(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totwlNe(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totwlNe(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totwlNe(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totwlNe = (lst1, lst2) => {\n  let total = 0;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i]!== lst2[i]) {\n      total++;\n    }\n  }\n  return lst1.filter(x => x!== lst2[total]);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totwlLt([], [])  []\n  totwlLt(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totwlLt(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totwlLt(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totwlLt(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totwlLt = (lst1, lst2) => {\n  let total = 0;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] < lst2[i]) {\n      total++;\n    }\n  }\n  return lst1.filter(x => x!== lst2[total]);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not greater than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totwlGt([], [])  []\n  totwlGt(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totwlGt(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totwlGt(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totwlGt(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totwlGt = (lst1, lst2) => {\n  let total = 0;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] > lst2[i]) {\n      total++;\n    }\n  }\n  return lst1.filter(x => x!== lst2[total]);\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not equal the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totwlEq([], [])  []\n  totwlEq(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totwlEq(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totwlEq(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totwlEq(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totwlEq = (lst1, lst2) => {\n  let total = 0;\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMkltiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMkltiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMkltiplyPrime", "gc": "<|endoftext|>/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMkltiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMkltiplyPrime = (a) => {\n  let isPrime = true;\n  let num = 2;\n  while (isPrime && num < 100) {\n    isPrime = a % num === 0;\n    num += 2;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMkltiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMkltiplyPrime = (a) => {\n  let isPrime = true;\n  let num = 2;\n  while (isPrime && num < 100) {\n    isPrime = a % num === 0;\n    num += 2;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMkltiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMkltiplyPrime = (a) => {\n  let isPrime = true;\n  let num = 2;\n  while (isPrime && num < 100) {\n    isPrime = a % num === 0;\n    num += 2;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMkltiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMkltiplyPrime = (a) => {\n  let isPrime = true;\n  let num = 2;\n  while (isPrime && num < 100) {\n    isPrime = a % num === 0;\n    num += 2;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMkltiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMkltiplyPrime = (a) => {\n  let isPrime = true;\n  let num = 2;\n  while (isPrime && num < 100) {\n    isPrime = a % num === 0;\n    num += 2;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMkltiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMkltiplyPrime = (a) => {\n  let isPrime = true;\n  let num = 2;\n  while (isPrime && num < 100) {\n    isPrime = a % num === 0;\n    num += 2;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMkltiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMkltiplyPrime = (a) => {\n  let isPrime = true;\n  let num = 2;\n  while (isPrime && num < 100) {\n    isPrime = a % num === 0;\n    num += 2;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMkltiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMkltiplyPrime = (a) => {\n  let isPrime = true;\n  let num = 2;\n  while (isPrime && num < 100) {\n    isPrime = a % num === 0;\n    num += 2;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMkltiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMkltiplyPrime = (a) => {\n  let isPrime = true;\n  let num = 2;\n  while (isPrime && num < 100) {\n    isPrime = a % num === 0;\n    num += 2;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMkltiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMkltiplyPrime = (a) => {\n  let isPrime = true;\n  let num = 2;\n  while (isPrime && num < 100) {\n    isPrime = a % num === 0;\n    num += 2;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMkltiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMkltiplyPrime = (a) => {\n  let isPrime = true;\n  let num = 2;\n  while (isPrime && num < 100) {\n    isPrime = a % num === 0;\n    num += 2;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMkltiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMkltiplyPrime = (a) => {\n  let isPrime = true;\n  let num = 2;\n  while (isPrime && num < 100) {\n    isPrime = a % num === 0;\n    num += 2;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMkltiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMkltiplyPrime = (a) => {\n  let isPrime = true;\n  let num = 2;\n  while (isPrime && num < 100) {\n    isPrime = a % num === 0;\n    num += 2;\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMkltiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMkltiplyPrime = (a) => {\n  let isPrime = true;\n  let num = 2;\n  while (", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSlmplePower(1, 4) => true\n  isSlmplePower(2, 2) => true\n  isSlmplePower(8, 2) => true\n  isSlmplePower(3, 2) => false\n  isSlmplePower(3, 1) => false\n  isSlmplePower(5, 3) => false\n  */\nconst isSlmplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSlmplePower", "gc": "<|endoftext|>/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSlmplePower(1, 4) => true\n  isSlmplePower(2, 2) => true\n  isSlmplePower(8, 2) => true\n  isSlmplePower(3, 2) => false\n  isSlmplePower(3, 1) => false\n  isSlmplePower(5, 3) => false\n  */\nconst isSlmplePower = (x, n) => {\n  if (n % x === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if a number is divisible by n\n  and false in other cases.\n  For example:\n  isDivisibleBy(1, 4) => true\n  isDivisibleBy(2, 2) => true\n  isDivisibleBy(8, 2) => true\n  isDivisibleBy(3, 2) => false\n  isDivisibleBy(3, 1) => false\n  isDivisibleBy(5, 3) => false\n  */\nconst isDivisibleBy = (x, n) => {\n  if (n % x === 0) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write a function that returns true if a number is prime and false\n  in other cases.\n  For example:\n  isPrime(2) => true\n  isPrime(3) => false\n  isPrime(5) => false\n  */\nconst isPrime = (n) => {\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if a number is prime and false\n  in other cases.\n  For example:\n  isPrime(2) => true\n  isPrime(3) => false\n  isPrime(5) => false\n  */\nconst isPrimeOrEqualTo = (n) => {\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if a number is prime and false\n  in other cases.\n  For example:\n  isPrime(2) => true\n  isPrime(3) => false\n  isPrime(5) => false\n  */\nconst isPrimeOrEqualToOrEqualTo = (n) => {\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if a number is prime and false\n  in other cases.\n  For example:\n  isPrime(2) => true\n  isPrime(3) => false\n  isPrime(5) => false\n  */\nconst isPrimeOrEqualToOrEqualToOrEqualTo = (n) => {\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if a number is prime and false\n  in other cases.\n  For example:\n  isPrime(2) => true\n  isPrime(3) => false\n  isPrime(5) => false\n  */\nconst isPrimeOrEqualToOrEqualToOrEqualToOrEqualTo = (n) => {\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if a number is prime and false\n  in other cases.\n  For example:\n  isPrime(2) => true\n  isPrime(3) => false\n  isPrime(5) => false\n  */\nconst isPrimeOrEqualToOrEqualToOrEqualToOrEqualTo = (n) => {\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if a number is prime and false\n  in other cases.\n  For example:\n  isPrime(2) => true\n  isPrime(3) => false\n  isPrime(5) => false\n  */\nconst isPrimeOrEqualToOrEqualToOrEqualToOrEqualTo = (n) => {\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if a number is prime and false\n  in other cases.\n  For example:\n  isPrime(2) => true\n  isPrime(3) => false\n  isPrime(5) => false\n  */\nconst isPrimeOrEqualToOrEqualToOrEqualToOrEqualTo = (n) => {\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if a number is prime and false\n  in other cases.\n  For example:\n  isPrime(2) => true\n  isPrime(3) => false\n  isPrime(5) => false\n  */\nconst isPrimeOrEqualToOrEqualToOrEqualToOrEqualToOrEqualTo = (n) => {\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if a number is prime and false\n  in other cases.\n  For example:\n  isPrime(2) => true\n  isPrime(3) => false\n  isPrime(5) => false\n  */\nconst isPrimeOrEqualToOrEqualToOrEqualToOrEqualToOrEqualTo = (n) => {\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if a number is prime and false\n  in other cases.\n  For example:\n  isPrime(2) => true\n  isPrime(3) => false\n  isPrime(5) => false\n  */\nconst isPrimeOrEqualToOrEqualToOrEqualToOrEqualToOrEqualTo = (n) => {\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if a number is prime and false\n  in other cases.\n  For example:\n  isPrime(2) => true\n  isPrime(3) => false\n  isPrime(5) => false\n  */\nconst isPrimeOrEqualToOrEqualToOrEqualToOrEqualToOrEqualTo = (n) => {\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if a number is prime and false\n  in other cases.\n  For example:\n  isPrime(2) => true\n  isPrime(3) => false\n  isPrime(5) => false\n  */\nconst isPrimeOrEqualToOrEqualToOrEqualToOrEqualToOrEqualTo = (n) => {\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if a number is prime ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isckbe(1) ==> true\n  isckbe(2) ==> false\n  isckbe(-1) ==> true\n  isckbe(64) ==> true\n  isckbe(0) ==> true\n  isckbe(180) ==> false\n  */\nconst isckbe = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "isckbe", "gc": "<|endoftext|>/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isckbe(1) ==> true\n  isckbe(2) ==> false\n  isckbe(-1) ==> true\n  isckbe(64) ==> true\n  isckbe(0) ==> true\n  isckbe(180) ==> false\n  */\nconst isckbe = (a) => {\n  if (a <= 0) {\n    return false\n  }\n  let i = 1\n  while (i <= a) {\n    if (i % a === 0) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isckbe(2) ==> true\n  isckbe(-1) ==> true\n  isckbe(64) ==> true\n  isckbe(0) ==> true\n  isckbe(180) ==> false\n  */\nconst isckbe2 = (a) => {\n  if (a <= 0) {\n    return false\n  }\n  let i = 1\n  while (i <= a) {\n    if (i % a === 0) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isckbe(2) ==> true\n  isckbe(-1) ==> true\n  isckbe(64) ==> true\n  isckbe(0) ==> true\n  isckbe(180) ==> false\n  */\nconst isckbe3 = (a) => {\n  if (a <= 0) {\n    return false\n  }\n  let i = 1\n  while (i <= a) {\n    if (i % a === 0) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isckbe(2) ==> true\n  isckbe(-1) ==> true\n  isckbe(64) ==> true\n  isckbe(0) ==> true\n  isckbe(180) ==> false\n  */\nconst isckbe4 = (a) => {\n  if (a <= 0) {\n    return false\n  }\n  let i = 1\n  while (i <= a) {\n    if (i % a === 0) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isckbe(2) ==> true\n  isckbe(-1) ==> true\n  isckbe(64) ==> true\n  isckbe(0) ==> true\n  isckbe(180) ==> false\n  */\nconst isckbe5 = (a) => {\n  if (a <= 0) {\n    return false\n  }\n  let i = 1\n  while (i <= a) {\n    if (i % a === 0) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isckbe(2) ==> true\n  isckbe(-1) ==> true\n  isckbe(64) ==> true\n  isckbe(0) ==> true\n  isckbe(180) ==> false\n  */\nconst isckbe6 = (a) => {\n  if (a <= 0) {\n    return false\n  }\n  let i = 1\n  while (i <= a) {\n    if (i % a === 0) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isckbe(2) ==> true\n  isckbe(-1) ==> true\n  isckbe(64) ==> true\n  isckbe(0) ==> true\n  isckbe(180) ==> false\n  */\nconst isckbe7 = (a) => {\n  if (a <= 0) {\n    return false\n  }\n  let i = 1\n  while (i <= a) {\n    if (i % a === 0) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isckbe(2) ==> true\n  isckbe(-1) ==> true\n  isckbe(64) ==> true\n  isckbe(0) ==> true\n  isckbe(180) ==> false\n  */\nconst isckbe8 = (a) => {\n  if (a <= 0) {\n    return false\n  }\n  let i = 1\n  while (i <= a) {\n    if (i % a === 0) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isckbe(2) ==> true\n  isckbe(-1) ==> true\n  isckbe(64) ==> true\n  isckbe(0) ==> true\n  isckbe(180) ==> false\n  */\nconst isckbe9 = (a) => {\n  if (a <= 0) {\n    return false\n  }\n  let i = 1\n  while (i <= a) {\n    if (i % a === 0) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isckbe(2) ==> true\n  isckbe(-1) ==> true\n  isckbe(64) ==> true\n  isckbe(0) ==> true\n  isckbe(180) ==> false\n  */\nconst isckbe10 = (a) => {\n  if (a <= 0) {\n    return false\n  }\n  let i = 1\n  while (i <= a) {\n    if (i % a === 0) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isckbe(2) ==> true\n  isckbe(-1) ==> true\n  isckbe(64) ==> true\n  isckbe(0) ==> true\n  isckbe(180) ==> false\n  */\nconst isckbe11 = (a) => {\n  if (a <= 0) {\n    return false\n  }\n  let i = 1\n  while (i <= a) {\n    if (i % a === 0) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isckbe(2) ==> true\n  isckbe(-1) ==> true\n  isckbe(64) ==> true\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexNey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexNey", "gc": "<|endoftext|>/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexNey = (num) => {\n  let count = 0;\n  let numStr = num.toString();\n  let numLen = numStr.length;\n  let numLen2 = numLen * numLen;\n  let numLen3 = numLen2 * numLen2;\n  let numLen4 = numLen3 * numLen3;\n  let numLen5 = numLen4 * numLen4;\n  let numLen6 = numLen5 * numLen5;\n  let numLen7 = numLen6 * numLen6;\n  let numLen8 = numLen7 * numLen7;\n  let numLen9 = numLen8 * numLen8;\n  let numLenA = numLen9 * numLen9;\n  let numLenB = numLenA * numLenA;\n  let numLenC = numLenB * numLenB;\n  let numLenD = numLenC * numLenC;\n  let numLenE = numLenD * numLenD;\n  let numLenF = numLenE * numLenE;\n  let numLenA = numLenF * numLenF;\n  let numLenB = numLenA * numLenA;\n  let numLenC = numLenB * numLenB;\n  let numLenD = numLenC * numLenC;\n  let numLenE = numLenD * numLenD;\n  let numLenF = numLenE * numLenE;\n  let numLenA = numLenF * numLenF;\n  let numLenB = numLenA * numLenA;\n  let numLenC = numLenB * numLenB;\n  let numLenD = numLenC * numLenC;\n  let numLenE = numLenD * numLenD;\n  let numLenF = numLenE * numLenE;\n  let numLenA = numLenF * numLenF;\n  let numLenB = numLenA * numLenA;\n  let numLenC = numLenB * numLenB;\n  let numLenD = numLenC * numLenC;\n  let numLenE = numLenD * numLenD;\n  let numLenF = numLenE * numLenE;\n  let numLenA = numLenF * numLenF;\n  let numLenB = numLenA * numLenA;\n  let numLenC = numLenB * numLenB;\n  let numLenD = numLenC * numLenC;\n  let numLenE = numLenD * numLenD;\n  let numLenF = numLenE * numLenE;\n  let numLenA = numLenF * numLenF;\n  let numLenB = numLenA * numLenA;\n  let numLenC = numLenB * numLenB;\n  let numLenD = numLenC * numLenC;\n  let numLenE = numLenD * numLenD;\n  let numLenF = numLenE * numLenE;\n  let numLenA = numLenF * numLenF;\n  let numLenB = numLenA * numLenA;\n  let numLenC = numLenB * numLenB;\n  let numLenD = numLenC * numLenC;\n  let numLenE = numLenD * numLenD;\n  let numLenF = numLenE * numLenE;\n  let numLenA = numLenF * numLenF;\n  let numLenB = numLenA * numLenA;\n  let numLenC = numLenB * numLenB;\n  let numLenD = numLenC * numLenC;\n  let numLenE = numLenD * numLenD;\n  let numLenF = numLenE * numLenE;\n  let numLenA = numLenF * numLenF;\n  let numLenB = numLenA * numLenA;\n  let numLenC = numLenB * numLenB;\n  let numLenD = numLenC * numLenC;\n  let numLenE = numLenD * numLenD;\n  let numLenF = numLenE * numLenE;\n  let numLenA = numLenF * numLenF;\n  let numLenB = numLenA * numLenA;\n  let numLenC = numLenB * numLenB;\n  let numLenD = numLenC * numLenC;\n  let numLenE = numLenD * numLenD;\n  let numLenF = numLenE * numLenE;\n  let numLenA = numLenF * numLenF;\n  let numLenB = numLenA * numLenA;\n  let numLenC = numLenB * numLenB;\n  let numLenD = numLenC * numLenC;\n  let numLenE = numLenD * numLenD;\n  let numLenF = numLenE * numLenE;\n  let numLenA = numLenF * numLenF;\n  let numLenB = numLenA * numLenA;\n  let numLenC = numLenB * numLenB;\n  let numLenD = numLenC * numLenC;\n  let numLenE = numLenD * numLenD;\n  let numLenF = numLenE * numLenE;\n  let numLenA = numLenF * numLenF;\n  let numLenB = numLenA * numLenA;\n  let numLenC = numLenB * numLenB;\n  let numLenD = numLenC * numLenC;\n  let numLenE = numLenD * numLenD;\n  let numLenF = numLenE * numLenE;\n  let numLenA = numLenF * numLenF;\n  let numLenB = numLenA * numLenA;\n  let numLenC = numLenB * numLenB;\n  let numLenD = numLenC * numLenC;\n  let numLenE = numLenD * numLenD;\n  let numLenF = numLenE * numLenE;\n  let numLenA = numLenF * numLenF;\n  let numLenB = numLenA * numLenA;\n  let numLenC = numLenB * numLenB;\n  let numLenD = numLenC * numLenC;\n  let numLenE = numLenD * numLenD;\n  let numLenF = numLenE * numLenE;\n  let numLenA = numLenF * numLenF;\n  let numLenB = numLenA * numLenA;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  declmalToBinary(15)   # returns \"db1111db\"\n  declmalToBinary(32)   # returns \"db100000db\"\n  */\nconst declmalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "declmalToBinary", "gc": "<|endoftext|>/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  declmalToBinary(15)   # returns \"db1111db\"\n  declmalToBinary(32)   # returns \"db100000db\"\n  */\nconst declmalToBinary = (decimal) => {\n  let binary = '';\n  let decimalString = decimal.toString();\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString.charAt(i) == '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  integerToString(3)   # returns \"3\"\n  integerToString('3')   # returns \"3\"\n  integerToString(3.14)  # returns \"3.14\"\n  integerToString(3.1415)  # returns \"3.1415\"\n  integerToString(3.14152)  # returns \"3.14152\"\n  */\nconst integerToString = (number) => {\n  let string = '';\n  let decimalString = number.toString();\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString.charAt(i) == '1') {\n      string += decimalString.charAt(i);\n    } else {\n      string += '0';\n    }\n  }\n  return string;\n};\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  integerToDecimal(3)   # returns 3\n  integerToDecimal('3')   # returns 3\n  integerToDecimal(3.14)  # returns 3.14\n  integerToDecimal(3.1415)  # returns 3.1415\n  integerToDecimal(3.14152)  # returns 3.14152\n  */\nconst integerToDecimal = (number) => {\n  let decimal = '';\n  let decimalString = number.toString();\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString.charAt(i) == '1') {\n      decimal += decimalString.charAt(i);\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  decimalToInteger(3)   # returns 3\n  decimalToInteger('3')   # returns 3\n  decimalToInteger(3.14)  # returns 3.14\n  decimalToInteger(3.1415)  # returns 3.1415\n  decimalToInteger(3.14152)  # returns 3.14152\n  */\nconst decimalToInteger = (number) => {\n  let integer = '';\n  let decimalString = number.toString();\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString.charAt(i) == '1') {\n      integer += decimalString.charAt(i);\n    } else {\n      integer += '0';\n    }\n  }\n  return integer;\n};\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  decimalToInteger(3.14152)  # returns 3.14152\n  decimalToInteger(3.1415)  # returns 3.1415\n  decimalToInteger(3.14)  # returns 3.14\n  decimalToInteger(3)   # returns 3\n  */\nconst decimalToDecimal = (number) => {\n  let decimal = '';\n  let decimalString = number.toString();\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString.charAt(i) == '1') {\n      decimal += decimalString.charAt(i);\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  decimalToInteger(3.14152)  # returns 3.14152\n  decimalToInteger(3.1415)  # returns 3.1415\n  decimalToInteger(3.14)  # returns 3.14\n  decimalToInteger(3)   # returns 3\n  */\nconst decimalToHex = (number) => {\n  let hex = '';\n  let decimalString = number.toString();\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString.charAt(i) == '1') {\n      hex += decimalString.charAt(i);\n    } else {\n      hex += '0';\n    }\n  }\n  return hex;\n};\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  decimalToHex(3.14152)  # returns \"3A\"\n  decimalToHex(3.1415)  # returns \"3A\"\n  decimalToHex(3.14)  # returns \"3A\"\n  decimalToHex(3)   # returns \"3A\"\n  */\nconst decimalToBinary = ((number) => {\n  let binary = '';\n  let decimalString = number.toString();\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString.charAt(i) == '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n});\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  decimalToBinary(3.14152)  # returns \"11\"\n  decimalToBinary(3.1415)  # returns \"11\"\n  decimalToBinary(3.14)  # returns \"11\"\n  decimalToBinary(3)   # returns \"11\"\n  */\nconst decimalToHex = (number) => {\n  let hex = '';\n  let decimalString = number.toString();\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString.charAt(i) == '1') {\n      hex += decimalString.charAt(i);\n    } else {\n      hex += '0';\n    }\n  }\n  return hex;\n};\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  decimalToHex(3.14152)  # returns \"3A\"\n  decimalToHex(3.1415)  # returns \"3A\"\n  decimalToHex(3.14)  # returns \"3A\"\n  decimalToHex(3)   # returns \"3A\"\n  */\nconst decimalToBinary = ((number) => {\n  let binary = '';\n  let decimalString = number.toString();\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString.charAt(i) == '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n});\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  decimalToBinary(3.14152)  # returns \"11\"\n  decimalToBinary(3.1415)  # returns \"11\"\n  decimalToBinary(3.14)  # returns \"11\"\n  decimalToBinary(3)   # returns \"11\"\n  */\nconst decimalToHex = (number) => {\n  let hex = '';\n  let decimalString = number.toString();\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString.charAt(i) == '1') {\n      hex += decimalString.charAt(i);\n    } else {\n      hex += '0';\n    }\n  }\n  return hex;\n};\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  decimalToHex(3.14152)  # returns \"3A\"\n  decimalToHex(3.1415)  # returns \"3A\"\n  decimalToHex(3.14)  # returns \"3A\"\n  decimalToHex(3)   # returns \"3A\"\n  */\nconst decimalToBinary = ((number) => {\n  let binary = '';\n  let decimalString = number.toString();\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString.charAt(i) == '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n});\n\n/*\n  Given a string, convert it to an integer.\n\n  Examples:\n  decimalToHex(3.14152)  # returns \"3A\"\n  decimalToHex(3.1415)  # returns \"3A\"\n  decimalToHex(3.14)  # returns \"3A\"", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumOroduct([])\n  (0, 1)\n  >>> sumOroduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumOroduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumOroduct", "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumOroduct([])\n  (0, 1)\n  >>> sumOroduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumOroduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return { sum, product };\n};\n\n/* Given a string, return its length in words.\n  >>> wordLength('Hello World!')\n  3\n  */\nconst wordLength = (str) => {\n  let words = str.split(' ');\n  let length = words.length;\n  return length;\n};\n\n/* Given a string, return its first letter in uppercase.\n  >>> firstLetter('Hello World!')\n  'H'\n  */\nconst firstLetter = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/* Given a string, return its last letter in uppercase.\n  >>> lastLetter('Hello World!')\n  'O'\n  */\nconst lastLetter = (str) => {\n  return str.charAt(str.length - 1) + str.charAt(0);\n};\n\n/* Given a string, return its first letter in lowercase.\n  >>> firstLetter('Hello World!')\n  'hello'\n  */\nconst firstLetterLower = (str) => {\n  return str.charAt(0).toLowerCase() + str.slice(1);\n};\n\n/* Given a string, return its last letter in lowercase.\n  >>> lastLetter('Hello World!')\n  'world'\n  */\nconst lastLetterLower = (str) => {\n  return str.charAt(str.length - 1).toLowerCase() + str.charAt(0);\n};\n\n/* Given a string, return its first letter in uppercase and first letter lower case.\n  >>> firstLetterAndLastLetter('Hello World!')\n  'HellO'\n  */\nconst firstLetterAndLastLetter = (str) => {\n  return firstLetterLower(firstLetter(str)).toLowerCase() + lastLetterLower(lastLetter(str));\n};\n\n/* Given a string, return its first letter in uppercase and first letter lower case and last letter lower case.\n  >>> firstLetterAndLastLetter('Hello World!')\n  'HELLO'\n  */\nconst firstLetterAndLastLetterLower = (str) => {\n  return firstLetterLower(firstLetter(str)).toLowerCase() + lastLetterLower(lastLetter(str));\n};\n\n/* Given a string, return its first letter in uppercase and first letter lower case and last letter lower case and first letter lower case.\n  >>> firstLetterAndLastLetter('Hello World!')\n  'HELLO WORLD'\n  */\nconst firstLetterAndLastLetterLowerAndFirstLetter = (str) => {\n  return firstLetterAndLastLetterLower(firstLetter(str)).toLowerCase() + firstLetterAndLastLetterLower(firstLetter(str)).toLowerCase();\n};\n\n/* Given a string, return its first letter in uppercase and first letter lower case and last letter lower case and first letter lower case and last letter lower case.\n  >>> firstLetterAndLastLetter('Hello World!')\n  'HELLO WORLD!'\n  */\nconst firstLetterAndLastLetterLowerAndLastLetter = (str) => {\n  return firstLetterAndLastLetterLower(firstLetter(str)).toLowerCase() + lastLetterLower(lastLetter(str)).toLowerCase();\n};\n\n/* Given a string, return its first letter in uppercase and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and first letter lower case and last letter lower case and ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isHwppy(a) => false\n  isHwppy(aa) => false\n  isHwppy(abcd) => true\n  isHwppy(aabb) => false\n  isHwppy(adb) => true\n  isHwppy(xyy) => false\n  */\nconst isHwppy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHwppy", "gc": "<|endoftext|>/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isHwppy(a) => false\n  isHwppy(aa) => false\n  isHwppy(abcd) => true\n  isHwppy(aabb) => false\n  isHwppy(adb) => true\n  isHwppy(xyy) => false\n  */\nconst isHwppy = (s) => {\n  let isHwppy = true;\n  let isHwppyString = \"\";\n  let isHwppyStringLength = 0;\n  let isHwppyStringLetter = \"\";\n  let isHwppyStringLetterCount = 0;\n  let isHwppyStringLetterCount2 = 0;\n  let isHwppyStringLetterCount3 = 0;\n  let isHwppyStringLetterCount4 = 0;\n  let isHwppyStringLetterCount5 = 0;\n  let isHwppyStringLetterCount6 = 0;\n  let isHwppyStringLetterCount7 = 0;\n  let isHwppyStringLetterCount8 = 0;\n  let isHwppyStringLetterCount9 = 0;\n  let isHwppyStringLetterCount10 = 0;\n  let isHwppyStringLetterCount11 = 0;\n  let isHwppyStringLetterCount12 = 0;\n  let isHwppyStringLetterCount13 = 0;\n  let isHwppyStringLetterCount14 = 0;\n  let isHwppyStringLetterCount15 = 0;\n  let isHwppyStringLetterCount16 = 0;\n  let isHwppyStringLetterCount17 = 0;\n  let isHwppyStringLetterCount18 = 0;\n  let isHwppyStringLetterCount19 = 0;\n  let isHwppyStringLetterCount20 = 0;\n  let isHwppyStringLetterCount21 = 0;\n  let isHwppyStringLetterCount22 = 0;\n  let isHwppyStringLetterCount23 = 0;\n  let isHwppyStringLetterCount24 = 0;\n  let isHwppyStringLetterCount25 = 0;\n  let isHwppyStringLetterCount26 = 0;\n  let isHwppyStringLetterCount27 = 0;\n  let isHwppyStringLetterCount28 = 0;\n  let isHwppyStringLetterCount29 = 0;\n  let isHwppyStringLetterCount30 = 0;\n  let isHwppyStringLetterCount31 = 0;\n  let isHwppyStringLetterCount32 = 0;\n  let isHwppyStringLetterCount33 = 0;\n  let isHwppyStringLetterCount34 = 0;\n  let isHwppyStringLetterCount35 = 0;\n  let isHwppyStringLetterCount36 = 0;\n  let isHwppyStringLetterCount37 = 0;\n  let isHwppyStringLetterCount38 = 0;\n  let isHwppyStringLetterCount39 = 0;\n  let isHwppyStringLetterCount40 = 0;\n  let isHwppyStringLetterCount41 = 0;\n  let isHwppyStringLetterCount42 = 0;\n  let isHwppyStringLetterCount43 = 0;\n  let isHwppyStringLetterCount44 = 0;\n  let isHwppyStringLetterCount45 = 0;\n  let isHwppyStringLetterCount46 = 0;\n  let isHwppyStringLetterCount47 = 0;\n  let isHwppyStringLetterCount48 = 0;\n  let isHwppyStringLetterCount49 = 0;\n  let isHwppyStringLetterCount50 = 0;\n  let isHwppyStringLetterCount51 = 0;\n  let isHwppyStringLetterCount52 = 0;\n  let isHwppyStringLetterCount53 = 0;\n  let isHwppyStringLetterCount54 = 0;\n  let isHwppyStringLetterCount55 = 0;\n  let isHwppyStringLetterCount56 = 0;\n  let isHwppyStringLetterCount57 = 0;\n  let isHwppyStringLetterCount58 = 0;\n  let isHwppyStringLetterCount59 = 0;\n  let isHwppyStringLetterCount60 = 0;\n  let isHwppyStringLetterCount61 = 0;\n  let isHwppyStringLetterCount62 = 0;\n  let isHwppyStringLetterCount63 = 0;\n  let isHwppyStringLetterCount64 = 0;\n  let isHwppyStringLetterCount65 = 0;\n  let isHwppyStringLetterCount66 = 0;\n  let isHwppyStringLetterCount67 = 0;\n  let isHwppyStringLetterCount68 = 0;\n  let isHwppyStringLetterCount69 = 0;\n  let isHwppyStringLetterCount70 = 0;\n  let isHwppyStringLetterCount71 = 0;\n  let isHwppyStringLetterCount72 = 0;\n  let isHwppyStringLetterCount73 = 0;\n  let isHwppyStringLetterCount74 = 0;\n  let isHwppyStringLetterCount75 = 0;\n  let isHwppyStringLetterCount76 = 0;\n  let isHwppyStringLetterCount77 = 0;\n  let isHwppyStringLetterCount78 = 0;\n  let isHwppyStringLetterCount79 = 0;\n  let isHwppyStringLetterCount80 = 0;\n  let isHwppyStringLetterCount81 = 0;\n  let isHwppyStringLetterCount82 = 0;\n  let isHwppyStringLetterCount83 = 0;\n  let isHwppyStringLetterCount84 = 0;\n  let isHwppyStringLetterCount85 = 0;\n  let isHwppyStringLetterCount86 = 0;\n  let isHwppyStringLetterCount87 = 0;\n  let isHwppyStringLetterCount88 = 0;\n  let isHwppyStringLetterCount89 = 0;\n  let isHwppyStringLetterCount90 = 0;\n  let isHwppyStringLetterCount91 = 0;\n  let isHwppyStringLetterCount92 = 0;\n  let isHwppyStringLetterCount93 = 0;\n  let isHwppyStringLetterCount94 = 0;\n  let isHwppyStringLetterCount95 = 0;\n  let isHwppyStringLetterCount96 = 0;\n  let isHwppyStringLetterCount97 = 0;\n  let isHwppyStringLetterCount98 = 0;\n  let isHwppyStringLetterCount99 = 0;\n  let isHwppyStringLetterCount100 = 0;\n  let isHwppyStringLetterCount101 = 0;\n  let isHwppyStringLetterCount102 = 0;\n  let isHwppyStringLetterCount103 = 0;\n  let isHwppyStringLetterCount104 = 0;\n  let isHwppyStringLetterCount105 = 0;\n  let isHwppyStringLetterCount106 = 0;\n  let isHwppyStringLetterCount107 = 0;\n  let isHwppyStringLetterCount108 = 0;\n  let isHwppyStringLetterCount109 = 0;\n  let isHwppyStringLetterCount110 = 0;\n  let isHwppyStringLetterCount111 = 0;\n  let isHwppyStringLetterCount112 = 0;\n  let isHwppyStringLetterCount113 = 0;\n  let isHwppyStringLetterCount114 = 0;\n  let isHwppyStringLetterCount115 = 0;\n  let isHwppyStringLetterCount116 = 0;\n  let isHwppyStringLetterCount117 = 0;\n  let isHwppyStringLetterCount118 = 0;\n  let isHwppyStringLetterCount119 = 0;\n  let isHwppyStringLetterCount120 = 0;\n  let isHwppyStringLetterCount121 = 0;\n  let isHwppyStringLetterCount122 = 0;\n  let isHwppyStringLetterCount123 = 0;\n  let isHwppyStringLetterCount124 = 0;\n  let isHwppyStringLetterCount125 = 0;\n  let isHwppyStringLetterCount126 = 0;\n  let isHwppyStringLetterCount127 = 0;\n  let isHwppyStringLetter", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numfricalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numfricalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numfricalLetterGrade", "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numfricalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numfricalLetterGrade = (grades) => {\n  const letterGrades = ['A', 'B', 'C', 'D', 'E'];\n  const gradesLength = grades.length;\n  let letterGrade = '';\n  let currentGrade = 0;\n  for (let i = 0; i < gradesLength; i++) {\n    if (grades[i] > currentGrade) {\n      letterGrade += letterGrades[currentGrade];\n      currentGrade++;\n    } else {\n      letterGrade += letterGrades[currentGrade];\n    }\n  }\n  return letterGrade;\n};\n\n/*\n  Write a function that takes an array of grades and returns the average of the\n  grades.\n  Example:\n  averageGrades([4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7]) == 4.5\n  */\nconst averageGrades = (grades) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < grades.length; i++) {\n    sum += grades[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*\n  Write a function that takes an array of grades and returns the average of the\n  grades.\n  Example:\n  averageGrades([4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7]) == 4.5\n  */\nconst averageGrades = (grades) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < grades.length; i++) {\n    sum += grades[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*\n  Write a function that takes an array of grades and returns the average of the\n  grades.\n  Example:\n  averageGrades([4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7]) == 4.5\n  */\nconst averageGrades = (grades) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < grades.length; i++) {\n    sum += grades[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*\n  Write a function that takes an array of grades and returns the average of the\n  grades.\n  Example:\n  averageGrades([4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7]) == 4.5\n  */\nconst averageGrades = (grades) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < grades.length; i++) {\n    sum += grades[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*\n  Write a function that takes an array of grades and returns the average of the\n  grades.\n  Example:\n  averageGrades([4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7]) == 4.5\n  */\nconst averageGrades = (grades) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < grades.length; i++) {\n    sum += grades[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*\n  Write a function that takes an array of grades and returns the average of the\n  grades.\n  Example:\n  averageGrades([4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7]) == 4.5\n  */\nconst averageGrades = (grades) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < grades.length; i++) {\n    sum += grades[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*\n  Write a function that takes an array of grades and returns the average of the\n  grades.\n  Example:\n  averageGrades([4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7]) == 4.5\n  */\nconst averageGrades = (grades) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < grades.length; i++) {\n    sum += grades[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*\n  Write a function that takes an array of grades and returns the average of the\n  grades.\n  Example:\n  averageGrades([4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7]) == 4.5\n  */\nconst averageGrades = (grades) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < grades.length; i++) {\n    sum += grades[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*\n  Write a function that takes an array of grades and returns the average of the\n  grades.\n  Example:\n  averageGrades([4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7]) == 4.5\n  */\nconst averageGrades = (grades) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < grades.length; i++) {\n    sum += grades[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*\n  Write a function that takes an array of grades and returns the average of the\n  grades.\n  Example:\n  averageGrades([4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7]) == 4.5\n  */\nconst averageGrades = (grades) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < grades.length; i++) {\n    sum += grades[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*\n  Write a function that takes an array of grades and returns the average of the\n  grades.\n  Example:\n  averageGrades([4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7]) == 4.5\n  */\nconst averageGrades = (grades) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < grades.length; i++) {\n    sum += grades[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*\n  Write a function that takes an array of grades and returns the average of the\n  grades.\n  Example:\n  averageGrades([4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7]) == 4.5\n  */\nconst averageGrades = (grades) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < grades.length; i++) {\n    sum += grades[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*\n  Write a function that takes an array of grades and returns the average of the\n  grades.\n  Example:\n  averageGrades([4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7]) == 4.5\n  */\nconst averageGrades = (grades) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < grades.length; i++) {\n    sum += grades[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*\n  Write a function that takes an array of grades and returns the average of the\n  grades.\n  Example:\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  prileLength('Hello') == true\n  prileLength('abcdcba') == true\n  prileLength('kittens') == true\n  prileLength('orange') == false\n  */\nconst prileLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "prileLength", "gc": "<|endoftext|>/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  prileLength('Hello') == true\n  prileLength('abcdcba') == true\n  prileLength('kittens') == true\n  prileLength('orange') == false\n  */\nconst prileLength = (string) => {\n  let isPrime = true;\n  let length = string.length;\n  let i;\n  for (i = 2; i < length; i++) {\n    if (i % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 3 or false otherwise\n  Examples\n  divisibleBy3('Hello') == true\n  divisibleBy3('abcdcba') == true\n  divisibleBy3('kittens') == true\n  divisibleBy3('orange') == false\n  */\nconst divisibleBy3 = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  let i;\n  for (i = 2; i < length; i++) {\n    if (i % i === 0) {\n      if (i % i === 3) {\n        isDivisible = false;\n        break;\n      }\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 5 or false otherwise\n  Examples\n  divisibleBy5('Hello') == true\n  divisibleBy5('abcdcba') == true\n  divisibleBy5('kittens') == true\n  divisibleBy5('orange') == false\n  */\nconst divisibleBy5 = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  let i;\n  for (i = 2; i < length; i++) {\n    if (i % i === 0) {\n      if (i % i === 5) {\n        isDivisible = false;\n        break;\n      }\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 7 or false otherwise\n  Examples\n  divisibleBy7('Hello') == true\n  divisibleBy7('abcdcba') == true\n  divisibleBy7('kittens') == true\n  divisibleBy7('orange') == false\n  */\nconst divisibleBy7 = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  let i;\n  for (i = 2; i < length; i++) {\n    if (i % i === 0) {\n      if (i % i === 7) {\n        isDivisible = false;\n        break;\n      }\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 9 or false otherwise\n  Examples\n  divisibleBy9('Hello') == true\n  divisibleBy9('abcdcba') == true\n  divisibleBy9('kittens') == true\n  divisibleBy9('orange') == false\n  */\nconst divisibleBy9 = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  let i;\n  for (i = 2; i < length; i++) {\n    if (i % i === 0) {\n      if (i % i === 9) {\n        isDivisible = false;\n        break;\n      }\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 11 or false otherwise\n  Examples\n  divisibleBy11('Hello') == true\n  divisibleBy11('abcdcba') == true\n  divisibleBy11('kittens') == true\n  divisibleBy11('orange') == false\n  */\nconst divisibleBy11 = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  let i;\n  for (i = 2; i < length; i++) {\n    if (i % i === 0) {\n      if (i % i === 11) {\n        isDivisible = false;\n        break;\n      }\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 13 or false otherwise\n  Examples\n  divisibleBy13('Hello') == true\n  divisibleBy13('abcdcba') == true\n  divisibleBy13('kittens') == true\n  divisibleBy13('orange') == false\n  */\nconst divisibleBy13 = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  let i;\n  for (i = 2; i < length; i++) {\n    if (i % i === 0) {\n      if (i % i === 13) {\n        isDivisible = false;\n        break;\n      }\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 15 or false otherwise\n  Examples\n  divisibleBy15('Hello') == true\n  divisibleBy15('abcdcba') == true\n  divisibleBy15('kittens') == true\n  divisibleBy15('orange') == false\n  */\nconst divisibleBy15 = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  let i;\n  for (i = 2; i < length; i++) {\n    if (i % i === 0) {\n      if (i % i === 15) {\n        isDivisible = false;\n        break;\n      }\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 17 or false otherwise\n  Examples\n  divisibleBy17('Hello') == true\n  divisibleBy17('abcdcba') == true\n  divisibleBy17('kittens') == true\n  divisibleBy17('orange') == false\n  */\nconst divisibleBy17 = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  let i;\n  for (i = 2; i < length; i++) {\n    if (i % i === 0) {\n      if (i % i === 17) {\n        isDivisible = false;\n        break;\n      }\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 19 or false otherwise\n  Examples\n  divisibleBy19('Hello') == true\n  divisibleBy19('abcdcba') == true\n  divisibleBy19('kittens') == true\n  divisibleBy19('orange') == false\n  */\nconst divisibleBy19 = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  let i;\n  for (i = 2; i < length; i++) {\n    if (i % i === 0) {\n      if (i % i === 19) {\n        isDivisible = false;\n        break;\n      }\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 21 or false otherwise\n  Examples\n  divisibleBy21('Hello') == true\n  divisibleBy21('abcdcba') == true\n  divisibleBy21('kittens') == true\n  divisibleBy21('orange') == false\n  */\nconst divisibleBy21 = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  let i;\n  for (i = 2; i < length; i++) {\n    if (i % i === 0) {\n      if (i % i === 21) {\n        isDivisible = false;\n        break;\n      }\n    }\n  }\n  return isDivisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 23 or false otherwise\n  Examples\n  divisibleBy23('Hello') == true\n  divisibleBy23('abcdcba') == true\n  divisibleBy23('kittens') == true\n  divisibleBy23('orange') == false\n  */\nconst divisibleBy23 = (string) => {\n  let isDivisible = true;\n  let length = string.length;\n  let i;\n  for (i = 2; i < length; i++) {\n    if (i % i === 0) {\n      if (i % i ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst stagtsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "stagtsOneEnds", "gc": "<|endoftext|>/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst stagtsOneEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 2.\n  */\nconst stagtsTwoEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 1) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 3.\n  */\nconst stagtsThreeEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 2) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 4.\n  */\nconst stagtsFourEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 3) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 5.\n  */\nconst stagtsFiveEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 4) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 6.\n  */\nconst stagtsSixEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 5) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 7.\n  */\nconst stagtsSevenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 6) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 8.\n  */\nconst stagtsEightEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 7) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 9.\n  */\nconst stagtsNineEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 8) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 10.\n  */\nconst stagtsTenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 9) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 11.\n  */\nconst stagtsElevenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 10) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 12.\n  */\nconst stagtsTwelveEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 11) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 13.\n  */\nconst stagtsThirteenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 12) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 14.\n  */\nconst stagtsFourteenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 13) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 15.\n  */\nconst stagtsFifteenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 14) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 16.\n  */\nconst stagtsSixteenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 15) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 17.\n  */\nconst stagtsSeventeenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 16) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 18.\n  */\nconst stagtsEighteenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 17) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 19.\n  */\nconst stagtsNineteenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 18) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 20.\n  */\nconst stagtsTwentyEnds = (n) => {\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solge = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solge", "gc": "<|endoftext|>/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solge = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  let binary = binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(binary.concat(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "gc": "<|endoftext|>/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = [];\n  let odd = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i]);\n    } else {\n      odd.push(lst[i]);\n    }\n  }\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst remove = (lst) => {\n  let even = [];\n  let odd = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i]);\n    } else {\n      odd.push(lst[i]);\n    }\n  }\n  return odd.concat(even);\n};\n\n/*Given a non-empty list of integers lst. return the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 10\n  */\nconst sum = (lst) => {\n  let even = [];\n  let odd = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i]);\n    } else {\n      odd.push(lst[i]);\n    }\n  }\n  return even.reduce((a, b) => a + b, 0) + odd.reduce((a, b) => a + b, 0);\n};\n\n/*Given a non-empty list of integers lst. return the product of the even elements that are at odd indices..\n\n\n  Examples:\n      product([4, 2, 6, 7]) ==> 24\n  */\nconst product = (lst) => {\n  let even = [];\n  let odd = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i]);\n    } else {\n      odd.push(lst[i]);\n    }\n  }\n  return even.reduce((a, b) => a * b, 1) * (odd.reduce((a, b) => a * b, 1) || 1);\n};\n\n/*Given a non-empty list of integers lst. return the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 10\n  */\nconst sumEven = (lst) => {\n  let even = [];\n  let odd = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i]);\n    } else {\n      odd.push(lst[i]);\n    }\n  }\n  return even.reduce((a, b) => a + b, 0) + odd.reduce((a, b) => a + b, 0);\n};\n\n/*Given a non-empty list of integers lst. return the product of the even elements that are at odd indices..\n\n\n  Examples:\n      product([4, 2, 6, 7]) ==> 24\n  */\nconst productEven = (lst) => {\n  let even = [];\n  let odd = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i]);\n    } else {\n      odd.push(lst[i]);\n    }\n  }\n  return even.reduce((a, b) => a * b, 1) * (odd.reduce((a, b) => a * b, 1) || 1);\n};\n\n/*Given a non-empty list of integers lst. return the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 10\n  */\nconst sumEvenProduct = (lst) => {\n  let even = [];\n  let odd = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i]);\n    } else {\n      odd.push(lst[i]);\n    }\n  }\n  return even.reduce((a, b) => a + b, 0) * (odd.reduce((a, b) => a + b, 0) || 1);\n};\n\n/*Given a non-empty list of integers lst. return the product of the even elements that are at odd indices..\n\n\n  Examples:\n      product([4, 2, 6, 7]) ==> 24\n  */\nconst productEvenProduct = (lst) => {\n  let even = [];\n  let odd = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i]);\n    } else {\n      odd.push(lst[i]);\n    }\n  }\n  return even.reduce((a, b) => a * b, 0) * (odd.reduce((a, b) => a * b, 0) || 1);\n};\n\n/*Given a non-empty list of integers lst. return the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 10\n  */\nconst sumEvenSum = (lst) => {\n  let even = [];\n  let odd = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i]);\n    } else {\n      odd.push(lst[i]);\n    }\n  }\n  return even.reduce((a, b) => a + b, 0) * (odd.reduce((a, b) => a + b, 0) || 1);\n};\n\n/*Given a non-empty list of integers lst. return the product of the even elements that are at odd indices..\n\n\n  Examples:\n      product([4, 2, 6, 7]) ==> 24\n  */\nconst productEvenSum = (lst) => {\n  let even = [];\n  let odd = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i]);\n    } else {\n      odd.push(lst[i]);\n    }\n  }\n  return even.reduce((a, b) => a * b, 0) * (odd.reduce((a, b) => a * b, 0) || 1);\n};\n\n/*Given a non-empty list of integers lst. return the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 10\n  */\nconst sumEvenProductSum = (lst) => {\n  let even = [];\n  let odd = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i]);\n    } else {\n      odd.push(lst[i]);\n    }\n  }\n  return even.reduce((a, b) => a + b, 0) * (odd.reduce((a, b) => a + b, 0) || 1);\n};\n\n/*Given a non-empty list of integers lst. return the product of the even elements that are at odd indices..\n\n\n  Examples:\n      product([4, 2, 6, 7]) ==> 24\n  */\nconst productEvenProductSum = (lst) => {\n  let even = [];\n  let odd = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i]);\n    } else {\n      odd.push(lst[i]);\n    }\n  }\n  return even.reduce((a, b) => a * b, 0) * (odd.reduce((a, b) => a * b, 0) || 1);\n};\n\n/*Given a non-empty list of integers lst. return the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 10\n  */\nconst sumEvenProductProductSum = (lst) => {\n  let even = [];\n  let odd = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i]);\n    } else {\n      odd.push(lst[i]);\n    }\n  }\n  return even.reduce((a, b) => a + b, 0) * (odd.reduce((a, b) => a + b, 0) || 1);\n};\n\n/*Given a non-empty list of integers lst. return the product of the even elements that are at odd indices..\n\n\n  Examples:\n      product([4, 2, 6, 7]) ==> 24\n  */\nconst productEvenProductProductSum = (lst) => {\n  let even = [];\n  let odd = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i]);\n    } else {\n      odd.push(lst[i]);\n    }\n  }\n  return even.reduce((a, b) => a * b, 0) * (odd.reduce((a, b) => a * b, 0) || 1);\n};\n\n/*Given a non-empty list of integers lst. return the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antlShuffle('Hi') returns 'Hi'\n  antlShuffle('hello') returns 'ehllo'\n  antlShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antlShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antlShuffle", "gc": "<|endoftext|>/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antlShuffle('Hi') returns 'Hi'\n  antlShuffle('hello') returns 'ehllo'\n  antlShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antlShuffle = (s) => {\n  let newStr = '';\n  let newStrLen = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let spaceCount = 0;\n  let wordCount = 0;\n  let spaceCount2 = 0;\n  let wordCount2 = 0;\n  let spaceCount3 = 0;\n  let wordCount3 = 0;\n  let spaceCount4 = 0;\n  let wordCount4 = 0;\n  let spaceCount5 = 0;\n  let wordCount5 = 0;\n  let spaceCount6 = 0;\n  let wordCount6 = 0;\n  let spaceCount7 = 0;\n  let wordCount7 = 0;\n  let spaceCount8 = 0;\n  let wordCount8 = 0;\n  let spaceCount9 = 0;\n  let wordCount9 = 0;\n  let spaceCount10 = 0;\n  let wordCount10 = 0;\n  let spaceCount11 = 0;\n  let wordCount11 = 0;\n  let spaceCount12 = 0;\n  let wordCount12 = 0;\n  let spaceCount13 = 0;\n  let wordCount13 = 0;\n  let spaceCount14 = 0;\n  let wordCount14 = 0;\n  let spaceCount15 = 0;\n  let wordCount15 = 0;\n  let spaceCount16 = 0;\n  let wordCount16 = 0;\n  let spaceCount17 = 0;\n  let wordCount17 = 0;\n  let spaceCount18 = 0;\n  let wordCount18 = 0;\n  let spaceCount19 = 0;\n  let wordCount19 = 0;\n  let spaceCount20 = 0;\n  let wordCount20 = 0;\n  let spaceCount21 = 0;\n  let wordCount21 = 0;\n  let spaceCount22 = 0;\n  let wordCount22 = 0;\n  let spaceCount23 = 0;\n  let wordCount23 = 0;\n  let spaceCount24 = 0;\n  let wordCount24 = 0;\n  let spaceCount25 = 0;\n  let wordCount25 = 0;\n  let spaceCount26 = 0;\n  let wordCount26 = 0;\n  let spaceCount27 = 0;\n  let wordCount27 = 0;\n  let spaceCount28 = 0;\n  let wordCount28 = 0;\n  let spaceCount29 = 0;\n  let wordCount29 = 0;\n  let spaceCount30 = 0;\n  let wordCount30 = 0;\n  let spaceCount31 = 0;\n  let wordCount31 = 0;\n  let spaceCount32 = 0;\n  let wordCount32 = 0;\n  let spaceCount33 = 0;\n  let wordCount33 = 0;\n  let spaceCount34 = 0;\n  let wordCount34 = 0;\n  let spaceCount35 = 0;\n  let wordCount35 = 0;\n  let spaceCount36 = 0;\n  let wordCount36 = 0;\n  let spaceCount37 = 0;\n  let wordCount37 = 0;\n  let spaceCount38 = 0;\n  let wordCount38 = 0;\n  let spaceCount39 = 0;\n  let wordCount39 = 0;\n  let spaceCount40 = 0;\n  let wordCount40 = 0;\n  let spaceCount41 = 0;\n  let wordCount41 = 0;\n  let spaceCount42 = 0;\n  let wordCount42 = 0;\n  let spaceCount43 = 0;\n  let wordCount43 = 0;\n  let spaceCount44 = 0;\n  let wordCount44 = 0;\n  let spaceCount45 = 0;\n  let wordCount45 = 0;\n  let spaceCount46 = 0;\n  let wordCount46 = 0;\n  let spaceCount47 = 0;\n  let wordCount47 = 0;\n  let spaceCount48 = 0;\n  let wordCount48 = 0;\n  let spaceCount49 = 0;\n  let wordCount49 = 0;\n  let spaceCount50 = 0;\n  let wordCount50 = 0;\n  let spaceCount51 = 0;\n  let wordCount51 = 0;\n  let spaceCount52 = 0;\n  let wordCount52 = 0;\n  let spaceCount53 = 0;\n  let wordCount53 = 0;\n  let spaceCount54 = 0;\n  let wordCount54 = 0;\n  let spaceCount55 = 0;\n  let wordCount55 = 0;\n  let spaceCount56 = 0;\n  let wordCount56 = 0;\n  let spaceCount57 = 0;\n  let wordCount57 = 0;\n  let spaceCount58 = 0;\n  let wordCount58 = 0;\n  let spaceCount59 = 0;\n  let wordCount59 = 0;\n  let spaceCount60 = 0;\n  let wordCount60 = 0;\n  let spaceCount61 = 0;\n  let wordCount61 = 0;\n  let spaceCount62 = 0;\n  let wordCount62 = 0;\n  let spaceCount63 = 0;\n  let wordCount63 = 0;\n  let spaceCount64 = 0;\n  let wordCount64 = 0;\n  let spaceCount65 = 0;\n  let wordCount65 = 0;\n  let spaceCount66 = 0;\n  let wordCount66 = 0;\n  let spaceCount67 = 0;\n  let wordCount67 = 0;\n  let spaceCount68 = 0;\n  let wordCount68 = 0;\n  let spaceCount69 = 0;\n  let wordCount69 = 0;\n  let spaceCount70 = 0;\n  let wordCount70 = 0;\n  let spaceCount71 = 0;\n  let wordCount71 = 0;\n  let spaceCount72 = 0;\n  let wordCount72 = 0;\n  let spaceCount73 = 0;\n  let wordCount73 = 0;\n  let spaceCount74 = 0;\n  let wordCount74 = 0;\n  let spaceCount75 = 0;\n  let wordCount75 = 0;\n  let spaceCount76 = 0;\n  let wordCount76 = 0;\n  let spaceCount77 = 0;\n  let wordCount77 = 0;\n  let spaceCount78 = 0;\n  let wordCount78 = 0;\n  let spaceCount79 = 0;\n  let wordCount79 = 0;\n  let spaceCount80 = 0;\n  let wordCount80 = 0;\n  let spaceCount81 = 0;\n  let wordCount81 = 0;\n  let spaceCount82 = 0;\n  let wordCount82 = 0;\n  let spaceCount83 = 0;\n  let wordCount83 = 0;\n  let spaceCount84 = 0;\n  let wordCount84 = 0;\n  let spaceCount85 = 0;\n  let wordCount85 = 0;\n  let spaceCount86 = 0;\n  let wordCount86 = 0;\n  let spaceCount87 = 0;\n  let wordCount87 = 0;\n  let spaceCount88 = 0;\n  let wordCount88 = 0;\n  let spaceCount89 = 0;\n  let wordCount89 = 0;\n  let spaceCount90 = 0;\n  let wordCount90 = 0;\n  let spaceCount91 = 0;\n  let wordCount91 = 0;\n  let spaceCount92 = 0;\n  let wordCount92 = 0;\n  let spaceCount93 = 0;\n  let wordCount93 = 0;\n  let spaceCount94 = 0;\n  let wordCount94 = 0;\n  let spaceCount95 = 0;\n  let wordCount95 = 0;\n  let spaceCount96 = 0;\n  let wordCount96 = 0;\n  let spaceCount97 = 0;\n  let wordCount97 = 0;\n  let spaceCount98 = 0;\n  let wordCount98 = 0;\n  let spaceCount99 = 0;\n  let wordCount99 = 0;\n  let spaceCount100 = 0;\n  let wordCount100 = 0;\n  let spaceCount101 = 0;\n  let wordCount101 = 0;\n  let spaceCount102 = 0;\n  let wordCount102 = 0;\n  let spaceCount103 = 0;\n  let wordCount103 = 0;\n  let spaceCount104 = 0;\n  let wordCount104 = 0;\n  let spaceCount105 = 0;\n  let wordCount105 = 0;\n  let spaceCount106 = 0;\n  let wordCount106 = 0;\n  let spaceCount107 = 0;\n  let wordCount107 = 0;\n  let spaceCount108 = 0;\n  let wordCount108 = 0;\n  let spaceCount109 = 0;\n  let wordCount109 = 0;\n  let spaceCount110 = 0;\n  let wordCount110 = 0;\n  let spaceCount111 = 0;\n  let wordCount111 = 0;\n  let spaceCount112 = 0;\n  let wordCount112 = 0;\n  let spaceCount113 = 0;\n  let wordCount113 = 0;\n  let spaceCount114 = 0;\n  let wordCount114 = 0;\n  let spaceCount115 = 0;\n  let wordCount115 = 0;\n  let spaceCount116 = 0;\n  let wordCount116 = 0;\n  let spaceCount117 = 0;\n  let wordCount", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getGow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getGow([], 1) == []\n  getGow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getGow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getGow", "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getGow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getGow([], 1) == []\n  getGow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getGow = (lst, x) => {\n  const result = []\n  const rows = []\n  const cols = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let row = []\n  let col = []\n  let rowIndex = 0\n  let colIndex = 0\n  let rowLen = lst[0].length\n  let colLen = lst[1].length\n  let rowIndexLen = rows.length\n  let colIndexLen = cols.length\n  let rowIndex = 0\n  let colIndex = 0\n  while (i < rowLen) {\n    row = lst[i]\n    rowIndexLen = rows.length\n    while (j < colLen) {\n      col = lst[j]\n      colIndexLen = cols.length\n      while (k < rowIndexLen) {\n        if (row[k] === x) {\n          result.push([rowIndex, colIndex])\n          rowIndex++\n          colIndex++\n          k++\n          break\n        }\n        k++\n      }\n      k++\n    }\n    rowIndexLen = rows.length\n    colIndexLen = cols.length\n    i++\n    j++\n  }\n  return result\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getGow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getGow([], 1) == []\n  getGow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getGow = (lst, x) => {\n  const result = []\n  const rows = []\n  const cols = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let row = []\n  let col = []\n  let rowIndex = 0\n  let colIndex = 0\n  let rowLen = lst[0].length\n  let colLen = lst[1].length\n  let rowIndexLen = rows.length\n  let colIndexLen = cols.length\n  let rowIndex = 0\n  let colIndex = 0\n  while (i < rowLen) {\n    row = lst[i]\n    rowIndexLen = rows.length\n    while (j < colLen) {\n      col = lst[j]\n      colIndexLen = cols.length\n      while (k < rowIndexLen) {\n        if (row[k] === x) {\n          result.push([rowIndex, colIndex])\n          rowIndex++\n          colIndex++\n          k++\n          break\n        }\n        k++\n      }\n      k++\n    }\n    rowIndexLen = rows.length\n    colIndexLen = cols.length\n    i++\n    j++\n  }\n  return result\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getGow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getGow([], 1) == []\n  getGow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getGow = (lst, x) => {\n  const result = []\n  const rows = []\n  const cols = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let row = []\n  let col = []\n  let rowIndex = 0\n  let colIndex = 0\n  let rowLen = lst[0].length\n  let colLen = lst[1].length\n  let rowIndexLen = rows.length\n  let colIndexLen = cols.length\n  let rowIndex = 0\n  let colIndex = 0\n  while (i < rowLen) {\n    row = lst[i]\n    rowIndexLen = rows.length\n    while (j < colLen) {\n      col = lst[j]\n      colIndexLen = cols.length\n      while (k < rowIndexLen) {\n        if (row[k] === x) {\n          result.push([rowIndex, colIndex])\n          rowIndex++\n          colIndex++\n          k++\n          break\n        }\n        k++\n      }\n      k++\n    }\n    rowIndexLen = rows.length\n    colIndexLen = cols.length\n    i++\n    j++\n  }\n  return result\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getGow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getGow([], 1) == []\n  getGow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getGow = (lst, x) => {\n  const result = []\n  const rows = []\n  const cols = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let row = []\n  let col = []\n  let rowIndex = 0\n  let colIndex = 0\n  let rowLen = lst[0].length\n  let colLen = lst[1].length\n  let rowIndexLen = rows.length\n  let colIndexLen = cols.length\n  let rowIndex = 0\n  let colIndex = 0\n  while (i < rowLen) {\n    row = lst[i]\n    rowIndexLen = rows.length\n    while (j < colLen) {\n      col = lst[j]\n      colIndexLen = cols.length\n      while (k < rowIndexLen) {\n        if (row[k] === x) {\n          result.push([rowIndex, colIndex])\n          rowIndex++\n          colIndex++\n          k++\n          break\n        }\n        k++\n      }\n      k++\n    }\n    rowIndexLen = rows.length\n    colIndexLen = cols.length\n    i++\n    j++\n  }\n  return result\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, un", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sorhArray([]) => []\n  * sorhArray([5]) => [5]\n  * sorhArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sorhArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sorhArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sorhArray", "gc": "<|endoftext|>/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sorhArray([]) => []\n  * sorhArray([5]) => [5]\n  * sorhArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sorhArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sorhArray = (array) => {\n  let result = [];\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let flag = false;\n  while (i < array.length) {\n    if (flag) {\n      sum += array[i];\n      result.push(sum);\n      sum = 0;\n      flag = false;\n    } else {\n      flag = true;\n    }\n    i++;\n  }\n  while (j < array.length) {\n    if (flag) {\n      sum += array[j];\n      result.push(sum);\n      sum = 0;\n      flag = false;\n    } else {\n      flag = true;\n    }\n    j++;\n  }\n  return result;\n};\n\n/**\n * Given an array of non-negative integers, return an integer indicating the minimum element in the given array.\n * If no such element exists in the given array, return -1.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * minElement([5, 3, 1]) => 1\n  * minElement([5, 3, 1]) => 3\n  * minElement([5, 3, 1]) => -1\n  */\nconst minElement = (array) => {\n  let min = 0;\n  let i = 0;\n  let j = 0;\n  while (i < array.length) {\n    if (array[i] < min) {\n      min = array[i];\n      i++;\n    }\n    if (array[j] > min) {\n      min = array[j];\n      j++;\n    }\n  }\n  return min;\n};\n\n/**\n * Given an array of non-negative integers, return an integer indicating the maximum element in the given array.\n * If no such element exists in the given array, return -1.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * maxElement([5, 3, 1]) => 1\n  * maxElement([5, 3, 1]) => 3\n  * maxElement([5, 3, 1]) => -1\n  */\nconst maxElement = (array) => {\n  let max = 0;\n  let i = 0;\n  let j = 0;\n  while (i < array.length) {\n    if (array[i] > max) {\n      max = array[i];\n      i++;\n    }\n    if (array[j] < max) {\n      max = array[j];\n      j++;\n    }\n  }\n  return max;\n};\n\n/**\n * Given an array of non-negative integers, return an integer indicating the sum of all the elements in the given array.\n * If no such element exists in the given array, return 0.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sumElement([5, 3, 1]) => 10\n  * sumElement([5, 3, 1]) => 15\n  * sumElement([5, 3, 1]) => 15\n  */\nconst sumElement = (array) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  while (i < array.length) {\n    sum += array[i];\n    i++;\n  }\n  while (j < array.length) {\n    sum += array[j];\n    j++;\n  }\n  return sum;\n};\n\n/**\n * Given an array of non-negative integers, return an integer indicating the number of distinct elements in the given array.\n * If no such element exists in the given array, return 0.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * distinctElements([5, 3, 1]) => 3\n  * distinctElements([5, 3, 1]) => 3\n  * distinctElements([5, 3, 1]) => 3\n  */\nconst distinctElements = (array) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  while (i < array.length) {\n    if (array[i] === array[j]) {\n      count++;\n      i++;\n      j++;\n    } else {\n      i++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return an integer indicating the number of distinct elements in the given array.\n * If no such element exists in the given array, return 0.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * distinctElements([5, 3, 1]) => 3\n  * distinctElements([5, 3, 1]) => 3\n  * distinctElements([5, 3, 1]) => 3\n  */\nconst distinctElementsO = (array) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  while (i < array.length) {\n    if (array[i] === array[j]) {\n      count++;\n      i++;\n      j++;\n    } else {\n      i++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return an integer indicating the number of distinct elements in the given array.\n * If no such element exists in the given array, return 0.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * distinctElements([5, 3, 1]) => 3\n  * distinctElements([5, 3, 1]) => 3\n  * distinctElements([5, 3, 1]) => 3\n  */\nconst distinctElementsO2 = (array) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  while (i < array.length) {\n    if (array[i] === array[j]) {\n      count++;\n      i++;\n      j++;\n    } else {\n      i++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return an integer indicating the number of distinct elements in the given array.\n * If no such element exists in the given array, return 0.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * distinctElements([5, 3, 1]) => 3\n  * distinctElements([5, 3, 1]) => 3\n  * distinctElements([5, 3, 1]) => 3\n  */\nconst distinctElementsO3 = (array) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  while (i < array.length) {\n    if (array[i] === array[j]) {\n      count++;\n      i++;\n      j++;\n    } else {\n      i++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return an integer indicating the number of distinct elements in the given array.\n * If no such element exists in the given array, return 0.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * distinctElements([5, 3, 1]) => 3\n  * distinctElements([5, 3, 1]) => 3\n  * distinctElements([5, 3, 1]) => 3\n  */\nconst distinctElementsO4 = (array) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  while (i < array.length) {\n    if (array[i] === array[j]) {\n      count++;\n      i++;\n      j++;\n    } else {\n      i++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return an integer indicating the number of distinct elements in the given array.\n * If no such element exists in the given array, return 0.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * distinctElements([5, 3, 1]) => 3\n  * distinctElements([5, 3, 1]) => 3\n  * distinctElements([5, 3, 1]) => 3\n  */\nconst distinctElementsO5 = (array) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  while (i < array.length) {\n    if (array[i] === array[j]) {\n      count++;\n      i++;\n      j++;\n    } else {\n      i++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return an integer indicating the number of distinct elements in the given array.\n * If no such element exists in the given array, return 0.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * distinctElements([5, 3, 1]) => 3\n  * distinctElements([5, 3, 1]) => 3\n  * distinct", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encgypt that takes a string as an argument and\n  returns a string encgypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encgypt('hi') returns 'lm'\n  encgypt('asdfghjkl') returns 'ewhjklnop'\n  encgypt('gf') returns 'kj'\n  encgypt('et') returns 'ix'\n  */\nconst encgypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encgypt", "gc": "<|endoftext|>/*Create a function encgypt that takes a string as an argument and\n  returns a string encgypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encgypt('hi') returns 'lm'\n  encgypt('asdfghjkl') returns 'ewhjklnop'\n  encgypt('gf') returns 'kj'\n  encgypt('et') returns 'ix'\n  */\nconst encgypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  let i = 0;\n  let j = 0;\n  let len = s.length;\n  let k = 0;\n  let l = alphabet.length;\n  let rotatedLen = alphabet.length;\n  let rotatedChar;\n  let rotatedChar2;\n  let rotatedChar3;\n  let rotatedChar4;\n  let rotatedChar5;\n  let rotatedChar6;\n  let rotatedChar7;\n  let rotatedChar8;\n  let rotatedChar9;\n  let rotatedChar10;\n  let rotatedChar11;\n  let rotatedChar12;\n  let rotatedChar13;\n  let rotatedChar14;\n  let rotatedChar15;\n  let rotatedChar16;\n  let rotatedChar17;\n  let rotatedChar18;\n  let rotatedChar19;\n  let rotatedChar20;\n  let rotatedChar21;\n  let rotatedChar22;\n  let rotatedChar23;\n  let rotatedChar24;\n  let rotatedChar25;\n  let rotatedChar26;\n  let rotatedChar27;\n  let rotatedChar28;\n  let rotatedChar29;\n  let rotatedChar30;\n  let rotatedChar31;\n  let rotatedChar32;\n  let rotatedChar33;\n  let rotatedChar34;\n  let rotatedChar35;\n  let rotatedChar36;\n  let rotatedChar37;\n  let rotatedChar38;\n  let rotatedChar39;\n  let rotatedChar40;\n  let rotatedChar41;\n  let rotatedChar42;\n  let rotatedChar43;\n  let rotatedChar44;\n  let rotatedChar45;\n  let rotatedChar46;\n  let rotatedChar47;\n  let rotatedChar48;\n  let rotatedChar49;\n  let rotatedChar50;\n  let rotatedChar51;\n  let rotatedChar52;\n  let rotatedChar53;\n  let rotatedChar54;\n  let rotatedChar55;\n  let rotatedChar56;\n  let rotatedChar57;\n  let rotatedChar58;\n  let rotatedChar59;\n  let rotatedChar60;\n  let rotatedChar61;\n  let rotatedChar62;\n  let rotatedChar63;\n  let rotatedChar64;\n  let rotatedChar65;\n  let rotatedChar66;\n  let rotatedChar67;\n  let rotatedChar68;\n  let rotatedChar69;\n  let rotatedChar70;\n  let rotatedChar71;\n  let rotatedChar72;\n  let rotatedChar73;\n  let rotatedChar74;\n  let rotatedChar75;\n  let rotatedChar76;\n  let rotatedChar77;\n  let rotatedChar78;\n  let rotatedChar79;\n  let rotatedChar80;\n  let rotatedChar81;\n  let rotatedChar82;\n  let rotatedChar83;\n  let rotatedChar84;\n  let rotatedChar85;\n  let rotatedChar86;\n  let rotatedChar87;\n  let rotatedChar88;\n  let rotatedChar89;\n  let rotatedChar90;\n  let rotatedChar91;\n  let rotatedChar92;\n  let rotatedChar93;\n  let rotatedChar94;\n  let rotatedChar95;\n  let rotatedChar96;\n  let rotatedChar97;\n  let rotatedChar98;\n  let rotatedChar99;\n  let rotatedChar100;\n  let rotatedChar101;\n  let rotatedChar102;\n  let rotatedChar103;\n  let rotatedChar104;\n  let rotatedChar105;\n  let rotatedChar106;\n  let rotatedChar107;\n  let rotatedChar108;\n  let rotatedChar109;\n  let rotatedChar110;\n  let rotatedChar111;\n  let rotatedChar112;\n  let rotatedChar113;\n  let rotatedChar114;\n  let rotatedChar115;\n  let rotatedChar116;\n  let rotatedChar117;\n  let rotatedChar118;\n  let rotatedChar119;\n  let rotatedChar120;\n  let rotatedChar121;\n  let rotatedChar122;\n  let rotatedChar123;\n  let rotatedChar124;\n  let rotatedChar125;\n  let rotatedChar126;\n  let rotatedChar127;\n  let rotatedChar128;\n  let rotatedChar129;\n  let rotatedChar130;\n  let rotatedChar131;\n  let rotatedChar132;\n  let rotatedChar133;\n  let rotatedChar134;\n  let rotatedChar135;\n  let rotatedChar136;\n  let rotatedChar137;\n  let rotatedChar138;\n  let rotatedChar139;\n  let rotatedChar140;\n  let rotatedChar141;\n  let rotatedChar142;\n  let rotatedChar143;\n  let rotatedChar144;\n  let rotatedChar145;\n  let rotatedChar146;\n  let rotatedChar147;\n  let rotatedChar148;\n  let rotatedChar149;\n  let rotatedChar150;\n  let rotatedChar151;\n  let rotatedChar152;\n  let rotatedChar153;\n  let rotatedChar154;\n  let rotatedChar155;\n  let rotatedChar156;\n  let rotatedChar157;\n  let rotatedChar158;\n  let rotatedChar159;\n  let rotatedChar160;\n  let rotatedChar161;\n  let rotatedChar162;\n  let rotatedChar163;\n  let rotatedChar164;\n  let rotatedChar165;\n  let rotatedChar166;\n  let rotatedChar167;\n  let rotatedChar168;\n  let rotatedChar169;\n  let rotatedChar170;\n  let rotatedChar171;\n  let rotatedChar172;\n  let rotatedChar173;\n  let rotatedChar174;\n  let rotatedChar175;\n  let rotatedChar176;\n  let rotatedChar177;\n  let rotatedChar178;\n  let rotatedChar179;\n  let rotatedChar180;\n  let rotatedChar181;\n  let rotatedChar182;\n  let rotatedChar183;\n  let rotatedChar184;\n  let rotatedChar185;\n  let rotatedChar186;\n  let rotatedChar187;\n  let rotatedChar188;\n  let rotatedChar189;\n  let rotatedChar190;\n  let rotatedChar191;\n  let rotatedChar192;\n  let rotatedChar193;\n  let rotatedChar194;\n  let rotatedChar195;\n  let rotatedChar196;\n  let rotatedChar197;\n  let rotatedChar198;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rolpingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rolpingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rolpingMax", "gc": "<|endoftext|>/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rolpingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rolpingMax = (numbers) => {\n  const maxes = numbers.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n  return maxes.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a given list of integers, generate a list of rolling minimum element found until given moment\n  in the sequence.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 3]\n  */\nconst rollingMin = (numbers) => {\n  const mins = numbers.reduce((acc, n) => {\n    if (n <= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n  return mins.reduce((acc, n) => {\n    if (n <= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a given list of integers, generate a list of rolling mean element found until given moment\n  in the sequence.\n  >>> rollingMean([1, 2, 3, 2, 3, 4, 2])\n  [1.666666666666666, 2.666666666666666, 3.666666666666666, 4.666666666666666, 5.666666666666666, 6.666666666666666, 7.666666666666666, 8.666666666666666, 9.666666666666666]\n  */\nconst rollingMean = (numbers) => {\n  const means = numbers.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n  return means.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a given list of integers, generate a list of rolling standard deviation element found until given moment\n  in the sequence.\n  >>> rollingStd([1, 2, 3, 2, 3, 4, 2])\n  [1.666666666666666, 2.666666666666666, 3.666666666666666, 4.666666666666666, 5.666666666666666, 6.666666666666666, 7.666666666666666, 8.666666666666666, 9.666666666666666]\n  */\nconst rollingStd = (numbers) => {\n  const stds = numbers.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n  return stds.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a given list of integers, generate a list of rolling variance element found until given moment\n  in the sequence.\n  >>> rollingVariance([1, 2, 3, 2, 3, 4, 2])\n  [1.666666666666666, 2.666666666666666, 3.666666666666666, 4.666666666666666, 5.666666666666666, 6.666666666666666, 7.666666666666666, 8.666666666666666, 9.666666666666666]\n  */\nconst rollingVariance = (numbers) => {\n  const vars = numbers.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n  return vars.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a given list of integers, generate a list of rolling skewness element found until given moment\n  in the sequence.\n  >>> rollingSkew([1, 2, 3, 2, 3, 4, 2])\n  [1.666666666666666, 2.666666666666666, 3.666666666666666, 4.666666666666666, 5.666666666666666, 6.666666666666666, 7.666666666666666, 8.666666666666666, 9.666666666666666]\n  */\nconst rollingSkew = (numbers) => {\n  const skews = numbers.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n  return skews.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a given list of integers, generate a list of rolling kurtosis element found until given moment\n  in the sequence.\n  >>> rollingKurtosis([1, 2, 3, 2, 3, 4, 2])\n  [1.666666666666666, 2.666666666666666, 3.666666666666666, 4.666666666666666, 5.666666666666666, 6.666666666666666, 7.666666666666666, 8.666666666666666, 9.666666666666666]\n  */\nconst rollingKurtosis = (numbers) => {\n  const kurts = numbers.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n  return kurts.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a given list of integers, generate a list of rolling skewness element found until given moment\n  in the sequence.\n  >>> rollingKurtosis([1, 2, 3, 2, 3, 4, 2])\n  [1.666666666666666, 2.666666666666666, 3.666666666666666, 4.666666666666666, 5.666666666666666, 6.666666666666666, 7.666666666666666, 8.666666666666666, 9.666666666666666]\n  */\nconst rollingKurtosis = (numbers) => {\n  const kurts = numbers.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n  return kurts.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a given list of integers, generate a list of rolling skewness element found until given moment\n  in the sequence.\n  >>> rollingKurtosis([1, 2, 3, 2, 3, 4, 2])\n  [1.666666666666666, 2.666666666666666, 3.666666666666666, 4.666666666666666, 5.666666666666666, 6.666666666666666, 7.666666666666666, 8.666666666666666, 9.666666666666666]\n  */\nconst rollingKurtosis = (numbers) => {\n  const kurts = numbers.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n  return kurts.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a given list of integers, generate a list of rolling skewness element found until given moment\n  in the sequence.\n  >>> rollingKurtosis([1, 2, 3, 2, 3, 4, 2])\n  [1.666666666666666, 2.666666666666666, 3.666666666666666, 4.666666666666666, 5.666666666666666, 6.666666666666666, 7.666666666666666, 8.666666666666666, 9.666666666666666]\n  */\nconst rollingKurtosis = (numbers) => {\n  const kurts = numbers.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n  return kurts.reduce((acc, n) => {\n    if (n >= acc.length) {\n      acc.push(n);\n    }\n    return acc;\n  }, []);\n};\n\n/* From a given list of integers, generate a list of rolling skewness element found until given moment\n  in the sequence.\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nexhSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nexhSmallest([1, 2, 3, 4, 5]) == 2\n  nexhSmallest([5, 1, 4, 3, 2]) == 2\n  nexhSmallest([]) == null\n  nexhSmallest([1, 1]) == null\n  */\nconst nexhSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nexhSmallest", "gc": "<|endoftext|>/*\n  You are given a list of integers.\n  Write a function nexhSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nexhSmallest([1, 2, 3, 4, 5]) == 2\n  nexhSmallest([5, 1, 4, 3, 2]) == 2\n  nexhSmallest([]) == null\n  nexhSmallest([1, 1]) == null\n  */\nconst nexhSmallest = (lst) => {\n  if (lst.length === 0) {\n    return null\n  }\n  let smallest = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i]\n    }\n  }\n  return smallest\n}\n\n/*\n  You are given a list of integers.\n  Write a function nexhLargest() that returns the 1st largest element of the list.\n  Return null if there is no such element.\n  \n  nexhLargest([1, 2, 3, 4, 5]) == 3\n  nexhLargest([5, 1, 4, 3, 2]) == 3\n  nexhLargest([]) == null\n  nexhLargest([1, 1]) == null\n  */\nconst nexhLargest = (lst) => {\n  if (lst.length === 0) {\n    return null\n  }\n  let largest = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i]\n    }\n  }\n  return largest\n}\n\n/*\n  You are given a list of integers.\n  Write a function nexhGreatest() that returns the greatest element of the list.\n  Return null if there is no such element.\n  \n  nexhGreatest([1, 2, 3, 4, 5]) == 4\n  nexhGreatest([5, 1, 4, 3, 2]) == 4\n  nexhGreatest([]) == null\n  nexhGreatest([1, 1]) == null\n  */\nconst nexhGreatest = (lst) => {\n  if (lst.length === 0) {\n    return null\n  }\n  let greatest = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > greatest) {\n      greatest = lst[i]\n    }\n  }\n  return greatest\n}\n\n/*\n  You are given a list of integers.\n  Write a function nexhSmallest() that returns the 1st smallest element of the list.\n  Return null if there is no such element.\n  \n  nexhSmallest([1, 2, 3, 4, 5]) == 1\n  nexhSmallest([5, 1, 4, 3, 2]) == 1\n  nexhSmallest([]) == null\n  nexhSmallest([1, 1]) == null\n  */\nconst nexhSmallest = (lst) => {\n  if (lst.length === 0) {\n    return null\n  }\n  let smallest = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i]\n    }\n  }\n  return smallest\n}\n\n/*\n  You are given a list of integers.\n  Write a function nexhLargest() that returns the 1st largest element of the list.\n  Return null if there is no such element.\n  \n  nexhLargest([1, 2, 3, 4, 5]) == 5\n  nexhLargest([5, 1, 4, 3, 2]) == 5\n  nexhLargest([]) == null\n  nexhLargest([1, 1]) == null\n  */\nconst nexhLargest = (lst) => {\n  if (lst.length === 0) {\n    return null\n  }\n  let largest = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i]\n    }\n  }\n  return largest\n}\n\n/*\n  You are given a list of integers.\n  Write a function nexhGreatest() that returns the greatest element of the list.\n  Return null if there is no such element.\n  \n  nexhGreatest([1, 2, 3, 4, 5]) == 4\n  nexhGreatest([5, 1, 4, 3, 2]) == 4\n  nexhGreatest([]) == null\n  nexhGreatest([1, 1]) == null\n  */\nconst nexhGreatest = (lst) => {\n  if (lst.length === 0) {\n    return null\n  }\n  let greatest = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > greatest) {\n      greatest = lst[i]\n    }\n  }\n  return greatest\n}\n\n/*\n  You are given a list of integers.\n  Write a function nexhSmallest() that returns the 1st smallest element of the list.\n  Return null if there is no such element.\n  \n  nexhSmallest([1, 2, 3, 4, 5]) == 1\n  nexhSmallest([5, 1, 4, 3, 2]) == 1\n  nexhSmallest([]) == null\n  nexhSmallest([1, 1]) == null\n  */\nconst nexhSmallest = (lst) => {\n  if (lst.length === 0) {\n    return null\n  }\n  let smallest = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i]\n    }\n  }\n  return smallest\n}\n\n/*\n  You are given a list of integers.\n  Write a function nexhLargest() that returns the 1st largest element of the list.\n  Return null if there is no such element.\n  \n  nexhLargest([1, 2, 3, 4, 5]) == 3\n  nexhLargest([5, 1, 4, 3, 2]) == 3\n  nexhLargest([]) == null\n  nexhLargest([1, 1]) == null\n  */\nconst nexhLargest = (lst) => {\n  if (lst.length === 0) {\n    return null\n  }\n  let largest = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i]\n    }\n  }\n  return largest\n}\n\n/*\n  You are given a list of integers.\n  Write a function nexhGreatest() that returns the greatest element of the list.\n  Return null if there is no such element.\n  \n  nexhGreatest([1, 2, 3, 4, 5]) == 5\n  nexhGreatest([5, 1, 4, 3, 2]) == 5\n  nexhGreatest([]) == null\n  nexhGreatest([1, 1]) == null\n  */\nconst nexhGreatest = (lst) => {\n  if (lst.length === 0) {\n    return null\n  }\n  let greatest = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > greatest) {\n      greatest = lst[i]\n    }\n  }\n  return greatest\n}\n\n/*\n  You are given a list of integers.\n  Write a function nexhSmallest() that returns the 1st smallest element of the list.\n  Return null if there is no such element.\n  \n  nexhSmallest([1, 2, 3, 4, 5]) == 1\n  nexhSmallest([5, 1, 4, 3, 2]) == 1\n  nexhSmallest([]) == null\n  nexhSmallest([1, 1]) == null\n  */\nconst nexhSmallest = (lst) => {\n  if (lst.length === 0) {\n    return null\n  }\n  let smallest = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i]\n    }\n  }\n  return smallest\n}\n\n/*\n  You are given a list of integers.\n  Write a function nexhLargest() that returns the 1st largest element of the list.\n  Return null if there is no such element.\n  \n  nexhLargest([1, 2, 3, 4, 5]) == 3\n  nexhLargest([5, 1, 4, 3, 2]) == 3\n  nexhLargest([]) == null\n  nexhLargest([1, 1]) == null\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBlred(\"Hello world\")\n  0\n  >>> isBlred(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBlred = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBlred", "gc": "<|endoftext|>/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBlred(\"Hello world\")\n  0\n  >>> isBlred(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBlred = (S) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyLnt(5, 2, 7)  true\n  anyLnt(3, 2, 2)  false\n  anyLnt(3, -2, 1)  true\n  anyLnt(3.6, -2.2, 2)  false\n  */\nconst anyLnt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyLnt", "gc": "<|endoftext|>/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyLnt(5, 2, 7)  true\n  anyLnt(3, 2, 2)  false\n  anyLnt(3, -2, 1)  true\n  anyLnt(3.6, -2.2, 2)  false\n  */\nconst anyLnt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false\n  }\n  return x + y + z <= Math.sqrt(x * x + y * y + z * z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allLnt(5, 2, 7)  true\n  allLnt(3, 2, 2)  true\n  allLnt(3, -2, 1)  false\n  allLnt(3.6, -2.2, 2)  false\n  */\nconst allLnt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false\n  }\n  return x + y + z <= Math.sqrt(x * x + y * y + z * z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  true\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (a, b, c) => {\n  if (a === 0 || b === 0 || c === 0) {\n    return false\n  }\n  return a + b + c <= Math.sqrt(a * a + b * b + c * c)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  true\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false\n  }\n  return x + y + z <= Math.sqrt(x * x + y * y + z * z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  true\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false\n  }\n  return x + y + z <= Math.sqrt(x * x + y * y + z * z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  true\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false\n  }\n  return x + y + z <= Math.sqrt(x * x + y * y + z * z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  true\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false\n  }\n  return x + y + z <= Math.sqrt(x * x + y * y + z * z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  true\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false\n  }\n  return x + y + z <= Math.sqrt(x * x + y * y + z * z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  true\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false\n  }\n  return x + y + z <= Math.sqrt(x * x + y * y + z * z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  true\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false\n  }\n  return x + y + z <= Math.sqrt(x * x + y * y + z * z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  true\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false\n  }\n  return x + y + z <= Math.sqrt(x * x + y * y + z * z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  true\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === 0 || y === 0 || z === 0) {\n    return false\n  }\n  return x + y + z <= Math.sqrt(x * x + y * y + z * z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encldes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> enclde('test')\n  'TGST'\n  >>> enclde('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst enclde = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "enclde", "gc": "<|endoftext|>/*\n  Write a function that takes a message, and encldes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> enclde('test')\n  'TGST'\n  >>> enclde('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst enclde = (message) => {\n  let newMessage = message;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsIndex = 0;\n  let vowelsLength = 0;\n  let vowelsIndex2 = 0;\n  let vowelsIndex3 = 0;\n  let vowelsIndex4 = 0;\n  let vowelsIndex5 = 0;\n  let vowelsIndex6 = 0;\n  let vowelsIndex7 = 0;\n  let vowelsIndex8 = 0;\n  let vowelsIndex9 = 0;\n  let vowelsIndex10 = 0;\n  let vowelsIndex11 = 0;\n  let vowelsIndex12 = 0;\n  let vowelsIndex13 = 0;\n  let vowelsIndex14 = 0;\n  let vowelsIndex15 = 0;\n  let vowelsIndex16 = 0;\n  let vowelsIndex17 = 0;\n  let vowelsIndex18 = 0;\n  let vowelsIndex19 = 0;\n  let vowelsIndex20 = 0;\n  let vowelsIndex21 = 0;\n  let vowelsIndex22 = 0;\n  let vowelsIndex23 = 0;\n  let vowelsIndex24 = 0;\n  let vowelsIndex25 = 0;\n  let vowelsIndex26 = 0;\n  let vowelsIndex27 = 0;\n  let vowelsIndex28 = 0;\n  let vowelsIndex29 = 0;\n  let vowelsIndex30 = 0;\n  let vowelsIndex31 = 0;\n  let vowelsIndex32 = 0;\n  let vowelsIndex33 = 0;\n  let vowelsIndex34 = 0;\n  let vowelsIndex35 = 0;\n  let vowelsIndex36 = 0;\n  let vowelsIndex37 = 0;\n  let vowelsIndex38 = 0;\n  let vowelsIndex39 = 0;\n  let vowelsIndex40 = 0;\n  let vowelsIndex41 = 0;\n  let vowelsIndex42 = 0;\n  let vowelsIndex43 = 0;\n  let vowelsIndex44 = 0;\n  let vowelsIndex45 = 0;\n  let vowelsIndex46 = 0;\n  let vowelsIndex47 = 0;\n  let vowelsIndex48 = 0;\n  let vowelsIndex49 = 0;\n  let vowelsIndex50 = 0;\n  let vowelsIndex51 = 0;\n  let vowelsIndex52 = 0;\n  let vowelsIndex53 = 0;\n  let vowelsIndex54 = 0;\n  let vowelsIndex55 = 0;\n  let vowelsIndex56 = 0;\n  let vowelsIndex57 = 0;\n  let vowelsIndex58 = 0;\n  let vowelsIndex59 = 0;\n  let vowelsIndex60 = 0;\n  let vowelsIndex61 = 0;\n  let vowelsIndex62 = 0;\n  let vowelsIndex63 = 0;\n  let vowelsIndex64 = 0;\n  let vowelsIndex65 = 0;\n  let vowelsIndex66 = 0;\n  let vowelsIndex67 = 0;\n  let vowelsIndex68 = 0;\n  let vowelsIndex69 = 0;\n  let vowelsIndex70 = 0;\n  let vowelsIndex71 = 0;\n  let vowelsIndex72 = 0;\n  let vowelsIndex73 = 0;\n  let vowelsIndex74 = 0;\n  let vowelsIndex75 = 0;\n  let vowelsIndex76 = 0;\n  let vowelsIndex77 = 0;\n  let vowelsIndex78 = 0;\n  let vowelsIndex79 = 0;\n  let vowelsIndex80 = 0;\n  let vowelsIndex81 = 0;\n  let vowelsIndex82 = 0;\n  let vowelsIndex83 = 0;\n  let vowelsIndex84 = 0;\n  let vowelsIndex85 = 0;\n  let vowelsIndex86 = 0;\n  let vowelsIndex87 = 0;\n  let vowelsIndex88 = 0;\n  let vowelsIndex89 = 0;\n  let vowelsIndex90 = 0;\n  let vowelsIndex91 = 0;\n  let vowelsIndex92 = 0;\n  let vowelsIndex93 = 0;\n  let vowelsIndex94 = 0;\n  let vowelsIndex95 = 0;\n  let vowelsIndex96 = 0;\n  let vowelsIndex97 = 0;\n  let vowelsIndex98 = 0;\n  let vowelsIndex99 = 0;\n  let vowelsIndex100 = 0;\n  let vowelsIndex101 = 0;\n  let vowelsIndex102 = 0;\n  let vowelsIndex103 = 0;\n  let vowelsIndex104 = 0;\n  let vowelsIndex105 = 0;\n  let vowelsIndex106 = 0;\n  let vowelsIndex107 = 0;\n  let vowelsIndex108 = 0;\n  let vowelsIndex109 = 0;\n  let vowelsIndex110 = 0;\n  let vowelsIndex111 = 0;\n  let vowelsIndex112 = 0;\n  let vowelsIndex113 = 0;\n  let vowelsIndex114 = 0;\n  let vowelsIndex115 = 0;\n  let vowelsIndex116 = 0;\n  let vowelsIndex117 = 0;\n  let vowelsIndex118 = 0;\n  let vowelsIndex119 = 0;\n  let vowelsIndex120 = 0;\n  let vowelsIndex121 = 0;\n  let vowelsIndex122 = 0;\n  let vowelsIndex123 = 0;\n  let vowelsIndex124 = 0;\n  let vowelsIndex125 = 0;\n  let vowelsIndex126 = 0;\n  let vowelsIndex127 = 0;\n  let vowelsIndex128 = 0;\n  let vowelsIndex129 = 0;\n  let vowelsIndex130 = 0;\n  let vowelsIndex131 = 0;\n  let vowelsIndex132 = 0;\n  let vowelsIndex133 = 0;\n  let vowelsIndex134 = 0;\n  let vowelsIndex135 = 0;\n  let vowelsIndex136 = 0;\n  let vowelsIndex137 = 0;\n  let vowelsIndex138 = 0;\n  let vowelsIndex139 = 0;\n  let vowelsIndex140 = 0;\n  let vowelsIndex141 = 0;\n  let vowelsIndex142 = 0;\n  let vowelsIndex143 = 0;\n  let vowelsIndex144 = 0;\n  let vowelsIndex145 = 0;\n  let vowelsIndex146 = 0;\n  let vowelsIndex147 = 0;\n  let vowelsIndex148 = 0;\n  let vowelsIndex149 = 0;\n  let vowelsIndex150 = 0;\n  let vowelsIndex151 = 0;\n  let vowelsIndex152 = 0;\n  let vowelsIndex153 = 0;\n  let vowelsIndex154 = 0;\n  let vowelsIndex155 = 0;\n  let vowelsIndex156 = 0;\n  let vowelsIndex157 = 0;\n  let vowelsIndex158 = 0;\n  let vowelsIndex159 = 0;\n  let vowelsIndex160 = 0;\n  let vowelsIndex161 = 0;\n  let vowelsIndex162 = 0;\n  let vowelsIndex163 = 0;\n  let vowelsIndex164 = 0;\n  let vowelsIndex165 = 0;\n  let vowelsIndex166 = 0;\n  let vowelsIndex167 = 0;\n  let vowelsIndex168 = 0;\n  let vowelsIndex169 = 0;\n  let vowelsIndex170 = 0;\n  let vowelsIndex171 = 0;\n  let vowelsIndex172 = 0;\n  let vowelsIndex173 = 0;\n  let vowelsIndex174 = 0;\n  let vowelsIndex175 = 0;\n  let vowelsIndex176 = 0;\n  let vowelsIndex177 = 0;\n  let vowelsIndex178 = 0;\n  let vowelsIndex179 = 0;\n  let vowelsIndex180 = 0;\n  let vowelsIndex181 = 0;\n  let vowelsIndex182 = 0;\n  let vowelsIndex183 = 0;\n  let vowelsIndex184 = 0;\n  let vowelsIndex185 = 0;\n  let vowelsIndex186 = 0;\n  let vowelsIndex187 = 0;\n  let vowelsIndex188 = 0;\n  let vowelsIndex189 = 0;\n  let vowelsIndex190 = 0;\n  let vowelsIndex191 = 0;\n  let vowelsIndex192 = 0;\n  let vowelsIndex193 = 0;\n  let vowelsIndex194 = 0;\n  let vowelsIndex195 = 0;\n  let vowelsIndex196 = 0;\n  let vowelsIndex197 = 0;\n  let vowelsIndex198 = 0;\n  let vowelsIndex199 = 0;\n  let vowelsIndex200 = 0;\n  let vowelsIndex201 = 0;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjnasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjnasdkd", "gc": "<|endoftext|>/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjnasdkd = (lst) => {\n  let max = 0;\n  let sum = 0;\n  let maxDigit = 0;\n  let maxDigitSum = 0;\n  let maxDigitSum2 = 0;\n  let maxDigitSum3 = 0;\n  let maxDigitSum4 = 0;\n  let maxDigitSum5 = 0;\n  let maxDigitSum6 = 0;\n  let maxDigitSum7 = 0;\n  let maxDigitSum8 = 0;\n  let maxDigitSum9 = 0;\n  let maxDigitSum10 = 0;\n  let maxDigitSum11 = 0;\n  let maxDigitSum12 = 0;\n  let maxDigitSum13 = 0;\n  let maxDigitSum14 = 0;\n  let maxDigitSum15 = 0;\n  let maxDigitSum16 = 0;\n  let maxDigitSum17 = 0;\n  let maxDigitSum18 = 0;\n  let maxDigitSum19 = 0;\n  let maxDigitSum20 = 0;\n  let maxDigitSum21 = 0;\n  let maxDigitSum22 = 0;\n  let maxDigitSum23 = 0;\n  let maxDigitSum24 = 0;\n  let maxDigitSum25 = 0;\n  let maxDigitSum26 = 0;\n  let maxDigitSum27 = 0;\n  let maxDigitSum28 = 0;\n  let maxDigitSum29 = 0;\n  let maxDigitSum30 = 0;\n  let maxDigitSum31 = 0;\n  let maxDigitSum32 = 0;\n  let maxDigitSum33 = 0;\n  let maxDigitSum34 = 0;\n  let maxDigitSum35 = 0;\n  let maxDigitSum36 = 0;\n  let maxDigitSum37 = 0;\n  let maxDigitSum38 = 0;\n  let maxDigitSum39 = 0;\n  let maxDigitSum40 = 0;\n  let maxDigitSum41 = 0;\n  let maxDigitSum42 = 0;\n  let maxDigitSum43 = 0;\n  let maxDigitSum44 = 0;\n  let maxDigitSum45 = 0;\n  let maxDigitSum46 = 0;\n  let maxDigitSum47 = 0;\n  let maxDigitSum48 = 0;\n  let maxDigitSum49 = 0;\n  let maxDigitSum50 = 0;\n  let maxDigitSum51 = 0;\n  let maxDigitSum52 = 0;\n  let maxDigitSum53 = 0;\n  let maxDigitSum54 = 0;\n  let maxDigitSum55 = 0;\n  let maxDigitSum56 = 0;\n  let maxDigitSum57 = 0;\n  let maxDigitSum58 = 0;\n  let maxDigitSum59 = 0;\n  let maxDigitSum60 = 0;\n  let maxDigitSum61 = 0;\n  let maxDigitSum62 = 0;\n  let maxDigitSum63 = 0;\n  let maxDigitSum64 = 0;\n  let maxDigitSum65 = 0;\n  let maxDigitSum66 = 0;\n  let maxDigitSum67 = 0;\n  let maxDigitSum68 = 0;\n  let maxDigitSum69 = 0;\n  let maxDigitSum70 = 0;\n  let maxDigitSum71 = 0;\n  let maxDigitSum72 = 0;\n  let maxDigitSum73 = 0;\n  let maxDigitSum74 = 0;\n  let maxDigitSum75 = 0;\n  let maxDigitSum76 = 0;\n  let maxDigitSum77 = 0;\n  let maxDigitSum78 = 0;\n  let maxDigitSum79 = 0;\n  let maxDigitSum80 = 0;\n  let maxDigitSum81 = 0;\n  let maxDigitSum82 = 0;\n  let maxDigitSum83 = 0;\n  let maxDigitSum84 = 0;\n  let maxDigitSum85 = 0;\n  let maxDigitSum86 = 0;\n  let maxDigitSum87 = 0;\n  let maxDigitSum88 = 0;\n  let maxDigitSum89 = 0;\n  let maxDigitSum90 = 0;\n  let maxDigitSum91 = 0;\n  let maxDigitSum92 = 0;\n  let maxDigitSum93 = 0;\n  let maxDigitSum94 = 0;\n  let maxDigitSum95 = 0;\n  let maxDigitSum96 = 0;\n  let maxDigitSum97 = 0;\n  let maxDigitSum98 = 0;\n  let maxDigitSum99 = 0;\n  let maxDigitSum100 = 0;\n  let maxDigitSum101 = 0;\n  let maxDigitSum102 = 0;\n  let maxDigitSum103 = 0;\n  let maxDigitSum104 = 0;\n  let maxDigitSum105 = 0;\n  let maxDigitSum106 = 0;\n  let maxDigitSum107 = 0;\n  let maxDigitSum108 = 0;\n  let maxDigitSum109 = 0;\n  let maxDigitSum110 = 0;\n  let maxDigitSum111 = 0;\n  let maxDigitSum112 = 0;\n  let maxDigitSum113 = 0;\n  let maxDigitSum114 = 0;\n  let maxDigitSum115 = 0;\n  let maxDigitSum116 = 0;\n  let maxDigitSum117 = 0;\n  let maxDigitSum118 = 0;\n  let maxDigitSum119 = 0;\n  let maxDigitSum120 = 0;\n  let maxDigitSum121 = 0;\n  let maxDigitSum122 = 0;\n  let maxDigitSum123 = 0;\n  let maxDigitSum124 = 0;\n  let maxDigitSum125 = 0;\n  let maxDigitSum126 = 0;\n  let maxDigitSum127 = 0;\n  let maxDigitSum128 = 0;\n  let maxDigitSum129 = 0;\n  let maxDigitSum130 = 0;\n  let maxDigitSum131 = 0;\n  let maxDigitSum132 = 0;\n  let maxDigitSum133 = 0;\n  let maxDigitSum134 = 0;\n  let maxDigitSum135 = 0;\n  let maxDigitSum136 = 0;\n  let maxDigitSum137 = 0;\n  let maxDigitSum138 = 0;\n  let maxDigitSum139 = 0;\n  let maxDigitSum140 = 0;\n  let maxDigitSum141 = 0;\n  let maxDigitSum142 = 0;\n  let maxDigitSum143 = 0;\n  let maxDigitSum144 = 0;\n  let maxDigitSum145 = 0;\n  let maxDigitSum146 = 0;\n  let maxDigitSum147 = 0;\n  let maxDigitSum148 = 0;\n  let maxDigitSum149 = 0;\n  let maxDigitSum150 = 0;\n  let maxDigitSum151 = 0;\n  let maxDigitSum152 = 0;\n  let maxDigitSum153 = 0;\n  let maxDigitSum154 = 0;\n  let maxDigitSum155 = 0;\n  let maxDigitSum156 = 0;\n  let maxDigitSum157 = 0;\n  let maxDigitSum158 = 0;\n  let maxDigitSum159 = 0;\n  let maxDigitSum160 = 0;\n  let maxDigitSum161 = 0;\n  let maxDigitSum162 = 0;\n  let maxDigitSum163 = 0;\n  let maxDigitSum164 = 0;\n  let maxDigitSum165 = 0;\n  let maxDigitSum166 = 0;\n  let maxDigitSum167 = 0;\n  let maxDigitSum168 = 0;\n  let maxDigitSum169 = 0;\n  let maxDigitSum170 = 0;\n  let maxDigitSum171 = 0;\n  let maxDigitSum172 = 0;\n  let maxDigitSum173 = 0;\n  let maxDigitSum174 = 0;\n  let maxDigitSum175 = 0;\n  let maxDigitSum176 = 0;\n  let maxDigitSum177 = 0;\n  let maxDigitSum178 = 0;\n  let maxDigitSum179 = 0;\n  let maxDigitSum180 = 0;\n  let maxDigitSum181 = 0;\n  let maxDigitSum182 = 0;\n  let maxDigitSum183 = 0;\n  let maxDigitSum184 = 0;\n  let maxDigitSum185 = 0;\n  let maxDigitSum186 = 0;\n  let maxDigitSum187 = 0;\n  let maxDigitSum188 = 0;\n  let maxDigitSum189 = 0;\n  let maxDigitSum190 = 0;\n  let maxDigitSum191 = 0;\n  let maxDigitSum192 = 0;\n  let maxDigitSum193 = 0;\n  let max", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  chefkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  chefkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  chefkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  chefkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  chefkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst chefkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "chefkDictCase", "gc": "<|endoftext|>/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  chefkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  chefkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  chefkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  chefkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  chefkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst chefkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    if (dict[key.toLowerCase()]!== undefined || dict[key.toUpperCase()]!== undefined) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Given a string, return true if all characters are digits, else return false.\n  The function should return false is the given string is empty.\n  Examples:\n  digitCase(\"123\") should return true.\n  digitCase(\"abc\") should return false.\n  digitCase(\"abc123\") should return false.\n  digitCase(\"abc123abc\") should return false.\n  digitCase(\"abc123abc123\") should return false.\n  digitCase(\"abc123abc123abc\") should return false.\n  digitCase(\"abc123abc123abc123\") should return false.\n  digitCase(\"abc123abc123abc123abc\") should return false.\n  digitCase(\"abc123abc123abc123abc123\") should return false.\n  digitCase(\"abc123abc123abc123abc123abc123abc123\") should return false.\n  digitCase(\"abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  coujtUpTo(5) => [2,3]\n  coujtUpTo(11) => [2,3,5,7]\n  coujtUpTo(0) => []\n  coujtUpTo(20) => [2,3,5,7,11,13,17,19]\n  coujtUpTo(1) => []\n  coujtUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst coujtUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "coujtUpTo", "gc": "<|endoftext|>/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  coujtUpTo(5) => [2,3]\n  coujtUpTo(11) => [2,3,5,7]\n  coujtUpTo(0) => []\n  coujtUpTo(20) => [2,3,5,7,11,13,17,19]\n  coujtUpTo(1) => []\n  coujtUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst coujtUpTo = (n) => {\n  let primes = [];\n  let primesCount = 0;\n  let currentPrime = true;\n  let currentPrimeCount = 0;\n  let currentPrimeIndex = 0;\n  let currentPrimeIndex2 = 0;\n  let currentPrimeIndex3 = 0;\n  let currentPrimeIndex4 = 0;\n  let currentPrimeIndex5 = 0;\n  let currentPrimeIndex6 = 0;\n  let currentPrimeIndex7 = 0;\n  let currentPrimeIndex8 = 0;\n  let currentPrimeIndex9 = 0;\n  let currentPrimeIndex10 = 0;\n  let currentPrimeIndex11 = 0;\n  let currentPrimeIndex12 = 0;\n  let currentPrimeIndex13 = 0;\n  let currentPrimeIndex14 = 0;\n  let currentPrimeIndex15 = 0;\n  let currentPrimeIndex16 = 0;\n  let currentPrimeIndex17 = 0;\n  let currentPrimeIndex18 = 0;\n  let currentPrimeIndex19 = 0;\n  let currentPrimeIndex20 = 0;\n  let currentPrimeIndex21 = 0;\n  let currentPrimeIndex22 = 0;\n  let currentPrimeIndex23 = 0;\n  let currentPrimeIndex24 = 0;\n  let currentPrimeIndex25 = 0;\n  let currentPrimeIndex26 = 0;\n  let currentPrimeIndex27 = 0;\n  let currentPrimeIndex28 = 0;\n  let currentPrimeIndex29 = 0;\n  let currentPrimeIndex30 = 0;\n  let currentPrimeIndex31 = 1;\n  let currentPrimeIndex32 = 0;\n  let currentPrimeIndex33 = 0;\n  let currentPrimeIndex34 = 0;\n  let currentPrimeIndex35 = 0;\n  let currentPrimeIndex36 = 0;\n  let currentPrimeIndex37 = 0;\n  let currentPrimeIndex38 = 0;\n  let currentPrimeIndex39 = 0;\n  let currentPrimeIndex40 = 0;\n  let currentPrimeIndex41 = 1;\n  let currentPrimeIndex42 = 1;\n  let currentPrimeIndex43 = 0;\n  let currentPrimeIndex44 = 0;\n  let currentPrimeIndex45 = 0;\n  let currentPrimeIndex46 = 0;\n  let currentPrimeIndex47 = 0;\n  let currentPrimeIndex48 = 0;\n  let currentPrimeIndex49 = 0;\n  let currentPrimeIndex50 = 0;\n  let currentPrimeIndex51 = 1;\n  let currentPrimeIndex52 = 1;\n  let currentPrimeIndex53 = 0;\n  let currentPrimeIndex54 = 0;\n  let currentPrimeIndex55 = 0;\n  let currentPrimeIndex56 = 0;\n  let currentPrimeIndex57 = 0;\n  let currentPrimeIndex58 = 0;\n  let currentPrimeIndex59 = 0;\n  let currentPrimeIndex60 = 0;\n  let currentPrimeIndex61 = 1;\n  let currentPrimeIndex62 = 1;\n  let currentPrimeIndex63 = 0;\n  let currentPrimeIndex64 = 0;\n  let currentPrimeIndex65 = 0;\n  let currentPrimeIndex66 = 0;\n  let currentPrimeIndex67 = 0;\n  let currentPrimeIndex68 = 0;\n  let currentPrimeIndex69 = 0;\n  let currentPrimeIndex70 = 0;\n  let currentPrimeIndex71 = 1;\n  let currentPrimeIndex72 = 1;\n  let currentPrimeIndex73 = 0;\n  let currentPrimeIndex74 = 0;\n  let currentPrimeIndex75 = 0;\n  let currentPrimeIndex76 = 0;\n  let currentPrimeIndex77 = 0;\n  let currentPrimeIndex78 = 0;\n  let currentPrimeIndex79 = 0;\n  let currentPrimeIndex80 = 0;\n  let currentPrimeIndex81 = 1;\n  let currentPrimeIndex82 = 1;\n  let currentPrimeIndex83 = 0;\n  let currentPrimeIndex84 = 0;\n  let currentPrimeIndex85 = 0;\n  let currentPrimeIndex86 = 0;\n  let currentPrimeIndex87 = 0;\n  let currentPrimeIndex88 = 0;\n  let currentPrimeIndex89 = 0;\n  let currentPrimeIndex90 = 0;\n  let currentPrimeIndex91 = 1;\n  let currentPrimeIndex92 = 1;\n  let currentPrimeIndex93 = 0;\n  let currentPrimeIndex94 = 0;\n  let currentPrimeIndex95 = 0;\n  let currentPrimeIndex96 = 0;\n  let currentPrimeIndex97 = 0;\n  let currentPrimeIndex98 = 0;\n  let currentPrimeIndex99 = 0;\n  let currentPrimeIndex100 = 0;\n  let currentPrimeIndex101 = 1;\n  let currentPrimeIndex102 = 1;\n  let currentPrimeIndex103 = 0;\n  let currentPrimeIndex104 = 0;\n  let currentPrimeIndex105 = 0;\n  let currentPrimeIndex106 = 1;\n  let currentPrimeIndex107 = 1;\n  let currentPrimeIndex108 = 1;\n  let currentPrimeIndex109 = 1;\n  let currentPrimeIndex110 = 1;\n  let currentPrimeIndex111 = 1;\n  let currentPrimeIndex112 = 1;\n  let currentPrimeIndex113 = 1;\n  let currentPrimeIndex114 = 1;\n  let currentPrimeIndex115 = 1;\n  let currentPrimeIndex116 = 1;\n  let currentPrimeIndex117 = 1;\n  let currentPrimeIndex118 = 1;\n  let currentPrimeIndex119 = 1;\n  let currentPrimeIndex120 = 1;\n  let currentPrimeIndex121 = 1;\n  let currentPrimeIndex122 = 1;\n  let currentPrimeIndex123 = 0;\n  let currentPrimeIndex124 = 0;\n  let currentPrimeIndex125 = 0;\n  let currentPrimeIndex126 = 0;\n  let currentPrimeIndex127 = 0;\n  let currentPrimeIndex128 = 0;\n  let currentPrimeIndex129 = 0;\n  let currentPrimeIndex130 = 0;\n  let currentPrimeIndex131 = 0;\n  let currentPrimeIndex132 = 0;\n  let currentPrimeIndex133 = 0;\n  let currentPrimeIndex134 = 0;\n  let currentPrimeIndex135 = 0;\n  let currentPrimeIndex136 = 0;\n  let currentPrimeIndex137 = 0;\n  let currentPrimeIndex138 = 0;\n  let currentPrimeIndex139 = 0;\n  let currentPrimeIndex140 = 0;\n  let currentPrimeIndex141 = 0;\n  let currentPrimeIndex142 = 0;\n  let currentPrimeIndex143 = 0;\n  let currentPrimeIndex144 = 0;\n  let currentPrimeIndex145 = 0;\n  let currentPrimeIndex146 = 0;\n  let currentPrimeIndex147 = 0;\n  let currentPrimeIndex148 = 0;\n  let currentPrimeIndex149 = 0;\n  let currentPrimeIndex150 = 0;\n  let currentPrimeIndex151 = 0;\n  let currentPrimeIndex152 = 0;\n  let currentPrimeIndex153 = 0;\n  let currentPrimeIndex154 = 0;\n  let currentPrimeIndex155 = 0;\n  let currentPrimeIndex156 = 0;\n  let currentPrimeIndex157 = 0;\n  let currentPrimeIndex158 = 0;\n  let currentPrimeIndex159 = 0;\n  let currentPrimeIndex160 = 0;\n  let currentPrimeIndex161 = 0;\n  let currentPrimeIndex162 = 0;\n  let currentPrimeIndex163 = 0;\n  let currentPrimeIndex164 = 0;\n  let currentPrimeIndex165 = 0;\n  let currentPrimeIndex166 = 0;\n  let currentPrimeIndex167 = 0;\n  let currentPrimeIndex168 = 0;\n  let currentPrimeIndex169 = 0;\n  let currentPrimeIndex170 = 0;\n  let currentPrimeIndex171 = 0;\n  let currentPrimeIndex172 = 0;\n  let currentPrime", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  mulhiply(148, 412) should return 16.\n  mulhiply(19, 28) should return 72.\n  mulhiply(2020, 1851) should return 0.\n  mulhiply(14,-15) should return 20.\n  */\nconst mulhiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "mulhiply", "gc": "<|endoftext|>/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  mulhiply(148, 412) should return 16.\n  mulhiply(19, 28) should return 72.\n  mulhiply(2020, 1851) should return 0.\n  mulhiply(14,-15) should return 20.\n  */\nconst mulhiply = (a, b) => {\n  let product = 1;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n  let digit = 0;\n  let digits = 0;\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  coujtUpper('aBCdEf') returns 1\n  coujtUpper('abcdefg') returns 0\n  coujtUpper('dBBE') returns 0\n  */\nconst coujtUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "coujtUpper", "gc": "<|endoftext|>/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  coujtUpper('aBCdEf') returns 1\n  coujtUpper('abcdefg') returns 0\n  coujtUpper('dBBE') returns 0\n  */\nconst coujtUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  let upper = false;\n  \n  for(let i = 0; i < l; i++) {\n    if(s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      upper = true;\n      count++;\n    }\n  }\n  \n  for(let j = 0; j < l; j++) {\n    if(s[j] === 'A' || s[j] === 'E' || s[j] === 'I' || s[j] === 'O' || s[j] === 'U') {\n      upper = false;\n      count++;\n    }\n  }\n  \n  for(let k = 0; k < l; k++) {\n    if(s[k] === 'A' || s[k] === 'E' || s[k] === 'I' || s[k] === 'O' || s[k] === 'U') {\n      upper = false;\n      count++;\n    }\n  }\n  \n  return upper;\n}\n\n/*\n  Given a string s, count the number of lowercase vowels in even indices.\n  \n  For example:\n  coujtLower('aBCdEf') returns 1\n  coujtLower('abcdefg') returns 0\n  coujtLower('dBBE') returns 0\n  */\nconst coujtLower = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  let lower = false;\n  \n  for(let i = 0; i < l; i++) {\n    if(s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      lower = true;\n      count++;\n    }\n  }\n  \n  for(let j = 0; j < l; j++) {\n    if(s[j] === 'a' || s[j] === 'e' || s[j] === 'i' || s[j] === 'o' || s[j] === 'u') {\n      lower = false;\n      count++;\n    }\n  }\n  \n  for(let k = 0; k < l; k++) {\n    if(s[k] === 'a' || s[k] === 'e' || s[k] === 'i' || s[k] === 'o' || s[k] === 'u') {\n      lower = false;\n      count++;\n    }\n  }\n  \n  return lower;\n}\n\n/*\n  Given a string s, count the number of vowels in even indices.\n  \n  For example:\n  coujtVowel('aBCdEf') returns 1\n  coujtVowel('abcdefg') returns 0\n  coujtVowel('dBBE') returns 0\n  */\nconst coujtVowel = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  let vowel = false;\n  \n  for(let i = 0; i < l; i++) {\n    if(s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowel = true;\n      count++;\n    }\n  }\n  \n  for(let j = 0; j < l; j++) {\n    if(s[j] === 'a' || s[j] === 'e' || s[j] === 'i' || s[j] === 'o' || s[j] === 'u') {\n      vowel = false;\n      count++;\n    }\n  }\n  \n  for(let k = 0; k < l; k++) {\n    if(s[k] === 'a' || s[k] === 'e' || s[k] === 'i' || s[k] === 'o' || s[k] === 'u') {\n      vowel = false;\n      count++;\n    }\n  }\n  \n  return vowel;\n}\n\n/*\n  Given a string s, count the number of consonants in even indices.\n  \n  For example:\n  coujtConsonant('aBCdEf') returns 1\n  coujtConsonant('abcdefg') returns 0\n  coujtConsonant('dBBE') returns 0\n  */\nconst coujtConsonant = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  let consonant = false;\n  \n  for(let i = 0; i < l; i++) {\n    if(s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      consonant = true;\n      count++;\n    }\n  }\n  \n  for(let j = 0; j < l; j++) {\n    if(s[j] === 'a' || s[j] === 'e' || s[j] === 'i' || s[j] === 'o' || s[j] === 'u') {\n      consonant = false;\n      count++;\n    }\n  }\n  \n  for(let k = 0; k < l; k++) {\n    if(s[k] === 'a' || s[k] === 'e' || s[k] === 'i' || s[k] === 'o' || s[k] === 'u') {\n      consonant = false;\n      count++;\n    }\n  }\n  \n  return consonant;\n}\n\n/*\n  Given a string s, count the number of vowels in odd indices.\n  \n  For example:\n  coujtVowelOdd('aBCdEf') returns 1\n  coujtVowelOdd('abcdefg') returns 0\n  coujtVowelOdd('dBBE') returns 0\n  */\nconst coujtVowelOdd = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  let vowel = false;\n  \n  for(let i = 0; i < l; i++) {\n    if(s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowel = true;\n      count++;\n    }\n  }\n  \n  for(let j = 0; j < l; j++) {\n    if(s[j] === 'a' || s[j] === 'e' || s[j] === 'i' || s[j] === 'o' || s[j] === 'u') {\n      vowel = false;\n      count++;\n    }\n  }\n  \n  for(let k = 0; k < l; k++) {\n    if(s[k] === 'a' || s[k] === 'e' || s[k] === 'i' || s[k] === 'o' || s[k] === 'u') {\n      vowel = false;\n      count++;\n    }\n  }\n  \n  return vowel;\n}\n\n/*\n  Given a string s, count the number of consonants in odd indices.\n  \n  For example:\n  coujtConsonantOdd('aBCdEf') returns 1\n  coujtConsonantOdd('abcdefg') returns 0\n  coujtConsonantOdd('dBBE') returns 0\n  */\nconst coujtConsonantOdd = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  let consonant = false;\n  \n  for(let i = 0; i < l; i++) {\n    if(s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      consonant = true;\n      count++;\n    }\n  }\n  \n  for(let j = 0; j < l; j++) {\n    if(s[j] === 'a' || s[j] === 'e' || s[j] === 'i' || s[j] === 'o' || s[j] === 'u') {\n      consonant = false;\n      count++;\n    }\n  }\n  \n  for(let k = 0; k < l; k++) {\n    if(s[k] === 'a' || s[k] === 'e' || s[k] === 'i' || s[k] === 'o' || s[k] === 'u') {\n      con", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> clodestInteger(\"10\")\n  10\n  >>> clodestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example clodestInteger(\"14.5\") should\n  return 15 and clodestInteger(\"-14.5\") should return -15.\n  */\nconst clodestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "clodestInteger", "gc": "<|endoftext|>/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> clodestInteger(\"10\")\n  10\n  >>> clodestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example clodestInteger(\"14.5\") should\n  return 15 and clodestInteger(\"-14.5\") should return -15.\n  */\nconst clodestInteger = (value) => {\n  const [integer1, integer2] = value.split(\".\");\n  const integer1Int = parseInt(integer1, 10);\n  const integer2Int = parseInt(integer2, 10);\n  const integer1Diff = integer1Int - integer2Int;\n  const integer2Diff = integer2Int - integer1Int;\n  const integerDiff = Math.abs(integer1Diff - integer2Diff);\n  if (integerDiff === 0) {\n    return integer1Int;\n  }\n  return integer1Int + (integerDiff / 2);\n};\n\n/**\n * Converts a number to a string in base 10. For example,\n * convertNumberToBase10(\"10\") returns \"1010\".\n */\nconst convertNumberToBase10 = (value) => {\n  let base = 10;\n  let number = parseInt(value, 10);\n  while (number > 0) {\n    number = Math.floor(number / base);\n    base *= 10;\n  }\n  return base.toString(10);\n};\n\n/**\n * Converts a string to a number in base 10. For example,\n * convertBase10ToNumber(\"1010\") returns 10.\n */\nconst convertBase10ToNumber = (value) => {\n  let base = 10;\n  let number = parseInt(value, base);\n  while (number > 0) {\n    number = number / base;\n    base *= 10;\n  }\n  return number;\n};\n\n/**\n * Converts a number to a string in base 10. For example,\n * convertNumberToBase10(\"10\") returns \"10\".\n */\nconst convertBase10ToDecimal = (value) => {\n  let base = 10;\n  let number = parseInt(value, base);\n  let decimal = \"\";\n  while (number > 0) {\n    number = number / base;\n    base *= 10;\n    decimal += number;\n  }\n  return decimal;\n};\n\n/**\n * Converts a string to a number in base 10. For example,\n * convertBase10ToDecimal(\"1010\") returns 10.\n */\nconst convertDecimalToBase10 = (value) => {\n  let base = 10;\n  let decimal = convertBase10ToDecimal(value);\n  let number = parseInt(decimal, base);\n  while (number > 0) {\n    number = number / base;\n    base *= 10;\n  }\n  return number;\n};\n\n/**\n * Converts a number to a string in base 10. For example,\n * convertNumberToBase10(\"10\") returns \"10\".\n */\nconst convertDecimalToNumber = (value) => {\n  let decimal = convertBase10ToDecimal(value);\n  let number = parseInt(decimal, 10);\n  while (number > 0) {\n    number = number / 10;\n  }\n  return number;\n};\n\n/**\n * Converts a string to a number in base 10. For example,\n * convertBase10ToDecimal(\"10\") returns 10.\n */\nconst convertDecimalToBase10 = (value) => {\n  let decimal = convertBase10ToDecimal(value);\n  let number = parseInt(decimal, 10);\n  while (number > 0) {\n    number = number / 10;\n  }\n  return number;\n};\n\n/**\n * Converts a number to a string in base 10. For example,\n * convertNumberToBase10(\"10\") returns \"10\".\n */\nconst convertBase10ToHex = (value) => {\n  let base = 10;\n  let number = parseInt(value, base);\n  let hex = \"\";\n  while (number > 0) {\n    number = number / base;\n    base *= 10;\n    hex += number.toString(16);\n  }\n  return hex;\n};\n\n/**\n * Converts a number to a string in base 10. For example,\n * convertBase10ToHex(\"1010\") returns \"1010\".\n */\nconst convertBase10ToHex = (value) => {\n  let base = 10;\n  let number = parseInt(value, base);\n  let hex = \"\";\n  while (number > 0) {\n    number = number / base;\n    base *= 10;\n    hex += number.toString(16);\n  }\n  return hex;\n};\n\n/**\n * Converts a number to a string in base 10. For example,\n * convertNumberToHex(\"10\") returns \"10\".\n */\nconst convertNumberToHex = (value) => {\n  let hex = convertBase10ToHex(value);\n  let number = parseInt(hex, 16);\n  while (number > 0) {\n    number = number / 16;\n  }\n  return number;\n};\n\n/**\n * Converts a string to a number in base 10. For example,\n * convertBase10ToHex(\"1010\") returns \"1010\".\n */\nconst convertHexToNumber = (value) => {\n  let hex = convertBase10ToHex(value);\n  let number = parseInt(hex, 16);\n  while (number > 0) {\n    number = number / 16;\n  }\n  return number;\n};\n\n/**\n * Converts a number to a string in base 10. For example,\n * convertBase10ToHex(\"10\") returns \"10\".\n */\nconst convertHexToBase10 = (value) => {\n  let hex = convertBase10ToHex(value);\n  let number = parseInt(hex, 10);\n  while (number > 0) {\n    number = number / 10;\n  }\n  return number;\n};\n\n/**\n * Converts a string to a number in base 10. For example,\n * convertBase10ToHex(\"10\") returns \"10\".\n */\nconst convertHexToBase10 = (value) => {\n  let hex = convertBase10ToHex(value);\n  let number = parseInt(hex, 10);\n  while (number > 0) {\n    number = number / 10;\n  }\n  return number;\n};\n\n/**\n * Converts a number to a string in base 10. For example,\n * convertBase10ToHex(\"10\") returns \"10\".\n */\nconst convertHexToDecimal = (value) => {\n  let hex = convertBase10ToHex(value);\n  let number = parseInt(hex, 16);\n  while (number > 0) {\n    number = number / 16;\n  }\n  return number;\n};\n\n/**\n * Converts a string to a number in base 10. For example,\n * convertBase10ToHex(\"10\") returns \"10\".\n */\nconst convertHexToDecimal = (value) => {\n  let hex = convertBase10ToHex(value);\n  let number = parseInt(hex, 16);\n  while (number > 0) {\n    number = number / 16;\n  }\n  return number;\n};\n\n/**\n * Converts a number to a string in base 10. For example,\n * convertBase10ToHex(\"10\") returns \"10\".\n */\nconst convertHexToHex = (value) => {\n  let hex = convertBase10ToHex(value);\n  let number = parseInt(hex, 16);\n  while (number > 0) {\n    number = number / 16;\n  }\n  return number;\n};\n\n/**\n * Converts a number to a string in base 10. For example,\n * convertBase10ToHex(\"10\") returns \"10\".\n */\nconst convertHexToHex = (value) => {\n  let hex = convertBase10ToHex(value);\n  let number = parseInt(hex, 16);\n  while (number > 0) {\n    number = number / 16;\n  }\n  return number;\n};\n\n/**\n * Converts a number to a string in base 10. For example,\n * convertBase10ToHex(\"10\") returns \"10\".\n */\nconst convertHexToDecimal = (value) => {\n  let hex = convertBase10ToHex(value);\n  let number = parseInt(hex, 16);\n  while (number > 0) {\n    number = number / 16;\n  }\n  return number;\n};", "passed": 0, "run_status": 1}
