{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> receiveCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> receiveCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst receiveCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "receiveCloseElements", "gc": "<|endoftext|>/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> receiveCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> receiveCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst receiveCloseElements = (numbers, threshold) => {\n  const closeElements = numbers.filter(n => Math.abs(n - threshold) < 1e-6)\n  return closeElements.length > 0\n}\n\n/**\n * Check if given list of numbers is in given list of numbers, are any two numbers\n * closer to each other than given threshold.\n * >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n * true\n * >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n * false\n */\nconst isCloseElements = (numbers, threshold) => {\n  const closeElements = numbers.filter(n => Math.abs(n - threshold) < 1e-6)\n  return closeElements.length > 0\n}\n\n/**\n * Check if given list of numbers is in given list of numbers, are any two numbers\n * closer to each other than given threshold.\n * >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n * true\n * >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n * false\n */\nconst isCloseElementsOrEqual = (numbers, threshold) => {\n  const closeElements = numbers.filter(n => Math.abs(n - threshold) < 1e-6)\n  return closeElements.length > 0\n}\n\n/**\n * Check if given list of numbers is in given list of numbers, are any two numbers\n * closer to each other than given threshold.\n * >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n * true\n * >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n * false\n */\nconst isCloseElementsOrEqualOrZero = (numbers, threshold) => {\n  const closeElements = numbers.filter(n => Math.abs(n - threshold) < 1e-6)\n  return closeElements.length > 0\n}\n\n/**\n * Check if given list of numbers is in given list of numbers, are any two numbers\n * closer to each other than given threshold.\n * >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n * true\n * >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n * false\n */\nconst isCloseElementsOrEqualOrZero = (numbers, threshold) => {\n  const closeElements = numbers.filter(n => Math.abs(n - threshold) < 1e-6)\n  return closeElements.length > 0\n}\n\n/**\n * Check if given list of numbers is in given list of numbers, are any two numbers\n * closer to each other than given threshold.\n * >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n * true\n * >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n * false\n */\nconst isCloseElementsOrEqualOrZeroOrZero = (numbers, threshold) => {\n  const closeElements = numbers.filter(n => Math.abs(n - threshold) < 1e-6)\n  return closeElements.length > 0\n}\n\n/**\n * Check if given list of numbers is in given list of numbers, are any two numbers\n * closer to each other than given threshold.\n * >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n * true\n * >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n * false\n */\nconst isCloseElementsOrEqualOrZeroOrZero = (numbers, threshold) => {\n  const closeElements = numbers.filter(n => Math.abs(n - threshold) < 1e-6)\n  return closeElements.length > 0\n}\n\n/**\n * Check if given list of numbers is in given list of numbers, are any two numbers\n * closer to each other than given threshold.\n * >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n * true\n * >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n * false\n */\nconst isCloseElementsOrEqualOrZeroOrZeroOrZero = (numbers, threshold) => {\n  const closeElements = numbers.filter(n => Math.abs(n - threshold) < 1e-6)\n  return closeElements.length > 0\n}\n\n/**\n * Check if given list of numbers is in given list of numbers, are any two numbers\n * closer to each other than given threshold.\n * >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n * true\n * >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n * false\n */\nconst isCloseElementsOrEqualOrZeroOrZeroOrZero = (numbers, threshold) => {\n  const closeElements = numbers.filter(n => Math.abs(n - threshold) < 1e-6)\n  return closeElements.length > 0\n}\n\n/**\n * Check if given list of numbers is in given list of numbers, are any two numbers\n * closer to each other than given threshold.\n * >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n * true\n * >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n * false\n */\nconst isCloseElementsOrEqualOrZeroOrZeroOrZero = (numbers, threshold) => {\n  const closeElements = numbers.filter(n => Math.abs(n - threshold) < 1e-6)\n  return closeElements.length > 0\n}\n\n/**\n * Check if given list of numbers is in given list of numbers, are any two numbers\n * closer to each other than given threshold.\n * >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n * true\n * >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n * false\n */\nconst isCloseElementsOrEqualOrZeroOrZeroOrZeroOrZero = (numbers, threshold) => {\n  const closeElements = numbers.filter(n => Math.abs(n - threshold) < 1e-6)\n  return closeElements.length > 0\n}\n\n/**\n * Check if given list of numbers is in given list of numbers, are any two numbers\n * closer to each other than given threshold.\n * >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n * true\n * >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n * false\n */\nconst isCloseElementsOrEqualOrZeroOrZeroOrZeroOrZeroOrZero = (numbers, threshold) => {\n  const closeElements = numbers.filter(n => Math.abs(n - threshold) < 1e-6)\n  return closeElements.length > 0\n}\n\n/**\n * Check if given list of numbers is in given list of numbers, are any two numbers\n * closer to each other than given threshold.\n * >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n * true\n * >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n * false\n */\nconst isCloseElementsOrEqualOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (numbers, threshold) => {\n  const closeElements = numbers.filter(n => Math.abs(n - threshold) < 1e-6)\n  return closeElements.length > 0\n}\n\n/**\n * Check if given list of numbers is in given list of numbers, are any two numbers\n * closer to each other than given threshold.\n * >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n * true\n * >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n * false\n */\nconst isCloseElementsOrEqualOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (numbers, threshold) => {\n  const closeElements = numbers.filter(n => Math.abs(n - threshold) < 1e-6)\n  return closeElements.length > 0\n}\n\n/**\n * Check if given list of numbers is in given list of numbers, are any two numbers\n * closer to each other than given threshold.\n * >>> ", "passed": 0}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> freestandingParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst freestandingParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "freestandingParenGroups", "gc": "<|endoftext|>/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> freestandingParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst freestandingParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  const paren_group_strings = [];\n  paren_groups.forEach((group) => {\n    const paren_group_string = '';\n    group.forEach((char) => {\n      if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {\n        paren_group_string += ')';\n      } else if (char === ')') {\n        paren_group_string += ')';\n      } else if (char === '(') {", "passed": 0}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "gc": "<|endoftext|>/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromePrefix = '';\n  let longestPalindromeSuffix = '';\n  let longestPalindromePrefixLength = 0;\n  let longestPalindromeSuffixLength = 0;\n\n  /* Loop through each character in the supplied string */\n  for (let i = 0; i < string.length; i++) {\n    /* If the character is a palindrome then append the character to the end of the string */\n    if (isPalindrome(string[i])) {\n      longestPalindrome += string[i];\n      longestPalindromeLength++;\n    } else {\n      /* If the character is not a palindrome then append the character to the end of the string */\n      longestPalindrome += string[i].split('').reverse().join('');\n      longestPalindromeLength++;\n    }\n  }\n\n  /* If the longest palindrome is longer than the longest palindrome prefix then append the longest palindrome prefix to the end of the string */\n  if (longestPalindromeLength > longestPalindromePrefixLength) {\n    longestPalindromePrefix = longestPalindrome.split('').reverse().join('');\n    longestPalindromePrefixLength = longestPalindromePrefix.length;\n  }\n\n  /* If the longest palindrome is longer than the longest palindrome suffix then append the longest palindrome suffix to the end of the string */\n  if (longestPalindromeLength > longestPalindromeSuffixLength) {\n    longestPalindromeSuffix = longestPalindrome.split('').reverse().join('');\n    longestPalindromeSuffixLength = longestPalindromeSuffix.length;\n  }\n\n  /* If the longest palindrome prefix is longer than the longest palindrome prefix then append the longest palindrome prefix to the end of the string */\n  if (longestPalindromePrefixLength > longestPalindromePrefixLength) {\n    longestPalindromePrefix = longestPalindromePrefix.split('').reverse().join('');\n    longestPalindromePrefixLength = longestPalindromePrefix.length;\n  }\n\n  /* If the longest palindrome suffix is longer than the longest palindrome suffix then append the longest palindrome suffix to the end of the string */\n  if (longestPalindromeSuffixLength > longestPalindromeSuffixLength) {\n    longestPalindromeSuffix = longestPalindromeSuffix.split('').reverse().join('');\n    longestPalindromeSuffixLength = longestPalindromeSuffix.length;\n  }\n\n  /* If the longest palindrome prefix and suffix are the same then return the string */\n  if (longestPalindromePrefix == longestPalindromeSuffix) {\n    return longestPalindromePrefix;\n  }\n\n  /* If the longest palindrome prefix and suffix are different then return the string with the longest palindrome prefix and suffix appended to the end of the string */\n  return longestPalindromePrefix + longestPalindromeSuffix;\n}\n\n/* Find the longest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst longestPalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromePrefix = '';\n  let longestPalindromeSuffix = '';\n  let longestPalindromePrefixLength = 0;\n  let longestPalindromeSuffixLength = 0;\n\n  /* Loop through each character in the supplied string */\n  for (let i = 0; i < string.length; i++) {\n    /* If the character is a palindrome then append the character to the end of the string */\n    if (isPalindrome(string[i])) {\n      longestPalindrome += string[i];\n      longestPalindromeLength++;\n    } else {\n      /* If the character is not a palindrome then append the character to the end of the string */\n      longestPalindrome += string[i].split('').reverse().join('');\n      longestPalindromeLength++;\n    }\n  }\n\n  /* If the longest palindrome is longer than the longest palindrome prefix then append the longest palindrome prefix to the end of the string */\n  if (longestPalindromeLength > longestPalindromePrefixLength) {\n    longestPalindromePrefix = longestPalindrome.split('').reverse().join('');\n    longestPalindromePrefixLength = longestPalindromePrefix.length;\n  }\n\n  /* If the longest palindrome is longer than the longest palindrome suffix then append the longest palindrome suffix to the end of the string */\n  if (longestPalindromeLength > longestPalindromeSuffixLength) {\n    longestPalindromeSuffix = longestPalindrome.split('').reverse().join('');\n    longestPalindromeSuffixLength = longestPalindromeSuffix.length;\n  }\n\n  /* If the longest palindrome prefix is longer than the longest palindrome prefix then append the longest palindrome prefix to the end of the string */\n  if (longestPalindromePrefixLength > longestPalindromePrefixLength) {\n    longestPalindromePrefix = longestPalindromePrefix.split('').reverse().join('');\n    longestPalindromePrefixLength = longestPalindromePrefix.length;\n  }\n\n  /* If the longest palindrome suffix is longer than the longest palindrome suffix then append the longest palindrome suffix to the end of the string */\n  if (longestPalindromeSuffixLength > longestPalindromeSuffixLength) {\n    longestPalindromeSuffix = longestPalindromeSuffix.split('').reverse().join('');\n    longestPalindromeSuffixLength = longestPalindromeSuffix.length;\n  }\n\n  /* If the longest palindrome prefix and suffix are the same then return the string */\n  if (longestPalindromePrefix == longestPalindromeSuffix) {\n    return longestPalindromePrefix;\n  }\n\n  /* If the longest palindrome prefix and suffix are different then return the string with the longest palindrome prefix and suffix appended to the end of the string */\n  return longestPalindromePrefix + longestPalindromeSuffix;\n}\n\n/* Find the longest palindrome ", "passed": 0}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(3)\n  [3, 5, 7]\n  */\nconst holdAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "holdAPile", "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(3)\n  [3, 5, 7]\n  */\nconst holdAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  let levelCount = 0;\n  while (level < n) {\n    levelCount++;\n    levels[level].push(levelCount);\n    level++;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(6)\n  [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, ", "passed": 0}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "bibleString", "gc": "<|endoftext|>/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWords = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWords(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWords(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleWordsArray(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleWordsArray(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleWordsArray = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map((word) => word.", "passed": 0}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "gc": "<|endoftext|>/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x >= y || y === 0) return -1;\n  if (x % 2 === 0 && y % 2 === 0) return x;\n  return chooseNum(y / 2, x / 2);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest odd integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x >= y || y === 0) return -1;\n  if (x % 2 === 0 && y % 2!== 0) return x;\n  return chooseNum(y / 2, x / 2);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x >= y || y === 0) return -1;\n  if (x % 2 === 0 && y % 2 === 0) return x;\n  return chooseNum(y / 2, x / 2);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x >= y || y === 0) return -1;\n  if (x % 2!== 0 && y % 2!== 0) return x;\n  return chooseNum(y / 2, x / 2);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x >= y || y === 0) return -1;\n  if (x % 2 === 0 && y % 2 === 0) return x;\n  return chooseNum(y / 2, x / 2);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x >= y || y === 0) return -1;\n  if (x % 2!== 0 && y % 2!== 0) return x;\n  return chooseNum(y / 2, x / 2);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x >= y || y === 0) return -1;\n  if (x % 2 === 0 && y % 2 === 0) return x;\n  return chooseNum(y / 2, x / 2);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x >= y || y === 0) return -1;\n  if (x % 2!== 0 && y % 2!== 0) return x;\n  return chooseNum(y / 2, x / 2);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x >= y || y === 0) return -1;\n  if (x % 2 === 0 && y % 2 === 0) return x;\n  return chooseNum(y / 2, x / 2);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x >= y || y === 0) return -1;\n  if (x % 2!== 0 && y % 2!== 0) return x;\n  return chooseNum(y / 2, x / 2);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x >= y || y === 0) return -1;\n  if (x % 2 === 0 && y % 2 === 0) return x;\n  return chooseNum(y / 2, x / 2);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x >= y || y === 0) return -1;\n  if (x % 2!== 0 && y % 2!== 0) return x;\n  return chooseNum(y / 2, x / 2);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x >= y || y === 0) return -1;\n  if (x % 2 === 0 && y % 2 === 0) return x;\n  return chooseNum(y / 2, x / 2);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x >= y || y === 0) return -1;\n  if (x % 2 === 0 && y % 2 === 0) return x;\n  return chooseNum(y / 2, x / 2);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y", "passed": 0}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "gc": "<|endoftext|>/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let binary = \"\";\n  let remainder = 0;\n  let remainder2 = 0;\n  let remainder3 = 0;\n  let remainder4 = 0;\n  let remainder5 = 0;\n  let remainder6 = 0;\n  let remainder7 = 0;\n  let remainder8 = 0;\n  let remainder9 = 0;\n  let remainder10 = 0;\n  let remainder11 = 0;\n  let remainder12 = 0;\n  let remainder13 = 0;\n  let remainder14 = 0;\n  let remainder15 = 0;\n  let remainder16 = 0;\n  let remainder17 = 0;\n  let remainder18 = 0;\n  let remainder19 = 0;\n  let remainder20 = 0;\n  let remainder21 = 0;\n  let remainder22 = 0;\n  let remainder23 = 0;\n  let remainder24 = 0;\n  let remainder25 = 0;\n  let remainder26 = 0;\n  let remainder27 = 0;\n  let remainder28 = 0;\n  let remainder29 = 0;\n  let remainder30 = 0;\n  let remainder31 = 0;\n  let remainder32 = 0;\n  let remainder33 = 0;\n  let remainder34 = 0;\n  let remainder35 = 0;\n  let remainder36 = 0;\n  let remainder37 = 0;\n  let remainder38 = 0;\n  let remainder39 = 0;\n  let remainder40 = 0;\n  let remainder41 = 0;\n  let remainder42 = 0;\n  let remainder43 = 0;\n  let remainder44 = 0;\n  let remainder45 = 0;\n  let remainder46 = 0;\n  let remainder47 = 0;\n  let remainder48 = 0;\n  let remainder49 = 0;\n  let remainder50 = 0;\n  let remainder51 = 0;\n  let remainder52 = 0;\n  let remainder53 = 0;\n  let remainder54 = 0;\n  let remainder55 = 0;\n  let remainder56 = 0;\n  let remainder57 = 0;\n  let remainder58 = 0;\n  let remainder59 = 0;\n  let remainder60 = 0;\n  let remainder61 = 0;\n  let remainder62 = 0;\n  let remainder63 = 0;\n  let remainder64 = 0;\n  let remainder65 = 0;\n  let remainder66 = 0;\n  let remainder67 = 0;\n  let remainder68 = 0;\n  let remainder69 = 0;\n  let remainder70 = 0;\n  let remainder71 = 0;\n  let remainder72 = 0;\n  let remainder73 = 0;\n  let remainder74 = 0;\n  let remainder75 = 0;\n  let remainder76 = 0;\n  let remainder77 = 0;\n  let remainder78 = 0;\n  let remainder79 = 0;\n  let remainder80 = 0;\n  let remainder81 = 0;\n  let remainder82 = 0;\n  let remainder83 = 0;\n  let remainder84 = 0;\n  let remainder85 = 0;\n  let remainder86 = 0;\n  let remainder87 = 0;\n  let remainder88 = 0;\n  let remainder89 = 0;\n  let remainder90 = 0;\n  let remainder91 = 0;\n  let remainder92 = 0;\n  let remainder93 = 0;\n  let remainder94 = 0;\n  let remainder95 = 0;\n  let remainder96 = 0;\n  let remainder97 = 0;\n  let remainder98 = 0;\n  let remainder99 = 0;\n  let remainder100 = 0;\n  let remainder101 = 0;\n  let remainder102 = 0;\n  let remainder103 = 0;\n  let remainder104 = 0;\n  let remainder105 = 0;\n  let remainder106 = 0;\n  let remainder107 = 0;\n  let remainder108 = 0;\n  let remainder109 = 0;\n  let remainder110 = 0;\n  let remainder111 = 0;\n  let remainder112 = 0;\n  let remainder113 = 0;\n  let remainder114 = 0;\n  let remainder115 = 0;\n  let remainder116 = 0;\n  let remainder117 = 0;\n  let remainder118 = 0;\n  let remainder119 = 0;\n  let remainder120 = 0;\n  let remainder121 = 0;\n  let remainder122 = 0;\n  let remainder123 = 0;\n  let remainder124 = 0;\n  let remainder125 = 0;\n  let remainder126 = 0;\n  let remainder127 = 0;\n  let remainder128 = 0;\n  let remainder129 = 0;\n  let remainder130 = 0;\n  let remainder131 = 0;\n  let remainder132 = 0;\n  let remainder133 = 0;\n  let remainder134 = 0;\n  let remainder135 = 0;\n  let remainder136 = 0;\n  let remainder137 = 0;\n  let remainder138 = 0;\n  let remainder139 = 0;\n  let remainder140 = 0;\n  let remainder141 = 0;\n  let remainder142 = 0;\n  let remainder143 = 0;\n  let remainder144 = 0;\n  let remainder145 = 0;\n  let remainder146 = 0;\n  let remainder147 = 0;\n  let remainder148 = 0;\n  let remainder149 = 0;\n  let remainder150 = 0;\n  let remainder151 = 0;\n  let remainder152 = 0;\n  let remainder153 = 0;\n  let remainder154 = 0;\n  let remainder155 = 0;\n  let remainder156 = 0;\n  let remainder157 = 0;\n  let remainder158 = 0;\n  let remainder159 = 0;\n  let remainder160 = 0;\n  let remainder161 = 0;\n  let remainder162 = 0;\n  let remainder163 = 0;\n  let remainder164 = 0;\n  let remainder165 = 0;\n  let remainder166 = 0;\n  let remainder167 = 0;\n  let remainder168 = 0;\n  let remainder169 = 0;\n  let remainder170 = 0;\n  let remainder171 = 0;\n  let remainder172 = 0;\n  let remainder173 = 0;\n  let remainder174 = 0;\n  let remainder175 = 0;\n  let remainder176 = 0;\n  let remainder177 = 0;\n  let remainder178 = 0;\n  let remainder179 = 0;\n  let remainder180 = 0;\n  let remainder181 = 0;\n  let remainder182 = 0;\n  let remainder183 = 0;\n  let remainder184 = 0;\n  let remainder185 = 0;\n  let remainder186 = 0;\n  let remainder187 = 0;\n  let remainder188 = 0;\n  let remainder189 = 0;\n  let remainder190 = 0;\n  let remainder191 = 0;\n  let remainder192 = 0;\n  let remainder193 = 0;\n  let remainder194 = 0;\n  let remainder195 = 0;\n  let remainder196 = 0;\n  let remainder197 = 0;\n  let remainder198 = 0;\n  let remainder199 = 0;\n  let remainder200 = 0;\n  let remainder201 = 0;\n  let remainder202 = 0;\n  let remainder203 = 0;\n  let remainder204 = 0;\n  let remainder205 = 0;\n  let remainder206 = 0;\n  let remainder207 = 0;\n  let remainder208 = 0;\n  let remainder209 = 0;\n  let remainder210 = 0;\n  let remainder211 = 0;\n  let remainder212 = 0;\n  let remainder213 = 0;\n  let remainder214 = 0;\n  let remainder215 = 0;\n  let remainder216 = 0;\n  let remainder217 = 0;\n  let remainder218 = 0;\n  let remainder219 = 0;\n  let remainder220 = 0;\n  let remainder221 = 0;\n  let remainder222 = 0;\n  let remainder223 = 0;\n  let remainder224 = 0;\n  let remainder225 = 0;\n  let remainder226 = 0;\n  let remainder227 = 0;\n  let remainder228 = 0;\n  let remainder229 = 0;\n  let remainder230 = 0;\n  let remainder231 = 0;\n  let remainder232 = 0;\n  let remainder233 = 0;\n  let remainder234 = 0;\n  let remainder235 = 0;\n  let remainder236", "passed": 0}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> aloneDigit([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> aloneDigit([152, 323, 1422, 10])\n  []\n  */\nconst aloneDigit = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "aloneDigit", "gc": "<|endoftext|>/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> aloneDigit([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> aloneDigit([152, 323, 1422, 10])\n  []\n  */\nconst aloneDigit = (x) => {\n  let result = []\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0) {\n      result.push(x[i])\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has only odd digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> aloneDigit([15, 33, 1422, 1])\n  [15, 33]\n  >>> aloneDigit([152, 323, 1422, 10])\n  []\n  */\nconst aloneOddDigit = (x) => {\n  let result = []\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2!== 0) {\n      result.push(x[i])\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has only even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> aloneOddDigit([15, 33, 1422, 1])\n  [15, 33]\n  >>> aloneOddDigit([152, 323, 1422, 10])\n  []\n  */\nconst aloneEvenDigit = (x) => {\n  let result = []\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0) {\n      result.push(x[i])\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has only odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> aloneOddEvenDigit([15, 33, 1422, 1])\n  [15, 33]\n  >>> aloneOddEvenDigit([152, 323, 1422, 10])\n  []\n  */\nconst aloneOddEvenDigit = (x) => {\n  let result = []\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0 || x[i] % 2 === 1) {\n      result.push(x[i])\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has only even or odd digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> aloneOddEvenDigit([15, 33, 1422, 1])\n  [15, 33]\n  >>> aloneOddEvenDigit([152, 323, 1422, 10])\n  []\n  */\nconst aloneOddOddDigit = (x) => {\n  let result = []\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0 || x[i] % 2 === 1) {\n      result.push(x[i])\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has only odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> aloneOddOddEvenDigit([15, 33, 1422, 1])\n  [15, 33]\n  >>> aloneOddOddEvenDigit([152, 323, 1422, 10])\n  []\n  */\nconst aloneOddEvenOddDigit = (x) => {\n  let result = []\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0 || x[i] % 2 === 1) {\n      result.push(x[i])\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has only odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> aloneOddEvenOddDigit([15, 33, 1422, 1])\n  [15, 33]\n  >>> aloneOddEvenOddDigit([152, 323, 1422, 10])\n  []\n  */\nconst aloneOddOddEvenOddDigit = (x) => {\n  let result = []\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0 || x[i] % 2 === 1) {\n      result.push(x[i])\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has only odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> aloneOddOddEvenOddDigit([15, 33, 1422, 1])\n  [15, 33]\n  >>> aloneOddOddEvenOddDigit([152, 323, 1422, 10])\n  []\n  */\nconst aloneOddOddOddEvenOddDigit = (x) => {\n  let result = []\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0 || x[i] % 2 === 1) {\n      result.push(x[i])\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has only odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> aloneOddOddEvenOddDigit([15, 33, 1422, 1])\n  [15, 33]\n  >>> aloneOddOddEvenOddDigit([152, 323, 1422, 10])\n  []\n  */\nconst aloneOddOddOddOddEvenOddDigit = (x) => {\n  let result = []\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0 || x[i] % 2 === 1) {\n      result.push(x[i])\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has only odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> aloneOddOddOddEvenOddDigit([15, 33, 1422, 1])\n  [15, 33]\n  >>> aloneOddOddOddEvenOddDigit([152, 323, 1422, 10])\n  []\n  */\nconst aloneOddOddOddOddEvenOddDigit = (x) => {\n  let result = []\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0 || x[i] % 2 === 1) {\n      result.push(x[i])\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has only odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> aloneOddOddOddEvenOddDigit([15, 33, 1422, 1])\n  [15, 33]\n  >>> aloneOddOddOddEvenOddDigit([152, 323, 1422, 10])\n  []\n  */\nconst aloneOddOddOddOddEvenOddDigit = (x) => {\n  let result = []\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0 || x[i] % 2 === 1) {\n      result.push(x[i])\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has only odd or even digit.\n\n  Note: Returned list should be sorted in incre", "passed": 0}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byDuration = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byDuration", "gc": "<|endoftext|>/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byDuration = (arr) => {\n  const durations = [\n    { duration: 1, name: 'One' },\n    { duration: 2, name: 'Two' },\n    { duration: 3, name: 'Three' },\n    { duration: 4, name: 'Four' },\n    { duration: 5, name: 'Five' },\n    { duration: 6, name: 'Six' },\n    { duration: 7, name: 'Seven' },\n    { duration: 8, name: 'Eight' },\n    { duration: 9, name: 'Nine' }\n  ];\n  const reversed = arr.slice().reverse();\n  return durations.map(({ duration, name }) => ({\n    duration: duration,\n    name: name\n  })).concat(reversed);\n};\n\nconst byDurationAndName = (arr) => {\n  const durations = [\n    { duration: 1, name: 'One' },\n    { duration: 2, name: 'Two' },\n    { duration: 3, name: 'Three' },\n    { duration: 4, name: 'Four' },\n    { duration: 5, name: 'Five' },\n    { duration: 6, name: 'Six' },\n    { duration: 7, name: 'Seven' },\n    { duration: 8, name: 'Eight' },\n    { duration: 9, name: 'Nine' }\n  ];\n  const reversed = arr.slice().reverse();\n  return durations.map(({ duration, name }) => ({\n    duration: duration,\n    name: name\n  })).concat(reversed);\n};\n\nconst byDurationAndNameAndDuration = (arr) => {\n  const durations = [\n    { duration: 1, name: 'One' },\n    { duration: 2, name: 'Two' },\n    { duration: 3, name: 'Three' },\n    { duration: 4, name: 'Four' },\n    { duration: 5, name: 'Five' },\n    { duration: 6, name: 'Six' },\n    { duration: 7, name: 'Seven' },\n    { duration: 8, name: 'Eight' },\n    { duration: 9, name: 'Nine' }\n  ];\n  const reversed = arr.slice().reverse();\n  return durations.map(({ duration, name }) => ({\n    duration: duration,\n    name: name\n  })).concat(reversed);\n};\n\nconst byDurationAndNameAndDurationAndDuration = (arr) => {\n  const durations = [\n    { duration: 1, name: 'One' },\n    { duration: 2, name: 'Two' },\n    { duration: 3, name: 'Three' },\n    { duration: 4, name: 'Four' },\n    { duration: 5, name: 'Five' },\n    { duration: 6, name: 'Six' },\n    { duration: 7, name: 'Seven' },\n    { duration: 8, name: 'Eight' },\n    { duration: 9, name: 'Nine' }\n  ];\n  const reversed = arr.slice().reverse();\n  return durations.map(({ duration, name }) => ({\n    duration: duration,\n    name: name\n  })).concat(reversed);\n};\n\nconst byDurationAndNameAndDurationAndDurationAndDuration = (arr) => {\n  const durations = [\n    { duration: 1, name: 'One' },\n    { duration: 2, name: 'Two' },\n    { duration: 3, name: 'Three' },\n    { duration: 4, name: 'Four' },\n    { duration: 5, name: 'Five' },\n    { duration: 6, name: 'Six' },\n    { duration: 7, name: 'Seven' },\n    { duration: 8, name: 'Eight' },\n    { duration: 9, name: 'Nine' }\n  ];\n  const reversed = arr.slice().reverse();\n  return durations.map(({ duration, name }) => ({\n    duration: duration,\n    name: name\n  })).concat(reversed);\n};\n\nconst byDurationAndNameAndDurationAndDurationAndDurationAndDuration = (arr) => {\n  const durations = [\n    { duration: 1, name: 'One' },\n    { duration: 2, name: 'Two' },\n    { duration: 3, name: 'Three' },\n    { duration: 4, name: 'Four' },\n    { duration: 5, name: 'Five' },\n    { duration: 6, name: 'Six' },\n    { duration: 7, name: 'Seven' },\n    { duration: 8, name: 'Eight' },\n    { duration: 9, name: 'Nine' }\n  ];\n  const reversed = arr.slice().reverse();\n  return durations.map(({ duration, name }) => ({\n    duration: duration,\n    name: name\n  })).concat(reversed);\n};\n\nconst byDurationAndNameAndDurationAndDurationAndDurationAndDuration = (arr) => {\n  const durations = [\n    { duration: 1, name: 'One' },\n    { duration: 2, name: 'Two' },\n    { duration: 3, name: 'Three' },\n    { duration: 4, name: 'Four' },\n    { duration: 5, name: 'Five' },\n    { duration: 6, name: 'Six' },\n    { duration: 7, name: 'Seven' },\n    { duration: 8, name: 'Eight' },\n    { duration: 9, name: 'Nine' }\n  ];\n  const reversed = arr.slice().reverse();\n  return durations.map(({ duration, name }) => ({\n    duration: duration,\n    name: name\n  })).concat(reversed);\n};\n\nconst byDurationAndNameAndDurationAndDurationAndDurationAndDurationAndDuration = (arr) => {\n  const durations = [\n    { duration: 1, name: 'One' },\n    { duration: 2, name: 'Two' },\n    { duration: 3, name: 'Three' },\n    { duration: 4, name: 'Four' },\n    { duration: 5, name: 'Five' },\n    { duration: 6, name: 'Six' },\n    { duration: 7, name: 'Seven' },\n    { duration: 8, name: 'Eight' },\n    { duration: 9, name: 'Nine' }\n  ];\n  const reversed = arr.slice().reverse();\n  return durations.map(({ duration, name }) => ({\n    duration: duration,\n    name: name\n  })).concat(reversed);\n};\n\nconst byDurationAndNameAndDurationAndDurationAndDurationAndDurationAndDurationAndDuration = (arr) => {\n  const durations = [\n    { duration: 1, name: 'One' },\n    { duration: 2, name: 'Two' },\n    { duration: 3, name: 'Three' },\n    { duration: 4, name: 'Four' },\n    { duration: 5, name: 'Five' },\n    { duration: 6, name: 'Six' },\n    { duration: 7, name: 'Seven' },\n    { duration: 8, name: 'Eight' },\n    { duration: 9, name: 'Nine' }\n  ];\n  const reversed = arr.slice().reverse();\n  return durations.map(({ duration, name }) => ({\n    duration: duration,\n    name: name\n  })).concat(reversed);\n};\n\nconst byDurationAndNameAndDurationAndDurationAndDurationAndDurationAndDurationAndDurationAndDuration = (arr) => {\n  const durations = [\n    { duration: 1, name: 'One' },\n    { duration: 2, name: 'Two' },\n    { duration: 3, name: 'Three' },\n    { duration: 4, name: 'Four' },\n    { duration: 5, name: 'Five' },\n    { duration: 6, name: 'Six' },\n    { duration: 7, name: 'Seven' },\n    { duration: 8, name: 'Eight' },\n    { duration: 9, name: 'Nine' }\n  ];\n  const reversed = ", "passed": 0}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "gc": "<|endoftext|>/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr));\n    }\n  }\n  return result;\n};\n\n/* Implement the function g that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  g(5) == [1, 1, 2, 6, 24]\n  */\nconst g = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr));\n    }\n  }\n  return result;\n};\n\n/* Implement the function h that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  h(5) == [1, 1, 2, 6, 24]\n  */\nconst h = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr));\n    }\n  }\n  return result;\n};\n\n/* Implement the function i that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  i(5) == [1, 1, 2, 6, 24]\n  */\nconst i = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr));\n    }\n  }\n  return result;\n};\n\n/* Implement the function j that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  j(5) == [1, 1, 2, 6, 24]\n  */\nconst j = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr));\n    }\n  }\n  return result;\n};\n\n/* Implement the function k that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  k(5) == [1, 1, 2, 6, 24]\n  */\nconst k = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr));\n    }\n  }\n  return result;\n};\n\n/* Implement the function l that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  l(5) == [1, 1, 2, 6, 24]\n  */\nconst l = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr));\n    }\n  }\n  return result;\n};\n\n/* Implement the function m that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  m(5) == [1, 1, 2, 6, 24]\n  */\nconst m = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr));\n    }\n  }\n  return result;\n};\n\n/* Implement the function n that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  n(5) == [1, 1, 2, 6, 24]\n  */\nconst n = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr));\n    }\n  }\n  return result;\n};\n\n/* Implement the function o that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  o(5) == [1, 1, 2, 6, 24]\n  */\nconst o = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr));\n    }\n  }\n  return result;\n};\n\n/* Implement the function p that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (", "passed": 0}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindromes.push(i);\n      count++;\n    } else {\n      oddPalindromes.push(i);\n      count++;\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a positive integer n, return an integer array that has all possible palindromes up to n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All integer palindromes upto n are unique.\n*/\nconst palindromes = (num) => {\n  const palindromes = [];\n  let count = 0;\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      palindromes.push(i);\n      count++;\n    } else {\n      palindromes.push(num);\n      count++;\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return an integer array that has all possible palindromes up to n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All integer palindromes upto n are unique.\n*/\nconst palindromesUpTo = (num) => {\n  const palindromes = [];\n  let count = 0;\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      palindromes.push(num);\n      count++;\n    } else {\n      palindromes.push(num % i);\n      count++;\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return an integer array that has all possible palindromes up to n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All integer palindromes upto n are unique.\n*/\nconst palindromesUpTo = (num) => {\n  const palindromes = [];\n  let count = 0;\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      palindromes.push(num % i);\n      count++;\n    } else {\n      palindromes.push(num);\n      count++;\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return an integer array that has all possible palindromes up to n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All integer palindromes upto n are unique.\n*/\nconst palindromesUpTo = (num) => {\n  const palindromes = [];\n  let count = 0;\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      palindromes.push(num % i);\n      count++;\n    } else {\n      palindromes.push(num);\n      count++;\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return an integer array that has all possible palindromes up to n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All integer palindromes upto n are unique.\n*/\nconst palindromesUpTo = (num) => {\n  const palindromes = [];\n  let count = 0;\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      palindromes.push(num % i);\n      count++;\n    } else {\n      palindromes.push(num);\n      count++;\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return an integer array that has all possible palindromes up to n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All integer palindromes upto n are unique.\n*/\nconst palindromesUpTo = (num) => {\n  const palindromes = [];\n  let count = 0;\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      palindromes.push(num % i);\n      count++;\n    } else {\n      palindromes.push(num);\n      count++;\n    }\n  }", "passed": 0}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function considerNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> considerNums([]) == 0\n  >>> considerNums([-1, 11, -11]) == 1\n  >>> considerNums([1, 1, 2]) == 3\n  */\nconst considerNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "considerNums", "gc": "<|endoftext|>/*\n  Write a function considerNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> considerNums([]) == 0\n  >>> considerNums([-1, 11, -11]) == 1\n  >>> considerNums([1, 1, 2]) == 3\n  */\nconst considerNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const num = arr[i];\n    if (num < 0) {\n      num *= -1;\n      sum += num;\n    }\n  }\n  return sum;\n};\n\n/**\n * Given an array of integers, return an array with unique elements,\n * such that no two elements appear more than once.\n * e.g. [1, 1, 1, 2, 2, 3] -> [1, 2, 3]\n */\nconst unique = (arr) => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (seen.has(arr[i])) {\n      continue;\n    }\n    seen.add(arr[i]);\n    result.push(arr[i]);\n  }\n  return result;\n};\n\n/**\n * Given an array of integers, return an array with unique elements,\n * such that no two elements appear more than once.\n * e.g. [1, 1, 1, 2, 2, 3] -> [1, 2, 3]\n */\nconst uniqueWith = (arr, fn) => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (seen.has(arr[i])) {\n      continue;\n    }\n    seen.add(arr[i]);\n    result.push(fn(arr[i]));\n  }\n  return result;\n};\n\n/**\n * Given an array of integers, return an array with unique elements,\n * such that no two elements appear more than once.\n * e.g. [1, 1, 1, 2, 2, 3] -> [1, 2, 3]\n */\nconst uniqueWithKeys = (arr, fn) => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (seen.has(arr[i])) {\n      continue;\n    }\n    seen.add(arr[i]);\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n  }\n  return result;\n};\n\n/**\n * Given an array of integers, return an array with unique elements,\n * such that no two elements appear more than once.\n * e.g. [1, 1, 1, 2, 2, 3] -> [1, 2, 3]\n */\nconst uniqueWithKeysAnd = (arr, fn) => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (seen.has(arr[i])) {\n      continue;\n    }\n    seen.add(arr[i]);\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n  }\n  return result;\n};\n\n/**\n * Given an array of integers, return an array with unique elements,\n * such that no two elements appear more than once.\n * e.g. [1, 1, 1, 2, 2, 3] -> [1, 2, 3]\n */\nconst uniqueWithKeysAndWith = (arr, fn) => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (seen.has(arr[i])) {\n      continue;\n    }\n    seen.add(arr[i]);\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n  }\n  return result;\n};\n\n/**\n * Given an array of integers, return an array with unique elements,\n * such that no two elements appear more than once.\n * e.g. [1, 1, 1, 2, 2, 3] -> [1, 2, 3]\n */\nconst uniqueWithKeysAndWithKeys = (arr, fn) => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (seen.has(arr[i])) {\n      continue;\n    }\n    seen.add(arr[i]);\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n  }\n  return result;\n};\n\n/**\n * Given an array of integers, return an array with unique elements,\n * such that no two elements appear more than once.\n * e.g. [1, 1, 1, 2, 2, 3] -> [1, 2, 3]\n */\nconst uniqueWithKeysAndWithKeysAnd = (arr, fn) => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (seen.has(arr[i])) {\n      continue;\n    }\n    seen.add(arr[i]);\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n  }\n  return result;\n};\n\n/**\n * Given an array of integers, return an array with unique elements,\n * such that no two elements appear more than once.\n * e.g. [1, 1, 1, 2, 2, 3] -> [1, 2, 3]\n */\nconst uniqueWithKeysAndWithKeysAndWith = (arr, fn) => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (seen.has(arr[i])) {\n      continue;\n    }\n    seen.add(arr[i]);\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n  }\n  return result;\n};\n\n/**\n * Given an array of integers, return an array with unique elements,\n * such that no two elements appear more than once.\n * e.g. [1, 1, 1, 2, 2, 3] -> [1, 2, 3]\n */\nconst uniqueWithKeysAndWithKeysAndWithKeysAnd = (arr, fn) => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (seen.has(arr[i])) {\n      continue;\n    }\n    seen.add(arr[i]);\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr[i]);\n    if (key!== undefined) {\n      result.push(key);\n    }\n    const key = fn(arr", "passed": 0}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  affectOneTestis([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  affectOneTestis([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst affectOneTestis = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "affectOneTestis", "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  affectOneTestis([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  affectOneTestis([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst affectOneTestis = (arr) => {\n  const arrLen = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let flag = true;\n  while (i < arrLen) {\n    while (j < arrLen) {\n      if (arr[i] > arr[j]) {\n        flag = false;\n        break;\n      }\n      j++;\n    }\n    if (flag) {\n      flag = false;\n      break;\n    }\n    i++;\n  }\n  return flag;\n};\n\n/*\n  Given an array of integers arr[], find the maximum element in the array.\n  \n  Return arr[0] if arr is empty or if arr[0] is greater than arr[1], otherwise\n  return arr[1]\n  \n  Note: The given array is guaranteed to have unique elements.\n  \n  */\nconst maxElement = (arr) => {\n  let max = 0;\n  let maxElement = 0;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    while (j < arr.length) {\n      if (arr[i] > arr[j]) {\n        max = arr[i];\n        maxElement = arr[j];\n        break;\n      }\n      j++;\n    }\n    i++;\n  }\n  return maxElement;\n};\n\n/*\n  Given an array of integers arr[], find the minimum element in the array.\n  \n  Return arr[0] if arr is empty or if arr[0] is less than arr[1], otherwise\n  return arr[1]\n  \n  Note: The given array is guaranteed to have unique elements.\n  \n  */\nconst minElement = (arr) => {\n  let min = 0;\n  let minElement = 0;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    while (j < arr.length) {\n      if (arr[i] < arr[j]) {\n        min = arr[i];\n        minElement = arr[j];\n        break;\n      }\n      j++;\n    }\n    i++;\n  }\n  return minElement;\n};\n\n/*\n  Given an array of integers arr[], find the maximum element in the array.\n  \n  Return arr[0] if arr is empty or if arr[0] is greater than arr[1], otherwise\n  return arr[1]\n  \n  Note: The given array is guaranteed to have unique elements.\n  \n  */\nconst maxElementInArray = (arr) => {\n  let max = 0;\n  let maxElement = 0;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    while (j < arr.length) {\n      if (arr[i] > arr[j]) {\n        max = arr[i];\n        maxElement = arr[j];\n        break;\n      }\n      j++;\n    }\n    i++;\n  }\n  return maxElement;\n};\n\n/*\n  Given an array of integers arr[], find the minimum element in the array.\n  \n  Return arr[0] if arr is empty or if arr[0] is less than arr[1], otherwise\n  return arr[1]\n  \n  Note: The given array is guaranteed to have unique elements.\n  \n  */\nconst minElementInArray = (arr) => {\n  let min = 0;\n  let minElement = 0;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    while (j < arr.length) {\n      if (arr[i] < arr[j]) {\n        min = arr[i];\n        minElement = arr[j];\n        break;\n      }\n      j++;\n    }\n    i++;\n  }\n  return minElement;\n};\n\n/*\n  Given an array of integers arr[], find the maximum element in the array.\n  \n  Return arr[0] if arr is empty or if arr[0] is greater than arr[1], otherwise\n  return arr[1]\n  \n  Note: The given array is guaranteed to have unique elements.\n  \n  */\nconst maxElementInArrayInArray = (arr) => {\n  let max = 0;\n  let maxElement = 0;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    while (j < arr.length) {\n      if (arr[i] > arr[j]) {\n        max = arr[i];\n        maxElement = arr[j];\n        break;\n      }\n      j++;\n    }\n    i++;\n  }\n  return maxElement;\n};\n\n/*\n  Given an array of integers arr[], find the minimum element in the array.\n  \n  Return arr[0] if arr is empty or if arr[0] is less than arr[1], otherwise\n  return arr[1]\n  \n  Note: The given array is guaranteed to have unique elements.\n  \n  */\nconst minElementInArrayInArray = (arr) => {\n  let min = 0;\n  let minElement = 0;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    while (j < arr.length) {\n      if (arr[i] < arr[j]) {\n        min = arr[i];\n        minElement = arr[j];\n        break;\n      }\n      j++;\n    }\n    i++;\n  }\n  return minElement;\n};\n\n/*\n  Given an array of integers arr[], find the maximum element in the array.\n  \n  Return arr[0] if arr is empty or if arr[0] is greater than arr[1], otherwise\n  return arr[1]\n  \n  Note: The given array is guaranteed to have unique elements.\n  \n  */\nconst maxElementInArrayInArrayInArray = (arr) => {\n  let max = 0;\n  let maxElement = 0;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    while (j < arr.length) {\n      if (arr[i] > arr[j]) {\n        max = arr[i];\n        maxElement = arr[j];\n        break;\n      }\n      j++;\n    }\n    i++;\n  }\n  return maxElement;\n};\n\n/*\n  Given an array of integers arr[], find the minimum element in the array.\n  \n  Return arr[0] if arr is empty or if arr[0] is less than arr[1], otherwise\n  return arr[1]\n  \n  Note: The given array is guaranteed to have unique elements.\n  \n  */\nconst minElementInArrayInArrayInArray = (arr) => {\n  let min = 0;\n  let minElement = 0;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    while (j < arr.length) {\n      if (arr[i] < arr[j]) {\n        min = arr[i];\n        minElement = arr[j];\n        break;\n      }\n      j++;\n    }\n    i++;\n  }\n  return minElement;\n};\n\n/*\n  Given an array of integers arr[], find the maximum element in the array.\n  \n  Return arr[0] if arr is empty or if arr[0] is greater than arr[1], otherwise\n  return arr[1]\n  \n  Note: The given array is guaranteed to have unique elements.\n  \n  */\nconst maxElementInArrayInArrayInArrayInArray = (arr) => {\n  let max = 0;\n  let maxElement = 0;\n  let i = 0;\n  let j = 0;\n  while (i < arr.length) {\n    while (j < arr.length) {\n      if (arr[i] > arr[j]) {\n        max = arr[i];\n        maxElement = arr[j];\n        break;\n      }\n      j", "passed": 0}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor('010', '110')\n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "bowedStringedInstrumentXor", "gc": "<|endoftext|>/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor('010', '110')\n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentOr(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentOr(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentOr(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentOr(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentOr(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(['010', '110'])\n  '100'\n  */\nconst bowedStringedInstrumentAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += ", "passed": 0}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an central of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of centrald elements between lst1 and lst2.\n  If it is possible to central elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  central([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  central([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst central = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "central", "gc": "<|endoftext|>/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an central of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of centrald elements between lst1 and lst2.\n  If it is possible to central elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  central([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  central([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst central = (lst1, lst2) => {\n  let centralNumber = 0;\n  let centralNumbers = [];\n  let centralNumbersSet = new Set();\n  let centralNumbersSetSet = new Set();\n  let centralNumbersSetSetSet = new Set();\n  let centralNumbersSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetSet = new Set();\n  let centralNumbersSetSetSetSetSetSetSetSetSetSetSetSetSet", "passed": 0}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "gc": "<|endoftext|>/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  let letter;\n  let letterCount;\n  let letterCounts = {};\n  for (let i = 0; i < letters.length; i++) {\n    letter = letters[i];\n    letterCount = counts[letter] || 0;\n    counts[letter] = letterCount + 1;\n    letterCounts[letter] = letterCount;\n  }\n  return letterCounts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  let letter;\n  let letterCount;\n  let letterCounts = {};\n  for (let i = 0; i < letters.length; i++) {\n    letter = letters[i];\n    letterCount = counts[letter] || 0;\n    counts[letter] = letterCount + 1;\n    letterCounts[letter] = letterCount;\n  }\n  return letterCounts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  let letter;\n  let letterCount;\n  let letterCounts = {};\n  for (let i = 0; i < letters.length; i++) {\n    letter = letters[i];\n    letterCount = counts[letter] || 0;\n    counts[letter] = letterCount + 1;\n    letterCounts[letter] = letterCount;\n  }\n  return letterCounts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  let letter;\n  let letterCount;\n  let letterCounts = {};\n  for (let i = 0; i < letters.length; i++) {\n    letter = letters[i];\n    letterCount = counts[letter] || 0;\n    counts[letter] = letterCount + 1;\n    letterCounts[letter] = letterCount;\n  }\n  return letterCounts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  let letter;\n  let letterCount;\n  let letterCounts = {};\n  for (let i = 0; i < letters.length; i++) {\n    letter = letters[i];\n    letterCount = counts[letter] || 0;\n    counts[letter] = letterCount + 1;\n    letterCounts[letter] = letterCount;\n  }\n  return letterCounts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  let letter;\n  let letterCount;\n  let letterCounts = {};\n  for (let i = 0; i < letters.length; i++) {\n    letter = letters[i];\n    letterCount = counts[letter] || 0;\n    counts[letter] = letterCount + 1;\n    letterCounts[letter] = letterCount;\n  }\n  return letterCounts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  let letter;\n  let letterCount;\n  let letterCounts = {};\n  for (let i = 0; i < letters.length; i++) {\n    letter = letters[i];\n    letterCount = counts[letter] || 0;\n    counts[letter] = letterCount + 1;\n    letterCounts[letter] = letterCount;\n  }\n  return letterCounts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  let letter;\n  let letterCount;\n  let letterCounts = {};\n  for (let i = 0; i < letters.length; i++) {\n    letter = letters[i];\n    letterCount = counts[letter] || 0;\n    counts[letter] = letterCount + 1;\n    letterCounts[letter] = letterCount;\n  }\n  return letterCounts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  ", "passed": 0}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst invertDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "invertDelete", "gc": "<|endoftext|>/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst invertDelete = (s, c) => {\n  let result = '';\n  let reversed = '';\n  let reversedChar = '';\n  let reversedCharIndex = 0;\n  let reversedCharIndex2 = 0;\n  let reversedCharIndex3 = 0;\n  let reversedCharIndex4 = 0;\n  let reversedCharIndex5 = 0;\n  let reversedCharIndex6 = 0;\n  let reversedCharIndex7 = 0;\n  let reversedCharIndex8 = 0;\n  let reversedCharIndex9 = 0;\n  let reversedCharIndex10 = 0;\n  let reversedCharIndex11 = 0;\n  let reversedCharIndex12 = 0;\n  let reversedCharIndex13 = 0;\n  let reversedCharIndex14 = 0;\n  let reversedCharIndex15 = 0;\n  let reversedCharIndex16 = 0;\n  let reversedCharIndex17 = 0;\n  let reversedCharIndex18 = 0;\n  let reversedCharIndex19 = 0;\n  let reversedCharIndex20 = 0;\n  let reversedCharIndex21 = 0;\n  let reversedCharIndex22 = 0;\n  let reversedCharIndex23 = 0;\n  let reversedCharIndex24 = 0;\n  let reversedCharIndex25 = 0;\n  let reversedCharIndex26 = 0;\n  let reversedCharIndex27 = 0;\n  let reversedCharIndex28 = 0;\n  let reversedCharIndex29 = 0;\n  let reversedCharIndex30 = 0;\n  let reversedCharIndex31 = 0;\n  let reversedCharIndex32 = 0;\n  let reversedCharIndex33 = 0;\n  let reversedCharIndex34 = 0;\n  let reversedCharIndex35 = 0;\n  let reversedCharIndex36 = 0;\n  let reversedCharIndex37 = 0;\n  let reversedCharIndex38 = 0;\n  let reversedCharIndex39 = 0;\n  let reversedCharIndex40 = 0;\n  let reversedCharIndex41 = 0;\n  let reversedCharIndex42 = 0;\n  let reversedCharIndex43 = 0;\n  let reversedCharIndex44 = 0;\n  let reversedCharIndex45 = 0;\n  let reversedCharIndex46 = 0;\n  let reversedCharIndex47 = 0;\n  let reversedCharIndex48 = 0;\n  let reversedCharIndex49 = 0;\n  let reversedCharIndex50 = 0;\n  let reversedCharIndex51 = 0;\n  let reversedCharIndex52 = 0;\n  let reversedCharIndex53 = 0;\n  let reversedCharIndex54 = 0;\n  let reversedCharIndex55 = 0;\n  let reversedCharIndex56 = 0;\n  let reversedCharIndex57 = 0;\n  let reversedCharIndex58 = 0;\n  let reversedCharIndex59 = 0;\n  let reversedCharIndex60 = 0;\n  let reversedCharIndex61 = 0;\n  let reversedCharIndex62 = 0;\n  let reversedCharIndex63 = 0;\n  let reversedCharIndex64 = 0;\n  let reversedCharIndex65 = 0;\n  let reversedCharIndex66 = 0;\n  let reversedCharIndex67 = 0;\n  let reversedCharIndex68 = 0;\n  let reversedCharIndex69 = 0;\n  let reversedCharIndex70 = 0;\n  let reversedCharIndex71 = 0;\n  let reversedCharIndex72 = 0;\n  let reversedCharIndex73 = 0;\n  let reversedCharIndex74 = 0;\n  let reversedCharIndex75 = 0;\n  let reversedCharIndex76 = 0;\n  let reversedCharIndex77 = 0;\n  let reversedCharIndex78 = 0;\n  let reversedCharIndex79 = 0;\n  let reversedCharIndex80 = 0;\n  let reversedCharIndex81 = 0;\n  let reversedCharIndex82 = 0;\n  let reversedCharIndex83 = 0;\n  let reversedCharIndex84 = 0;\n  let reversedCharIndex85 = 0;\n  let reversedCharIndex86 = 0;\n  let reversedCharIndex87 = 0;\n  let reversedCharIndex88 = 0;\n  let reversedCharIndex89 = 0;\n  let reversedCharIndex90 = 0;\n  let reversedCharIndex91 = 0;\n  let reversedCharIndex92 = 0;\n  let reversedCharIndex93 = 0;\n  let reversedCharIndex94 = 0;\n  let reversedCharIndex95 = 0;\n  let reversedCharIndex96 = 0;\n  let reversedCharIndex97 = 0;\n  let reversedCharIndex98 = 0;\n  let reversedCharIndex99 = 0;\n  let reversedCharIndex100 = 0;\n  let reversedCharIndex101 = 0;\n  let reversedCharIndex102 = 0;\n  let reversedCharIndex103 = 0;\n  let reversedCharIndex104 = 0;\n  let reversedCharIndex105 = 0;\n  let reversedCharIndex106 = 0;\n  let reversedCharIndex107 = 0;\n  let reversedCharIndex108 = 0;\n  let reversedCharIndex109 = 0;\n  let reversedCharIndex110 = 0;\n  let reversedCharIndex111 = 0;\n  let reversedCharIndex112 = 0;\n  let reversedCharIndex113 = 0;\n  let reversedCharIndex114 = 0;\n  let reversedCharIndex115 = 0;\n  let reversedCharIndex116 = 0;\n  let reversedCharIndex117 = 0;\n  let reversedCharIndex118 = 0;\n  let reversedCharIndex119 = 0;\n  let reversedCharIndex120 = 0;\n  let reversedCharIndex121 = 0;\n  let reversedCharIndex122 = 0;\n  let reversedCharIndex123 = 0;\n  let reversedCharIndex124 = 0;\n  let reversedCharIndex125 = 0;\n  let reversedCharIndex126 = 0;\n  let reversedCharIndex127 = 0;\n  let reversedCharIndex128 = 0;\n  let reversedCharIndex129 = 0;\n  let reversedCharIndex130 = 0;\n  let reversedCharIndex131 = 0;\n  let reversedCharIndex132 = 0;\n  let reversedCharIndex133 = 0;\n  let reversedCharIndex134 = 0;\n  let reversedCharIndex135 = 0;\n  let reversedCharIndex136 = 0;\n  let reversedCharIndex137 = 0;\n  let reversedCharIndex138 = 0;\n  let reversedCharIndex139 = 0;\n  let reversedCharIndex140 = 0;\n  let reversedCharIndex141 = 0;\n  let reversedCharIndex142 = 0;\n  let reversedCharIndex143 = 0;\n  let reversedCharIndex144 = 0;\n  let reversedCharIndex145 = 0;\n  let reversedCharIndex146 = 0;\n  let reversedCharIndex147 = 0;\n  let reversedCharIndex148 = 0;\n  let reversedCharIndex149 = 0;\n  let reversedCharIndex150 = 0;\n  let reversedCharIndex151 = 0;\n  let reversedCharIndex152 = 0;\n  let reversedCharIndex153 = 0;\n  let reversedCharIndex154 = 0;\n  let reversedCharIndex155 = 0;\n  let reversedCharIndex156 = 0;\n  let reversedCharIndex157 = 0;\n  let reversedCharIndex158 = 0;\n  let reversedCharIndex159 = 0;\n  let reversedCharIndex160 = 0;\n  let reversedCharIndex161 = 0;\n  let reversedCharIndex162 = 0;\n  let reversedCharIndex163 = 0;\n  let reversedCharIndex164 = 0;\n  let reversedCharIndex165 = 0;\n  let reversedCharIndex166 = 0;\n  let reversedCharIndex167 = 0;\n  let reversedCharIndex168 = 0;\n  let reversedCharIndex169 = 0;\n  let reversedCharIndex170 = 0;\n  let reversedCharIndex171 = 0;\n  let reversedCharIndex172 = 0;\n  let reversedCharIndex173 = 0;\n  let reversedCharIndex174 = 0;\n", "passed": 0}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> curiousCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> curiousCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst curiousCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "curiousCount", "gc": "<|endoftext|>/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> curiousCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> curiousCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst curiousCount = (lst) => {\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length == 1) {\n      oddCount++;\n    }\n  }\n  return [oddCount].concat(\n    lst.map(str => str.toString().replace(/[^\\d]/g, ''))\n  );\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length == 1) {\n      evenCount++;\n    }\n  }\n  return [evenCount].concat(\n    lst.map(str => str.toString().replace(/[^\\d]/g, ''))\n  );\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length == 1) {\n      oddCount++;\n    }\n  }\n  return [oddCount].concat(\n    lst.map(str => str.toString().replace(/[^\\d]/g, ''))\n  );\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length == 1) {\n      evenCount++;\n    }\n  }\n  return [evenCount].concat(\n    lst.map(str => str.toString().replace(/[^\\d]/g, ''))\n  );\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length == 1) {\n      oddCount++;\n    }\n  }\n  return [oddCount].concat(\n    lst.map(str => str.toString().replace(/[^\\d]/g, ''))\n  );\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length == 1) {\n      evenCount++;\n    }\n  }\n  return [evenCount].concat(\n    lst.map(str => str.toString().replace(/[^\\d]/g, ''))\n  );\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length == 1) {\n      oddCount++;\n    }\n  }\n  return [oddCount].concat(\n    lst.map(str => str.toString().replace(/[^\\d]/g, ''))\n  );\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length", "passed": 0}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minuteSubArraySum", "gc": "<|endoftext|>/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArraySum = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const sum = acc + num;\n    if (sum > 0) {\n      acc.push(sum);\n    }\n    return acc;\n  }, []);\n  return sums.reduce((acc, sum) => acc + sum, 0);\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySum([-1, -2, -3]) == 6\n  */\nconst minuteSubArrayMaxSum = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const sum = acc + num;\n    if (sum > 0) {\n      acc.push(sum);\n    }\n    return acc;\n  }, []);\n  return sums.reduce((acc, sum) => Math.max(acc, sum), 0);\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArrayMaxSum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArrayMaxSum([-1, -2, -3]) == 6\n  */\nconst minuteSubArrayMinSum = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const sum = acc + num;\n    if (sum > 0) {\n      acc.push(sum);\n    }\n    return acc;\n  }, []);\n  return sums.reduce((acc, sum) => Math.min(acc, sum), 0);\n};\n\n/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArrayMinSum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArrayMinSum([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMin = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const sum = acc + num;\n    if (sum > 0) {\n      acc.push(sum);\n    }\n    return acc;\n  }, []);\n  return sums.reduce((acc, sum) => Math.min(acc, sum), 0);\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMax([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMax([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMax = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const sum = acc + num;\n    if (sum > 0) {\n      acc.push(sum);\n    }\n    return acc;\n  }, []);\n  return sums.reduce((acc, sum) => Math.max(acc, sum), 0);\n};\n\n/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMin([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMin([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMaxMin = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const sum = acc + num;\n    if (sum > 0) {\n      acc.push(sum);\n    }\n    return acc;\n  }, []);\n  return sums.reduce((acc, sum) => Math.min(acc, sum), 0);\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMaxSum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMaxSum([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMaxSumMin = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const sum = acc + num;\n    if (sum > 0) {\n      acc.push(sum);\n    }\n    return acc;\n  }, []);\n  return sums.reduce((acc, sum) => Math.max(acc, sum), 0);\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMaxMin([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMaxMin([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMaxMinMax = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const sum = acc + num;\n    if (sum > 0) {\n      acc.push(sum);\n    }\n    return acc;\n  }, []);\n  return sums.reduce((acc, sum) => Math.min(acc, sum), 0);\n};\n\n/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMinSum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMinSum([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMinSumMin = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const sum = acc + num;\n    if (sum > 0) {\n      acc.push(sum);\n    }\n    return acc;\n  }, []);\n  return sums.reduce((acc, sum) => Math.min(acc, sum), 0);\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMaxSum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMaxSum([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMaxSumMin = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const sum = acc + num;\n    if (sum > 0) {\n      acc.push(sum);\n    }\n    return acc;\n  }, []);\n  return sums.reduce((acc, sum) => Math.max(acc, sum), 0);\n};\n\n/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMaxSumMin([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMaxSumMin([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMaxSumMinMax = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const sum = acc + num;\n    if (sum > 0) {\n      acc.push(sum);\n    }\n    return acc;\n  }, []);\n  return sums.reduce((acc, sum) => Math.min(acc, sum), 0);\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMaxMin([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMaxMin([-1, -2, -3]) == 6\n  */\nconst minuteSubArraySumMaxMinMaxMax = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const sum = acc + num;\n    if (sum > 0) {\n      acc.push(sum);\n    }\n    return acc;\n  }, []);\n  return sums.reduce((acc, sum) => Math.max(acc, sum), 0);\n};\n\n/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySumMaxSumMin([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySumMaxSumMin([-1, -2, -3]) == ", "passed": 0}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst soapFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "soapFill", "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst soapFill = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                result += (grid[i][j] * capacity);\n            }\n        }\n    }\n    return result;\n};\n\n/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst soapFill = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                result += (grid[i][j] * capacity);\n            }\n        }\n    }\n    return result;\n};\n\n/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst soapFill = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                result += (grid[i][j] * capacity);\n            }\n        }\n    }\n    return result;\n};\n\n/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst soapFill = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                result += (grid[i][j] * capacity);\n            }\n        }\n    }\n    return result;\n};\n\n/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst soapFill = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                result += (grid[i][j] * capacity);\n            }\n        }\n    }\n    return result;\n};\n\n/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input", "passed": 0}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "gc": "<|endoftext|>/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const ones = arr.filter((x) => x === 1);\n  const onesBinary = ones.map((x) => x.toString(2));\n  const onesBinarySorted = onesBinary.sort((a, b) => a - b);\n  const onesBinarySorted = onesBinarySorted.map((x) => parseInt(x, 2));\n  return onesBinarySorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const ones = arr.filter((x) => x === 1);\n  const onesBinary = ones.map((x) => x.toString(2));\n  const onesBinarySorted = onesBinary.sort((a, b) => a - b);\n  const onesBinarySorted = onesBinarySorted.map((x) => parseInt(x, 2));\n  return onesBinarySorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const ones = arr.filter((x) => x === 1);\n  const onesBinary = ones.map((x) => x.toString(2));\n  const onesBinarySorted = onesBinary.sort((a, b) => a - b);\n  const onesBinarySorted = onesBinarySorted.map((x) => parseInt(x, 2));\n  return onesBinarySorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const ones = arr.filter((x) => x === 1);\n  const onesBinary = ones.map((x) => x.toString(2));\n  const onesBinarySorted = onesBinary.sort((a, b) => a - b);\n  const onesBinarySorted = onesBinarySorted.map((x) => parseInt(x, 2));\n  return onesBinarySorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const ones = arr.filter((x) => x === 1);\n  const onesBinary = ones.map((x) => x.toString(2));\n  const onesBinarySorted = onesBinary.sort((a, b) => a - b);\n  const onesBinarySorted = onesBinarySorted.map((x) => parseInt(x, 2));\n  return onesBinarySorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const ones = arr.filter((x) => x === 1);\n  const onesBinary = ones.map((x) => x.toString(2));\n  const onesBinarySorted = onesBinary.sort((a, b) => a - b);\n  const onesBinarySorted = onesBinarySorted.map((x) => parseInt(x, 2));\n  return onesBinarySorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const ones = arr.filter((x) => x === 1);\n  const onesBinary = ones.map((x) => x.toString(2));\n  const onesBinarySorted = onesBinary.sort((a, b) => a - b);\n  const onesBinarySorted = onesBinarySorted.map((x) => parseInt(x, 2));\n  return onesBinarySorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const ones = arr.filter((x) => x === 1);\n  const onesBinary = ones.map((x) => x.toString(2));\n  const onesBinarySorted = onesBinary.sort((a, b) => a - b);\n  const onesBinarySorted = onesBinarySorted.map((x) => parseInt(x, 2));\n  return onesBinarySorted;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const ones = arr.filter((x) => x === 1);\n  const onesBinary = ones.map((x) => x.toString(2));\n  const onesBinarySor", "passed": 0}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  choiceDiscussion(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  choiceDiscussion(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  choiceDiscussion(\"simple white space\", 2) ==> []\n  choiceDiscussion(\"Hello world\", 4) ==> [\"world\"]\n  choiceDiscussion(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst choiceDiscussion = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "choiceDiscussion", "gc": "<|endoftext|>/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  choiceDiscussion(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  choiceDiscussion(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  choiceDiscussion(\"simple white space\", 2) ==> []\n  choiceDiscussion(\"Hello world\", 4) ==> [\"world\"]\n  choiceDiscussion(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst choiceDiscussion = (s, n) => {\n  let words = []\n  let word = ''\n  let count = 0\n  let wordCount = 0\n  let wordCountMax = 0\n  let wordCountMin = 0\n  let wordCountMaxMin = 0\n  let wordCountMaxMax = 0\n  let wordCountMinMax = 0\n  let wordCountMaxMinMax = 0\n  let wordCountMaxMaxMinMax = 0\n  let wordCountMaxMaxMaxMinMax = 0\n  let wordCountMinMaxMax = 0\n  let wordCountMaxMinMaxMax = 0\n  let wordCountMaxMaxMinMaxMax = 0\n  let wordCountMinMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMax = 0\n  let wordCountMaxMaxMinMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMax = 0\n  let wordCountMaxMaxMinMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMax = 0\n  let wordCountMaxMaxMinMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMaxMaxMaxMaxMaxMax = 0\n  let wordCountMaxMinMaxMaxMaxMaxMaxMax = 0\n  let wordCountMinMaxMax", "passed": 0}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  catchClosestVowel(\"yogurt\") ==> \"u\"\n  catchClosestVowel(\"FULL\") ==> \"U\"\n  catchClosestVowel(\"quick\") ==> \"\"\n  catchClosestVowel(\"ab\") ==> \"\"\n  */\nconst catchClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "catchClosestVowel", "gc": "<|endoftext|>/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  catchClosestVowel(\"yogurt\") ==> \"u\"\n  catchClosestVowel(\"FULL\") ==> \"U\"\n  catchClosestVowel(\"quick\") ==> \"\"\n  catchClosestVowel(\"ab\") ==> \"\"\n  */\nconst catchClosestVowel = (word) => {\n  let vowels = vowels.split('');\n  let vowelsArray = vowels.map((v) => v.charCodeAt(0));\n  let vowelsArrayLength = vowelsArray.length;\n  let vowelsArrayIndex = 0;\n  let vowelsArrayLengthIndex = 0;\n  let vowelsArrayIndex2 = 0;\n  let vowelsArrayLengthIndex2 = 0;\n  let vowelsArrayIndex3 = 0;\n  let vowelsArrayLengthIndex3 = 0;\n  let vowelsArrayIndex4 = 0;\n  let vowelsArrayLengthIndex4 = 0;\n  let vowelsArrayIndex5 = 0;\n  let vowelsArrayLengthIndex5 = 0;\n  let vowelsArrayIndex6 = 0;\n  let vowelsArrayLengthIndex6 = 0;\n  let vowelsArrayIndex7 = 0;\n  let vowelsArrayLengthIndex7 = 0;\n  let vowelsArrayIndex8 = 0;\n  let vowelsArrayLengthIndex8 = 0;\n  let vowelsArrayIndex9 = 0;\n  let vowelsArrayLengthIndex9 = 0;\n  let vowelsArrayIndex10 = 0;\n  let vowelsArrayLengthIndex10 = 0;\n  let vowelsArrayIndex11 = 0;\n  let vowelsArrayLengthIndex11 = 0;\n  let vowelsArrayIndex12 = 0;\n  let vowelsArrayLengthIndex12 = 0;\n  let vowelsArrayIndex13 = 0;\n  let vowelsArrayLengthIndex13 = 0;\n  let vowelsArrayIndex14 = 0;\n  let vowelsArrayLengthIndex14 = 0;\n  let vowelsArrayIndex15 = 0;\n  let vowelsArrayLengthIndex15 = 0;\n  let vowelsArrayIndex16 = 0;\n  let vowelsArrayLengthIndex16 = 0;\n  let vowelsArrayIndex17 = 0;\n  let vowelsArrayLengthIndex17 = 0;\n  let vowelsArrayIndex18 = 0;\n  let vowelsArrayLengthIndex18 = 0;\n  let vowelsArrayIndex19 = 0;\n  let vowelsArrayLengthIndex19 = 0;\n  let vowelsArrayIndex20 = 0;\n  let vowelsArrayLengthIndex20 = 0;\n  let vowelsArrayIndex21 = 0;\n  let vowelsArrayLengthIndex21 = 0;\n  let vowelsArrayIndex22 = 0;\n  let vowelsArrayLengthIndex22 = 0;\n  let vowelsArrayIndex23 = 0;\n  let vowelsArrayLengthIndex23 = 0;\n  let vowelsArrayIndex24 = 0;\n  let vowelsArrayLengthIndex24 = 0;\n  let vowelsArrayIndex25 = 0;\n  let vowelsArrayLengthIndex25 = 0;\n  let vowelsArrayIndex26 = 0;\n  let vowelsArrayLengthIndex26 = 0;\n  let vowelsArrayIndex27 = 0;\n  let vowelsArrayLengthIndex27 = 0;\n  let vowelsArrayIndex28 = 0;\n  let vowelsArrayLengthIndex28 = 0;\n  let vowelsArrayIndex29 = 0;\n  let vowelsArrayLengthIndex29 = 0;\n  let vowelsArrayIndex30 = 0;\n  let vowelsArrayLengthIndex30 = 0;\n  let vowelsArrayIndex31 = 0;\n  let vowelsArrayLengthIndex31 = 0;\n  let vowelsArrayIndex32 = 0;\n  let vowelsArrayLengthIndex32 = 0;\n  let vowelsArrayIndex33 = 0;\n  let vowelsArrayLengthIndex33 = 0;\n  let vowelsArrayIndex34 = 0;\n  let vowelsArrayLengthIndex34 = 0;\n  let vowelsArrayIndex35 = 0;\n  let vowelsArrayLengthIndex35 = 0;\n  let vowelsArrayIndex36 = 0;\n  let vowelsArrayLengthIndex36 = 0;\n  let vowelsArrayIndex37 = 0;\n  let vowelsArrayLengthIndex37 = 0;\n  let vowelsArrayIndex38 = 0;\n  let vowelsArrayLengthIndex38 = 0;\n  let vowelsArrayIndex39 = 0;\n  let vowelsArrayLengthIndex39 = 0;\n  let vowelsArrayIndex40 = 0;\n  let vowelsArrayLengthIndex40 = 0;\n  let vowelsArrayIndex41 = 0;\n  let vowelsArrayLengthIndex41 = 0;\n  let vowelsArrayIndex42 = 0;\n  let vowelsArrayLengthIndex42 = 0;\n  let vowelsArrayIndex43 = 0;\n  let vowelsArrayLengthIndex43 = 0;\n  let vowelsArrayIndex44 = 0;\n  let vowelsArrayLengthIndex44 = 0;\n  let vowelsArrayIndex45 = 0;\n  let vowelsArrayLengthIndex45 = 0;\n  let vowelsArrayIndex46 = 0;\n  let vowelsArrayLengthIndex46 = 0;\n  let vowelsArrayIndex47 = 0;\n  let vowelsArrayLengthIndex47 = 0;\n  let vowelsArrayIndex48 = 0;\n  let vowelsArrayLengthIndex48 = 0;\n  let vowelsArrayIndex49 = 0;\n  let vowelsArrayLengthIndex49 = 0;\n  let vowelsArrayIndex50 = 0;\n  let vowelsArrayLengthIndex50 = 0;\n  let vowelsArrayIndex51 = 0;\n  let vowelsArrayLengthIndex51 = 0;\n  let vowelsArrayIndex52 = 0;\n  let vowelsArrayLengthIndex52 = 0;\n  let vowelsArrayIndex53 = 0;\n  let vowelsArrayLengthIndex53 = 0;\n  let vowelsArrayIndex54 = 0;\n  let vowelsArrayLengthIndex54 = 0;\n  let vowelsArrayIndex55 = 0;\n  let vowelsArrayLengthIndex55 = 0;\n  let vowelsArrayIndex56 = 0;\n  let vowelsArrayLengthIndex56 = 0;\n  let vowelsArrayIndex57 = 0;\n  let vowelsArrayLengthIndex57 = 0;\n  let vowelsArrayIndex58 = 0;\n  let vowelsArrayLengthIndex58 = 0;\n  let vowelsArrayIndex59 = 0;\n  let vowelsArrayLengthIndex59 = 0;\n  let vowelsArrayIndex60 = 0;\n  let vowelsArrayLengthIndex60 = 0;\n  let vowelsArrayIndex61 = 0;\n  let vowelsArrayLengthIndex61 = 0;\n  let vowelsArrayIndex62 = 0;\n  let vowelsArrayLengthIndex62 = 0;\n  let vowelsArrayIndex63 = 0;\n  let vowelsArrayLengthIndex63 = 0;\n  let vowelsArrayIndex64 = 0;\n  let vowelsArrayLengthIndex64 = 0;\n  let vowelsArrayIndex65 = 0;\n  let vowelsArrayLengthIndex65 = 0;\n  let vowelsArrayIndex66 = 0;\n  let vowelsArrayLengthIndex66 = 0;\n  let vowelsArrayIndex67 = 0;\n  let vowelsArrayLengthIndex67 = 0;\n  let vowelsArrayIndex68 = 0;\n  let vowelsArrayLengthIndex68 = 0;\n  let vowelsArrayIndex69 = 0;\n  let vowelsArrayLengthIndex69 = 0;\n  let vowelsArrayIndex70 = 0;\n  let vowelsArrayLengthIndex70 = 0;\n  let vowelsArrayIndex71 = 0;\n  let vowelsArrayLengthIndex71 = 0;\n  let vowelsArrayIndex72 = 0;\n  let vowelsArrayLengthIndex72 = 0;\n  let vowelsArrayIndex73 = 0;\n  let vowelsArrayLengthIndex73 = 0;\n  let vowelsArrayIndex74 = 0;\n  let vowelsArrayLengthIndex74 = 0;\n  let vowelsArrayIndex75 = 0;\n  let vowelsArrayLengthIndex75 = 0;\n  let vowelsArrayIndex76 = 0;\n  let vowelsArrayLengthIndex76 = 0;\n  let vowelsArrayIndex77 = 0;\n  let vowelsArrayLengthIndex77 = 0;\n  let vowelsArrayIndex78 = 0;\n  let vowelsArrayLengthIndex78 = 0;\n  let vowelsArrayIndex79 = 0;\n  let vowelsArrayLengthIndex79 = 0;\n  let vowelsArrayIndex80 = 0;\n  let vowelsArrayLengthIndex80 = 0;", "passed": 0}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  catchParens(['()(', ')']) == 'Yes'\n  catchParens([')', ')']) == 'No'\n  */\nconst catchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "catchParens", "gc": "<|endoftext|>/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  catchParens(['()(', ')']) == 'Yes'\n  catchParens([')', ')']) == 'No'\n  */\nconst catchParens = (lst) => {\n  let isGood = true;\n  let isBalanced = true;\n  let isBalanced = false;\n  let isBalancedParentheses = false;\n  let isBalancedParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses = false;\n  let isBalancedParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParenthesesParentheses", "passed": 1}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the farseeing one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> farseeing([])\n\n  >>> farseeing(['a', 'b', 'c'])\n  'a'\n  >>> farseeing(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst farseeing = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "farseeing", "gc": "<|endoftext|>/* Out of list of strings, return the farseeing one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> farseeing([])\n\n  >>> farseeing(['a', 'b', 'c'])\n  'a'\n  >>> farseeing(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst farseeing = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  const stringLength = strings[0].length\n  let farseeingString = ''\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length!== stringLength) {\n      return null\n    }\n    farseeingString += strings[i]\n  }\n  return farseeingString\n}\n\n/**\n  Returns a random integer between min and max (inclusive)\n  >>> randomInt(0, 100)\n\n  >>> randomInt(0, 100)\n  0\n  >>> randomInt(0, 100)\n  1\n  >>> randomInt(0, 100)\n  2\n  >>> randomInt(0, 100)\n  3\n  >>> randomInt(0, 100)\n  4\n  >>> randomInt(0, 100)\n  5\n  >>> randomInt(0, 100)\n  6\n  >>> randomInt(0, 100)\n  7\n  >>> randomInt(0, 100)\n  8\n  >>> randomInt(0, 100)\n  9\n  >>> randomInt(0, 100)\n  10\n  >>> randomInt(0, 100)\n  11\n  >>> randomInt(0, 100)\n  12\n  >>> randomInt(0, 100)\n  13\n  >>> randomInt(0, 100)\n  14\n  >>> randomInt(0, 100)\n  15\n  >>> randomInt(0, 100)\n  16\n  >>> randomInt(0, 100)\n  17\n  >>> randomInt(0, 100)\n  18\n  >>> randomInt(0, 100)\n  19\n  >>> randomInt(0, 100)\n  20\n  >>> randomInt(0, 100)\n  21\n  >>> randomInt(0, 100)\n  22\n  >>> randomInt(0, 100)\n  23\n  >>> randomInt(0, 100)\n  24\n  >>> randomInt(0, 100)\n  25\n  >>> randomInt(0, 100)\n  26\n  >>> randomInt(0, 100)\n  27\n  >>> randomInt(0, 100)\n  28\n  >>> randomInt(0, 100)\n  29\n  >>> randomInt(0, 100)\n  30\n  >>> randomInt(0, 100)\n  31\n  >>> randomInt(0, 100)\n  32\n  >>> randomInt(0, 100)\n  33\n  >>> randomInt(0, 100)\n  34\n  >>> randomInt(0, 100)\n  35\n  >>> randomInt(0, 100)\n  36\n  >>> randomInt(0, 100)\n  37\n  >>> randomInt(0, 100)\n  38\n  >>> randomInt(0, 100)\n  39\n  >>> randomInt(0, 100)\n  40\n  >>> randomInt(0, 100)\n  41\n  >>> randomInt(0, 100)\n  42\n  >>> randomInt(0, 100)\n  43\n  >>> randomInt(0, 100)\n  44\n  >>> randomInt(0, 100)\n  45\n  >>> randomInt(0, 100)\n  46\n  >>> randomInt(0, 100)\n  47\n  >>> randomInt(0, 100)\n  48\n  >>> randomInt(0, 100)\n  49\n  >>> randomInt(0, 100)\n  50\n  >>> randomInt(0, 100)\n  51\n  >>> randomInt(0, 100)\n  52\n  >>> randomInt(0, 100)\n  53\n  >>> randomInt(0, 100)\n  54\n  >>> randomInt(0, 100)\n  55\n  >>> randomInt(0, 100)\n  56\n  >>> randomInt(0, 100)\n  57\n  >>> randomInt(0, 100)\n  58\n  >>> randomInt(0, 100)\n  59\n  >>> randomInt(0, 100)\n  60\n  >>> randomInt(0, 100)\n  61\n  >>> randomInt(0, 100)\n  62\n  >>> randomInt(0, 100)\n  63\n  >>> randomInt(0, 100)\n  64\n  >>> randomInt(0, 100)\n  65\n  >>> randomInt(0, 100)\n  66\n  >>> randomInt(0, 100)\n  67\n  >>> randomInt(0, 100)\n  68\n  >>> randomInt(0, 100)\n  69\n  >>> randomInt(0, 100)\n  70\n  >>> randomInt(0, 100)\n  71\n  >>> randomInt(0, 100)\n  72\n  >>> randomInt(0, 100)\n  73\n  >>> randomInt(0, 100)\n  74\n  >>> randomInt(0, 100)\n  75\n  >>> randomInt(0, 100)\n  76\n  >>> randomInt(0, 100)\n  77\n  >>> randomInt(0, 100)\n  78\n  >>> randomInt(0, 100)\n  79\n  >>> randomInt(0, 100)\n  80\n  >>> randomInt(0, 100)\n  81\n  >>> randomInt(0, 100)\n  82\n  >>> randomInt(0, 100)\n  83\n  >>> randomInt(0, 100)\n  84\n  >>> randomInt(0, 100)\n  85\n  >>> randomInt(0, 100)\n  86\n  >>> randomInt(0, 100)\n  87\n  >>> randomInt(0, 100)\n  88\n  >>> randomInt(0, 100)\n  89\n  >>> randomInt(0, 100)\n  90\n  >>> randomInt(0, 100)\n  91\n  >>> randomInt(0, 100)\n  92\n  >>> randomInt(0, 100)\n  93\n  >>> randomInt(0, 100)\n  94\n  >>> randomInt(0, 100)\n  95\n  >>> randomInt(0, 100)\n  96\n  >>> randomInt(0, 100)\n  97\n  >>> randomInt(0, 100)\n  98\n  >>> randomInt(0, 100)\n  99\n  >>> randomInt(0, 100)\n  100\n  >>> randomInt(0, 100)\n  101\n  >>> randomInt(0, 100)\n  102\n  >>> randomInt(0, 100)\n  103\n  >>> randomInt(0, 100)\n  104\n  >>> randomInt(0, 100)\n  105\n  >>> randomInt(0, 100)\n  106\n  >>> randomInt(0, 100)\n  107\n  >>> randomInt(0, 100)\n  108\n  >>> randomInt(0, 100)\n  109\n  >>> randomInt(0, 100)\n  110\n  >>> randomInt(0, 100)\n  111\n  >>> randomInt(0, 100)\n  112\n  >>> randomInt(0, 100)\n  113\n  >>> randomInt(0, 100)\n  114\n  >>> randomInt(0, 100)\n  115\n  >>> randomInt(0, 100)\n  116\n  >>> randomInt(0, 100)\n  117\n  >>> randomInt(0, 100)\n  118\n  >>> randomInt(0, 100)\n  119\n  >>> randomInt(0, 100)\n  120\n  >>> randomInt(0, 100)\n  121\n  >>> randomInt(0, 100)\n  122\n  >>> randomInt(0, 100)\n  123\n  >>> randomInt(0, 100)\n  124\n  >>> randomInt(0, 100)\n  125\n  >>> randomInt(0, 100)\n  126\n  >>> randomInt(0, 100)\n  127\n  >>> randomInt(0, 100)\n  128\n  >>> randomInt(0, 100)\n  129\n  >>> randomInt(0, 100)\n  130\n  >>> randomInt(0, 100)\n  131\n  >>> randomInt(0, 100)\n  132\n  >>> randomInt(0, 100)\n  133\n  >>> randomInt(0, 100)\n  134\n  >>> randomInt(0, 100)\n  135\n  >>> randomInt(0, 100)\n", "passed": 0}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maximal k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximal = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximal", "gc": "<|endoftext|>/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maximal k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximal = (arr, k) => {\n  let max = 0;\n  let maxIndex = 0;\n  let maxValue = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > maxValue) {\n      max = arr[i];\n      maxIndex = i;\n      maxValue = arr[i];\n    }\n  }\n  return [arr[maxIndex], max];\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-with-sum/\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar findMaxSubArray = function (nums, target) {\n  let ans = [];\n  let anIndex = 0;\n  let anValue = 0;\n  let anMax = 0;\n  let anMin = 0;\n  let anSum = 0;\n  let anMaxIndex = 0;\n  let anMinIndex = 0;\n  let anMaxValue = 0;\n  let anMinValue = 0;\n  let anSumValue = 0;\n  let anMaxIndex2 = 0;\n  let anMinIndex2 = 0;\n  let anMaxValue2 = 0;\n  let anMinValue2 = 0;\n  let anSumValue2 = 0;\n  let anMaxIndex3 = 0;\n  let anMinIndex3 = 0;\n  let anMaxValue3 = 0;\n  let anMinValue3 = 0;\n  let anSumValue3 = 0;\n  let anMaxIndex4 = 0;\n  let anMinIndex4 = 0;\n  let anMaxValue4 = 0;\n  let anMinValue4 = 0;\n  let anSumValue4 = 0;\n  let anMaxIndex5 = 0;\n  let anMinIndex5 = 0;\n  let anMaxValue5 = 0;\n  let anMinValue5 = 0;\n  let anSumValue5 = 0;\n  let anMaxIndex6 = 0;\n  let anMinIndex6 = 0;\n  let anMaxValue6 = 0;\n  let anMinValue6 = 0;\n  let anSumValue6 = 0;\n  let anMaxIndex7 = 0;\n  let anMinIndex7 = 0;\n  let anMaxValue7 = 0;\n  let anMinValue7 = 0;\n  let anSumValue7 = 0;\n  let anMaxIndex8 = 0;\n  let anMinIndex8 = 0;\n  let anMaxValue8 = 0;\n  let anMinValue8 = 0;\n  let anSumValue8 = 0;\n  let anMaxIndex9 = 0;\n  let anMinIndex9 = 0;\n  let anMaxValue9 = 0;\n  let anMinValue9 = 0;\n  let anSumValue9 = 0;\n  let anMaxIndex10 = 0;\n  let anMinIndex10 = 0;\n  let anMaxValue10 = 0;\n  let anMinValue10 = 0;\n  let anSumValue10 = 0;\n  let anMaxIndex11 = 0;\n  let anMinIndex11 = 0;\n  let anMaxValue11 = 0;\n  let anMinValue11 = 0;\n  let anSumValue11 = 0;\n  let anMaxIndex12 = 0;\n  let anMinIndex12 = 0;\n  let anMaxValue12 = 0;\n  let anMinValue12 = 0;\n  let anSumValue12 = 0;\n  let anMaxIndex13 = 0;\n  let anMinIndex13 = 0;\n  let anMaxValue13 = 0;\n  let anMinValue13 = 0;\n  let anSumValue13 = 0;\n  let anMaxIndex14 = 0;\n  let anMinIndex14 = 0;\n  let anMaxValue14 = 0;\n  let anMinValue14 = 0;\n  let anSumValue14 = 0;\n  let anMaxIndex15 = 0;\n  let anMinIndex15 = 0;\n  let anMaxValue15 = 0;\n  let anMinValue15 = 0;\n  let anSumValue15 = 0;\n  let anMaxIndex16 = 0;\n  let anMinIndex16 = 0;\n  let anMaxValue16 = 0;\n  let anMinValue16 = 0;\n  let anSumValue16 = 0;\n  let anMaxIndex17 = 0;\n  let anMinIndex17 = 0;\n  let anMaxValue17 = 0;\n  let anMinValue17 = 0;\n  let anSumValue17 = 0;\n  let anMaxIndex18 = 0;\n  let anMinIndex18 = 0;\n  let anMaxValue18 = 0;\n  let anMinValue18 = 0;\n  let anSumValue18 = 0;\n  let anMaxIndex19 = 0;\n  let anMinIndex19 = 0;\n  let anMaxValue19 = 0;\n  let anMinValue19 = 0;\n  let anSumValue19 = 0;\n  let anMaxIndex20 = 0;\n  let anMinIndex20 = 0;\n  let anMaxValue20 = 0;\n  let anMinValue20 = 0;\n  let anSumValue20 = 0;\n  let anMaxIndex21 = 1;\n  let anMinIndex21 = 1;\n  let anMaxValue21 = 1;\n  let anMinValue21 = 1;\n  let anSumValue21 = 1;\n  let anMaxIndex22 = 1;\n  let anMinIndex22 = 1;\n  let anMaxValue22 = 1;\n  let anMinValue22 = 1;\n  let anSumValue22 = 1;\n  let anMaxIndex23 = 1;\n  let anMinIndex23 = 1;\n  let anMaxValue23 = 1;\n  let anMinValue23 = 1;\n  let anSumValue23 = 1;\n  let anMaxIndex24 = 1;\n  let anMinIndex24 = 1;\n  let anMaxValue24 = 1;\n  let anMinValue24 = 1;\n  let anSumValue24 = 1;\n  let anMaxIndex25 = 1;\n  let anMinIndex25 = 1;\n  let anMaxValue25 = 1;\n  let anMinValue25 = 1;\n  let anSumValue25 = 1;\n  let anMaxIndex26 = 1;\n  let anMinIndex26 = 1;\n  let anMaxValue26 = 1;\n  let anMinValue26 = 1;\n  let anSumValue26 = 1;\n  let anMaxIndex27 = 1;\n  let anMinIndex27 = 1;\n  let anMaxValue27 = 1;\n  let anMinValue27 = 1;\n  let anSumValue27 = 1;\n  let anMaxIndex28 = 1;\n  let anMinIndex28 = 1;\n  let anMaxValue28 = 1;\n  let anMinValue28 = 1;\n  let anSumValue28 = 1;\n  let anMaxIndex29 = 1;\n  let anMinIndex29 = 1;\n  let anMaxValue29 = 1;\n  let anMinValue29 = 1;\n  let anSumValue29 = 1;\n  let anMaxIndex30 = 1;\n  let anMinIndex30 = 1;\n  let anMaxValue30 = 1;\n  let anMinValue30 = 1;\n  let anSumValue30 = 1;\n  let anMaxIndex31 = 1;\n  let anMinIndex31 = 1;\n  let anMaxValue31 = 1;\n  let anMinValue31 = 1;\n  let anSumValue31 = 1;\n  let anMaxIndex32 = 1;\n  let anMinIndex32 = 1;\n  let anMaxValue32 = 1;\n  let anMinValue32 = 1;\n  let anSumValue32 = 1;\n  let anMaxIndex33 = 1;\n  let anMinIndex33 = 1;\n  let anMaxValue33 = 1;\n  let anMinValue33 = 1;\n  let anSumValue33 = 1;\n  let anMaxIndex34 = 1;\n  let anMinIndex34 = 1;\n  let anMaxValue34 = 1;\n  let anMinValue34 = 1;\n  let anSumValue34 = 1;\n  let anMaxIndex35 = 1;\n  let anMinIndex35 = 1;\n  let anMaxValue35 = 1;\n  let anMinValue35 = 1;\n  let anSumValue35 = 1;\n  let anMaxIndex36 = 1;\n  let anMinIndex36 = 1;\n  let anMaxValue36 = 1;\n  let anMinValue36 = 1;\n  let anSumValue36 = 1;\n  let anMaxIndex37 = 1;\n  let anMinIndex37 = 1;\n  let anMax", "passed": 0}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "gc": "<|endoftext|>/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution\n};\n\n},{}],6:[function(require,module,exports){\n/*\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  ", "passed": 0}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst lendElement = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "lendElement", "gc": "<|endoftext|>/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst lendElement = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && arr[i] > arr[0]) {\n      sum += arr[i];\n    }\n  }\n  return sum + lendElement(arr, k - 1);\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element of the array that has at most k digits from the first k elements of arr.\n\n * Note:\n * The maximum element of an empty array is undefined.\n */\nconst maxElement = (arr, k) => {\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && arr[i] > max) {\n      max = arr[i];\n    }\n  }\n  return max;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the minimum element of the array that has at most k digits from the first k elements of arr.\n\n * Note:\n * The minimum element of an empty array is undefined.\n */\nconst minElement = (arr, k) => {\n  let min = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element of the array that has at most k digits from the first k elements of arr.\n\n * Note:\n * The maximum element of an empty array is undefined.\n */\nconst maxElementWithKDigits = (arr, k) => {\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && arr[i] > max) {\n      max = arr[i];\n    }\n  }\n  return max;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the minimum element of the array that has at most k digits from the first k elements of arr.\n\n * Note:\n * The minimum element of an empty array is undefined.\n */\nconst minElementWithKDigits = (arr, k) => {\n  let min = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element of the array that has at most k digits from the first k elements of arr.\n\n * Note:\n * The maximum element of an empty array is undefined.\n */\nconst maxElementWithKDigitsWithK = (arr, k) => {\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && arr[i] > max) {\n      max = arr[i];\n    }\n  }\n  return max;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the minimum element of the array that has at most k digits from the first k elements of arr.\n\n * Note:\n * The minimum element of an empty array is undefined.\n */\nconst minElementWithKDigitsWithK = (arr, k) => {\n  let min = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element of the array that has at most k digits from the first k elements of arr.\n\n * Note:\n * The maximum element of an empty array is undefined.\n */\nconst maxElementWithKDigitsWithKWithK = (arr, k) => {\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && arr[i] > max) {\n      max = arr[i];\n    }\n  }\n  return max;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element of the array that has at most k digits from the first k elements of arr.\n\n * Note:\n * The maximum element of an empty array is undefined.\n */\nconst minElementWithKDigitsWithKWithK = (arr, k) => {\n  let min = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element of the array that has at most k digits from the first k elements of arr.\n\n * Note:\n * The maximum element of an empty array is undefined.\n */\nconst maxElementWithKDigitsWithKWithKWithK = (arr, k) => {\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && arr[i] > max) {\n      max = arr[i];\n    }\n  }\n  return max;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element of the array that has at most k digits from the first k elements of arr.\n\n * Note:\n * The maximum element of an empty array is undefined.\n */\nconst minElementWithKDigitsWithKWithKWithK = (arr, k) => {\n  let min = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element of the array that has at most k digits from the first k elements of arr.\n\n * Note:\n * The maximum element of an empty array is undefined.\n */\nconst maxElementWithKDigitsWithKWithKWithKWithK = (arr, k) => {\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && arr[i] > max) {\n      max = arr[i];\n    }\n  }\n  return max;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element of the array that has at most k digits from the first k elements of arr.\n\n * Note:\n * The maximum element of an empty array is undefined.\n */\nconst minElementWithKDigitsWithKWithKWithKWithK = (arr, k) => {\n  let min = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element of the array that has at most k digits from the first k elements of arr.\n\n * Note:\n * The maximum element of an empty array is undefined.\n */\nconst maxElementWithKDigitsWithKWithKWithKWithKWithK = (arr, k) => {\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && arr[i] > max) {\n      max = arr[i];\n    }\n  }\n  return max;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element of the array that has at most k digits from the first k elements of arr.\n\n * Note:\n * The maximum element of an empty array is undefined.\n */\nconst minElementWithKDigitsWithKWithKWithKWithKWithK = (arr, k) => {\n  let min = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && arr[i] < min) {\n      ", "passed": 0}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst catchOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "catchOddCollatz", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst catchOddCollatz = (n) => {\n  let collatz = [];\n  let num = 1;\n  let prev = 1;\n  let next;\n\n  while (num < n) {\n    next = prev * prev;\n    prev = num;\n    num = next;\n    collatz.push(num);\n  }\n\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [1, 3, 5, 8, 4, 2], so the even numbers are 1, 5, 16, and 8.\n  */\nconst catchEvenCollatz = (n) => {\n  let collatz = [];\n  let num = 1;\n  let prev = 1;\n  let next;\n\n  while (num < n) {\n    next = prev * prev;\n    prev = num;\n    num = next;\n    collatz.push(num);\n  }\n\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n.\n\n  The Prime Factors conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Prime Factors(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchPrimeFactors(5) returns [1, 5, 3] # The prime factors of 5 is [1, 3, 5, 7], so the factors are 1, 3, 5, 7.\n  */\nconst catchPrimeFactors = (n) => {\n  let factors = [];\n  let num = 1;\n  let prev = 1;\n  let next;\n\n  while (num < n) {\n    next = prev * prev;\n    prev = num;\n    num = next;\n    factors.push(num);\n  }\n\n  return factors;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n that \n  are greater than n.\n\n  The Prime Factors conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Prime Factors(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchPrimeFactorsGreaterThan(5) returns [1, 5, 3] # The prime factors of 5 is [1, 3, 5, 7], so the factors are 1, 3, 5, 7.\n  */\nconst catchPrimeFactorsGreaterThan = (n) => {\n  let factors = [];\n  let num = 1;\n  let prev = 1;\n  let next;\n\n  while (num < n) {\n    next = prev * prev;\n    prev = num;\n    num = next;\n    factors.push(num);\n  }\n\n  return factors;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n that \n  are less than n.\n\n  The Prime Factors conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Prime Factors(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchPrimeFactorsLessThan(5) returns [1, 5, 3] # The prime factors of 5 is [1, 3, 5, 7], so the factors are 1, 3, 5, 7.\n  */\nconst catchPrimeFactorsLessThan = (n) => {\n  let factors = [];\n  let num = 1;\n  let prev = 1;\n  let next;\n\n  while (num < n) {\n    next = prev * prev;\n    prev = num;\n    num = next;\n    factors.push(num);\n  }\n\n  return factors;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n that \n  are divisible by n.\n\n  The Prime Factors conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Prime Factors(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchPrimeFactorsDivisibleBy(5) returns [1, 5, 3] # The prime factors of 5 is [1, 3, 5, 7], so the factors are 1, 3, 5, 7.\n  */\nconst catchPrimeFactorsDivisibleBy = (n) => {\n  let factors = [];\n  let num = 1;\n  let prev = 1;\n  let next;\n\n  while (num < n) {\n    next = prev * prev;\n    prev = num;\n    num = next;\n    factors.push(num);\n  }\n\n  return factors;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n that \n  are divisible by n and less than n.\n\n  The Prime Factors conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next ", "passed": 0}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "gc": "<|endoftext|>/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  let dateArray = date.split('-');\n  let monthArray = dateArray[0];\n  let dayArray = dateArray[1];\n  let yearArray = dateArray[2];\n  let dateArrayLength = dateArray.length;\n  let monthArrayLength = monthArray.length;\n  let dayArrayLength = dayArray.length;\n  let yearArrayLength = yearArray.length;\n  let isValid = true;\n  if (dateArrayLength < 1 || dateArrayLength > 31) {\n    isValid = false;\n  }\n  if (monthArrayLength < 1 || monthArrayLength > 12) {\n    isValid = false;\n  }\n  if (dayArrayLength < 1 || dayArrayLength > 31) {\n    isValid = false;\n  }\n  if (yearArrayLength < 1 || yearArrayLength > 4) {\n    isValid = false;\n  }\n  if (dateArrayLength < 1 || dateArrayLength > 30) {\n    isValid = false;\n  }\n  if (monthArrayLength < 1 || monthArrayLength > 12) {\n    isValid = false;\n  }\n  if (dayArrayLength < 1 || dayArrayLength > 29) {\n    isValid = false;\n  }\n  if (yearArrayLength < 1 || yearArrayLength > 29) {\n    isValid = false;\n  }\n  return isValid;\n};\n\n/*\n  Given a date string and a month number, this function returns the date in that month.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid or if the month number is invalid, the function returns null.\n  If the month number is invalid, the function returns null.\n  If the date string is not valid ", "passed": 0}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  disconnectedWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  disconnectedWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  disconnectedWords(\"abcdef\") == 3\n  */\nconst disconnectedWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "disconnectedWords", "gc": "<|endoftext|>/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  disconnectedWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  disconnectedWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  disconnectedWords(\"abcdef\") == 3\n  */\nconst disconnectedWords = (txt) => {\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let count = 0\n  let letters = []\n  let letter = ''\n  let oddLetters = []\n  let oddLetter = ''\n  let oddLetterCount = 0\n  let oddLettersCount = 0\n  let oddLettersCount2 = 0\n  let oddLettersCount3 = 0\n  let oddLettersCount4 = 0\n  let oddLettersCount5 = 0\n  let oddLettersCount6 = 0\n  let oddLettersCount7 = 0\n  let oddLettersCount8 = 0\n  let oddLettersCount9 = 0\n  let oddLettersCount10 = 0\n  let oddLettersCount11 = 0\n  let oddLettersCount12 = 0\n  let oddLettersCount13 = 0\n  let oddLettersCount14 = 0\n  let oddLettersCount15 = 0\n  let oddLettersCount16 = 0\n  let oddLettersCount17 = 0\n  let oddLettersCount18 = 0\n  let oddLettersCount19 = 0\n  let oddLettersCount20 = 0\n  let oddLettersCount21 = 0\n  let oddLettersCount22 = 0\n  let oddLettersCount23 = 0\n  let oddLettersCount24 = 0\n  let oddLettersCount25 = 0\n  let oddLettersCount26 = 0\n  let oddLettersCount27 = 0\n  let oddLettersCount28 = 0\n  let oddLettersCount29 = 0\n  let oddLettersCount30 = 0\n  let oddLettersCount31 = 0\n  let oddLettersCount32 = 0\n  let oddLettersCount33 = 0\n  let oddLettersCount34 = 0\n  let oddLettersCount35 = 0\n  let oddLettersCount36 = 0\n  let oddLettersCount37 = 0\n  let oddLettersCount38 = 0\n  let oddLettersCount39 = 0\n  let oddLettersCount40 = 0\n  let oddLettersCount41 = 0\n  let oddLettersCount42 = 0\n  let oddLettersCount43 = 0\n  let oddLettersCount44 = 0\n  let oddLettersCount45 = 0\n  let oddLettersCount46 = 0\n  let oddLettersCount47 = 0\n  let oddLettersCount48 = 0\n  let oddLettersCount49 = 0\n  let oddLettersCount50 = 0\n  let oddLettersCount51 = 0\n  let oddLettersCount52 = 0\n  let oddLettersCount53 = 0\n  let oddLettersCount54 = 0\n  let oddLettersCount55 = 0\n  let oddLettersCount56 = 0\n  let oddLettersCount57 = 0\n  let oddLettersCount58 = 0\n  let oddLettersCount59 = 0\n  let oddLettersCount60 = 0\n  let oddLettersCount61 = 0\n  let oddLettersCount62 = 0\n  let oddLettersCount63 = 0\n  let oddLettersCount64 = 0\n  let oddLettersCount65 = 0\n  let oddLettersCount66 = 0\n  let oddLettersCount67 = 0\n  let oddLettersCount68 = 0\n  let oddLettersCount69 = 0\n  let oddLettersCount70 = 0\n  let oddLettersCount71 = 0\n  let oddLettersCount72 = 0\n  let oddLettersCount73 = 0\n  let oddLettersCount74 = 0\n  let oddLettersCount75 = 0\n  let oddLettersCount76 = 0\n  let oddLettersCount77 = 0\n  let oddLettersCount78 = 0\n  let oddLettersCount79 = 0\n  let oddLettersCount80 = 0\n  let oddLettersCount81 = 0\n  let oddLettersCount82 = 0\n  let oddLettersCount83 = 0\n  let oddLettersCount84 = 0\n  let oddLettersCount85 = 0\n  let oddLettersCount86 = 0\n  let oddLettersCount87 = 0\n  let oddLettersCount88 = 0\n  let oddLettersCount89 = 0\n  let oddLettersCount90 = 0\n  let oddLettersCount91 = 0\n  let oddLettersCount92 = 0\n  let oddLettersCount93 = 0\n  let oddLettersCount94 = 0\n  let oddLettersCount95 = 0\n  let oddLettersCount96 = 0\n  let oddLettersCount97 = 0\n  let oddLettersCount98 = 0\n  let oddLettersCount99 = 0\n  let oddLettersCount100 = 0\n  let oddLettersCount101 = 0\n  let oddLettersCount102 = 0\n  let oddLettersCount103 = 0\n  let oddLettersCount104 = 0\n  let oddLettersCount105 = 0\n  let oddLettersCount106 = 0\n  let oddLettersCount107 = 0\n  let oddLettersCount108 = 0\n  let oddLettersCount109 = 0\n  let oddLettersCount110 = 0\n  let oddLettersCount111 = 0\n  let oddLettersCount112 = 0\n  let oddLettersCount113 = 0\n  let oddLettersCount114 = 0\n  let oddLettersCount115 = 0\n  let oddLettersCount116 = 0\n  let oddLettersCount117 = 0\n  let oddLettersCount118 = 0\n  let oddLettersCount119 = 0\n  let oddLettersCount120 = 0\n  let oddLettersCount121 = 0\n  let oddLettersCount122 = 0\n  let oddLettersCount123 = 0\n  let oddLettersCount124 = 0\n  let oddLettersCount125 = 0\n  let oddLettersCount126 = 0\n  let oddLettersCount127 = 0\n  let oddLettersCount128 = 0\n  let oddLettersCount129 = 0\n  let oddLettersCount130 = 0\n  let oddLettersCount131 = 0\n  let oddLettersCount132 = 0\n  let oddLettersCount133 = 0\n  let oddLettersCount134 = 0\n  let oddLettersCount135 = 0\n  let oddLettersCount136 = 0\n  let oddLettersCount137 = 0\n  let oddLettersCount138 = 0\n  let oddLettersCount139 = 0\n  let oddLettersCount140 = 0\n  let oddLettersCount141 = 0\n  let oddLettersCount142 = 0\n  let oddLettersCount143 = 0\n  let oddLettersCount144 = 0\n  let oddLettersCount145 = 0\n  let oddLettersCount146 = 0\n  let oddLettersCount147 = 0\n  let oddLettersCount148 = 0\n  let oddLettersCount149 = 0\n  let oddLettersCount150 = 0\n  let oddLettersCount151 = 0\n  let oddLettersCount152 = 0\n  let oddLettersCount153 = 0\n  let oddLettersCount154 = 0\n  let oddLettersCount155 = 0\n  let oddLettersCount156 = 0\n  let oddLettersCount157 = 0\n  let oddLettersCount158 = 0\n  let oddLettersCount159 = 0\n  let oddLettersCount160 = 0\n  let oddLettersCount161 = 0\n  let oddLettersCount162 = 0\n  let oddLettersCount163 = 0\n  let oddLettersCount164 = 0\n  let oddLettersCount165 = 0\n  let oddLettersCount166 = 0\n  let oddLettersCount167 = 0\n  let oddLettersCount168 = 0\n  let oddLettersCount169 = 0\n  let oddLettersCount170 = 0", "passed": 0}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isScreen([5]) ➞ true\n  isScreen([1, 2, 3, 4, 5]) ➞ true\n  isScreen([1, 3, 2, 4, 5]) ➞ false\n  isScreen([1, 2, 3, 4, 5, 6]) ➞ true\n  isScreen([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isScreen([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 4]) ➞ true\n  isScreen([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isScreen = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isScreen", "gc": "<|endoftext|>/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isScreen([5]) ➞ true\n  isScreen([1, 2, 3, 4, 5]) ➞ true\n  isScreen([1, 3, 2, 4, 5]) ➞ false\n  isScreen([1, 2, 3, 4, 5, 6]) ➞ true\n  isScreen([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isScreen([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 4]) ➞ true\n  isScreen([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isScreen = (lst) => {\n  let isScreen = true;\n  let arr = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[lst.length - 1]) {\n      isScreen = false;\n      break;\n    }\n    arr.push(lst[i]);\n  }\n  return isScreen;\n};\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n  in descending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isScreenDesc([5]) ➞ false\n  isScreenDesc([1, 2, 3, 4, 5]) ➞ true\n  isScreenDesc([1, 3, 2, 4, 5]) ➞ true\n  isScreenDesc([1, 2, 3, 4, 5, 6]) ➞ false\n  isScreenDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isScreenDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isScreenDesc([1, 2, 2, 3, 3, 4]) ➞ false\n  isScreenDesc([1, 2, 2, 2, 3, 4]) ➞ true\n  isScreenDesc([1, 2, 2, 2, 2, 3]) ➞ false\n  */\nconst isScreenDesc = (lst) => {\n  let isScreen = true;\n  let arr = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[lst.length - 1]) {\n      isScreen = false;\n      break;\n    }\n    arr.push(lst[i]);\n  }\n  return isScreen;\n};\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n  in ascending order and in descending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isScreenDesc([5]) ➞ false\n  isScreenDesc([1, 2, 3, 4, 5]) ➞ false\n  isScreenDesc([1, 3, 2, 4, 5]) ➞ true\n  isScreenDesc([1, 2, 3, 4, 5, 6]) ➞ false\n  isScreenDesc([1, 2, 3, 4, 5, 6, 7]) ➞ false\n  isScreenDesc([1, 3, 2, 4, 5, 6, 7]) ➞ true\n  isScreenDesc([1, 2, 2, 3, 3, 4]) ➞ false\n  isScreenDesc([1, 2, 2, 2, 3, 4]) ➞ true\n  isScreenDesc([1, 2, 2, 2, 2, 3]) ➞ false\n  */\nconst isScreenDescDesc = (lst) => {\n  let isScreen = true;\n  let arr = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[lst.length - 1]) {\n      isScreen = false;\n      break;\n    }\n    arr.push(lst[i]);\n  }\n  return isScreen;\n};\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n  in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order ", "passed": 0}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of overlap of these two \n  intervals is a prime number.\n  Example, the overlap of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the overlap is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  overlap((1, 2), (2, 3)) ==> \"NO\"\n  overlap((-1, 1), (0, 4)) ==> \"NO\"\n  overlap((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst overlap = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "overlap", "gc": "<|endoftext|>/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of overlap of these two \n  intervals is a prime number.\n  Example, the overlap of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the overlap is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  overlap((1, 2), (2, 3)) ==> \"NO\"\n  overlap((-1, 1), (0, 4)) ==> \"NO\"\n  overlap((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst overlap = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 < end2 && start2 < end1) {\n    if (start1 < start2) {\n      if (end1 < end2) {\n        if (start1 < end2 && start2 < end2) {\n          if (start1 < end2 && end1 < end2) {\n            if (start1 < end2 && end1 < end2) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n};\n\nmodule.exports = overlap;\n\n},{}],9:[function(require,module,exports){\n/*\n  You are given two intervals, where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of overlap of these two \n  intervals is a prime number.\n  Example, the overlap of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the overlap is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  overlap((1, 2), (2, 3)) ==> \"NO\"\n  overlap((-1, 1), (0, 4)) ==> \"NO\"\n  overlap((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst overlap = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 < end2 && start2 < end1) {\n    if (start1 < start2) {\n      if (end1 < end2) {\n        if (start1 < end2 && start2 < end2) {\n          if (start1 < end2 && end1 < end2) {\n            if (start1 < end2 && end1 < end2) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n};\n\nmodule.exports = overlap;\n\n},{}],10:[function(require,module,exports){\n/*\n  You are given two intervals, where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of overlap of these two \n  intervals is a prime number.\n  Example, the overlap of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the overlap is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  overlap((1, 2), (2, 3)) ==> \"NO\"\n  overlap((-1, 1), (0, 4)) ==> \"NO\"\n  overlap((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst overlap = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 < end2 && start2 < end1) {\n    if (start1 < start2) {\n      if (end1 < end2) {\n        if (start1 < end2 && start2 < end2) {\n          if (start1 < end2 && end1 < end2) {\n            if (start1 < end2 && end1 < end2) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n};\n\nmodule.exports = overlap;\n\n},{}],11:[function(require,module,exports){\n/*\n  You are given two intervals, where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of overlap of these two \n  intervals is a prime number.\n  Example, the overlap of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the overlap is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  overlap((1, 2), (2, 3)) ==> \"NO\"\n  overlap((-1, 1), (0, 4)) ==> \"NO\"\n  overlap((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst overlap = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 < end2 && start2 < end1) {\n    if (start1 < start2) {\n      if (end1 < end2) {\n        if (start1 < end2 && start2 < end2) {\n          if (start1 < end2 && end1 < end2) {\n            if (start1 < end2 && end1 < end2) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n};\n\nmodule.exports = overlap;\n\n},{}],12:[function(require,module,exports){\n/*\n  You are given two intervals, where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of overlap of these two \n  intervals is a prime number.\n  Example, the overlap of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the overlap is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  overlap((1, 2), (2, 3)) ==> \"NO\"\n  overlap((-1, 1), (0, 4)) ==> \"NO\"\n  overlap((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst overlap = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 < end2 && start2 < end1) {\n    if (start1 < start2) {\n      if (end1 < end2) {\n        if (start1 < end2 && start2 < end2) {\n          if (start1 < end2 && end1 < end2) {\n            if (start1 < end2 && end1 < end2) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n};\n\nmodule.exports = overlap;\n\n},{}],13:[function(require,module,exports){\n/*\n  You are given two intervals, where each interval is a pair of integers. ", "passed": 0}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "goadSigns", "gc": "<|endoftext|>/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sign = -1;\n    } else if (arr[i] < 0) {\n      sign = 1;\n    }\n    sum += sign * Math.pow(Math.abs(arr[i]), 2);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns2 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sign = -1;\n    } else if (arr[i] < 0) {\n      sign = 1;\n    }\n    sum += sign * Math.pow(Math.abs(arr[i]), 2);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns3 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sign = -1;\n    } else if (arr[i] < 0) {\n      sign = 1;\n    }\n    sum += sign * Math.pow(Math.abs(arr[i]), 2);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns4 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sign = -1;\n    } else if (arr[i] < 0) {\n      sign = 1;\n    }\n    sum += sign * Math.pow(Math.abs(arr[i]), 2);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns5 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sign = -1;\n    } else if (arr[i] < 0) {\n      sign = 1;\n    }\n    sum += sign * Math.pow(Math.abs(arr[i]), 2);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns6 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sign = -1;\n    } else if (arr[i] < 0) {\n      sign = 1;\n    }\n    sum += sign * Math.pow(Math.abs(arr[i]), 2);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns7 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sign = -1;\n    } else if (arr[i] < 0) {\n      sign = 1;\n    }\n    sum += sign * Math.pow(Math.abs(arr[i]), 2);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns8 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sign = -1;\n    } else if (arr[i] < 0) {\n      sign = 1;\n    }\n    sum += sign * Math.pow(Math.abs(arr[i]), 2);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns9 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sign = -1;\n    } else if (arr[i] < 0) {\n      sign = 1;\n    }\n    sum += sign * Math.pow(Math.abs(arr[i]), 2);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns10 = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sign = -1;\n    } else if (arr[i] < 0) {\n      sign = 1;\n    }\n    sum += sign * Math.pow(Math.abs(arr[i]), 2);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:", "passed": 0}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minutePath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minutePath", "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minutePath = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [startCell, startRow] = [0, rows];\n  const [endCell, endRow] = [startRow, rows];\n  const [startCell, startCol] = [startRow, 0];\n  const [endCell, endCol] = [endRow, cols];\n  const [visited, set] = new Set();\n  const result = [];\n  const queue = [\n    [startCell, startRow, startCol],\n    [endCell, endRow, endCol]\n  ];\n  while (queue.length) {\n    const [currentCell, currentRow, currentCol] = queue.shift();\n    if (visited.has(currentCell)) {\n      continue;\n    }\n    visited.add(currentCell);\n    const neighbors = grid[currentRow][currentCol].filter(\n      neighbor =>!visited.has(neighbor)\n    );\n    neighbors.forEach(neighbor => {\n      const neighborCell = currentCell + neighbor;\n      if (visited.has(neighborCell)) {\n        return;\n      }\n      visited.add(neighborCell);\n      queue.push([neighborCell, currentRow, currentCol]);\n    });\n    result.push(currentCell);\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/minimum-path-sum-ii/\n/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number[]}\n */\nvar minPathSum = function(grid, k) {\n  const result = [];\n  const [rows, cols] = grid.length;\n  const [startCell, startRow] = [0, rows];\n  const [endCell, endRow] = [startRow, rows];\n  const [startCell, startCol] = [startRow, 0];\n  const [endCell, endCol] = [endRow, cols];\n  const [visited, set] = new Set();\n  const queue = [\n    [startCell, startRow, startCol],\n    [endCell, endRow, endCol]\n  ];\n  while (queue.length) {\n    const [currentCell, currentRow, currentCol] = queue.shift();\n    if (visited.has(currentCell)) {\n      continue;\n    }\n    visited.add(currentCell);\n    const neighbors = grid[currentRow][currentCol].filter(\n      neighbor =>!visited.has(neighbor)\n    );\n    neighbors.forEach(neighbor => {\n      const neighborCell = currentCell + neighbor;\n      if (visited.has(neighborCell)) {\n        return;\n      }\n      visited.add(neighborCell);\n      queue.push([neighborCell, currentRow, currentCol]);\n    });\n    result.push(currentCell);\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/minimum-path-sum-iii/\n/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number[]}\n */\nvar minPathSumIII = function(grid, k) {\n  const result = [];\n  const [rows, cols] = grid.length;\n  const [startCell, startRow] = [0, rows];\n  const [endCell, endRow] = [startRow, rows];\n  const [startCell, startCol] = [startRow, 0];\n  const [endCell, endCol] = [endRow, cols];\n  const [visited, set] = new Set();\n  const queue = [\n    [startCell, startRow, startCol],\n    [endCell, endRow, endCol]\n  ];\n  while (queue.length) {\n    const [currentCell, currentRow, currentCol] = queue.shift();\n    if (visited.has(currentCell)) {\n      continue;\n    }\n    visited.add(currentCell);\n    const neighbors = grid[currentRow][currentCol].filter(\n      neighbor =>!visited.has(neighbor)\n    );\n    neighbors.forEach(neighbor => {\n      const neighborCell = currentCell + neighbor;\n      if (visited.has(neighborCell)) {\n        return;\n      }\n      visited.add(neighborCell);\n      queue.push([neighborCell, currentRow, currentCol]);\n    });\n    result.push(currentCell);\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/minimum-path-sum-iv/\n/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number[]}\n */\nvar minPathSumIV = function(grid, k) {\n  const result = [];\n  const [rows, cols] = grid.length;\n  const [startCell, startRow] = [0, rows];\n  const [endCell, endRow] = [startRow, rows];\n  const [startCell, startCol] = [startRow, 0];\n  const [endCell, endCol] = [endRow, cols];\n  const [visited, set] = new Set();\n  const queue = [\n    [startCell, startRow, startCol],\n    [endCell, endRow, endCol]\n  ];\n  while (queue.length) {\n    const [currentCell, currentRow, currentCol] = queue.shift();\n    if (visited.has(currentCell)) {\n      continue;\n    }\n    visited.add(currentCell);\n    const neighbors = grid[currentRow][currentCol].filter(\n      neighbor =>!visited.has(neighbor)\n    );\n    neighbors.forEach(neighbor => {\n      const neighborCell = currentCell + neighbor;\n      if (visited.has(neighborCell)) {\n        return;\n      }\n      visited.add(neighborCell);\n      queue.push([neighborCell, currentRow, currentCol]);\n    });\n    result.push(currentCell);\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/minimum-path-sum-iii/\n/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number[]}\n */\nvar minPathSumIII = function(grid, k) {\n  const result = [];\n  const [rows, cols] = grid.length;\n  const [startCell, startRow] = [0, rows];\n  const [endCell, endRow] = [startRow, rows];\n  const [startCell, startCol] = [startRow, 0];\n  const [endCell, endCol] = [endRow, cols];\n  const [visited, set] = new Set();\n  const queue = [\n    [", "passed": 0}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest common divisor of two integers a and b\n  >>> capitalCoarseDivisor(3, 5)\n  1\n  >>> capitalCoarseDivisor(25, 15)\n  5\n  */\nconst capitalCoarseDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "capitalCoarseDivisor", "gc": "<|endoftext|>/* Return a greatest common divisor of two integers a and b\n  >>> capitalCoarseDivisor(3, 5)\n  1\n  >>> capitalCoarseDivisor(25, 15)\n  5\n  */\nconst capitalCoarseDivisor = (a, b) => {\n  if (a < b) return a;\n  if (b < a) return b;\n  return a % b;\n};\n\n/**\n * Capitalize first letter of a string\n * >>> capitalize('hello')\n 'Hello'\n */\nconst capitalize = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n * Capitalize first letter of a string and remove trailing space\n * >>> capitalize('   hello   ')\n 'Hello'\n */\nconst capitalizeAndTrim = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n};\n\n/**\n * Capitalize first letter of a string and remove trailing space\n * >>> capitalizeAndTrim('   hello   ')\n 'Hello'\n */\nconst capitalizeAndTrimAndTrim = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() + str.slice(2);\n};\n\n/**\n * Capitalize first letter of a string and remove trailing space\n * >>> capitalizeAndTrimAndTrim('   hello   ')\n 'Hello'\n */\nconst capitalizeAndTrimAndTrimAndTrim = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() + str.slice(2) + str.slice(3);\n};\n\n/**\n * Capitalize first letter of a string and remove trailing space\n * >>> capitalizeAndTrimAndTrimAndTrim('   hello   ')\n 'Hello'\n */\nconst capitalizeAndTrimAndTrimAndTrimAndTrim = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() + str.slice(2) + str.slice(3) + str.slice(4);\n};\n\n/**\n * Capitalize first letter of a string and remove trailing space\n * >>> capitalizeAndTrimAndTrimAndTrimAndTrim('   hello   ')\n 'Hello'\n */\nconst capitalizeAndTrimAndTrimAndTrimAndTrimAndTrim = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() + str.slice(2) + str.slice(3) + str.slice(4) + str.slice(5);\n};\n\n/**\n * Capitalize first letter of a string and remove trailing space\n * >>> capitalizeAndTrimAndTrimAndTrimAndTrimAndTrim('   hello   ')\n 'Hello'\n */\nconst capitalizeAndTrimAndTrimAndTrimAndTrimAndTrimAndTrim = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() + str.slice(2) + str.slice(3) + str.slice(4) + str.slice(5) + str.slice(6);\n};\n\n/**\n * Capitalize first letter of a string and remove trailing space\n * >>> capitalizeAndTrimAndTrimAndTrimAndTrimAndTrimAndTrim = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() + str.slice(2) + str.slice(3) + str.slice(4) + str.slice(5) + str.slice(6) + str.slice(7);\n};\n\n/**\n * Capitalize first letter of a string and remove trailing space\n * >>> capitalizeAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrim = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() + str.slice(2) + str.slice(3) + str.slice(4) + str.slice(5) + str.slice(6) + str.slice(7) + str.slice(8);\n};\n\n/**\n * Capitalize first letter of a string and remove trailing space\n * >>> capitalizeAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrim = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() + str.slice(2) + str.slice(3) + str.slice(4) + str.slice(5) + str.slice(6) + str.slice(7) + str.slice(8) + str.slice(9);\n};\n\n/**\n * Capitalize first letter of a string and remove trailing space\n * >>> capitalizeAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrim = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() + str.slice(2) + str.slice(3) + str.slice(4) + str.slice(5) + str.slice(6) + str.slice(7) + str.slice(8) + str.slice(9) + str.slice(10);\n};\n\n/**\n * Capitalize first letter of a string and remove trailing space\n * >>> capitalizeAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrim = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() + str.slice(2) + str.slice(3) + str.slice(4) + str.slice(5) + str.slice(6) + str.slice(7) + str.slice(8) + str.slice(9) + str.slice(10) + str.slice(11);\n};\n\n/**\n * Capitalize first letter of a string and remove trailing space\n * >>> capitalizeAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrim = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() + str.slice(2) + str.slice(3) + str.slice(4) + str.slice(5) + str.slice(6) + str.slice(7) + str.slice(8) + str.slice(9) + str.slice(10) + str.slice(11) + str.slice(12);\n};\n\n/**\n * Capitalize first letter of a string and remove trailing space\n * >>> capitalizeAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrim = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() + str.slice(2) + str.slice(3) + str.slice(4) + str.slice(5) + str.slice(6) + str.slice(7) + str.slice(8) + str.slice(9) + str.slice(10) + str.slice(11) + str.slice(12) + str.slice(13);\n};\n\n/**\n * Capitalize first letter of a string and remove trailing space\n * >>> capitalizeAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrimAndTrim", "passed": 0}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "gc": "<|endoftext|>/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  if (n <= 1) {\n    return [1];\n  }\n  return [tri(n - 1) + tri(n - 2) + tri(n + 1)];\n};\n\n/*\n  Given a non-negative integer n, return a list of all the prime factors of n.\n  For example, factors(3) returns [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  Factorization is done by dividing the number by each of the factors until \n  the result is less than or equal to the number n. For example, factors(3) returns \n  [2, 3, 5]. \n  ", "passed": 0}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd digit.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digit = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digit", "gc": "<|endoftext|>/*Given a positive integer n, return the product of the odd digit.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digit = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the even digit.\n  Return 0 if all digit are odd.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 4\n  digit(235) == 24\n  */\nconst digitEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*Given a positive integer n, return the sum of all digit.\n  Return 0 if n is 0.\n  For example:\n  digit(5) == 5\n  digit(23) == 23\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of all digit even and odd.\n  Return 0 if n is 0.\n  For example:\n  digitEven(5) == 5\n  digitEven(23) == 23\n  */\nconst digitSumEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n    if (n % 2 === 0) {\n      sum += 1;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of all digit even and odd.\n  Return 0 if n is 0.\n  For example:\n  digitEvenOdd(5) == 5\n  digitEvenOdd(23) == 23\n  */\nconst digitSumEvenOddOdd = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n    if (n % 2 === 0) {\n      sum += 1;\n    }\n    if (n % 2 === 1) {\n      sum += 2;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of all digit even and odd.\n  Return 0 if n is 0.\n  For example:\n  digitEvenOddOdd(5) == 5\n  digitEvenOddOdd(23) == 23\n  */\nconst digitSumEvenOddOddOddOdd = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n    if (n % 2 === 0) {\n      sum += 1;\n    }\n    if (n % 2 === 1) {\n      sum += 2;\n    }\n    if (n % 2 === 2) {\n      sum += 3;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of all digit even and odd.\n  Return 0 if n is 0.\n  For example:\n  digitEvenOddOddOddOddOdd(5) == 5\n  digitEvenOddOddOddOddOddOdd(23) == 23\n  */\nconst digitSumEvenOddOddOddOddOddOdd = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n    if (n % 2 === 0) {\n      sum += 1;\n    }\n    if (n % 2 === 1) {\n      sum += 2;\n    }\n    if (n % 2 === 2) {\n      sum += 3;\n    }\n    if (n % 2 === 3) {\n      sum += 4;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of all digit even and odd.\n  Return 0 if n is 0.\n  For example:\n  digitEvenOddOddOddOddOddOddOdd(5) == 5\n  digitEvenOddOddOddOddOddOddOddOddOdd(23) == 23\n  */\nconst digitSumEvenOddOddOddOddOddOddOddOdd = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n    if (n % 2 === 0) {\n      sum += 1;\n    }\n    if (n % 2 === 1) {\n      sum += 2;\n    }\n    if (n % 2 === 2) {\n      sum += 3;\n    }\n    if (n % 2 === 3) {\n      sum += 4;\n    }\n    if (n % 2 === 4) {\n      sum += 5;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of all digit even and odd.\n  Return 0 if n is 0.\n  For example:\n  digitEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOdd", "passed": 0}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]') ➞ true\n  isNest('[]]]]]]][[[[[]') ➞ false\n  isNest('[][]') ➞ false\n  isNest('[]') ➞ false\n  isNest('[[][]]') ➞ true\n  isNest('[[]][[') ➞ true\n  */\nconst isNest = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNest", "gc": "<|endoftext|>/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]') ➞ true\n  isNest('[]]]]]]][[[[[]') ➞ false\n  isNest('[][]') ➞ false\n  isNest('[]') ➞ false\n  isNest('[[][]]') ➞ true\n  isNest('[[]][[') ➞ true\n  */\nconst isNest = (string) => {\n  const nestingRegex = /[\\[\\]]/g;\n  const nestingDepth = 0;\n  let nesting = false;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let nestingDepth = 0;\n  let ", "passed": 0}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst summarizeSquare = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "summarizeSquare", "gc": "<|endoftext|>/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst summarizeSquare = (lst) => {\n  let sum = 0;\n  let sumOfSquare = 0;\n  let sumOfSquareOfList = 0;\n  let sumOfSquareOfListOfList = 0;\n  let sumOfSquareOfListOfListOfList = 0;\n  let sumOfSquareOfListOfListOfListOfListOfList = 0;\n  let sumOfSquareOfListOfListOfListOfListOfListOfList = 0;\n  let sumOfSquareOfListOfListOfListOfListOfListOfListOfList = 0;\n  let sumOfSquareOfListOfListOfListOfListOfListOfListOfListOfList = 0;\n  let sumOfSquareOfListOfListOfListOfListOfListOfListOfListOfListOfList = 0;\n  let sumOfSquareOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList = 0;\n  let sumOfSquareOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList = 0;\n  let sumOfSquareOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList = 0;\n  let sumOfSquareOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList = 0;\n  let sumOfSquareOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList = 0;\n  let sumOfSquareOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList = 0;\n  let sumOfSquareOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList", "passed": 0}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "determineIfConcludingCharConstituteALetter", "gc": "<|endoftext|>/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n  const letters = txt.split(\" \");\n  const lastLetter = letters[letters.length - 1];\n  return lastLetter!== \".\" && lastLetter!== \" \";\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pie e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pie e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n  const letters = txt.split(\" \");\n  const lastLetter = letters[letters.length - 1];\n  return lastLetter!== \".\" && lastLetter!== \" \";\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pie e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pie e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n  const letters = txt.split(\" \");\n  const lastLetter = letters[letters.length - 1];\n  return lastLetter!== \".\" && lastLetter!== \" \";\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pie e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pie e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n  const letters = txt.split(\" \");\n  const lastLetter = letters[letters.length - 1];\n  return lastLetter!== \".\" && lastLetter!== \" \";\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pie e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pie e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n  const letters = txt.split(\" \");\n  const lastLetter = letters[letters.length - 1];\n  return lastLetter!== \".\" && lastLetter!== \" \";\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pie e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pie e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n  const letters = txt.split(\" \");\n  const lastLetter = letters[letters.length - 1];\n  return lastLetter!== \".\" && lastLetter!== \" \";\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pie e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pie e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n  const letters = txt.split(\" \");\n  const lastLetter = letters[letters.length - 1];\n  return lastLetter!== \".\" && lastLetter!== \" \";\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pie e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pie e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n  const letters = txt.split(\" \");", "passed": 0}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canStage([1,2,4,3,5]) = 3\n  canStage([1,2,3]) = -1\n  */\nconst canStage = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canStage", "gc": "<|endoftext|>/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canStage([1,2,4,3,5]) = 3\n  canStage([1,2,3]) = -1\n  */\nconst canStage = (arr) => {\n  let i = arr.length - 1;\n  let j = 0;\n  let k = 0;\n  while (arr[j] < arr[i]) {\n    i++;\n    j++;\n  }\n  while (arr[j] > arr[i]) {\n    j--;\n  }\n  while (arr[j] === arr[i]) {\n    i++;\n    j++;\n  }\n  while (arr[j] === arr[k]) {\n    j--;\n    k++;\n  }\n  return j;\n};\n\n/*\n  Given an array of integers, return a new array which contains all the\n  elements of the original array except the element at position k. If\n  the element at position k is greater than the element at position i, then\n  the new array should contain all elements from position i to k. If\n  the element at position k is less than the element at position i, then the\n  new array should contain all elements from position i to k+1.\n\n  Examples:\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,3,4,5,6,7]\n  removeElements([1,2,3,4,5,6,7,8]) = [2,", "passed": 0}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  bigSmallIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  bigSmallIntegers([]) == (null, null)\n  bigSmallIntegers([0]) == (null, null)\n  */\nconst bigSmallIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "bigSmallIntegers", "gc": "<|endoftext|>/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  bigSmallIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  bigSmallIntegers([]) == (null, null)\n  bigSmallIntegers([0]) == (null, null)\n  */\nconst bigSmallIntegers = (lst) => {\n  const maxNum = lst.reduce((a, b) => Math.max(a, b), 0);\n  const minNum = lst.reduce((a, b) => Math.min(a, b), 0);\n  if (maxNum < minNum) {\n    return null;\n  }\n  return [minNum, maxNum];\n};\n\n/**\n * Given a sorted array of numbers, return the largest and smallest\n * number in the array.\n * If there are no numbers in the array, return null.\n * Examples:\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 2)\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 5)\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 1)\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 3)\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 2)\n */\nconst smallestAndLargest = (lst) => {\n  const [minNum, maxNum] = bigSmallIntegers(lst);\n  if (minNum === null || maxNum === null) {\n    return null;\n  }\n  return [minNum, maxNum];\n};\n\n/**\n * Given a sorted array of numbers, return the largest and smallest\n * number in the array.\n * If there are no numbers in the array, return null.\n * Examples:\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 2)\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 5)\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 1)\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 3)\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 2)\n */\nconst smallest = (lst) => {\n  const [minNum, maxNum] = smallestAndLargest(lst);\n  if (minNum === null || maxNum === null) {\n    return null;\n  }\n  return [minNum, maxNum];\n};\n\n/**\n * Given a sorted array of numbers, return the largest and smallest\n * number in the array.\n * If there are no numbers in the array, return null.\n * Examples:\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 2)\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 5)\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 1)\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 3)\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 2)\n */\nconst largest = (lst) => {\n  const [minNum, maxNum] = smallestAndLargest(lst);\n  if (minNum === null || maxNum === null) {\n    return null;\n  }\n  return [maxNum, minNum];\n};\n\n/**\n * Given a sorted array of numbers, return the largest and smallest\n * number in the array.\n * If there are no numbers in the array, return null.\n * Examples:\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 2)\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 5)\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 1)\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 3)\n * smallestAndLargest([10, 5, 1, 3, 2]) == (null, 2)\n */\nconst smallestAndLargestAndLargest = (lst) => {\n  const [minNum, maxNum] = smallestAndLargest(lst);\n  if (minNum === null || maxNum === null) {\n    return null;\n  }\n  const [minNum2, maxNum2] = bigSmallIntegers(lst);\n  if (minNum2 === null || maxNum2 === null) {\n    return null;\n  }\n  return [minNum, maxNum, minNum2, maxNum2];\n};\n\n/**\n * Given a sorted array of numbers, return the largest and smallest\n * number in the array.\n * If there are no numbers in the array, return null.\n * Examples:\n * smallestAndLargestAndLargest([10, 5, 1, 3, 2]) == (null, 2)\n * smallestAndLargestAndLargest([10, 5, 1, 3, 2]) == (null, 5)\n * smallestAndLargestAndLargest([10, 5, 1, 3, 2]) == (null, 1)\n * smallestAndLargestAndLargest([10, 5, 1, 3, 2]) == (null, 3)\n * smallestAndLargestAndLargest([10, 5, 1, 3, 2]) == (null, 2)\n */\nconst smallestAndLargestAndLargest = (lst) => {\n  const [minNum, maxNum, minNum2, maxNum2] = smallestAndLargestAndLargest(lst);\n  if (minNum === null || maxNum === null) {\n    return null;\n  }\n  return [minNum, maxNum, minNum2, maxNum2];\n};\n\n/**\n * Given a sorted array of numbers, return the largest and smallest\n * number in the array.\n * If there are no numbers in the array, return null.\n * Examples:\n * smallestAndLargestAndLargest([10, 5, 1, 3, 2]) == (null, 2)\n * smallestAndLargestAndLargest([10, 5, 1, 3, 2]) == (null, 5)\n * smallestAndLargestAndLargest([10, 5, 1, 3, 2]) == (null, 1)\n * smallestAndLargestAndLargest([10, 5, 1, 3, 2]) == (null, 3)\n * smallestAndLargestAndLargest([10, 5, 1, 3, 2]) == (null, 2)\n */\nconst largestAndSmallest = (lst) => {\n  const [minNum, maxNum] = smallestAndLargest(lst);\n  if (minNum === null || maxNum === null) {\n    return null;\n  }\n  return [maxNum, minNum];\n};\n\n/**\n * Given a sorted array of numbers, return the largest and smallest\n * number in the array.\n * If there are no numbers in the array, return null.\n * Examples:\n * smallestAndLargestAndLargest([10, 5, 1, 3, 2]) == (null, 2)\n * smallestAndLargestAndLargest([10, 5, 1, 3, 2]) == (null, 5)\n * smallestAndLargestAndLargest([10, 5, 1, 3, 2]) == (null, 1)\n * smallestAndLargestAndLargest([10, 5, 1, 3, 2]) == (null, 3)\n * smallestAndLargestAndLargest([10, 5, 1, 3, 2]) == (null, 2)\n */\nconst largestAndSmallest = (lst) => {\n  const [minNum, maxNum] = smallestAndLargest(lst);\n  if (minNum === null || maxNum === null) {\n    return null;\n  }\n  return [minNum, maxNum];\n};\n\n/**\n * Given a sorted array of numbers, return the largest and smallest", "passed": 0}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "gc": "<|endoftext|>/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return null\n  }\n  if (a === null) {\n    return b\n  }\n  if (b === null) {\n    return a\n  }\n  if (typeof a === \"string\") {\n    a = parseFloat(a)\n  }\n  if (typeof b === \"string\") {\n    b = parseFloat(b)\n  }\n  if (isNaN(a) && isNaN(b)) {\n    return null\n  }\n  if (a === b) {\n    return null\n  }\n  if (a < b) {\n    return -1\n  }\n  if (a > b) {\n    return 1\n  }\n  return 0\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ 2.5\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return null\n  }\n  if (a === null) {\n    return b\n  }\n  if (b === null) {\n    return a\n  }\n  if (typeof a === \"string\") {\n    a = parseFloat(a)\n  }\n  if (typeof b === \"string\") {\n    b = parseFloat(b)\n  }\n  if (isNaN(a) && isNaN(b)) {\n    return null\n  }\n  if (a === b) {\n    return null\n  }\n  if (a > b) {\n    return 1\n  }\n  if (a < b) {\n    return -1\n  }\n  return 0\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ 2.5\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return null\n  }\n  if (a === null) {\n    return b\n  }\n  if (b === null) {\n    return a\n  }\n  if (typeof a === \"string\") {\n    a = parseFloat(a)\n  }\n  if (typeof b === \"string\") {\n    b = parseFloat(b)\n  }\n  if (isNaN(a) && isNaN(b)) {\n    return null\n  }\n  if (a === b) {\n    return null\n  }\n  if (a > b) {\n    return 1\n  }\n  if (a < b) {\n    return -1\n  }\n  return 0\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ 2.5\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return null\n  }\n  if (a === null) {\n    return b\n  }\n  if (b === null) {\n    return a\n  }\n  if (typeof a === \"string\") {\n    a = parseFloat(a)\n  }\n  if (typeof b === \"string\") {\n    b = parseFloat(b)\n  }\n  if (isNaN(a) && isNaN(b)) {\n    return null\n  }\n  if (a === b) {\n    return null\n  }\n  if (a < b) {\n    return -1\n  }\n  if (a > b) {\n    return 1\n  }\n  return 0\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ 2.5\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return null\n  }\n  if (a === null) {\n    return b\n  }\n  if (b === null) {\n    return a\n  }\n  if (typeof a === \"string\") {\n    a = parseFloat(a)\n  }\n  if (typeof b === \"string\") {\n    b = parseFloat(b)\n  }\n  if (isNaN(a) && isNaN(b)) {\n    return null\n  }\n  if (a === b) {\n    return null\n  }\n  if (a > b) {\n    return 1\n  }\n  if (a < b) {\n    return -1\n  }\n  return 0\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ 2.5\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return null\n  }\n  if (a === null) {\n    return b\n  }\n  if (b === null) {\n    return a\n  }\n  if (typeof a === \"string\") {\n    a = parseFloat(a)\n  }\n  if (typeof b === \"string\") {\n    b = parseFloat(b)\n  }\n  if (isNaN(a) && isNaN(b)) {\n    return null\n  }\n  if (a === b) {\n    return null\n  }\n  if (a > b) {\n    return -1\n  }\n  if (a < b) {\n    return 1\n  }\n  return 0\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ 2.5\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === b) {\n    return null\n  }\n  if (a === null) {\n    return b\n  }\n  if (b === null) {\n    return a\n  }\n  if (typeof a === \"string\") {\n    a = parseFloat(a)\n  }\n  if (typeof b === \"string\") {\n    b = parseFloat(b)\n  }\n  if (isNaN(a) && isNaN(b)) {\n    return null\n  }\n  if (a === b) {\n    return null\n  }\n  if (a > b) {\n    return 1\n  }\n  if (a < b) {\n    return -1\n  }\n  return 0\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,", "passed": 0}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isAdequateToSumEven(4) == false\n  isAdequateToSumEven(6) == false\n  isAdequateToSumEven(8) == true\n  */\nconst isAdequateToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isAdequateToSumEven", "gc": "<|endoftext|>/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isAdequateToSumEven(4) == false\n  isAdequateToSumEven(6) == false\n  isAdequateToSumEven(8) == true\n  */\nconst isAdequateToSumEven = (n) => {\n  const nums = [...Array(n).keys()];\n  const evenNumbers = nums.filter((n) => n % 2 === 0);\n  return evenNumbers.length === 4;\n};\n\n/*\n  Given a number n, return whether it is possible to write n as a sum of exactly 2 prime numbers\n  Example\n  isPrime(2) == true\n  isPrime(3) == false\n  isPrime(5) == true\n  isPrime(7) == false\n  */\nconst isPrime = (n) => {\n  const nums = [...Array(n).keys()];\n  const primeNumbers = nums.filter((n) => n % 2 === 0);\n  return primeNumbers.length === 2;\n};\n\n/*\n  Given a number n, return whether it is possible to write n as a sum of exactly 2 prime numbers\n  Example\n  isPrime(2) == true\n  isPrime(3) == false\n  isPrime(5) == true\n  isPrime(7) == false\n  */\nconst isPrime = (n) => {\n  const nums = [...Array(n).keys()];\n  const primeNumbers = nums.filter((n) => n % 2 === 0);\n  return primeNumbers.length === 2;\n};\n\n/*\n  Given a number n, return whether it is possible to write n as a sum of exactly 2 prime numbers\n  Example\n  isPrime(2) == true\n  isPrime(3) == false\n  isPrime(5) == true\n  isPrime(7) == false\n  */\nconst isPrime = (n) => {\n  const nums = [...Array(n).keys()];\n  const primeNumbers = nums.filter((n) => n % 2 === 0);\n  return primeNumbers.length === 2;\n};\n\n/*\n  Given a number n, return whether it is possible to write n as a sum of exactly 2 prime numbers\n  Example\n  isPrime(2) == true\n  isPrime(3) == false\n  isPrime(5) == true\n  isPrime(7) == false\n  */\nconst isPrime = (n) => {\n  const nums = [...Array(n).keys()];\n  const primeNumbers = nums.filter((n) => n % 2 === 0);\n  return primeNumbers.length === 2;\n};\n\n/*\n  Given a number n, return whether it is possible to write n as a sum of exactly 2 prime numbers\n  Example\n  isPrime(2) == true\n  isPrime(3) == false\n  isPrime(5) == true\n  isPrime(7) == false\n  */\nconst isPrime = (n) => {\n  const nums = [...Array(n).keys()];\n  const primeNumbers = nums.filter((n) => n % 2 === 0);\n  return primeNumbers.length === 2;\n};\n\n/*\n  Given a number n, return whether it is possible to write n as a sum of exactly 2 prime numbers\n  Example\n  isPrime(2) == true\n  isPrime(3) == false\n  isPrime(5) == true\n  isPrime(7) == false\n  */\nconst isPrime = (n) => {\n  const nums = [...Array(n).keys()];\n  const primeNumbers = nums.filter((n) => n % 2 === 0);\n  return primeNumbers.length === 2;\n};\n\n/*\n  Given a number n, return whether it is possible to write n as a sum of exactly 2 prime numbers\n  Example\n  isPrime(2) == true\n  isPrime(3) == false\n  isPrime(5) == true\n  isPrime(7) == false\n  */\nconst isPrime = (n) => {\n  const nums = [...Array(n).keys()];\n  const primeNumbers = nums.filter((n) => n % 2 === 0);\n  return primeNumbers.length === 2;\n};\n\n/*\n  Given a number n, return whether it is possible to write n as a sum of exactly 2 prime numbers\n  Example\n  isPrime(2) == true\n  isPrime(3) == false\n  isPrime(5) == true\n  isPrime(7) == false\n  */\nconst isPrime = (n) => {\n  const nums = [...Array(n).keys()];\n  const primeNumbers = nums.filter((n) => n % 2 === 0);\n  return primeNumbers.length === 2;\n};\n\n/*\n  Given a number n, return whether it is possible to write n as a sum of exactly 2 prime numbers\n  Example\n  isPrime(2) == true\n  isPrime(3) == false\n  isPrime(5) == true\n  isPrime(7) == false\n  */\nconst isPrime = (n) => {\n  const nums = [...Array(n).keys()];\n  const primeNumbers = nums.filter((n) => n % 2 === 0);\n  return primeNumbers.length === 2;\n};\n\n/*\n  Given a number n, return whether it is possible to write n as a sum of exactly 2 prime numbers\n  Example\n  isPrime(2) == true\n  isPrime(3) == false\n  isPrime(5) == true\n  isPrime(7) == false\n  */\nconst isPrime = (n) => {\n  const nums = [...Array(n).keys()];\n  const primeNumbers = nums.filter((n) => n % 2 === 0);\n  return primeNumbers.length === 2;\n};\n\n/*\n  Given a number n, return whether it is possible to write n as a sum of exactly 2 prime numbers\n  Example\n  isPrime(2) == true\n  isPrime(3) == false\n  isPrime(5) == true\n  isPrime(7) == false\n  */\nconst isPrime = (n) => {\n  const nums = [...Array(n).keys()];\n  const primeNumbers = nums.filter((n) => n % 2 === 0);\n  return primeNumbers.length === 2;\n};\n\n/*\n  Given a number n, return whether it is possible to write n as a sum of exactly 2 prime numbers\n  Example\n  isPrime(2) == true\n  isPrime(3) == false\n  isPrime(5) == true\n  isPrime(7) == false\n  */\nconst isPrime = (n) => {\n  const nums = [...Array(n).keys()];\n  const primeNumbers = nums.filter((n) => n % 2 === 0);\n  return primeNumbers.length === 2;\n};\n\n/*\n  Given a number n, return whether it is possible to write n as a sum of exactly 2 prime numbers\n  Example\n  isPrime(2) == true\n  isPrime(3) == false\n  isPrime(5) == true\n  isPrime(7) == false\n  */\nconst isPrime = (n) => {\n  const nums = [...Array(n).keys()];\n  const primeNumbers = nums.filter((n) => n % 2 === 0);\n  return primeNumbers.length === 2;\n};\n\n/*\n  Given a number n, return whether it is possible to write n as a sum of exactly 2 prime numbers\n  Example\n  isPrime(2) == true\n  isPrime(3) == false\n  isPrime(5) == true\n  isPrime(7) == false\n  */\nconst isPrime = (n) => {\n  const nums = [...Array(n).keys()];\n  const primeNumbers = nums.filter((n) => n % 2 === 0);\n  return primeNumbers.length === 2;\n};\n\n/*\n  Given a number n, return whether it is possible to write n as a sum of exactly 2 prime numbers\n  Example\n  isPrime(2) == true\n  isPrime(3) == false\n  isPrime(5) == true\n  isPrime(7) == false\n  */\nconst isPrime = (n) => {\n  const nums = [...Array(n).", "passed": 0}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> extraFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst extraFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "extraFactorial", "gc": "<|endoftext|>/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> extraFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst extraFactorial = (n) => {\n  let result = 1;\n  for (let i = 2; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given the number 5, the largest prime factor of 5 is 2.\n  If the number n is negative, return -1.\n  */\nconst largestPrimeFactor = (n) => {\n  if (n < 2) {\n    return -1;\n  }\n  let result = 2;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given the number 5, the largest prime factor of 5 is 2.\n  If the number n is negative, return -1.\n  */\nconst largestPrimeFactorOf = (n) => {\n  if (n < 2) {\n    return -1;\n  }\n  let result = 2;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given the number 5, the largest prime factor of 5 is 2.\n  If the number n is negative, return -1.\n  */\nconst largestPrimeFactorOf2 = (n) => {\n  if (n < 2) {\n    return -1;\n  }\n  let result = 2;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given the number 5, the largest prime factor of 5 is 2.\n  If the number n is negative, return -1.\n  */\nconst largestPrimeFactorOf3 = (n) => {\n  if (n < 2) {\n    return -1;\n  }\n  let result = 2;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given the number 5, the largest prime factor of 5 is 2.\n  If the number n is negative, return -1.\n  */\nconst largestPrimeFactorOf4 = (n) => {\n  if (n < 2) {\n    return -1;\n  }\n  let result = 2;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given the number 5, the largest prime factor of 5 is 2.\n  If the number n is negative, return -1.\n  */\nconst largestPrimeFactorOf5 = (n) => {\n  if (n < 2) {\n    return -1;\n  }\n  let result = 2;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given the number 5, the largest prime factor of 5 is 2.\n  If the number n is negative, return -1.\n  */\nconst largestPrimeFactorOf6 = (n) => {\n  if (n < 2) {\n    return -1;\n  }\n  let result = 2;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given the number 5, the largest prime factor of 5 is 2.\n  If the number n is negative, return -1.\n  */\nconst largestPrimeFactorOf7 = (n) => {\n  if (n < 2) {\n    return -1;\n  }\n  let result = 2;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given the number 5, the largest prime factor of 5 is 2.\n  If the number n is negative, return -1.\n  */\nconst largestPrimeFactorOf8 = (n) => {\n  if (n < 2) {\n    return -1;\n  }\n  let result = 2;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given the number 5, the largest prime factor of 5 is 2.\n  If the number n is negative, return -1.\n  */\nconst largestPrimeFactorOf9 = (n) => {\n  if (n < 2) {\n    return -1;\n  }\n  let result = 2;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given the number 5, the largest prime factor of 5 is 2.\n  If the number n is negative, return -1.\n  */\nconst largestPrimeFactorOf10 = (n) => {\n  if (n < 2) {\n    return -1;\n  }\n  let result = 2;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given the number 5, the largest prime factor of 5 is 2.\n  If the number n is negative, return -1.\n  */\nconst largestPrimeFactorOf11 = (n) => {\n  if (n < 2) {\n    return -1;\n  }\n  let result = 2;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given the number 5, the largest prime factor of 5 is 2.\n  If the number n is negative, return -1.\n  */\nconst largestPrimeFactorOf12 = (n) => {\n  if (n < 2) {\n    return -1;\n  }\n  let result = 2;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given the number 5, the largest prime factor of 5 is 2.\n  If the number n is negative, return -1.\n  */\nconst largestPrimeFactorOf13 = (n) => {\n  if (n < 2) {\n    return -1;\n  }\n  let result = 2;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given the number 5, the largest prime factor of 5 is 2.\n  If the number n is negative, return -1.\n  */\nconst largestPrimeFactorOf14 = (n) => {\n  if (n < 2) {\n    return -1;\n  }\n  let result = 2;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result *= i;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the largest prime factor of n.\n  For example, given the number 5, the largest prime factor of 5 is 2.\n  If the number n is negative, ", "passed": 0}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefix('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefix = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefix", "gc": "<|endoftext|>/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefix('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefix = (string) => {\n  let prefixes = [];\n  let currentPrefix = string;\n  let currentLength = 1;\n  let currentLengthIndex = 0;\n\n  while (currentLengthIndex < string.length) {\n    if (currentLengthIndex === currentPrefix.length) {\n      prefixes.push(currentPrefix);\n      currentLengthIndex++;\n      currentLength = 1;\n    } else {\n      currentLength++;\n    }\n  }\n\n  return prefixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffix('abc')\n  ['c', 'ba', 'ca']\n  */\nconst allSuffix = (string) => {\n  let suffixes = [];\n  let currentSuffix = string;\n  let currentLength = 1;\n  let currentLengthIndex = 0;\n\n  while (currentLengthIndex < string.length) {\n    if (currentLengthIndex === currentSuffix.length) {\n      suffixes.push(currentSuffix);\n      currentLengthIndex++;\n      currentLength = 1;\n    } else {\n      currentLength++;\n    }\n  }\n\n  return suffixes;\n};\n\n/* Return list of all common prefixes from shortest to longest of the input string\n  >>> commonPrefix('abc')\n  ['a', 'b', 'c']\n  */\nconst commonPrefix = (string) => {\n  let prefixes = [];\n  let currentPrefix = string;\n  let currentLength = 1;\n  let currentLengthIndex = 0;\n\n  while (currentLengthIndex < string.length) {\n    if (currentLengthIndex === currentPrefix.length) {\n      prefixes.push(currentPrefix);\n      currentLengthIndex++;\n      currentLength = 1;\n    } else {\n      currentLength++;\n    }\n  }\n\n  return prefixes;\n};\n\n/* Return list of all common suffixes from shortest to longest of the input string\n  >>> commonSuffix('abc')\n  ['c', 'ba', 'ca']\n  */\nconst commonSuffix = (string) => {\n  let suffixes = [];\n  let currentSuffix = string;\n  let currentLength = 1;\n  let currentLengthIndex = 0;\n\n  while (currentLengthIndex < string.length) {\n    if (currentLengthIndex === currentSuffix.length) {\n      suffixes.push(currentSuffix);\n      currentLengthIndex++;\n      currentLength = 1;\n    } else {\n      currentLength++;\n    }\n  }\n\n  return suffixes;\n};\n\n/* Return list of all common characters from shortest to longest of the input string\n  >>> commonCharacters('abc')\n  ['a', 'b', 'c']\n  */\nconst commonCharacters = (string) => {\n  let characters = [];\n  let currentCharacter = string;\n  let currentLength = 1;\n  let currentLengthIndex = 0;\n\n  while (currentLengthIndex < string.length) {\n    if (currentLengthIndex === currentCharacter.length) {\n      characters.push(currentCharacter);\n      currentLengthIndex++;\n      currentLength = 1;\n    } else {\n      currentLength++;\n    }\n  }\n\n  return characters;\n};\n\n/* Return list of all common words from shortest to longest of the input string\n  >>> commonWords('abc')\n  ['a', 'b', 'c']\n  */\nconst commonWords = (string) => {\n  let words = [];\n  let currentWord = string;\n  let currentLength = 1;\n  let currentLengthIndex = 0;\n\n  while (currentLengthIndex < string.length) {\n    if (currentLengthIndex === currentWord.length) {\n      words.push(currentWord);\n      currentLengthIndex++;\n      currentLength = 1;\n    } else {\n      currentLength++;\n    }\n  }\n\n  return words;\n};\n\n/* Return list of all common numbers from shortest to longest of the input string\n  >>> commonNumbers('abc')\n  ['a', 'b', 'c']\n  */\nconst commonNumbers = (string) => {\n  let numbers = [];\n  let currentNumber = string;\n  let currentLength = 1;\n  let currentLengthIndex = 0;\n\n  while (currentLengthIndex < string.length) {\n    if (currentLengthIndex === currentNumber.length) {\n      numbers.push(currentNumber);\n      currentLengthIndex++;\n      currentLength = 1;\n    } else {\n      currentLength++;\n    }\n  }\n\n  return numbers;\n};\n\n/* Return list of all common symbols from shortest to longest of the input string\n  >>> commonSymbols('abc')\n  ['a', 'b', 'c']\n  */\nconst commonSymbols = (string) => {\n  let symbols = [];\n  let currentSymbol = string;\n  let currentLength = 1;\n  let currentLengthIndex = 0;\n\n  while (currentLengthIndex < string.length) {\n    if (currentLengthIndex === currentSymbol.length) {\n      symbols.push(currentSymbol);\n      currentLengthIndex++;\n      currentLength = 1;\n    } else {\n      currentLength++;\n    }\n  }\n\n  return symbols;\n};\n\n/* Return list of all common special characters from shortest to longest of the input string\n  >>> commonSpecialCharacters('abc')\n  ['a', 'b', 'c']\n  */\nconst commonSpecialCharacters = (string) => {\n  let specialCharacters = [];\n  let currentSpecialCharacter = string;\n  let currentLength = 1;\n  let currentLengthIndex = 0;\n\n  while (currentLengthIndex < string.length) {\n    if (currentLengthIndex === currentSpecialCharacter.length) {\n      specialCharacters.push(currentSpecialCharacter);\n      currentLengthIndex++;\n      currentLength = 1;\n    } else {\n      currentLength++;\n    }\n  }\n\n  return specialCharacters;\n};\n\n/* Return list of all common special words from shortest to longest of the input string\n  >>> commonSpecialWords('abc')\n  ['a', 'b', 'c']\n  */\nconst commonSpecialWords = (string) => {\n  let specialWords = [];\n  let currentSpecialWord = string;\n  let currentLength = 1;\n  let currentLengthIndex = 0;\n\n  while (currentLengthIndex < string.length) {\n    if (currentLengthIndex === currentSpecialWord.length) {\n      specialWords.push(currentSpecialWord);\n      currentLengthIndex++;\n      currentLength = 1;\n    } else {\n      currentLength++;\n    }\n  }\n\n  return specialWords;\n};\n\n/* Return list of all common special numbers from shortest to longest of the input string\n  >>> commonSpecialNumbers('abc')\n  ['a', 'b', 'c']\n  */\nconst commonSpecialNumbers = (string) => {\n  let specialNumbers = [];\n  let currentSpecialNumber = string;\n  let currentLength = 1;\n  let currentLengthIndex = 0;\n\n  while (currentLengthIndex < string.length) {\n    if (currentLengthIndex === currentSpecialNumber.length) {\n      specialNumbers.push(currentSpecialNumber);\n      currentLengthIndex++;\n      currentLength = 1;\n    } else {\n      currentLength++;\n    }\n  }\n\n  return specialNumbers;\n};\n\n/* Return list of all common special symbols from shortest to longest of the input string\n  >>> commonSpecialSymbols('abc')\n  ['a', 'b', 'c']\n  */\nconst commonSpecialSymbols = (string) => {\n  let specialSymbols = [];\n  let currentSpecialSymbol = string;\n  let currentLength = 1;\n  let currentLengthIndex = 0;\n\n  while (currentLengthIndex < string.length) {\n    if (currentLengthIndex === currentSpecialSymbol.length) {\n      specialSymbols.push(currentSpecialSymbol);\n      currentLengthIndex++;\n      currentLength = 1;\n    } else {\n      currentLength++;\n    }\n  }\n\n  return specialSymbols;\n};\n\n/* Return list of all common special characters from shortest to longest of the input string\n  >>> commonSpecialCharacters('abc')\n  ['a', 'b', 'c']\n  */\nconst commonSpecialCharacters = (string) => {\n  let specialCharacters = [];\n  let currentSpecialCharacter = string;\n  let currentLength = 1;\n  let currentLengthIndex = 0;\n\n  while (currentLengthIndex < string.length) {\n    if (currentLengthIndex === currentSpecialCharacter.length) {\n      specialCharacters.push(currentSpecialCharacter);\n      currentLengthIndex++;\n      currentLength = 1;\n    } else {\n      currentLength++;\n    }\n  }\n\n  return specialCharacters;\n};\n\n/* Return list of all common special words from shortest to longest of the input string\n  >>> commonSpecialWords('abc')\n  ['a', 'b', 'c']\n  */\nconst commonSpecial", "passed": 0}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairSpace(\"Example\") == \"Example\"\n  repairSpace(\"Example 1\") == \"Example_1\"\n  repairSpace(\" Example 2\") == \"_Example_2\"\n  repairSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst repairSpace = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "repairSpace", "gc": "<|endoftext|>/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairSpace(\"Example\") == \"Example\"\n  repairSpace(\"Example 1\") == \"Example_1\"\n  repairSpace(\" Example 2\") == \"_Example_2\"\n  repairSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst repairSpace = (text) => {\n  return text.replace(/\\s+/g, \"_\")\n   .replace(/  +/g, \" \")\n   .replace(/  /g, \" \");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairUnderscore(\"Example\") == \"Example\"\n  repairUnderscore(\"Example 1\") == \"Example_1\"\n  repairUnderscore(\" Example 2\") == \"Example_2\"\n  repairUnderscore(\" Example   3\") == \"Example_3\"\n  */\nconst repairUnderscore = (text) => {\n  return text.replace(/\\s+/g, \"_\")\n   .replace(/_+/g, \" \")\n   .replace(/_/g, \" \");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairCapitalize(\"Example\") == \"Example\"\n  repairCapitalize(\"Example 1\") == \"Example_1\"\n  repairCapitalize(\" Example 2\") == \"Example_2\"\n  repairCapitalize(\" Example   3\") == \"Example_3\"\n  */\nconst repairCapitalize = (text) => {\n  return text.replace(/\\s+/g, \"_\")\n   .replace(/_+/g, \" \")\n   .replace(/_/g, \" \");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairTitleCase(\"Example\") == \"Example\"\n  repairTitleCase(\"Example 1\") == \"Example_1\"\n  repairTitleCase(\" Example 2\") == \"Example_2\"\n  repairTitleCase(\" Example   3\") == \"Example_3\"\n  */\nconst repairTitleCase = (text) => {\n  return text.replace(/\\s+/g, \"_\")\n   .replace(/_+/g, \" \")\n   .replace(/_/g, \" \");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairTitleCase(\"Example\") == \"Example\"\n  repairTitleCase(\"Example 1\") == \"Example_1\"\n  repairTitleCase(\" Example 2\") == \"Example_2\"\n  repairTitleCase(\" Example   3\") == \"Example_3\"\n  */\nconst repairTitleCase = (text) => {\n  return text.replace(/\\s+/g, \"_\")\n   .replace(/_+/g, \" \")\n   .replace(/_/g, \" \");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairTitleCase(\"Example\") == \"Example\"\n  repairTitleCase(\"Example 1\") == \"Example_1\"\n  repairTitleCase(\" Example 2\") == \"Example_2\"\n  repairTitleCase(\" Example   3\") == \"Example_3\"\n  */\nconst repairTitleCase = (text) => {\n  return text.replace(/\\s+/g, \"_\")\n   .replace(/_+/g, \" \")\n   .replace(/_/g, \" \");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairTitleCase(\"Example\") == \"Example\"\n  repairTitleCase(\"Example 1\") == \"Example_1\"\n  repairTitleCase(\" Example 2\") == \"Example_2\"\n  repairTitleCase(\" Example   3\") == \"Example_3\"\n  */\nconst repairTitleCase = (text) => {\n  return text.replace(/\\s+/g, \"_\")\n   .replace(/_+/g, \" \")\n   .replace(/_/g, \" \");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairTitleCase(\"Example\") == \"Example\"\n  repairTitleCase(\"Example 1\") == \"Example_1\"\n  repairTitleCase(\" Example 2\") == \"Example_2\"\n  repairTitleCase(\" Example   3\") == \"Example_3\"\n  */\nconst repairTitleCase = (text) => {\n  return text.replace(/\\s+/g, \"_\")\n   .replace(/_+/g, \" \")\n   .replace(/_/g, \" \");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairTitleCase(\"Example\") == \"Example\"\n  repairTitleCase(\"Example 1\") == \"Example_1\"\n  repairTitleCase(\" Example 2\") == \"Example_2\"\n  repairTitleCase(\" Example   3\") == \"Example_3\"\n  */\nconst repairTitleCase = (text) => {\n  return text.replace(/\\s+/g, \"_\")\n   .replace(/_+/g, \" \")\n   .replace(/_/g, \" \");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairTitleCase(\"Example\") == \"Example\"\n  repairTitleCase(\"Example 1\") == \"Example_1\"\n  repairTitleCase(\" Example 2\") == \"Example_2\"\n  repairTitleCase(\" Example   3\") == \"Example_3\"\n  */\nconst repairTitleCase = (text) => {\n  return text.replace(/\\s+/g, \"_\")\n   .replace(/_+/g, \" \")\n   .replace(/_/g, \" \");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairTitleCase(\"Example\") == \"Example\"\n  repairTitleCase(\"Example 1\") == \"Example_1\"\n  repairTitleCase(\" Example 2\") == \"Example_2\"\n  repairTitleCase(\" Example   3\") == \"Example_3\"\n  */\nconst repairTitleCase = (text) => {\n  return text.replace(/\\s+/g, \"_\")\n   .replace(/_+/g, \" \")\n   .replace(/_/g, \" \");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairTitleCase(\"Example\") == \"Example\"\n  repairTitleCase(\"Example 1\") == \"Example_1\"\n  repairTitleCase(\" Example 2\") == \"Example_2\"\n  repairTitleCase(\" Example   3\") == \"Example_3\"\n  */\nconst repairTitleCase = (text) => {\n  return text.replace(/\\s+/g, \"_\")\n   .replace(/_+/g, \" \")\n   .replace(/_/g, \" \");\n}", "passed": 0}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "gc": "<|endoftext|>/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const file_name_length = file_name.length;\n  const file_name_starts_with_dot = file_name.indexOf('.')!== -1;\n  const file_name_contains_one_dot = file_name.indexOf('.') === file_name.length - 1;\n  const file_name_contains_letter = file_name.match(/[a-zA-Z]/)!== null;\n  const file_name_contains_numbers = file_name.match(/[0-9]/)!== null;\n  const file_name_contains_letters_and_numbers = file_name.match(/[a-zA-Z0-9]/)!== null;\n  const file_name_contains_numbers_and_letters = file_name.match(/[0-9a-zA-Z]/)!== null;\n  const file_name_contains_numbers_and_letters_and_numbers = file_name.match(/[0-9a-zA-Z0-9]/)!== null;\n  const file_name_contains_letters_and_numbers_and_letters = file_name.match(/[a-zA-Z0-9a-zA-Z]/)!== null;\n  const file_name_contains_letters_and_numbers_and_letters_and_numbers = file_name.match(/[a-zA-Z0-9a-zA-Z0-9]/)!== null;\n  const file_name_contains_letters_and_numbers_and_letters_and_numbers_and_letters = file_name.match(/[a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9]/)!== null;\n  const file_name_contains_letters_and_numbers_and_letters_and_numbers_and_letters_and_numbers = file_name.match(/[a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9]/)!== null;\n  const file_name_contains_letters_and_numbers_and_letters_and_numbers_and_letters_and_numbers_and_letters_and_numbers = file_name.match(/[a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z0-9a-zA-Z", "passed": 0}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeSquare = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "summarizeSquare", "gc": "<|endoftext|>/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3 === 0 && i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and \n  will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCube = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3 === 0 && i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and \n  will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeSquareCube = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3 === 0 && i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and \n  will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeSquareCubeNoChange = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3 === 0 && i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and \n  will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeSquareCubeNoChangeNoChange = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3 === 0 && i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and \n  will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeSquareCubeNoChangeNoChangeNoChangeNoChange = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3 === 0 && i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and \n  will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeSquareCubeNoChangeNoChangeNoChangeNoChangeNoChange = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3 === 0 && i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and \n  will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeSquareCubeNoChangeNoChangeNoChangeNoChangeNoChangeNoChange = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3 === 0 && i % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and \n  will square it if its index is a multiple of 4. The function will not change the entries in the ", "passed": 0}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst bibleInPrisonTerm = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "bibleInPrisonTerm", "gc": "<|endoftext|>/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst bibleInPrisonTerm = (sentence) => {\n    const words = sentence.split(\" \");\n    const newWords = [];\n    let currentWord = \"\";\n    let currentLength = 0;\n    let currentPrime = true;\n    for (let i = 0; i < words.length; i++) {\n        currentLength += words[i].length;\n        if (currentLength % 2 === 0) {\n            currentPrime = false;\n        }\n        if (currentPrime) {\n            newWords.push(currentWord);\n            currentWord = \"\";\n            currentLength = 0;\n            currentPrime = true;\n        }\n        currentWord += words[i];\n    }\n    if (currentPrime) {\n        newWords.push(currentWord);\n    }\n    return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst bibleInPrisonTerm = (sentence) => {\n    const words = sentence.split(\" \");\n    const newWords = [];\n    let currentWord = \"\";\n    let currentLength = 0;\n    let currentPrime = true;\n    for (let i = 0; i < words.length; i++) {\n        currentLength += words[i].length;\n        if (currentLength % 2 === 0) {\n            currentPrime = false;\n        }\n        if (currentPrime) {\n            newWords.push(currentWord);\n            currentWord = \"\";\n            currentLength = 0;\n            currentPrime = true;\n        }\n        currentWord += words[i];\n    }\n    if (currentPrime) {\n        newWords.push(currentWord);\n    }\n    return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst bibleInPrisonTerm = (sentence) => {\n    const words = sentence.split(\" \");\n    const newWords = [];\n    let currentWord = \"\";\n    let currentLength = 0;\n    let currentPrime = true;\n    for (let i = 0; i < words.length; i++) {\n        currentLength += words[i].length;\n        if (currentLength % 2 === 0) {\n            currentPrime = false;\n        }\n        if (currentPrime) {\n            newWords.push(currentWord);\n            currentWord = \"\";\n            currentLength = 0;\n            currentPrime = true;\n        }\n        currentWord += words[i];\n    }\n    if (currentPrime) {\n        newWords.push(currentWord);\n    }\n    return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst bibleInPrisonTerm = (sentence) => {\n    const words = sentence.split(\" \");\n    const newWords = [];\n    let currentWord = \"\";\n    let currentLength = 0;\n    let currentPrime = true;\n    for (let i = 0; i < words.length; i++) {\n        currentLength += words[i].length;\n        if (currentLength % 2 === 0) {\n            currentPrime = false;\n        }\n        if (currentPrime) {\n            newWords.push(currentWord);\n            currentWord = \"\";\n            currentLength = 0;\n            currentPrime = true;\n        }\n        currentWord += words[i];\n    }\n    if (currentPrime) {\n        newWords.push(currentWord);\n    }\n    return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst bibleInPrisonTerm = (sentence) => {\n    const words = sentence.split(\" \");\n    const newWords = [];\n    let currentWord = \"\";\n    let currentLength = 0;\n    let currentPrime = true;\n    for (let i = 0; i < words.length; i++) {\n        currentLength += words[i].length;\n        if (currentLength % 2 === 0) {\n            currentPrime = false;\n        }\n        if (currentPrime) {\n            newWords.push(currentWord);\n            currentWord = \"\";\n            currentLength = 0;\n            currentPrime = true;\n        }\n        currentWord += words[i];\n    }\n    if (currentPrime) {\n        newWords.push(currentWord);\n    }\n    return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst bibleInPrisonTerm = (sentence) => {\n    const words = sentence.split(\" \");\n    const newWords = [];\n    let currentWord = \"\";\n    let currentLength = 0;\n    let currentPrime = true;\n    for (let i = 0; i < words.length; i++) {\n        currentLength += words[i].length;\n        if (currentLength % 2 === 0) {\n            currentPrime = false;\n        }\n        if (currentPrime) {\n            newWords.push(currentWord);\n            currentWord = \"\";\n            currentLength = 0;\n            currentPrime = true;\n        }\n        currentWord += words[i];\n    }\n    if (currentPrime) {\n        newWords.push(currentWord);\n    }\n    return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  ", "passed": 0}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "gc": "<|endoftext|>/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task is to implement a function that will simplify the expression", "passed": 0}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPoint([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPoint([]) == []\n  */\nconst holyOrderByPoint = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "holyOrderByPoint", "gc": "<|endoftext|>/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPoint([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPoint([]) == []\n  */\nconst holyOrderByPoint = (nums) => {\n  const sums = nums.reduce((acc, cur) => acc + cur, 0);\n  const sorted = nums.sort((a, b) => a - b);\n  return sorted.map((num) => sums[num]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPoint([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPoint([]) == []\n  */\nconst holyOrderByPointDesc = (nums) => {\n  const sums = nums.reduce((acc, cur) => acc + cur, 0);\n  const sorted = nums.sort((a, b) => b - a);\n  return sorted.map((num) => sums[num]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDesc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPointDesc([]) == []\n  */\nconst holyOrderByPointAsc = (nums) => {\n  const sums = nums.reduce((acc, cur) => acc + cur, 0);\n  const sorted = nums.sort((a, b) => a - b);\n  return sorted.map((num) => sums[num]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointAsc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPointAsc([]) == []\n  */\nconst holyOrderByPointDescAsc = (nums) => {\n  const sums = nums.reduce((acc, cur) => acc + cur, 0);\n  const sorted = nums.sort((a, b) => b - a);\n  return sorted.map((num) => sums[num]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDescAsc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPointDescAsc([]) == []\n  */\nconst holyOrderByPointAscDesc = (nums) => {\n  const sums = nums.reduce((acc, cur) => acc + cur, 0);\n  const sorted = nums.sort((a, b) => b - a);\n  return sorted.map((num) => sums[num]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointAscDesc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPointAscDesc([]) == []\n  */\nconst holyOrderByPointDescDesc = (nums) => {\n  const sums = nums.reduce((acc, cur) => acc + cur, 0);\n  const sorted = nums.sort((a, b) => b - a);\n  return sorted.map((num) => sums[num]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDescDesc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPointDescDesc([]) == []\n  */\nconst holyOrderByPointDescAscAsc = (nums) => {\n  const sums = nums.reduce((acc, cur) => acc + cur, 0);\n  const sorted = nums.sort((a, b) => b - a);\n  return sorted.map((num) => sums[num]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDescAscAsc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPointDescAscAsc([]) == []\n  */\nconst holyOrderByPointDescDescAsc = (nums) => {\n  const sums = nums.reduce((acc, cur) => acc + cur, 0);\n  const sorted = nums.sort((a, b) => b - a);\n  return sorted.map((num) => sums[num]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDescDescAsc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPointDescDescAsc([]) == []\n  */\nconst holyOrderByPointDescDescDesc = (nums) => {\n  const sums = nums.reduce((acc, cur) => acc + cur, 0);\n  const sorted = nums.sort((a, b) => b - a);\n  return sorted.map((num) => sums[num]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDescDescDesc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPointDescDescDesc([]) == []\n  */\nconst holyOrderByPointDescDescDescAsc = (nums) => {\n  const sums = nums.reduce((acc, cur) => acc + cur, 0);\n  const sorted = nums.sort((a, b) => b - a);\n  return sorted.map((num) => sums[num]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDescDescDescAsc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]", "passed": 0}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "extraFilter", "gc": "<|endoftext|>/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1' && nums[i].toString().charAt(nums[i].toString().length - 1) > '9') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilter2 = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1' && nums[i].toString().charAt(nums[i].toString().length - 1) > '9') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilter3 = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1' && nums[i].toString().charAt(nums[i].toString().length - 1) > '9') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilter4 = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1' && nums[i].toString().charAt(nums[i].toString().length - 1) > '9') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilter5 = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1' && nums[i].toString().charAt(nums[i].toString().length - 1) > '9') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilter6 = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1' && nums[i].toString().charAt(nums[i].toString().length - 1) > '9') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilter7 = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1' && nums[i].toString().charAt(nums[i].toString().length - 1) > '9') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilter8 = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1' && nums[i].toString().charAt(nums[i].toString().length - 1) > '9') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilter9 = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1' && nums[i].toString().charAt(nums[i].toString().length - 1) > '9') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilter10 = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1' && nums[i].toString().charAt(nums[i].toString().length - 1) > '9') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilter11 = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1' && nums[i].toString().", "passed": 0}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "catchMaxTriples", "gc": "<|endoftext|>/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  let count = 0;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] % 3 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 2\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples2 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  let count = 0;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] % 3 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples3 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  let count = 0;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] % 3 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 4\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples4 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  let count = 0;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] % 3 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 5\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples5 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  let count = 0;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] % 3 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 6\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples6 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  let count = 0;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] % 3 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 7\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples7 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  let count = 0;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] % 3 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 8\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples8 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  let count = 0;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] % 3 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 9\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is ", "passed": 0}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "gc": "<|endoftext|>/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1Orbit = orbit(planet1);\n  const planet2Orbit = orbit(planet2);\n  const planet1OrbitOrbit = planet1Orbit && planet2Orbit;\n  const planet2OrbitOrbit = planet2Orbit && planet1Orbit;\n  const planet1OrbitOrbitOrbit = planet1OrbitOrbit && planet2OrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1OrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbit = planet1OrbitOrbitOrbit && planet2OrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit && planet1Or", "passed": 0}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "screenTiltSum", "gc": "<|endoftext|>/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltSum = (lst) => {\n  let result = [];\n  let sum = 0;\n  let len = lst.length;\n  for (let i = 0; i < len; i++) {\n    sum += lst[i];\n  }\n  result.push(sum);\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 2!== 0) {\n      result.push(lst[i]);\n    }\n  }\n  return result;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltProd = (lst) => {\n  let result = [];\n  let prod = 1;\n  let len = lst.length;\n  for (let i = 0; i < len; i++) {\n    prod *= lst[i];\n  }\n  result.push(prod);\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 2!== 0) {\n      result.push(lst[i]);\n    }\n  }\n  return result;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltProdSum = (lst) => {\n  let result = [];\n  let prod = 1;\n  let sum = 0;\n  let len = lst.length;\n  for (let i = 0; i < len; i++) {\n    prod *= lst[i];\n    sum += prod;\n  }\n  result.push(sum);\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 2!== 0) {\n      result.push(lst[i]);\n    }\n  }\n  return result;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltProdSum2 = (lst, sum) => {\n  let result = [];\n  let prod = 1;\n  let sum = 0;\n  let len = lst.length;\n  for (let i = 0; i < len; i++) {\n    prod *= lst[i];\n    sum += prod;\n  }\n  result.push(sum);\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 2!== 0) {\n      result.push(lst[i]);\n    }\n  }\n  return result;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltProdSum3 = (lst, sum) => {\n  let result = [];\n  let prod = 1;\n  let sum = 0;\n  let len = lst.length;\n  for (let i = 0; i < len; i++) {\n    prod *= lst[i];\n    sum += prod;\n  }\n  result.push(sum);\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 2!== 0) {\n      result.push(lst[i]);\n    }\n  }\n  return result;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltProdSum4 = (lst, sum) => {\n  let result = [];\n  let prod = 1;\n  let sum = 0;\n  let len = lst.length;\n  for (let i = 0; i < len; i++) {\n    prod *= lst[i];\n    sum += prod;\n  }\n  result.push(sum);\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 2!== 0) {\n      result.push(lst[i]);\n    }\n  }\n  return result;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltProdSum5 = (lst, sum) => {\n  let result = [];\n  let prod = 1;", "passed": 0}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> bowedStringedInstrumentSuccession(0)\n  '0'\n  >>> bowedStringedInstrumentSuccession(5)\n  '0 1 2 3 4 5'\n  */\nconst bowedStringedInstrumentSuccession = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "bowedStringedInstrumentSuccession", "gc": "<|endoftext|>/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> bowedStringedInstrumentSuccession(0)\n  '0'\n  >>> bowedStringedInstrumentSuccession(5)\n  '0 1 2 3 4 5'\n  */\nconst bowedStringedInstrumentSuccession = (n) => {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(Math.floor(Math.random() * 10)));\n  }\n  return result.join(' ');\n};\n\n/**\n  Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> bowedStringedInstrumentSuccession(10)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst bowedStringedInstrumentFailure = (n) => {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(Math.floor(Math.random() * 10)));\n  }\n  return result.join(' ');\n};\n\n/**\n  Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> bowedStringedInstrumentFailure(10)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 (461) 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 ", "passed": 0}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrYttrium", "gc": "<|endoftext|>/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x <= 0) {\n    return 0\n  }\n  if (n % y === 0) {\n    return y\n  }\n  if (n % x === 0) {\n    return x\n  }\n  return xOrYttrium(n / x, n % y, y)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium2 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x <= 0) {\n    return 0\n  }\n  if (n % y === 0) {\n    return y\n  }\n  if (n % x === 0) {\n    return x\n  }\n  return xOrYttrium2(n / x, n % y, y)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium3 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x <= 0) {\n    return 0\n  }\n  if (n % y === 0) {\n    return y\n  }\n  if (n % x === 0) {\n    return x\n  }\n  return xOrYttrium3(n / x, n % y, y)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium4 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x <= 0) {\n    return 0\n  }\n  if (n % y === 0) {\n    return y\n  }\n  if (n % x === 0) {\n    return x\n  }\n  return xOrYttrium4(n / x, n % y, y)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium5 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x <= 0) {\n    return 0\n  }\n  if (n % y === 0) {\n    return y\n  }\n  if (n % x === 0) {\n    return x\n  }\n  return xOrYttrium5(n / x, n % y, y)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium6 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x <= 0) {\n    return 0\n  }\n  if (n % y === 0) {\n    return y\n  }\n  if (n % x === 0) {\n    return x\n  }\n  return xOrYttrium6(n / x, n % y, y)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium7 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x <= 0) {\n    return 0\n  }\n  if (n % y === 0) {\n    return y\n  }\n  if (n % x === 0) {\n    return x\n  }\n  return xOrYttrium7(n / x, n % y, y)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium8 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x <= 0) {\n    return 0\n  }\n  if (n % y === 0) {\n    return y\n  }\n  if (n % x === 0) {\n    return x\n  }\n  return xOrYttrium8(n / x, n % y, y)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium9 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x <= 0) {\n    return 0\n  }\n  if (n % y === 0) {\n    return y\n  }\n  if (n % x === 0) {\n    return x\n  }\n  return xOrYttrium9(n / x, n % y, y)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium10 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x <= 0) {\n    return 0\n  }\n  if (n % y === 0) {\n    return y\n  }\n  if (n % x === 0) {\n    return x\n  }\n  return xOrYttrium10(n / x, n % y, y)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium11 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x <= 0) {\n    return 0\n  }\n  if (n % y === 0) {\n    return y\n  }\n  if (n % x === 0) {\n    return x\n  }\n  return xOrYttrium11(n / x, n % y, y)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium12 = (n, x, y) => {\n  if (n <= 0 || y <= 0 || x <= 0) {\n    return 0\n  }\n  if (n % y === 0) {\n    return y\n  }\n  if (n % x === 0) {\n    return x\n  }\n  return xOrYttrium12(n / x, n % y, y)\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOr", "passed": 0}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == 0\n  doubleTheDeviation([9, -2]) == 81\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDeviation", "gc": "<|endoftext|>/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == 0\n  doubleTheDeviation([9, -2]) == 81\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst === []) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst === []) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by three. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 0 + 0 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst === []) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by five. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 0 + 0 + 0 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst === []) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 5 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by seven. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 0 + 0 + 0 + 0 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst === []) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 7 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by nine. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst === []) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 9 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by ten. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst === []) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 10 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by eleven. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst === []) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 11 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by twelve. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst === []) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 12 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by thirteen. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst === []) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 13 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by fourteen. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 10\n  doubleTheDevi", "passed": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "gc": "<|endoftext|>/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let score = 0;\n  let guesses = 0;\n  \n  game.forEach((gameItem, index) => {\n    \n    gameItem.forEach((gameItemItem, index2) => {\n      \n      gameItemItem.forEach((gameItemItemItem, index3) => {\n        \n        if (gameItemItem === guess) {\n          \n          score += gameItemItem;\n          \n          guesses++;\n        }\n      });\n    });\n  });\n  \n  return [score, guesses];\n};\n\n/*\n  Given a game of cards, return an array of all possible combinations of cards \n  that could result in a winning combination.\n  \n  \n  example:\n\n  combinations([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,", "passed": 0}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for hardExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst hardExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "hardExtension", "gc": "<|endoftext|>/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for hardExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst hardExtension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_strength;\n    if (extension_strength > 0) {\n      extension_class = `${extension_class}.${extension.charAt(0)}`;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name, a list with extensions and a number of\n  extensions, return the class name with the highest extension.\n  Example:\n  Given'my_class', ['AA', 'Be', 'CC'], 3\n  Return my_class.AA\n*/\nconst highestExtension = (class_name, extensions, number_of_extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_strength;\n    if (extension_strength > 0) {\n      extension_class = `${extension_class}.${extension.charAt(0)}`;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name, a list with extensions and a number of\n  extensions, return the class name with the lowest extension.\n  Example:\n  Given'my_class', ['AA', 'Be', 'CC'], 3\n  Return my_class.Be\n*/\nconst lowestExtension = (class_name, extensions, number_of_extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_strength;\n    if (extension_strength > 0) {\n      extension_class = `${extension_class}.${extension.charAt(0)}`;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name, a list with extensions and a number of\n  extensions, return the class name with the strongest extension.\n  Example:\n  Given'my_class', ['AA', 'Be', 'CC'], 3\n  Return my_class.Be\n*/\nconst strongestExtension = (class_name, extensions, number_of_extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_strength;\n    if (extension_strength > 0) {\n      extension_class = `${extension_class}.${extension.charAt(0)}`;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name, a list with extensions and a number of\n  extensions, return the class name with the strongest extension.\n  Example:\n  Given'my_class', ['AA', 'Be', 'CC'], 3\n  Return my_class.Be\n*/\nconst strongestExtensionByStrength = (class_name, extensions, number_of_extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_strength;\n    if (extension_strength > 0) {\n      extension_class = `${extension_class}.${extension.charAt(0)}`;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name, a list with extensions and a number of\n  extensions, return the class name with the strongest extension.\n  Example:\n  Given'my_class', ['AA', 'Be', 'CC'], 3\n  Return my_class.Be\n*/\nconst strongestExtensionByStrengthAndStrength = (class_name, extensions, number_of_extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_strength;\n    if (extension_strength > 0) {\n      extension_class = `${extension_class}.${extension.charAt(0)}`;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name, a list with extensions and a number of\n  extensions, return the class name with the strongest extension.\n  Example:\n  Given'my_class', ['AA', 'Be', 'CC'], 3\n  Return my_class.Be\n*/\nconst strongestExtensionByStrengthAndStrengthAndStrength = (class_name, extensions, number_of_extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_strength;\n    if (extension_strength > 0) {\n      extension_class = `${extension_class}.${extension.charAt(0)}`;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name, a list with extensions and a number of\n  extensions, return the class name with the strongest extension.\n  Example:\n  Given'my_class', ['AA', 'Be', 'CC'], 3\n  Return my_class.Be\n*/\nconst strongestExtensionByStrengthAndStrengthAndStrengthAndStrength = (class_name, extensions, number_of_extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_strength;\n    if (extension_strength > 0) {\n      extension_class = `${extension_class}.${extension.charAt(0)}`;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name, a list with extensions and a number of\n  extensions, return the class name with the strongest extension.\n  Example:\n  Given'my_class', ['AA', 'Be', 'CC'], 3\n  Return my_class.Be\n*/\nconst strongestExtensionByStrengthAndStrengthAndStrengthAndStrengthAndStrength = (class_name, extensions, number_of_extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.length - extension_strength;\n    if (extension_strength > 0) {\n      extension_class = `${extension_class}.${extension.charAt(0)}`;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name, a list with extensions and a number of\n  extensions, return the class name with the strongest extension.\n  Example:\n  Given'my_class', ['AA', 'Be', 'CC'], 3\n  Return my_class.Be\n*/\nconst ", "passed": 0}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "gc": "<|endoftext|>/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let aFirst = a.split('')\n  let bFirst = b.split('')\n  let aFirstLen = aFirst.length\n  let bFirstLen = bFirst.length\n  let aFirstRot = aFirst.map((v, i) => i % bFirstLen)\n  let bFirstRot = bFirst.map((v, i) => i % bFirstLen)\n  let aFirstRotLen = aFirstRot.length\n  let bFirstRotLen = bFirstRot.length\n  let aFirstRotRot = aFirstRot.map((v, i) => i % bFirstRotLen)\n  let bFirstRotRot = bFirstRot.map((v, i) => i % bFirstRotLen)\n  let aFirstRotRotRot = aFirstRotRot.map((v, i) => i % bFirstRotRotLen)\n  let bFirstRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotLen)\n  let aFirstRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotLen)\n  let bFirstRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotLen)\n  let aFirstRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotLen)\n  let bFirstRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotLen)\n  let aFirstRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotLen)\n  let bFirstRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let bFirstRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotLen)\n  let aFirstRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotLen)\n  let bFirstRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let bFirstRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let bFirstRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let bFirstRotRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let bFirstRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let bFirstRotRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotRotLen)\n  let bFirstRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotRotLen)\n  let bFirstRotRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotRotLen)\n  let bFirstRotRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let bFirstRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let bFirstRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let bFirstRotRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotRotRotLen)\n  let bFirstRotRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotRotLen)\n  let bFirstRotRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotRotLen)\n  let bFirstRotRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotRotLen)\n  let bFirstRotRotRotRotRot = bFirstRotRot.map((v, i) => i % bFirstRotRotRotRotRotRotLen)\n  let aFirstRotRotRotRotRot = aFirstRotRotRot.map((v, i) => i % b", "passed": 0}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "gc": "<|endoftext|>/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let count = 0;\n  let digit;\n  while (num) {\n    digit = num % 10;\n    if (digit === 0) count++;\n    num = Math.floor(num / 10);\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of characters in the string.\n\n   Example:\n      characterCount(\"hello\") ==> (3, 4)\n      characterCount(\"helloworld\") ==> (3, 6)\n  */\nconst characterCount = (str) => {\n  let count = 0;\n  let char;\n  for (let i = 0; i < str.length; i++) {\n    char = str.charAt(i);\n    if (char ==='') count++;\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of words in the string.\n\n   Example:\n      wordCount(\"hello\") ==> (3, 4)\n      wordCount(\"helloworld\") ==> (3, 6)\n  */\nconst wordCount = (str) => {\n  let count = 0;\n  let word;\n  for (let i = 0; i < str.length; i++) {\n    word = str.charAt(i);\n    if (word ==='') count++;\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of lines in the string.\n\n   Example:\n      lineCount(\"hello\") ==> (3, 4)\n      lineCount(\"helloworld\") ==> (3, 6)\n  */\nconst lineCount = (str) => {\n  let count = 0;\n  let line;\n  for (let i = 0; i < str.length; i++) {\n    line = str.charAt(i);\n    if (line ==='') count++;\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of characters in the string.\n\n   Example:\n      characterCount(\" hello world\") ==> (3, 6)\n      characterCount(\"helloworld\") ==> (3, 6)\n  */\nconst characterCount = (str) => {\n  let count = 0;\n  let char;\n  for (let i = 0; i < str.length; i++) {\n    char = str.charAt(i);\n    if (char ==='') count++;\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of characters in the string.\n\n   Example:\n      characterCount(\" hello world\") ==> (3, 6)\n      characterCount(\"helloworld\") ==> (3, 6)\n  */\nconst characterCount = (str) => {\n  let count = 0;\n  let char;\n  for (let i = 0; i < str.length; i++) {\n    char = str.charAt(i);\n    if (char ==='') count++;\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of characters in the string.\n\n   Example:\n      characterCount(\" hello world\") ==> (3, 6)\n      characterCount(\"helloworld\") ==> (3, 6)\n  */\nconst characterCount = (str) => {\n  let count = 0;\n  let char;\n  for (let i = 0; i < str.length; i++) {\n    char = str.charAt(i);\n    if (char ==='') count++;\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of characters in the string.\n\n   Example:\n      characterCount(\" hello world\") ==> (3, 6)\n      characterCount(\"helloworld\") ==> (3, 6)\n  */\nconst characterCount = (str) => {\n  let count = 0;\n  let char;\n  for (let i = 0; i < str.length; i++) {\n    char = str.charAt(i);\n    if (char ==='') count++;\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of characters in the string.\n\n   Example:\n      characterCount(\" hello world\") ==> (3, 6)\n      characterCount(\"helloworld\") ==> (3, 6)\n  */\nconst characterCount = (str) => {\n  let count = 0;\n  let char;\n  for (let i = 0; i < str.length; i++) {\n    char = str.charAt(i);\n    if (char ==='') count++;\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of characters in the string.\n\n   Example:\n      characterCount(\" hello world\") ==> (3, 6)\n      characterCount(\"helloworld\") ==> (3, 6)\n  */\nconst characterCount = (str) => {\n  let count = 0;\n  let char;\n  for (let i = 0; i < str.length; i++) {\n    char = str.charAt(i);\n    if (char ==='') count++;\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of characters in the string.\n\n   Example:\n      characterCount(\" hello world\") ==> (3, 6)\n      characterCount(\"helloworld\") ==> (3, 6)\n  */\nconst characterCount = (str) => {\n  let count = 0;\n  let char;\n  for (let i = 0; i < str.length; i++) {\n    char = str.charAt(i);\n    if (char ==='') count++;\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of characters in the string.\n\n   Example:\n      characterCount(\" hello world\") ==> (3, 6)\n      characterCount(\"helloworld\") ==> (3, 6)\n  */\nconst characterCount = (str) => {\n  let count = 0;\n  let char;\n  for (let i = 0; i < str.length; i++) {\n    char = str.charAt(i);\n    if (char ==='') count++;\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of characters in the string.\n\n   Example:\n      characterCount(\" hello world\") ==> (3, 6)\n      characterCount(\"helloworld\") ==> (3, 6)\n  */\nconst characterCount = (str) => {\n  let count = 0;\n  let char;\n  for (let i = 0; i < str.length; i++) {\n    char = str.charAt(i);\n    if (char ==='') count++;\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of characters in the string.\n\n   Example:\n      characterCount(\" hello world\") ==> (3, 6)\n      characterCount(\"helloworld\") ==> (3, 6)\n  */\nconst characterCount = (str) => {\n  let count = 0;\n  let char;\n  for (let i = 0; i < str.length; i++) {\n    char = str.charAt(i);\n    if (char ==='') count++;\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of characters in the string.\n\n   Example:\n      characterCount(\" hello world\") ==> (3, 6)\n      characterCount(\"helloworld\") ==> (3, 6)\n  */\nconst characterCount = (str) => {\n  let count = 0;\n  let char;\n  for (let i = 0; i < str.length; i++) {\n    char = str.charAt(i);\n    if (char ==='') count++;\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of characters in the string.\n\n   Example:\n      characterCount(\" hello world\") ==> (3, 6)\n      characterCount(\"helloworld\") ==> (3, 6)\n  */\nconst characterCount = (str) => {\n  let count = 0;\n  let char;\n  for (let i = 0; i < str.length; i++) {\n    char = str.charAt(i);\n    if (char ==='') count++;\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of characters in the string.\n\n   Example:\n      characterCount(\" hello world\") ==> (3, 6)\n      characterCount(\"helloworld\") ==> (3, 6)\n  */\nconst characterCount = (str) => {\n  let count = 0;\n  let char;\n  for (let i = 0; i < str.length; i++) {\n    char = str.charAt(i);\n    if (char ==='') count++;\n  }\n  return [count, count];\n};\n\n/*Given a string, return a tuple that has the number of characters in the string.\n\n   Example:\n      characterCount(\" hello world\") ==> (3, 6)\n      characterCount(\"helloworld\") ==> (3, 6)\n  */\nconst characterCount = (str) => {\n  let count = 0;\n  let char;\n  for (let i = 0; i < str.length; i++) {\n    char = str.charAt(i);\n    if (", "passed": 0}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "gc": "<|endoftext|>/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const num = (number + '');\n  const numArray = num.split('');\n  const numArrayLength = numArray.length;\n  const numArrayReversed = numArray.slice(0).reverse();\n  const numArrayReversedLength = numArrayReversed.length;\n  const numArrayReversedReversed = numArrayReversed.slice(0).reverse();\n  const numArrayReversedReversedLength = numArrayReversedReversed.length;\n  let numArrayReversedReversedString = '';\n  let numArrayReversedReversedStringLength = 0;\n  let numArrayReversedReversedStringReversed = '';\n  let numArrayReversedReversedStringReversedLength = 0;\n  let numArrayReversedReversedStringReversedReversed = '';\n  let numArrayReversedReversedStringReversedReversedLength = 0;\n  let numArrayReversedReversedStringReversedReversedReversed = '';\n  let numArrayReversedReversedStringReversedReversedReversedLength = 0;\n  let numArrayReversedReversedStringReversedReversedReversedReversed = '';\n  let numArrayReversedReversedStringReversedReversedReversedReversedReversed = '';\n  let numArrayReversedReversedStringReversedReversedReversedReversedReversedReversed = '';\n  let numArrayReversedReversedStringReversedReversedReversedReversedReversedReversedReversed = '';\n  let numArrayReversedReversedStringReversedReversedReversedReversedReversedReversedReversedReversed = '';\n  let numArrayReversedReversedStringReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed", "passed": 0}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantTriangle(3, 4, 5) == true\n  goodSlantTriangle(1, 2, 3) == false\n  */\nconst goodSlantTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "goodSlantTriangle", "gc": "<|endoftext|>/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantTriangle(3, 4, 5) == true\n  goodSlantTriangle(1, 2, 3) == false\n  */\nconst goodSlantTriangle = (a, b, c) => {\n  const a1 = Math.sqrt(a * a + b * b);\n  const a2 = Math.sqrt(a * a + c * c);\n  const a3 = Math.sqrt(a * a + b * c);\n  const b1 = Math.sqrt(b * b + c * c);\n  const b2 = Math.sqrt(b * b + a * a);\n  const b3 = Math.sqrt(b * b + a * a);\n  const c1 = Math.sqrt(c * c + a * a);\n  const c2 = Math.sqrt(c * c + b * b);\n  const c3 = Math.sqrt(c * c + b * b);\n  const d1 = Math.sqrt(a1 * a1 + b1 * b1);\n  const d2 = Math.sqrt(a1 * a1 + c1 * c1);\n  const d3 = Math.sqrt(a1 * a1 + b1 * b1);\n  const e1 = Math.sqrt(a2 * a2 + b2 * b2);\n  const e2 = Math.sqrt(a2 * a2 + c2 * c2);\n  const e3 = Math.sqrt(a2 * a2 + b2 * b2);\n  const f1 = Math.sqrt(a3 * a3 + b3 * b3);\n  const f2 = Math.sqrt(a3 * a3 + c3 * c3);\n  const f3 = Math.sqrt(a3 * a3 + b3 * b3);\n  const g1 = Math.sqrt(b1 * b1 + c1 * c1);\n  const g2 = Math.sqrt(b1 * b1 + a1 * a1);\n  const g3 = Math.sqrt(b1 * b1 + a1 * a1);\n  const h1 = Math.sqrt(c1 * c1 + a1 * a1);\n  const h2 = Math.sqrt(c1 * c1 + b1 * b1);\n  const h3 = Math.sqrt(c1 * c1 + b1 * b1);\n  const d1 = e1 * e1;\n  const d2 = e2 * e2;\n  const d3 = e3 * e3;\n  const e1 = f1 * f1;\n  const e2 = f2 * f2;\n  const e3 = f3 * f3;\n  const f1 = g1 * g1;\n  const f2 = g2 * g2;\n  const f3 = g3 * g3;\n  const g1 = h1 * h1;\n  const g2 = h2 * h2;\n  const g3 = h3 * h3;\n  const h1 = d1 * d1;\n  const h2 = d2 * d2;\n  const h3 = d3 * d3;\n  const d1 = e1 * e1;\n  const d2 = e2 * e2;\n  const d3 = e3 * e3;\n  const e1 = f1 * f1;\n  const e2 = f2 * f2;\n  const e3 = f3 * f3;\n  const f1 = g1 * g1;\n  const f2 = g2 * g2;\n  const f3 = g3 * g3;\n  const g1 = h1 * h1;\n  const g2 = h2 * h2;\n  const g3 = h3 * h3;\n  const h1 = d1 * d1;\n  const h2 = d2 * d2;\n  const h3 = d3 * d3;\n  const d1 = e1 * e1;\n  const d2 = e2 * e2;\n  const d3 = e3 * e3;\n  const e1 = f1 * f1;\n  const e2 = f2 * f2;\n  const e3 = f3 * f3;\n  const f1 = g1 * g1;\n  const f2 = g2 * g2;\n  const f3 = g3 * g3;\n  const g1 = h1 * h1;\n  const g2 = h2 * h2;\n  const g3 = h3 * h3;\n  const h1 = d1 * d1;\n  const h2 = d2 * d2;\n  const h3 = d3 * d3;\n  const d1 = e1 * e1;\n  const d2 = e2 * e2;\n  const d3 = e3 * e3;\n  const e1 = f1 * f1;\n  const e2 = f2 * f2;\n  const e3 = f3 * f3;\n  const f1 = g1 * g1;\n  const f2 = g2 * g2;\n  const f3 = g3 * g3;\n  const g1 = h1 * h1;\n  const g2 = h2 * h2;\n  const g3 = h3 * h3;\n  const h1 = d1 * d1;\n  const h2 = d2 * d2;\n  const h3 = d3 * d3;\n  const d1 = e1 * e1;\n  const d2 = e2 * e2;\n  const d3 = e3 * e3;\n  const e1 = f1 * f1;\n  const e2 = f2 * f2;\n  const e3 = f3 * f3;\n  const f1 = g1 * g1;\n  const f2 = g2 * g2;\n  const f3 = g3 * g3;\n  const g1 = h1 * h1;\n  const g2 = h2 * h2;\n  const g3 = h3 * h3;\n  const h1 = d1 * d1;\n  const h2 = d2 * d2;\n  const h3 = d3 * d3;\n  const d1 = e1 * e1;\n  const d2 = e2 * e2;\n  const d3 = e3 * e3;\n  const e1 = f1 * f1;\n  const e2 = f2 * f2;\n  const e3 = f3 * f3;\n  const f1 = g1 * g1;\n  const f2 = g2 * g2;\n  const f3 = g3 * g3;\n  const g1 = h1 * h1;\n  const g2 = h2 * h2;\n  const g3 = h3 * h3;\n  const h1 = d1 * d1;\n  const h2 = d2 * d2;\n  const h3 = d3 * d3;\n  const d1 = e1 * e1;\n  const d2 = e2 * e2;\n  const d3 = e3 * e3;\n  const e1 = f1 * f1;\n  const e2 = f2 * f2;\n  const e3 = f3 * f3;\n  const f1 = g1 * g1;\n  const f2 = g2 * g2;\n  const f3 = g3 * g3;\n  const g1 = h1 * h1;\n  const g2 = h2 * h2;\n  const g3 = h3 * h3;\n  const h1 = d1 * d1;\n  const h2 = d2 * d2;\n  const h3 = d3 * d3;\n  const d1 = e1 * e1;\n  const d2 = e2 * e2;\n  const d3 = e3 * e3;\n  const e1 = f1 * f1;\n  const e2 = f2 * f2;\n  const e3 = f3 * f3;\n  const f1 = g1 * g1;\n  const f2 = g2 * g2;\n  const f3 = g3 * g3;\n  const g1 = h1 * h1;\n  const g2 = h2 * h2;\n  const g3 = h3 * h3;\n  const h1 = d1 * d1;\n  const h2 = d2 * d2;\n  const h3 = d3 * d3;\n  const d1 = e1 * e1;\n  const d2 = e2 * e2;\n  const d3 = e3 * e3;\n  const e1 = f1 * f1;\n  const e2 = f2 * f2;\n  const e3 = f3 * f3;\n  const f1 = g1 * g1;\n  const f2 = g2 * g2;\n  const f3 = g3 * g3;\n  const g1 = h1 * h1;\n  const g2 = h2 * h2;\n  const g3 = h3 * h3;\n  const h1 = d1 * d1;\n  const h2 = d2 * d2;\n  const h3 = d3 * d3;\n  const d1 = e1 * e1;\n  const d2 = e2 * e2;\n  const d3 = e3 * e3;\n  const e1 = f1 * f1;\n  const e2 = f2 * f2;\n  const e3 = f3 * f3;\n  const f1 = g1 * g1;\n  const f2 = g2 * g", "passed": 0}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  receiveMax([\"name\", \"of\", \"string\"]) === \"string\"\n  receiveMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  receiveMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst receiveMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "receiveMax", "gc": "<|endoftext|>/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  receiveMax([\"name\", \"of\", \"string\"]) === \"string\"\n  receiveMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  receiveMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst receiveMax = (words) => {\n  let maxLength = 0;\n  let maxWord = '';\n  let maxChar = 0;\n  let uniqueChar = 0;\n  let uniqueWord = '';\n  let uniqueWords = [];\n  let uniqueWordsIndex = 0;\n  let uniqueWordsLength = 0;\n  let uniqueWordsIndex2 = 0;\n  let uniqueWordsLength2 = 0;\n  let uniqueWordsIndex3 = 0;\n  let uniqueWordsLength3 = 0;\n  let uniqueWordsIndex4 = 0;\n  let uniqueWordsLength4 = 0;\n  let uniqueWordsIndex5 = 0;\n  let uniqueWordsLength5 = 0;\n  let uniqueWordsIndex6 = 0;\n  let uniqueWordsLength6 = 0;\n  let uniqueWordsIndex7 = 0;\n  let uniqueWordsLength7 = 0;\n  let uniqueWordsIndex8 = 0;\n  let uniqueWordsLength8 = 0;\n  let uniqueWordsIndex9 = 0;\n  let uniqueWordsLength9 = 0;\n  let uniqueWordsIndex10 = 0;\n  let uniqueWordsLength10 = 0;\n  let uniqueWordsIndex11 = 0;\n  let uniqueWordsLength11 = 0;\n  let uniqueWordsIndex12 = 0;\n  let uniqueWordsLength12 = 0;\n  let uniqueWordsIndex13 = 0;\n  let uniqueWordsLength13 = 0;\n  let uniqueWordsIndex14 = 0;\n  let uniqueWordsLength14 = 0;\n  let uniqueWordsIndex15 = 0;\n  let uniqueWordsLength15 = 0;\n  let uniqueWordsIndex16 = 0;\n  let uniqueWordsLength16 = 0;\n  let uniqueWordsIndex17 = 0;\n  let uniqueWordsLength17 = 0;\n  let uniqueWordsIndex18 = 0;\n  let uniqueWordsLength18 = 0;\n  let uniqueWordsIndex19 = 0;\n  let uniqueWordsLength19 = 0;\n  let uniqueWordsIndex20 = 0;\n  let uniqueWordsLength20 = 0;\n  let uniqueWordsIndex21 = 0;\n  let uniqueWordsLength21 = 0;\n  let uniqueWordsIndex22 = 0;\n  let uniqueWordsLength22 = 0;\n  let uniqueWordsIndex23 = 0;\n  let uniqueWordsLength23 = 0;\n  let uniqueWordsIndex24 = 0;\n  let uniqueWordsLength24 = 0;\n  let uniqueWordsIndex25 = 0;\n  let uniqueWordsLength25 = 0;\n  let uniqueWordsIndex26 = 0;\n  let uniqueWordsLength26 = 0;\n  let uniqueWordsIndex27 = 0;\n  let uniqueWordsLength27 = 0;\n  let uniqueWordsIndex28 = 0;\n  let uniqueWordsLength28 = 0;\n  let uniqueWordsIndex29 = 0;\n  let uniqueWordsLength29 = 0;\n  let uniqueWordsIndex30 = 0;\n  let uniqueWordsLength30 = 0;\n  let uniqueWordsIndex31 = 0;\n  let uniqueWordsLength31 = 0;\n  let uniqueWordsIndex32 = 0;\n  let uniqueWordsLength32 = 0;\n  let uniqueWordsIndex33 = 0;\n  let uniqueWordsLength33 = 0;\n  let uniqueWordsIndex34 = 0;\n  let uniqueWordsLength34 = 0;\n  let uniqueWordsIndex35 = 0;\n  let uniqueWordsLength35 = 0;\n  let uniqueWordsIndex36 = 0;\n  let uniqueWordsLength36 = 0;\n  let uniqueWordsIndex37 = 0;\n  let uniqueWordsLength37 = 0;\n  let uniqueWordsIndex38 = 0;\n  let uniqueWordsLength38 = 0;\n  let uniqueWordsIndex39 = 0;\n  let uniqueWordsLength39 = 0;\n  let uniqueWordsIndex40 = 0;\n  let uniqueWordsLength40 = 0;\n  let uniqueWordsIndex41 = 0;\n  let uniqueWordsLength41 = 0;\n  let uniqueWordsIndex42 = 0;\n  let uniqueWordsLength42 = 0;\n  let uniqueWordsIndex43 = 0;\n  let uniqueWordsLength43 = 0;\n  let uniqueWordsIndex44 = 0;\n  let uniqueWordsLength44 = 0;\n  let uniqueWordsIndex45 = 0;\n  let uniqueWordsLength45 = 0;\n  let uniqueWordsIndex46 = 0;\n  let uniqueWordsLength46 = 0;\n  let uniqueWordsIndex47 = 0;\n  let uniqueWordsLength47 = 0;\n  let uniqueWordsIndex48 = 0;\n  let uniqueWordsLength48 = 0;\n  let uniqueWordsIndex49 = 0;\n  let uniqueWordsLength49 = 0;\n  let uniqueWordsIndex50 = 0;\n  let uniqueWordsLength50 = 0;\n  let uniqueWordsIndex51 = 0;\n  let uniqueWordsLength51 = 0;\n  let uniqueWordsIndex52 = 0;\n  let uniqueWordsLength52 = 0;\n  let uniqueWordsIndex53 = 0;\n  let uniqueWordsLength53 = 0;\n  let uniqueWordsIndex54 = 0;\n  let uniqueWordsLength54 = 0;\n  let uniqueWordsIndex55 = 0;\n  let uniqueWordsLength55 = 0;\n  let uniqueWordsIndex56 = 0;\n  let uniqueWordsLength56 = 0;\n  let uniqueWordsIndex57 = 0;\n  let uniqueWordsLength57 = 0;\n  let uniqueWordsIndex58 = 0;\n  let uniqueWordsLength58 = 0;\n  let uniqueWordsIndex59 = 0;\n  let uniqueWordsLength59 = 0;\n  let uniqueWordsIndex60 = 0;\n  let uniqueWordsLength60 = 0;\n  let uniqueWordsIndex61 = 0;\n  let uniqueWordsLength61 = 0;\n  let uniqueWordsIndex62 = 0;\n  let uniqueWordsLength62 = 0;\n  let uniqueWordsIndex63 = 0;\n  let uniqueWordsLength63 = 0;\n  let uniqueWordsIndex64 = 0;\n  let uniqueWordsLength64 = 0;\n  let uniqueWordsIndex65 = 0;\n  let uniqueWordsLength65 = 0;\n  let uniqueWordsIndex66 = 0;\n  let uniqueWordsLength66 = 0;\n  let uniqueWordsIndex67 = 0;\n  let uniqueWordsLength67 = 0;\n  let uniqueWordsIndex68 = 0;\n  let uniqueWordsLength68 = 0;\n  let uniqueWordsIndex69 = 0;\n  let uniqueWordsLength69 = 0;\n  let uniqueWordsIndex70 = 0;\n  let uniqueWordsLength70 = 0;\n  let uniqueWordsIndex71 = 0;\n  let uniqueWordsLength71 = 0;\n  let uniqueWordsIndex72 = 0;\n  let uniqueWordsLength72 = 0;\n  let uniqueWordsIndex73 = 0;\n  let uniqueWordsLength73 = 0;\n  let uniqueWordsIndex74 = 0;\n  let uniqueWordsLength74 = 0;\n  let uniqueWordsIndex75 = 0;\n  let uniqueWordsLength75 = 0;\n  let uniqueWordsIndex76 = 0;\n  let uniqueWordsLength76 = 0;\n  let uniqueWordsIndex77 = 0;\n  let uniqueWordsLength77 = 0;\n  let uniqueWordsIndex78 = 0;\n  let uniqueWordsLength78 = 0;\n  let uniqueWordsIndex79 = 0;\n  let uniqueWordsLength79 = 0;\n  let uniqueWordsIndex80 = 0;\n  let uniqueWordsLength80 = 0;\n  let uniqueWordsIndex81 = 0;\n  let uniqueWordsLength81 = 0;\n  let uniqueWordsIndex82 = 0;\n  let uniqueWordsLength82 = 0;\n  let uniqueWordsIndex83 = 0;\n  let uniqueWordsLength83 = 0;\n  let uniqueWordsIndex84 = 0;\n  let uniqueWordsLength84 = 0;\n  let uniqueWordsIndex85 = 0;\n  let uniqueWordsLength85 = 0;\n  let uniqueWordsIndex86 = 0;\n  let uniqueWordsLength86 = 0;\n  let uniqueWordsIndex87 = 0;\n  let uniqueWordsLength87 = 0;\n  let uniqueWordsIndex88 = 0;\n  let uniqueWordsLength88 = 0;\n  let unique", "passed": 0}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have feeden a certain number of carrots,\n  but now you need to feed more carrots to complete the day's meals.\n  you should return an array of [ total number of feeden carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will feed all remaining carrots, but will still be hungry.\n  \n  Example:\n  * feed(5, 6, 10) -> [11, 4]\n  * feed(4, 8, 9) -> [12, 1]\n  * feed(1, 10, 10) -> [11, 0]\n  * feed(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have feeden.\n  @need : integer\n      the number of carrots that you need to feed.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst feed = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "feed", "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have feeden a certain number of carrots,\n  but now you need to feed more carrots to complete the day's meals.\n  you should return an array of [ total number of feeden carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will feed all remaining carrots, but will still be hungry.\n  \n  Example:\n  * feed(5, 6, 10) -> [11, 4]\n  * feed(4, 8, 9) -> [12, 1]\n  * feed(1, 10, 10) -> [11, 0]\n  * feed(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have feeden.\n  @need : integer\n      the number of carrots that you need to feed.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst feed = (number, need, remaining) => {\n  const totalCarrots = Math.ceil(number * need / remaining);\n  const remainingCarrots = Math.ceil(number * need / remaining);\n  const remainingCarrotLeft = number * need / remaining;\n  const remainingCarrotsLeft = number * need / remaining;\n  const remainingCarrotsRemaining = number * need / remaining;\n  const remainingCarrotsRemainingLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightLeft = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRight = number * need / remaining;\n  const remainingCarrotsRemainingLeftLeftLeftRightRightRightRightRightLeft = number * need / remaining;\n  const ", "passed": 0}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "considerClearcutCharacters", "gc": "<|endoftext|>/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].length > 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].length > 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].length > 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].length > 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].length > 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].length > 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].length > 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].length > 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].length > 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].length > 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].length > 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].length > 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].length > 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].length > 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].length > 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i].length > 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n", "passed": 0}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst sufficeAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "sufficeAlgebra", "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst sufficeAlgebra = (operator, operand) => {\n  const operatorLength = operator.length;\n  const operandLength = operand.length;\n  let result = 0;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      if (operator[operatorIndex] === '+') {\n        result += operand[operandIndex++];\n      } else if (operator[operatorIndex] === '-') {\n        result -= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '*') {\n        result *= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '/') {\n        result /= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '**') {\n        result **= operand[operandIndex++];\n      }\n      operatorIndex++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\nconst sufficeAlgebraWithOperator = (operator, operand) => {\n  const operatorLength = operator.length;\n  const operandLength = operand.length;\n  let result = 0;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      if (operator[operatorIndex] === '+') {\n        result += operand[operandIndex++];\n      } else if (operator[operatorIndex] === '-') {\n        result -= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '*') {\n        result *= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '/') {\n        result /= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '**') {\n        result **= operand[operandIndex++];\n      }\n      operatorIndex++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\nconst sufficeAlgebraWithOperatorAndOperator = (operator, operand) => {\n  const operatorLength = operator.length;\n  const operandLength = operand.length;\n  let result = 0;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      if (operator[operatorIndex] === '+') {\n        result += operand[operandIndex++];\n      } else if (operator[operatorIndex] === '-') {\n        result -= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '*') {\n        result *= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '/') {\n        result /= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '**') {\n        result **= operand[operandIndex++];\n      }\n      operatorIndex++;\n    } else if (operatorIndex < operatorLength) {\n      if (operator[operatorIndex] === '+') {\n        result += operand[operandIndex++];\n      } else if (operator[operatorIndex] === '-') {\n        result -= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '*') {\n        result *= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '/') {\n        result /= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '**') {\n        result **= operand[operandIndex++];\n      }\n      operatorIndex++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\nconst sufficeAlgebraWithOperatorAndOperatorAndOperator = (operator, operand) => {\n  const operatorLength = operator.length;\n  const operandLength = operand.length;\n  let result = 0;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      if (operator[operatorIndex] === '+') {\n        result += operand[operandIndex++];\n      } else if (operator[operatorIndex] === '-') {\n        result -= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '*') {\n        result *= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '/') {\n        result /= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '**') {\n        result **= operand[operandIndex++];\n      }\n      operatorIndex++;\n    } else if (operatorIndex < operatorLength) {\n      if (operator[operatorIndex] === '+') {\n        result += operand[operandIndex++];\n      } else if (operator[operatorIndex] === '-') {\n        result -= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '*') {\n        result *= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '/') {\n        result /= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '**') {\n        result **= operand[operandIndex++];\n      }\n      operatorIndex++;\n    } else if (operatorIndex < operatorLength) {\n      if (operator[operatorIndex] === '+') {\n        result += operand[operandIndex++];\n      } else if (operator[operatorIndex] === '-') {\n        result -= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '*') {\n        result *= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '/') {\n        result /= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '**') {\n        result **= operand[operandIndex++];\n      }\n      operatorIndex++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\nconst sufficeAlgebraWithOperatorAndOperatorAndOperatorAndOperator = (operator, operand) => {\n  const operatorLength = operator.length;\n  const operandLength = operand.length;\n  let result = 0;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n  while (operandIndex < operandLength) {\n    if (operatorIndex < operatorLength) {\n      if (operator[operatorIndex] === '+') {\n        result += operand[operandIndex++];\n      } else if (operator[operatorIndex] === '-') {\n        result -= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '*') {\n        result *= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '/') {\n        result /= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '**') {\n        result **= operand[operandIndex++];\n      }\n      operatorIndex++;\n    } else if (operatorIndex < operatorLength) {\n      if (operator[operatorIndex] === '+') {\n        result += operand[operandIndex++];\n      } else if (operator[operatorIndex] === '-') {\n        result -= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '*') {\n        result *= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '/') {\n        result /= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '**') {\n        result **= operand[operandIndex++];\n      }\n      operatorIndex++;\n    } else if (operatorIndex < operatorLength) {\n      if (operator[operatorIndex] === '+') {\n        result += operand[operandIndex++];\n      } else if (operator[operatorIndex] === '-') {\n        result -= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '*') {\n        result *= operand[operandIndex++];\n      } else if (operator[operatorIndex] === '/') {\n        result /= operand[operandIndex++];\n      } else if (operator", "passed": 0}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  resolve(\"1234\") = \"4321\"\n  resolve(\"ab\") = \"AB\"\n  resolve(\"#a@C\") = \"#A@c\"\n  */\nconst resolve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "resolve", "gc": "<|endoftext|>/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  resolve(\"1234\") = \"4321\"\n  resolve(\"ab\") = \"AB\"\n  resolve(\"#a@C\") = \"#A@c\"\n  */\nconst resolve = (s) => {\n  let res = '';\n  let len = s.length;\n  let i;\n  let ch;\n  let ch2;\n  let ch3;\n  let ch4;\n  let ch5;\n  let ch6;\n  let ch7;\n  let ch8;\n  let ch9;\n  let ch10;\n  let ch11;\n  let ch12;\n  let ch13;\n  let ch14;\n  let ch15;\n  let ch16;\n  let ch17;\n  let ch18;\n  let ch19;\n  let ch20;\n  let ch21;\n  let ch22;\n  let ch23;\n  let ch24;\n  let ch25;\n  let ch26;\n  let ch27;\n  let ch28;\n  let ch29;\n  let ch30;\n  let ch31;\n  let ch32;\n  let ch33;\n  let ch34;\n  let ch35;\n  let ch36;\n  let ch37;\n  let ch38;\n  let ch39;\n  let ch40;\n  let ch41;\n  let ch42;\n  let ch43;\n  let ch44;\n  let ch45;\n  let ch46;\n  let ch47;\n  let ch48;\n  let ch49;\n  let ch50;\n  let ch51;\n  let ch52;\n  let ch53;\n  let ch54;\n  let ch55;\n  let ch56;\n  let ch57;\n  let ch58;\n  let ch59;\n  let ch60;\n  let ch61;\n  let ch62;\n  let ch63;\n  let ch64;\n  let ch65;\n  let ch66;\n  let ch67;\n  let ch68;\n  let ch69;\n  let ch70;\n  let ch71;\n  let ch72;\n  let ch73;\n  let ch74;\n  let ch75;\n  let ch76;\n  let ch77;\n  let ch78;\n  let ch79;\n  let ch80;\n  let ch81;\n  let ch82;\n  let ch83;\n  let ch84;\n  let ch85;\n  let ch86;\n  let ch87;\n  let ch88;\n  let ch89;\n  let ch90;\n  let ch91;\n  let ch92;\n  let ch93;\n  let ch94;\n  let ch95;\n  let ch96;\n  let ch97;\n  let ch98;\n  let ch99;\n  let ch100;\n  let ch101;\n  let ch102;\n  let ch103;\n  let ch104;\n  let ch105;\n  let ch106;\n  let ch107;\n  let ch108;\n  let ch109;\n  let ch110;\n  let ch111;\n  let ch112;\n  let ch113;\n  let ch114;\n  let ch115;\n  let ch116;\n  let ch117;\n  let ch118;\n  let ch119;\n  let ch120;\n  let ch121;\n  let ch122;\n  let ch123;\n  let ch124;\n  let ch125;\n  let ch126;\n  let ch127;\n  let ch128;\n  let ch129;\n  let ch130;\n  let ch131;\n  let ch132;\n  let ch133;\n  let ch134;\n  let ch135;\n  let ch136;\n  let ch137;\n  let ch138;\n  let ch139;\n  let ch140;\n  let ch141;\n  let ch142;\n  let ch143;\n  let ch144;\n  let ch145;\n  let ch146;\n  let ch147;\n  let ch148;\n  let ch149;\n  let ch150;\n  let ch151;\n  let ch152;\n  let ch153;\n  let ch154;\n  let ch155;\n  let ch156;\n  let ch157;\n  let ch158;\n  let ch159;\n  let ch160;\n  let ch161;\n  let ch162;\n  let ch163;\n  let ch164;\n  let ch165;\n  let ch166;\n  let ch167;\n  let ch168;\n  let ch169;\n  let ch170;\n  let ch171;\n  let ch172;\n  let ch173;\n  let ch174;\n  let ch175;\n  let ch176;\n  let ch177;\n  let ch178;\n  let ch179;\n  let ch180;\n  let ch181;\n  let ch182;\n  let ch183;\n  let ch184;\n  let ch185;\n  let ch186;\n  let ch187;\n  let ch188;\n  let ch189;\n  let ch190;\n  let ch191;\n  let ch192;\n  let ch193;\n  let ch194;\n  let ch195;\n  let ch196;\n  let ch197;\n  let ch198;\n  let ch199;\n  let ch200;\n  let ch201;\n  let ch202;\n  let ch203;\n  let ch204;\n  let ch205;\n  let ch206;\n  let ch207;\n  let ch208;\n  let ch209;\n  let ch210;\n  let ch211;\n  let ch212;\n  let ch213;\n  let ch214;\n  let ch215;\n  let ch216;\n  let ch217;\n  let ch218;\n  let ch219;\n  let ch220;\n  let ch221;\n  let ch222;\n  let ch223;\n  let ch224;\n  let ch225;\n  let ch226;\n  let ch227;\n  let ch228;\n  let ch229;\n  let ch230;\n  let ch231;\n  let ch232;\n  let ch233;\n  let ch234;\n  let ch235;\n  let ch236;\n  let ch237;\n  let ch238;\n  let ch239;\n  let ch240;\n  let ch241;\n  let ch242;\n  let ch243;\n  let ch244;\n  let ch245;\n  let ch246;\n  let ch247;\n  let ch248;\n  let ch249;\n  let ch250;\n  let ch251;\n  let ch252;\n  let ch253;\n  let ch254;\n  let ch255;\n  let ch256;\n  let ch257;\n  let ch258;\n  let ch259;\n  let ch260;\n  let ch261;\n  let ch262;\n  let ch263;\n  let ch264;\n  let ch265;\n  let ch266;\n  let ch267;\n  let ch268;\n  let ch269;\n  let ch270;\n  let ch271;\n  let ch272;\n  let ch273;\n  let ch274;\n  let ch275;\n  let ch276;\n  let ch277;\n  let ch278;\n  let ch279;\n  let ch280;\n  let ch281;\n  let ch282;\n  let ch283;\n  let ch284;\n  let ch285;\n  let ch286;\n  let ch287;\n  let ch288;\n  let ch289;\n  let ch290;\n  let ch", "passed": 0}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "bowedStringedInstrumentToMd5", "gc": "<|endoftext|>/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5Hex = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HexWithPadding = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HexWithPaddingAndPadding = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HexWithPaddingAndPaddingAndPadding = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HexWithPaddingAndPaddingAndPadding = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HexWithPaddingAndPaddingAndPaddingAndPadding = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HexWithPaddingAndPaddingAndPaddingAndPaddingAndPadding = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HexWithPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPadding = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HexWithPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAndPaddingAnd", "passed": 0}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  renderInteger(2, 8) => [2, 4, 6, 8]\n  renderInteger(8, 2) => [2, 4, 6, 8]\n  renderInteger(10, 14) => []\n  */\nconst renderInteger = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "renderInteger", "gc": "<|endoftext|>/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  renderInteger(2, 8) => [2, 4, 6, 8]\n  renderInteger(8, 2) => [2, 4, 6, 8]\n  renderInteger(10, 14) => []\n  */\nconst renderInteger = (a, b) => {\n  const result = [];\n  let digit;\n  let i;\n  let j;\n\n  for (i = a; i; i--) {\n    digit = i % b;\n    result.push(digit);\n  }\n\n  for (i = b; i; i--) {\n    digit = i % a;\n    result.push(digit);\n  }\n\n  return result;\n};\n\n/**\n * Given a string, return the string with each character replaced by its\n * corresponding ASCII character.\n *\n * For example:\n * ascii('hello') => 'h'\n * ascii('hello ') => 'h e'\n * ascii('hello world') => 'h e l l o'\n */\nconst ascii = str => {\n  let result = '';\n  let i;\n\n  for (i = 0; i < str.length; i++) {\n    result += String.fromCharCode(str.charCodeAt(i));\n  }\n\n  return result;\n};\n\n/**\n * Given a string, return the string with each character replaced by its\n * corresponding Unicode character.\n *\n * For example:\n * unicode('hello') => 'h'\n * unicode('hello ') => 'h e'\n * unicode('hello world') => 'h e l l o'\n */\nconst unicode = str => {\n  let result = '';\n  let i;\n\n  for (i = 0; i < str.length; i++) {\n    result += String.fromCharCode(str.codePointAt(i));\n  }\n\n  return result;\n};\n\n/**\n * Given a string, return the string with each character replaced by its\n * corresponding Unicode character and surrogate pairs.\n *\n * For example:\n * surrogatePairs('hello') => '\\uD800\\uDC00'\n * surrogatePairs('hello ') => '\\uD800\\uDC00 h'\n * surrogatePairs('hello world') => '\\uD800\\uDC00 h e l l o'\n */\nconst surrogatePairs = str => {\n  let result = '';\n  let i;\n\n  for (i = 0; i < str.length; i++) {\n    result += String.fromCharCode(str.codePointAt(i) + 0xD800);\n    result += String.fromCharCode(str.codePointAt(i) + 0xDC00);\n  }\n\n  return result;\n};\n\n/**\n * Given a string, return the string with each character replaced by its\n * corresponding Unicode character and surrogate pairs.\n *\n * For example:\n * surrogatePairsUtf8('hello') => '\\uD800\\uDC00'\n * surrogatePairsUtf8('hello ') => '\\uD800\\uDC00 h'\n * surrogatePairsUtf8('hello world') => '\\uD800\\uDC00 h e l l o'\n */\nconst surrogatePairsUtf8 = str => {\n  let result = '';\n  let i;\n\n  for (i = 0; i < str.length; i++) {\n    result += String.fromCharCode(str.codePointAt(i) + 0xD800);\n    result += String.fromCharCode(str.codePointAt(i) + 0xDC00);\n  }\n\n  return result.replace(/[\\uD800-\\uDBFF]/g, c => String.fromCharCode((c >> 10) + 0xDC00));\n};\n\n/**\n * Given a string, return the string with each character replaced by its\n * corresponding Unicode character and surrogate pairs.\n *\n * For example:\n * surrogatePairsUtf16('hello') => '\\uD800\\uDC00'\n * surrogatePairsUtf16('hello ') => '\\uD800\\uDC00 h'\n * surrogatePairsUtf16('hello world') => '\\uD800\\uDC00 h e l l o'\n */\nconst surrogatePairsUtf16 = str => {\n  let result = '';\n  let i;\n\n  for (i = 0; i < str.length; i++) {\n    result += String.fromCharCode(str.codePointAt(i) + 0xD800);\n    result += String.fromCharCode(str.codePointAt(i) + 0xDC00);\n  }\n\n  return result.replace(/[\\uD800-\\uDBFF]/g, c => String.fromCharCode((c >> 10) + 0xD800));\n};\n\n/**\n * Given a string, return the string with each character replaced by its\n * corresponding Unicode character and surrogate pairs.\n *\n * For example:\n * surrogatePairsUtf32('hello') => '\\uD800\\uDC00'\n * surrogatePairsUtf32('hello ') => '\\uD800\\uDC00 h'\n * surrogatePairsUtf32('hello world') => '\\uD800\\uDC00 h e l l o'\n */\nconst surrogatePairsUtf32 = str => {\n  let result = '';\n  let i;\n\n  for (i = 0; i < str.length; i++) {\n    result += String.fromCharCode(str.codePointAt(i) + 0xD800);\n    result += String.fromCharCode(str.codePointAt(i) + 0xDC00);\n  }\n\n  return result.replace(/[\\uD800-\\uDBFF]/g, c => String.fromCharCode((c >> 10) + 0xD800));\n};\n\n/**\n * Given a string, return the string with each character replaced by its\n * corresponding Unicode character and surrogate pairs.\n *\n * For example:\n * surrogatePairsUtf8Utf16('hello') => '\\uD800\\uDC00'\n * surrogatePairsUtf8Utf16('hello ') => '\\uD800\\uDC00 h'\n * surrogatePairsUtf8Utf16('hello world') => '\\uD800\\uDC00 h e l l o'\n */\nconst surrogatePairsUtf8Utf16 = str => {\n  let result = '';\n  let i;\n\n  for (i = 0; i < str.length; i++) {\n    result += String.fromCharCode(str.codePointAt(i) + 0xD800);\n    result += String.fromCharCode(str.codePointAt(i) + 0xDC00);\n  }\n\n  return result.replace(/[\\uD800-\\uDBFF]/g, c => String.fromCharCode((c >> 10) + 0xD800));\n};\n\n/**\n * Given a string, return the string with each character replaced by its\n * corresponding Unicode character and surrogate pairs.\n *\n * For example:\n * surrogatePairsUtf8Utf32('hello') => '\\uD800\\uDC00'\n * surrogatePairsUtf8Utf32('hello ') => '\\uD800\\uDC00 h'\n * surrogatePairsUtf8Utf32('hello world') => '\\uD800\\uDC00 h e l l o'\n */\nconst surrogatePairsUtf8Utf32 = str => {\n  let result = '';\n  let i;\n\n  for (i = 0; i < str.length; i++) {\n    result += String.fromCharCode(str.codePointAt(i) + 0xD800);\n    result += String.fromCharCode(str.codePointAt(i) + 0xDC00);\n  }\n\n  return result.replace(/[\\uD800-\\uDBFF]/g, c => String.fromCharCode((c >> 10) + 0xD800));\n};\n\n/**\n * Given a string, return the string with each character replaced by its\n * corresponding Unicode character and surrogate pairs.\n *\n * For example:\n * surrogatePairsUtf16U", "passed": 0}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "gc": "<|endoftext|>/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const notes_lengths = notes.map((note) => note.length);\n  const notes_beats = notes_lengths.map((length) => length / 4);\n  return notes_beats;\n};\n\n/**\n  Given a string, return a list of integers corresponding to how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseNotes('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes = (notes_string) => {\n  const notes = notes_string.split('|');\n  const notes_lengths = notes.map((note) => note.length);\n  const notes_beats = notes_lengths.map((length) => length / 4);\n  return notes_beats;\n};\n\n/**\n  Given a string, return a list of integers corresponding to how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseNotes('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_reverse = (notes_string) => {\n  const notes = notes_string.split('|');\n  const notes_lengths = notes.map((note) => note.length);\n  const notes_beats = notes_lengths.map((length) => length / 4);\n  return notes_beats;\n};\n\n/**\n  Given a string, return a list of integers corresponding to how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseNotes_reverse('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_reverse_reverse = (notes_string) => {\n  const notes = notes_string.split('|');\n  const notes_lengths = notes.map((note) => note.length);\n  const notes_beats = notes_lengths.map((length) => length / 4);\n  return notes_beats;\n};\n\n/**\n  Given a string, return a list of integers corresponding to how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseNotes_reverse_reverse('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_reverse_reverse_notes_string = (notes_string) => {\n  const notes = notes_string.split('|');\n  const notes_lengths = notes.map((note) => note.length);\n  const notes_beats = notes_lengths.map((length) => length / 4);\n  return notes_beats;\n};\n\n/**\n  Given a string, return a list of integers corresponding to how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseNotes_reverse_reverse_notes_string('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_reverse_reverse_notes_string_notes_string = (notes_string) => {\n  const notes = notes_string.split('|');\n  const notes_lengths = notes.map((note) => note.length);\n  const notes_beats = notes_lengths.map((length) => length / 4);\n  return notes_beats;\n};\n\n/**\n  Given a string, return a list of integers corresponding to how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseNotes_reverse_reverse_notes_string_notes_string('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_reverse_reverse_notes_string_notes_string_notes_string = (notes_string) => {\n  const notes = notes_string.split('|');\n  const notes_lengths = notes.map((note) => note.length);\n  const notes_beats = notes_lengths.map((length) => length / 4);\n  return notes_beats;\n};\n\n/**\n  Given a string, return a list of integers corresponding to how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseNotes_reverse_reverse_notes_string_notes_string_notes_string_notes_string\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_reverse_reverse_notes_string_notes_string_notes_string_notes_string = (notes_string) => {\n  const notes = notes_string.split('|');\n  const notes_lengths = notes.map((note) => note.length);\n  const notes_beats = notes_lengths.map((length) => length / 4);\n  return notes_beats;\n};\n\n/**\n  Given a string, return a list of integers corresponding to how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseNotes_reverse_reverse_notes_string_notes_string_notes_string_notes_string_notes_string\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_reverse_reverse_notes_string_notes_string_notes_string_notes_string_notes_string = (notes_string) => {\n  const notes = notes_string.split('|');\n  const notes_lengths = notes.map((note) => note.length);\n  const notes_beats = notes_lengths.map((length) => length / 4);\n  return notes_", "passed": 0}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "gc": "<|endoftext|>/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let index = 0;\n  let length = string.length;\n  while (index < length) {\n    if (string.charAt(index) === substring) {\n      count++;\n      index++;\n    }\n    index++;\n  }\n  return count;\n};\n\n/**\n * Given a string, find the first occurrence of a substring within another string.\n * Returns -1 if substring is not found.\n * Returns 0 if substring is found.\n * Returns 1 if substring is within another string.\n * Returns 2 if substring is within another string and substring is not found.\n */\nconst findSubstring = (string, substring) => {\n  let index = string.indexOf(substring);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/**\n * Given a string, find the last occurrence of a substring within another string.\n * Returns -1 if substring is not found.\n * Returns 0 if substring is found.\n * Returns 1 if substring is within another string.\n * Returns 2 if substring is within another string and substring is not found.\n */\nconst findLastSubstring = (string, substring) => {\n  let index = string.lastIndexOf(substring);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/**\n * Given a string, find the first occurrence of a substring within another string.\n * Returns -1 if substring is not found.\n * Returns 0 if substring is found.\n * Returns 1 if substring is within another string.\n * Returns 2 if substring is within another string and substring is not found.\n */\nconst findFirstSubstring = (string, substring) => {\n  let index = string.indexOf(substring, 0);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/**\n * Given a string, find the last occurrence of a substring within another string.\n * Returns -1 if substring is not found.\n * Returns 0 if substring is found.\n * Returns 1 if substring is within another string.\n * Returns 2 if substring is within another string and substring is not found.\n */\nconst findLastSubstring = (string, substring) => {\n  let index = string.lastIndexOf(substring, string.length - substring.length);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/**\n * Given a string, find the first occurrence of a substring within another string.\n * Returns -1 if substring is not found.\n * Returns 0 if substring is found.\n * Returns 1 if substring is within another string.\n * Returns 2 if substring is within another string and substring is not found.\n */\nconst findFirstSubstring = (string, substring) => {\n  let index = string.indexOf(substring, 0);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/**\n * Given a string, find the last occurrence of a substring within another string.\n * Returns -1 if substring is not found.\n * Returns 0 if substring is found.\n * Returns 1 if substring is within another string.\n * Returns 2 if substring is within another string and substring is not found.\n */\nconst findLastSubstring = (string, substring) => {\n  let index = string.lastIndexOf(substring, string.length - substring.length);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/**\n * Given a string, find the first occurrence of a substring within another string.\n * Returns -1 if substring is not found.\n * Returns 0 if substring is found.\n * Returns 1 if substring is within another string.\n * Returns 2 if substring is within another string and substring is not found.\n */\nconst findFirstSubstring = (string, substring) => {\n  let index = string.indexOf(substring, 0);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/**\n * Given a string, find the last occurrence of a substring within another string.\n * Returns -1 if substring is not found.\n * Returns 0 if substring is found.\n * Returns 1 if substring is within another string.\n * Returns 2 if substring is within another string and substring is not found.\n */\nconst findLastSubstring = (string, substring) => {\n  let index = string.lastIndexOf(substring, string.length - substring.length);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/**\n * Given a string, find the first occurrence of a substring within another string.\n * Returns -1 if substring is not found.\n * Returns 0 if substring is found.\n * Returns 1 if substring is within another string.\n * Returns 2 if substring is within another string and substring is not found.\n */\nconst findFirstSubstring = (string, substring) => {\n  let index = string.indexOf(substring, 0);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/**\n * Given a string, find the last occurrence of a substring within another string.\n * Returns -1 if substring is not found.\n * Returns 0 if substring is found.\n * Returns 1 if substring is within another string.\n * Returns 2 if substring is within another string and substring is not found.\n */\nconst findLastSubstring = (string, substring) => {\n  let index = string.lastIndexOf(substring, string.length - substring.length);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/**\n * Given a string, find the first occurrence of a substring within another string.\n * Returns -1 if substring is not found.\n * Returns 0 if substring is found.\n * Returns 1 if substring is within another string.\n * Returns 2 if substring is within another string and substring is not found.\n */\nconst findFirstSubstring = (string, substring) => {\n  let index = string.indexOf(substring, 0);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/**\n * Given a string, find the last occurrence of a substring within another string.\n * Returns -1 if substring is not found.\n * Returns 0 if substring is found.\n * Returns 1 if substring is within another string.\n * Returns 2 if substring is within another string and substring is not found.\n */\nconst findLastSubstring = (string, substring) => {\n  let index = string.lastIndexOf(substring, string.length - substring.length);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/**\n * Given a string, find the first occurrence of a substring within another string.\n * Returns -1 if substring is not found.\n * Returns 0 if substring is found.\n * Returns 1 if substring is within another string.\n * Returns 2 if substring is within another string and substring is not found.\n */\nconst findFirstSubstring = (string, substring) => {\n  let index = string.indexOf(substring, 0);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/**\n * Given a string, find the last occurrence of a substring within another string.\n * Returns -1 if substring is not found.\n * Returns 0 if substring is found.\n * Returns 1 if substring is within another string.\n * Returns 2 if substring is within another string and substring is not found.\n */\nconst findLastSubstring = (string, substring) => {\n  let index = string.lastIndexOf(substring, string.length - substring.length);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/**\n * Given a string, find the first occurrence of a substring within another string.\n * Returns -1 if substring is not found.\n * Returns 0 if substring is found.\n * Returns 1 if substring is within another string.\n * Returns 2 if substring is within another string and substring is not found.\n */\nconst findFirstSubstring = (string, substring) => {\n  let index = string.indexOf(substring, 0);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/**\n * Given a string, find the last occurrence of a substring within another string.\n * Returns -1 if substring is not found.\n * Returns 0 if substring is ", "passed": 0}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "gc": "<|endoftext|>/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ');\n  sortedNumbers.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ');\n  sortedNumbers.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ');\n  sortedNumbers.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ');\n  sortedNumbers.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ');\n  sortedNumbers.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ');\n  sortedNumbers.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ');\n  sortedNumbers.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ');\n  sortedNumbers.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ');\n  sortedNumbers.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ');\n  sortedNumbers.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ');\n  sortedNumbers.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ');\n  sortedNumbers.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ');\n  sortedNumbers.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'n", "passed": 0}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "gc": "<|endoftext|>/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateInteger = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the fractional part of the number.\n  >>> truncateFraction(3.5)\n  0.5\n  */\nconst truncateFraction = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponent = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the mantissa part of the number.\n  >>> truncateMantissa(3.5)\n  3\n  */\nconst truncateMantissa = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponentMantissa = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponentFraction = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponentExponent = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponentMantissaFraction = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponentExponentMantissaFraction = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponentExponentFractionMantissaFraction = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponentExponentFractionFractionMantissaFraction = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponentExponentFractionFractionFractionMantissaFraction = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponentExponentFractionFractionFractionFractionMantissaFraction = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponentExponentFractionFractionFractionFractionFractionFractionMantissaFraction = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateExponent(3.5)\n  3\n  */\nconst truncateExponentExponentFractionFractionFractionFractionFractionFractionFractionFractionMantissaFraction = (number) => {\n  const decimal = number % 1;\n  const remainder = number - decimal;\n  return decimal + remainder;\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the ", "passed": 0}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> receiveClosestChemicalElement([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> receiveClosestChemicalElement([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst receiveClosestChemicalElement = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "receiveClosestChemicalElement", "gc": "<|endoftext|>/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> receiveClosestChemicalElement([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> receiveClosestChemicalElement([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst receiveClosestChemicalElement = (numbers) => {\n  const smallest = Math.min(...numbers);\n  const largest = Math.max(...numbers);\n  const closestToLargest = Math.abs(largest - smallest);\n  const closestToSmallest = Math.abs(smallest - largest);\n  return [smallest, largest, closestToSmallest, closestToLargest];\n};\n\n/**\n  Given a chemical element (a string), return its chemical formula (a string).\n  >>> getChemicalFormula('H2O')\n  'H'\n  >>> getChemicalFormula('H')\n  'H'\n  >>> getChemicalFormula('H2')\n  'H2O'\n  >>> getChemicalFormula('H2')\n  'H2O'\n  >>> getChemicalFormula('H2')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemicalFormula('H2O')\n  'H2O'\n  >>> getChemical", "passed": 0}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "gc": "<|endoftext|>/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const range = max - min;\n  const factor = Math.pow(10, Math.floor(Math.log(range) / Math.LN10));\n  const result = numbers.map((number) => {\n    return number * factor;\n  });\n  return result;\n};\n\n/**\n * Given a list of numbers (of at least two elements), return a new list where\n * each element is the result of scaling the corresponding element in the original\n * list by the same factor.\n * >>> scaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst scaleToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const range = max - min;\n  const factor = Math.pow(10, Math.floor(Math.log(range) / Math.LN10));\n  return numbers.map((number) => {\n    return number * factor;\n  });\n};\n\n/**\n * Given a list of numbers (of at least two elements), return a new list where\n * each element is the result of dividing the corresponding element in the original\n * list by the same factor.\n * >>> divideToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [1.0, 2.0, 0.5, 1.0, 2.0]\n */\nconst divideToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const range = max - min;\n  const factor = Math.pow(10, Math.floor(Math.log(range) / Math.LN10));\n  return numbers.map((number) => {\n    return number * factor;\n  });\n};\n\n/**\n * Given a list of numbers (of at least two elements), return a new list where\n * each element is the result of multiplying the corresponding element in the original\n * list by the same factor.\n * >>> multiplyToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst multiplyToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const range = max - min;\n  const factor = Math.pow(10, Math.floor(Math.log(range) / Math.LN10));\n  return numbers.map((number) => {\n    return number * factor;\n  });\n};\n\n/**\n * Given a list of numbers (of at least two elements), return a new list where\n * each element is the result of dividing the corresponding element in the original\n * list by the same factor.\n * >>> divideToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [1.0, 2.0, 0.5, 1.0, 2.0]\n */\nconst divideToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const range = max - min;\n  const factor = Math.pow(10, Math.floor(Math.log(range) / Math.LN10));\n  return numbers.map((number) => {\n    return number * factor;\n  });\n};\n\n/**\n * Given a list of numbers (of at least two elements), return a new list where\n * each element is the result of multiplying the corresponding element in the original\n * list by the same factor.\n * >>> multiplyToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst multiplyToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const range = max - min;\n  const factor = Math.pow(10, Math.floor(Math.log(range) / Math.LN10));\n  return numbers.map((number) => {\n    return number * factor;\n  });\n};\n\n/**\n * Given a list of numbers (of at least two elements), return a new list where\n * each element is the result of dividing the corresponding element in the original\n * list by the same factor.\n * >>> divideToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [1.0, 2.0, 0.5, 1.0, 2.0]\n */\nconst divideToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const range = max - min;\n  const factor = Math.pow(10, Math.floor(Math.log(range) / Math.LN10));\n  return numbers.map((number) => {\n    return number * factor;\n  });\n};\n\n/**\n * Given a list of numbers (of at least two elements), return a new list where\n * each element is the result of multiplying the corresponding element in the original\n * list by the same factor.\n * >>> multiplyToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst multiplyToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const range = max - min;\n  const factor = Math.pow(10, Math.floor(Math.log(range) / Math.LN10));\n  return numbers.map((number) => {\n    return number * factor;\n  });\n};\n\n/**\n * Given a list of numbers (of at least two elements), return a new list where\n * each element is the result of dividing the corresponding element in the original\n * list by the same factor.\n * >>> divideToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [1.0, 2.0, 0.5, 1.0, 2.0]\n */\nconst divideToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const range = max - min;\n  const factor = Math.pow(10, Math.floor(Math.log(range) / Math.LN10));\n  return numbers.map((number) => {\n    return number * factor;\n  });\n};\n\n/**\n * Given a list of numbers (of at least two elements), return a new list where\n * each element is the result of dividing the corresponding element in the original\n * list by the same factor.\n * >>> divideToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [1.0, 2.0, 0.5, 1.0, 2.0]\n */\nconst divideToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const range = max - min;\n  const factor = Math.pow(10, Math.floor(Math.log(range) / Math.LN10));\n  return numbers.map((number) => {\n    return number * factor;\n  });\n};\n\n/**\n * Given a list of numbers (of at least two elements), return a new list where\n * each element is the result of dividing the corresponding element in the original\n * list by the same factor.\n * >>> divideToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [1.0, 2.0, 0.5, 1.0, 2.0]\n */\nconst divideToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const range = max - min;\n  const factor = Math.pow(10, Math.floor(Math.log(range) / Math.LN10));\n  return numbers.map((number) => {\n    return number * factor;\n  });\n};\n\n/**\n * Given a list of numbers (of at least two elements), return a new list where\n * each element is the result of dividing the corresponding element in the original\n * list by the same factor.\n * >>> divideToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [1.0, 2.0, 0.5, 1.0, 2.0]\n */\nconst divideToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const range = max - min;\n  const factor = Math.pow(10, Math.floor(Math.log(range) / Math.LN10));\n  return numbers.map((number) => {\n    return number * factor;\n  });\n};\n\n/**\n * Given a list of numbers (of at least two elements), return a new list where\n * each element is the result of dividing the corresponding element in the original\n * list by the same factor.\n * >>> divideToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [1.0, 2.0, ", "passed": 0}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "gc": "<|endoftext|>/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filter given list of any python values only for floats\n  >>> filterFloats(['a', 3.14, 5])\n  [5]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFloats = (values) => {\n  return values.filter(value => typeof value === 'number' && isFinite(value));\n};\n\n/**\n * Filter given list of any python values only for strings\n  >>> filterStrings(['a', 3.14, 5])\n  [5]\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterStrings = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given list of any python values only for booleans\n  >>> filterBooleans(['a', 3.14, 5])\n  [5]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean');\n};\n\n/**\n * Filter given list of any python values only for None\n  >>> filterNone([])\n  []\n  >>> filterNone([None])\n  [None]\n  >>> filterNone([None, True])\n  [None, True]\n  >>> filterNone([None, False, None])\n  [None, False, None]\n  >>> filterNone([None, False, True, None])\n  [None, False, True, None]\n  */\nconst filterNone = values => {\n  return values.filter(value => value === null);\n};\n\n/**\n * Filter given list of any python values only for empty lists\n  >>> filterEmptyLists([])\n  []\n  >>> filterEmptyLists([None])\n  [None]\n  >>> filterEmptyLists([None, True])\n  [None, True]\n  >>> filterEmptyLists([None, False, None])\n  [None, False, None]\n  >>> filterEmptyLists([None, False, True, None])\n  [None, False, True, None]\n  */\nconst filterEmptyLists = values => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty dictionaries\n  >>> filterEmptyDicts({})\n  {}\n  >>> filterEmptyDicts([None])\n  [None]\n  >>> filterEmptyDicts([None, True])\n  [None, True]\n  >>> filterEmptyDicts([None, False, None])\n  [None, False, None]\n  >>> filterEmptyDicts([None, False, True, None])\n  [None, False, True, None]\n  */\nconst filterEmptyDicts = values => {\n  return values.filter(value => value === {});\n};\n\n/**\n * Filter given list of any python values only for empty strings\n  >>> filterEmptyStrings([])\n  []\n  >>> filterEmptyStrings([None])\n  [None]\n  >>> filterEmptyStrings([None, True])\n  [None, True]\n  >>> filterEmptyStrings([None, False, None])\n  [None, False, None]\n  >>> filterEmptyStrings([None, False, True, None])\n  [None, False, True, None]\n  */\nconst filterEmptyStrings = values => {\n  return values.filter(value => value === '');\n};\n\n/**\n * Filter given list of any python values only for empty arrays\n  >>> filterEmptyArrays([])\n  []\n  >>> filterEmptyArrays([None])\n  [None]\n  >>> filterEmptyArrays([None, True])\n  [None, True]\n  >>> filterEmptyArrays([None, False, None])\n  [None, False, None]\n  >>> filterEmptyArrays([None, False, True, None])\n  [None, False, True, None]\n  */\nconst filterEmptyArrays = values => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty objects\n  >>> filterEmptyObjects({})\n  {}\n  >>> filterEmptyObjects([None])\n  [None]\n  >>> filterEmptyObjects([None, True])\n  [None, True]\n  >>> filterEmptyObjects([None, False, None])\n  [None, False, None]\n  >>> filterEmptyObjects([None, False, True, None])\n  [None, False, True, None]\n  */\nconst filterEmptyObjects = values => {\n  return values.filter(value => value === {});\n};\n\n/**\n * Filter given list of any python values only for empty functions\n  >>> filterEmptyFunctions({})\n  {}\n  >>> filterEmptyFunctions([None])\n  [None]\n  >>> filterEmptyFunctions([None, True])\n  [None, True]\n  >>> filterEmptyFunctions([None, False, None])\n  [None, False, None]\n  >>> filterEmptyFunctions([None, False, True, None])\n  [None, False, True, None]\n  */\nconst filterEmptyFunctions = values => {\n  return values.filter(value => value === Function);\n};\n\n/**\n * Filter given list of any python values only for empty generators\n  >>> filterEmptyGenerators({})\n  {}\n  >>> filterEmptyGenerators([None])\n  [None]\n  >>> filterEmptyGenerators([None, True])\n  [None, True]\n  >>> filterEmptyGenerators([None, False, None])\n  [None, False, None]\n  >>> filterEmptyGenerators([None, False, True, None])\n  [None, False, True, None]\n  */\nconst filterEmptyGenerators = values => {\n  return values.filter(value => value === Generator);\n};\n\n/**\n * Filter given list of any python values only for empty iterables\n  >>> filterEmptyIterables({})\n  {}\n  >>> filterEmptyIterables([None])\n  [None]\n  >>> filterEmptyIterables([None, True])\n  [None, True]\n  >>> filterEmptyIterables([None, False, None])\n  [None, False, None]\n  >>> filterEmptyIterables([None, False, True, None])\n  [None, False, True, None]\n  */\nconst filterEmptyIterables = values => {\n  return values.filter(value => value === Iterable);\n};\n\n/**\n * Filter given list of any python values only for empty lists\n  >>> filterEmptyLists([])\n  []\n  >>> filterEmptyLists([None])\n  [None]\n  >>> filterEmptyLists([None, True])\n  [None, True]\n  >>> filterEmptyLists([None, False, None])\n  [None, False, None]\n  >>> filterEmptyLists([None, False, True, None])\n  [None, False, True, None]\n  */\nconst filterEmptyLists = values => {\n  return values.filter(value => value === []);\n};\n\n/**\n * Filter given list of any python values only for empty dictionaries\n  >>> filterEmptyDicts({})\n  {}\n  >>> filterEmptyDicts([None])\n  [None]\n  >>> filterEmptyDicts([None, True])\n  [None, True]\n  >>> filterEmptyDicts([None, False, None])\n  [None, False, None]\n  >>> filterEmptyDicts([None, False, True, None])\n  [None, False, True, None]\n  */\nconst filterEmptyDicts = values => {\n  return values.filter(value => value === {});\n};\n\n/**\n * Filter given list of any python values only for empty strings\n  >>> filterEmptyStrings([])\n  []\n  >>> filterEmptyStrings([None])\n  [None]\n  >>> filterEmptyStrings([None, True])\n  [None, True]\n  >>> filterEmptyStrings([None, False, None])\n  [None, False, None]\n  >>> filterEmptyStrings([None, False, True, None])\n  [None, False, True, None]\n  */\nconst filterEmptyStrings = values => {\n  return values.filter(value => value === '');\n};\n\n/**\n * Filter given list of any python values ", "passed": 0}
{"task_id": "JavaScript/23", "prompt": "/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "gc": "<|endoftext|>/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'b')\n  false\n  */\nconst startsWith = (string, prefix) => {\n  return string.indexOf(prefix) === 0\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWith('abc', 'a')\n  true\n  >>> endsWith('abc', 'b')\n  false\n  */\nconst endsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'a')\n  true\n  >>> contains('abc', 'b')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'b')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'a')\n  true\n  >>> endsWith('abc', 'b')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'a')\n  true\n  >>> contains('abc', 'b')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'b')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'a')\n  true\n  >>> endsWith('abc', 'b')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'a')\n  true\n  >>> contains('abc', 'b')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'b')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'a')\n  true\n  >>> endsWith('abc', 'b')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'a')\n  true\n  >>> contains('abc', 'b')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'b')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'a')\n  true\n  >>> endsWith('abc', 'b')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'a')\n  true\n  >>> contains('abc', 'b')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'b')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'a')\n  true\n  >>> endsWith('abc', 'b')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'a')\n  true\n  >>> contains('abc', 'b')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'b')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'a')\n  true\n  >>> endsWith('abc', 'b')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'a')\n  true\n  >>> contains('abc', 'b')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'b')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'a')\n  true\n  >>> endsWith('abc', 'b')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'a')\n  true\n  >>> contains('abc', 'b')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'b')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'a')\n  true\n  >>> endsWith('abc', 'b')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'a')\n  true\n  >>> contains('abc', 'b')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n", "passed": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> bigDivisor(15)\n  5\n  */\nconst bigDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "bigDivisor", "gc": "<|endoftext|>/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> bigDivisor(15)\n  5\n  */\nconst bigDivisor = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, larger than n\n * >>> bigDivisor(20)\n * 10\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return Math.floor(n / divisor);\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigModulo(15)\n * 5\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, larger than n\n * >>> bigModulo(20)\n * 10\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return Math.floor(n / divisor);\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigModulo(15)\n * 5\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, larger than n\n * >>> bigModulo(20)\n * 10\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigModulo(15)\n * 5\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, larger than n\n * >>> bigModulo(20)\n * 10\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigModulo(15)\n * 5\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, larger than n\n * >>> bigModulo(20)\n * 10\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigModulo(15)\n * 5\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, larger than n\n * >>> bigModulo(20)\n * 10\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigModulo(15)\n * 5\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, larger than n\n * >>> bigModulo(20)\n * 10\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigModulo(15)\n * 5\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, larger than n\n * >>> bigModulo(20)\n * 10\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigModulo(15)\n * 5\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, larger than n\n * >>> bigModulo(20)\n * 10\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigModulo(15)\n * 5\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, larger than n\n * >>> bigModulo(20)\n * 10\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigModulo(15)\n * 5\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, larger than n\n * >>> bigModulo(20)\n * 10\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, find the largest number that divides n evenly, smaller than n\n * >>> bigModulo(15)\n * 5\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return n % divisor", "passed": 0}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "gc": "<|endoftext|>/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize2 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize3 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize4 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize5 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize6 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize7 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize8 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize9 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize10 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize11 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, ", "passed": 0}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> getRidOfDuplicate([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst getRidOfDuplicate = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "getRidOfDuplicate", "gc": "<|endoftext|>/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> getRidOfDuplicate([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst getRidOfDuplicate = (numbers) => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate2 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate3 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate4 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate5 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate6 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate7 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate8 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate9 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate10 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate11 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate12 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate13 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate14 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate15 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate16 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate17 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate18 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate19 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate20 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate21 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate22 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRidOfDuplicate23 = numberList => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numberList.length; i++) {\n    const number = numberList[i];", "passed": 0}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> impudentCase('Hello')\n  'hELLO'\n  */\nconst impudentCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "impudentCase", "gc": "<|endoftext|>/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> impudentCase('Hello')\n  'hELLO'\n  */\nconst impudentCase = (string) => {\n  return string.toLowerCase().replace(/([a-z])([A-Z])/g, '$1 $2').toUpperCase();\n};\n\n/**\n * Converts a string to uppercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase characters to uppercase ", "passed": 0}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "gc": "<|endoftext|>/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, curr) => acc + curr, \"\");\n};\n\n/* Convert string to number\n  >>> convert(\"123\")\n  123\n  >>> convert(\"123.45\")\n  123.45\n  >>> convert(\"123.45.67\")\n  123.4567\n  >>> convert(\"123.4567.89\")\n  123.456789\n  >>> convert(\"123.4567.89.123\")\n  123.456789123\n  >>> convert(\"123.4567.89.123.45\")\n  123.456789123.45\n  >>> convert(\"123.4567.89.123.45.67\")\n  123.456789123.4567\n  >>> convert(\"123.4567.89.123.4567.89\")\n  123.456789123.456789\n  >>> convert(\"123.4567.89.123.4567.89.123\")\n  123.456789123.456789123\n  >>> convert(\"123.4567.89.123.4567.89.123.45\")\n  123.456789123.456789123.45\n  >>> convert(\"123.4567.89.123.4567.89.123.45.67\")\n  123.456789123.456789123.4567\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89\")\n  123.456789123.456789123.456789\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123\")\n  123.456789123.456789123.456789123\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.45\")\n  123.456789123.456789123.456789123.45\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.45.67\")\n  123.456789123.456789123.456789123.4567\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89\")\n  123.456789123.456789123.456789123.456789\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123\")\n  123.456789123.456789123.456789123.456789123\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.45\")\n  123.456789123.456789123.456789123.456789123.45\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.45.67\")\n  123.456789123.456789123.456789123.456789123.4567\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89\")\n  123.456789123.456789123.456789123.456789123.456789\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123\")\n  123.456789123.456789123.456789123.456789123.456789123\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.45\")\n  123.456789123.456789123.456789123.456789123.456789123.45\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.45.67\")\n  123.456789123.456789123.456789123.456789123.456789123.4567\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89\")\n  123.456789123.456789123.456789123.456789123.456789123.456789\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123\")\n  123.456789123.456789123.456789123.456789123.456789123.456789123\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.45\")\n  123.456789123.456789123.456789123.456789123.456789123.456789123.45\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.45.67\")\n  123.456789123.456789123.456789123.456789123.456789123.456789123.4567\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.45\")\n  123.456789123.456789123.456789123.456789123.456789123.456789123.45\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.45.67\")\n  123.456789123.456789123.456789123.456789123.456789123.456789123.4567\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89\")\n  123.456789123.456789123.456789123.456789123.456789123.456789123.456789\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123\")\n  123.456789123.456789123.456789123.456789123.456789123.456789123.456789123\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.45\")\n  123.456789123.456789123.456789123.456789123.456789123.456789123.456789123.456789123.45\n  >>> convert(\"123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.4567.89.123.45.67\")\n  123.456789123.456789123.456789123.456789", "passed": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for the ones that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only for the ones that do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByPrefix = filterBy", "passed": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "gc": "<|endoftext|>/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls above zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> aboveZero([1, 2, 3])\n  false\n  >>> aboveZero([1, 2, -4, 5])\n  true\n  */\nconst aboveZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance -= operations[i];\n  }\n  return balance >= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([-4, -4, -4, -5])\n  true\n  >>> belowZero([-4, -4, -4, -5])\n  false\n  */\nconst belowZeroOrEqualToZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls above zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> aboveZeroOrEqualToZero([-4, -4, -4, -5])\n  true\n  >>> aboveZeroOrEqualToZero([-4, -4, -4, -5])\n  false\n  */\nconst aboveZeroOrEqualToZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance -= operations[i];\n  }\n  return balance >= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeroOrEqualToZero([-4, -4, -4, -5])\n  true\n  >>> belowZeroOrEqualToZero([-4, -4, -4, -5])\n  false\n  */\nconst belowZeroOrEqualToZeroOrEqualToZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls above zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> aboveZeroOrEqualToZeroOrEqualToZero([-4, -4, -4, -5])\n  true\n  >>> aboveZeroOrEqualToZeroOrEqualToZeroOrEqualToZero([-4, -4, -4, -5])\n  false\n  */\nconst aboveZeroOrEqualToZeroOrEqualToZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance -= operations[i];\n  }\n  return balance >= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeroOrEqualToZeroOrEqualToZero([-4, -4, -4, -5])\n  true\n  >>> belowZeroOrEqualToZeroOrEqualToZeroOrEqualToZero([-4, -4, -4, -5])\n  false\n  */\nconst belowZeroOrEqualToZeroOrEqualToZeroOrEqualToZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls above zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> aboveZeroOrEqualToZeroOrEqualToZeroOrEqualToZero([-4, -4, -4, -5])\n  true\n  >>> aboveZeroOrEqualToZeroOrEqualToZeroOrEqualToZeroOrEqualToZero([-4, -4, -4, -5])\n  false\n  */\nconst aboveZeroOrEqualToZeroOrEqualToZeroOrEqualToZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance -= operations[i];\n  }\n  return balance >= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeroOrEqualToZeroOrEqualToZeroOrEqualToZero([-4, -4, -4, -5])\n  true\n  >>> belowZeroOrEqualToZeroOrEqualToZeroOrEqualToZeroOrEqualToZero([-4, -4, -4, -5])\n  false\n  */\nconst belowZeroOrEqualToZeroOrEqualToZeroOrEqualToZeroOrEqualToZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance <= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls above zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> aboveZeroOrEqualToZeroOrEqualToZeroOrEqualToZeroOrEqualToZero([-4, -4, -4, -5])\n  true\n  >>> aboveZeroOrEqualToZeroOrEqualToZeroOrEqualToZeroOrEqualToZero([-4, -4, -4, -5])\n  false\n  */\nconst aboveZeroOrEqualToZeroOrEqualToZeroOrEqualToZeroOrEqualToZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance -= operations[i];\n  }\n  return balance >= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeroOrEqualToZeroOrEqualToZeroOrEqualToZeroOrEqualTo", "passed": 0}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> catchPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> catchPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst catchPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "catchPositive", "gc": "<|endoftext|>/*Return only positive numbers in the list.\n  >>> catchPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> catchPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst catchPositive = (l) => {\n  return l.filter((v) => v > 0)\n}\n\n/*Return only negative numbers in the list.\n  >>> catchNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchNegative = (l) => {\n  return l.filter((v) => v < 0)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchDivisible = (l) => {\n  return l.filter((v) => v % 3 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 5.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchDivisible5 = (l) => {\n  return l.filter((v) => v % 5 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 7.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchDivisible7 = (l) => {\n  return l.filter((v) => v % 7 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 9.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchDivisible9 = (l) => {\n  return l.filter((v) => v % 9 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 11.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchDivisible11 = (l) => {\n  return l.filter((v) => v % 11 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 13.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchDivisible13 = (l) => {\n  return l.filter((v) => v % 13 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 15.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchDivisible15 = (l) => {\n  return l.filter((v) => v % 15 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 17.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchDivisible17 = (l) => {\n  return l.filter((v) => v % 17 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 19.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchDivisible19 = (l) => {\n  return l.filter((v) => v % 19 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 23.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchDivisible23 = (l) => {\n  return l.filter((v) => v % 23 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 29.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchDivisible29 = (l) => {\n  return l.filter((v) => v % 29 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 31.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchDivisible31 = (l) => {\n  return l.filter((v) => v % 31 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 35.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchDivisible35 = (l) => {\n  return l.filter((v) => v % 35 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 37.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchDivisible37 = (l) => {\n  return l.filter((v) => v % 37 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 40.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchDivisible40 = (l) => {\n  return l.filter((v) => v % 40 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 45.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst catchDivisible45 = (l) => {\n  return l.filter((v) => v % 45 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 50.\n  >>> catchDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> catchDivisible([5, 3, -5, 2, -", "passed": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number is prime, and false otherwise.\n  >>> isPremier(6)\n  false\n  >>> isPremier(101)\n  true\n  >>> isPremier(11)\n  true\n  >>> isPremier(13441)\n  true\n  >>> isPremier(61)\n  true\n  >>> isPremier(4)\n  false\n  >>> isPremier(1)\n  false\n  */\nconst isPremier = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPremier", "gc": "<|endoftext|>/*Return true if a given number is prime, and false otherwise.\n  >>> isPremier(6)\n  false\n  >>> isPremier(101)\n  true\n  >>> isPremier(11)\n  true\n  >>> isPremier(13441)\n  true\n  >>> isPremier(61)\n  true\n  >>> isPremier(4)\n  false\n  >>> isPremier(1)\n  false\n  */\nconst isPremier = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  true\n  >>> isPrime(101)\n  false\n  >>> isPrime(11)\n  false\n  >>> isPrime(13441)\n  false\n  >>> isPrime(61)\n  false\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  true\n  >>> isPrime(101)\n  false\n  >>> isPrime(11)\n  false\n  >>> isPrime(13441)\n  false\n  >>> isPrime(61)\n  false\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrimeOrZero = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  return true;\n};\n\n/*\n  >>> isPrimeOrZero(6)\n  true\n  >>> isPrimeOrZero(101)\n  false\n  >>> isPrimeOrZero(11)\n  false\n  >>> isPrimeOrZero(13441)\n  false\n  >>> isPrimeOrZero(61)\n  false\n  >>> isPrimeOrZero(4)\n  false\n  >>> isPrimeOrZero(1)\n  false\n  */\nconst isPrimeOrZero = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  return true;\n};\n\n/*\n  >>> isPrimeOrZero(6)\n  true\n  >>> isPrimeOrZero(101)\n  false\n  >>> isPrimeOrZero(11)\n  false\n  >>> isPrimeOrZero(13441)\n  false\n  >>> isPrimeOrZero(61)\n  false\n  >>> isPrimeOrZero(4)\n  false\n  >>> isPrimeOrZero(1)\n  false\n  */\nconst isPrimeOrOne = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  return true;\n};\n\n/*\n  >>> isPrimeOrOne(6)\n  true\n  >>> isPrimeOrOne(101)\n  false\n  >>> isPrimeOrOne(11)\n  false\n  >>> isPrimeOrOne(13441)\n  false\n  >>> isPrimeOrOne(61)\n  false\n  >>> isPrimeOrOne(4)\n  false\n  >>> isPrimeOrOne(1)\n  false\n  */\nconst isPrimeOrOne = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  return true;\n};\n\n/*\n  >>> isPrimeOrOne(6)\n  true\n  >>> isPrimeOrOne(101)\n  false\n  >>> isPrimeOrOne(11)\n  false\n  >>> isPrimeOrOne(13441)\n  false\n  >>> isPrimeOrOne(61)\n  false\n  >>> isPrimeOrOne(4)\n  false\n  >>> isPrimeOrOne(1)\n  false\n  */\nconst isPrimeOrTwo = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  return true;\n};\n\n/*\n  >>> isPrimeOrTwo(6)\n  true\n  >>> isPrimeOrTwo(101)\n  false\n  >>> isPrimeOrTwo(11)\n  false\n  >>> isPrimeOrTwo(13441)\n  false\n  >>> isPrimeOrTwo(61)\n  false\n  >>> isPrimeOrTwo(4)\n  false\n  >>> isPrimeOrTwo(1)\n  false\n  */\nconst isPrimeOrTwo = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  return true;\n};\n\n/*\n  >>> isPrimeOrTwo(6)\n  true\n  >>> isPrimeOrTwo(101)\n  false\n  >>> isPrimeOrTwo(11)\n  false\n  >>> isPrimeOrTwo(13441)\n  false\n  >>> isPrimeOrTwo(61)\n  false\n  >>> isPrimeOrTwo(4)\n  false\n  >>> isPrimeOrTwo(1)\n  false\n  */\nconst isPrimeOrThree = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return true;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  return true;\n};\n\n/*\n  >>> isPrimeOrThree(6)\n  true\n  >>> isPrimeOrThree(101)\n  false\n  >>> isPrimeOrThree(11)\n  false\n  >>> isPrimeOrThree(13441)\n  false\n  >>> isPrimeOrThree(61)\n  false\n  >>> isPrimeOrThree(4)\n  false\n  >>> isPrimeOrThree(1)\n  false\n  */\nconst isPrimeOrThree = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  return true;\n};\n\n/*\n  >>> isPrimeOrThree(6)\n  true\n  >>> isPrimeOrThree(101)\n  false\n  >>> isPrimeOrThree(11)\n  false\n  >>> isPrimeOrThree(13441)\n  false\n  >>> isPrimeOrThree(61)\n  false\n", "passed": 0}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let x = 0;\n  let xZero = 0;\n  let xZeroIndex = 0;\n  let xZeroLength = 0;\n  let xZeroLengthIndex = 0;\n  let xZeroLengthLength = 0;\n  let xZeroLengthLengthIndex = 0;\n  let xZeroLengthLengthLength = 0;\n  let xZeroLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLengthLengthIndex = 0;\n  let xZeroLengthLengthLength", "passed": 1}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = l.slice();\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l2;\n  while (i < l.length) {\n    if (l[i] % 3 === 0) {\n      l2.splice(j, 1);\n      j++;\n    }\n    if (l[i] % 3 === 1) {\n      l2.splice(k, 1);\n      k++;\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  Given a list l, return a new list l' such that l' is a permutation of l.\n  >>> permute([1, 2, 3])\n  [3, 2, 1]\n  >>> permute([5, 6, 3, 4, 8, 9, 2])\n  [4, 2, 6, 5, 3, 8, 9, 1]\n  */\nconst permute = (l) => {\n  const l2 = l.slice();\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l2;\n  while (i < l.length) {\n    if (l[i] % 3 === 0) {\n      l2.splice(j, 1);\n      j++;\n    }\n    if (l[i] % 3 === 1) {\n      l2.splice(k, 1);\n      k++;\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  Given a list l, return a new list l' such that l' is a permutation of l with repetitions removed.\n  >>> removeRepeat([1, 2, 3])\n  [3, 2, 1]\n  >>> removeRepeat([5, 6, 3, 4, 8, 9, 2])\n  [4, 2, 6, 5, 3, 8, 9, 1]\n  */\nconst removeRepeat = (l) => {\n  const l2 = l.slice();\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l2;\n  while (i < l.length) {\n    if (l[i] % 3 === 0) {\n      l2.splice(j, 1);\n      j++;\n    }\n    if (l[i] % 3 === 1) {\n      l2.splice(k, 1);\n      k++;\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  Given a list l, return a new list l' such that l' is a permutation of l with repetitions removed.\n  >>> removeRepeat([1, 2, 3])\n  [3, 2, 1]\n  >>> removeRepeat([5, 6, 3, 4, 8, 9, 2])\n  [4, 2, 6, 5, 3, 8, 9, 1]\n  */\nconst removeRepeat2 = (l) => {\n  const l2 = l.slice();\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l2;\n  while (i < l.length) {\n    if (l[i] % 3 === 0) {\n      l2.splice(j, 1);\n      j++;\n    }\n    if (l[i] % 3 === 1) {\n      l2.splice(k, 1);\n      k++;\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  Given a list l, return a new list l' such that l' is a permutation of l with repetitions removed.\n  >>> removeRepeat([1, 2, 3])\n  [3, 2, 1]\n  >>> removeRepeat([5, 6, 3, 4, 8, 9, 2])\n  [4, 2, 6, 5, 3, 8, 9, 1]\n  */\nconst removeRepeat3 = (l) => {\n  const l2 = l.slice();\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l2;\n  while (i < l.length) {\n    if (l[i] % 3 === 0) {\n      l2.splice(j, 1);\n      j++;\n    }\n    if (l[i] % 3 === 1) {\n      l2.splice(k, 1);\n      k++;\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  Given a list l, return a new list l' such that l' is a permutation of l with repetitions removed.\n  >>> removeRepeat([1, 2, 3])\n  [3, 2, 1]\n  >>> removeRepeat([5, 6, 3, 4, 8, 9, 2])\n  [4, 2, 6, 5, 3, 8, 9, 1]\n  */\nconst removeRepeat4 = (l) => {\n  const l2 = l.slice();\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l2;\n  while (i < l.length) {\n    if (l[i] % 3 === 0) {\n      l2.splice(j, 1);\n      j++;\n    }\n    if (l[i] % 3 === 1) {\n      l2.splice(k, 1);\n      k++;\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  Given a list l, return a new list l' such that l' is a permutation of l with repetitions removed.\n  >>> removeRepeat([1, 2, 3])\n  [3, 2, 1]\n  >>> removeRepeat([5, 6, 3, 4, 8, 9, 2])\n  [4, 2, 6, 5, 3, 8, 9, 1]\n  */\nconst removeRepeat5 = (l) => {\n  const l2 = l.slice();\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l2;\n  while (i < l.length) {\n    if (l[i] % 3 === 0) {\n      l2.splice(j, 1);\n      j++;\n    }\n    if (l[i] % 3 === 1) {\n      l2.splice(k, 1);\n      k++;\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  Given a list l, return a new list l' such that l' is a permutation of l with repetitions removed.\n  >>> removeRepeat([1, 2, 3])\n  [3, 2, 1]\n  >>> removeRepeat([5, 6, 3, 4, 8, 9, 2])\n  [4, 2, 6, 5, 3, 8, 9, 1]\n  */\nconst removeRepeat6 = (l) => {\n  const l2 = l.slice();\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l2;\n  while (i < l.length) {\n    if (l[i] % 3 === 0) {\n      l2.splice(j, 1);\n      j++;\n    }\n    if (l[i] % 3 === 1) {\n      l2.splice(k, 1);\n      k++;\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  Given a list l, return a new list l' such that l' is a permutation of l with repetitions removed.\n  >>> removeRepeat([1, 2, 3])\n  [3, 2, 1]\n  >>> removeRepeat([5, 6, 3, 4, 8, 9, 2])\n  [4, 2, 6, 5, 3, 8, 9, 1]\n  */\nconst removeRepeat7 = (l) => {\n  const l2 = l.slice();\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l2;\n  while (i < l.length) {\n    if (l[i] % 3 === 0) {\n      l2.splice(j, 1);\n      j++;\n    }\n    if (l[i] % 3 === 1) {\n      l2.splice(k, 1);\n      k++;\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  Given a list l, return a new list l' such that l' is a permutation of l with repetitions removed.\n  >>> removeRepeat([1, 2, 3])\n  [3, 2, 1]\n  >>> removeRepeat([5, 6, 3, 4, 8, 9, 2])\n  [4, 2, 6, 5, 3, 8, 9, 1]\n  */\nconst removeRepeat8 = (l) => {\n  const l2 = l.slice();\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l2;\n  while (i < l.length) {\n    if (l[i] % 3 === 0) {\n      l2.splice(j, 1);\n      j++;\n    }\n    if (l[i] % 3 === 1) {\n      l2.splice(k, 1);\n      k++;\n    }\n    i++;\n  }\n  return l2;\n};\n\n/*\n  Given a list l, return a new list l' such that l' is a permutation of l with repetitions removed.\n  >>> removeRepeat([1, 2, 3])\n  [3, 2, 1]\n  >>> removeRepeat([5, 6, 3, 4, 8, 9, ", "passed": 0}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted alone elements in a list\n  >>> alone([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst alone = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "alone", "gc": "<|endoftext|>/*Return sorted alone elements in a list\n  >>> alone([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst alone = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> alone([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSorted = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> aloneSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversed = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSorted = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedReversed = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedReversed = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedSortedReversed = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedSortedSortedReversed = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedSortedSortedSortedReversed = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedSortedSortedSortedReversed = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === l[i - 1]) continue\n    res.push(l[i])\n  }\n  return res\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  let res = []\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === ", "passed": 0}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum element in the list.\n  >>> soapElement([1, 2, 3])\n  3\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst soapElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "soapElement", "gc": "<|endoftext|>/*Return maximum element in the list.\n  >>> soapElement([1, 2, 3])\n  3\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst soapElement = (l) => {\n  return l.length > 0? l[0] : null;\n};\n\n/*Return minimum element in the list.\n  >>> soapElement([1, 2, 3])\n  1\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst soapElementMin = (l) => {\n  return l.length > 0? l[0] : null;\n};\n\n/*Return maximum element in the list.\n  >>> soapElement([1, 2, 3])\n  3\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst soapElementMax = (l) => {\n  return l.length > 0? l[l.length - 1] : null;\n};\n\n/*Return minimum element in the list.\n  >>> soapElement([1, 2, 3])\n  1\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst soapElementMinMax = (l) => {\n  return l.length > 0? [soapElementMin(l), soapElementMax(l)] : null;\n};\n\n/*Return maximum element in the list.\n  >>> soapElement([1, 2, 3])\n  3\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst soapElementMaxMin = (l) => {\n  return l.length > 0? [soapElementMax(l), soapElementMin(l)] : null;\n};\n\n/*Return minimum element in the list.\n  >>> soapElement([1, 2, 3])\n  1\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst soapElementMinMaxMin = (l) => {\n  return l.length > 0? [soapElementMinMax(l), soapElementMinMaxMin(l)] : null;\n};\n\n/*Return maximum element in the list.\n  >>> soapElement([1, 2, 3])\n  3\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst soapElementMaxMinMax = (l) => {\n  return l.length > 0? [soapElementMaxMin(l), soapElementMinMaxMax(l)] : null;\n};\n\n/*Return minimum element in the list.\n  >>> soapElement([1, 2, 3])\n  1\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst soapElementMaxMinMaxMin = (l) => {\n  return l.length > 0? [soapElementMaxMinMax(l), soapElementMinMaxMin(l)] : null;\n};\n\n/*Return maximum element in the list.\n  >>> soapElement([1, 2, 3])\n  3\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst soapElementMaxMinMaxMax = (l) => {\n  return l.length > 0? [soapElementMaxMinMax(l), soapElementMaxMinMaxMax(l)] : null;\n};\n\n/*Return minimum element in the list.\n  >>> soapElement([1, 2, 3])\n  1\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst soapElementMaxMinMaxMaxMin = (l) => {\n  return l.length > 0? [soapElementMaxMinMaxMax(l), soapElementMaxMinMaxMin(l)] : null;\n};\n\n/*Return maximum element in the list.\n  >>> soapElement([1, 2, 3])\n  3\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst soapElementMaxMinMaxMaxMinMax = (l) => {\n  return l.length > 0? [soapElementMaxMinMaxMax(l), soapElementMaxMinMaxMinMax(l)] : null;\n};\n\n/*Return minimum element in the list.\n  >>> soapElement([1, 2, 3])\n  1\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst soapElementMaxMinMaxMaxMinMaxMin = (l) => {\n  return l.length > 0? [soapElementMaxMinMaxMaxMin(l), soapElementMaxMinMaxMinMaxMin(l)] : null;\n};\n\n/*Return maximum element in the list.\n  >>> soapElement([1, 2, 3])\n  3\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst soapElementMaxMinMaxMinMaxMinMax = (l) => {\n  return l.length > 0? [soapElementMaxMinMaxMinMax(l), soapElementMaxMinMaxMinMaxMin(l)] : null;\n};\n\n/*Return minimum element in the list.\n  >>> soapElement([1, 2, 3])\n  1\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst soapElementMaxMinMaxMinMaxMinMaxMin = (l) => {\n  return l.length > 0? [soapElementMaxMinMaxMinMaxMin(l), soapElementMaxMinMaxMinMaxMinMax(l)] : null;\n};\n\n/*Return maximum element in the list.\n  >>> soapElement([1, 2, 3])\n  3\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst soapElementMaxMinMaxMinMaxMinMaxMinMax = (l) => {\n  return l.length > 0? [soapElementMaxMinMaxMinMaxMin(l), soapElementMaxMinMaxMinMaxMinMaxMin(l)] : null;\n};\n\n/*Return minimum element in the list.\n  >>> soapElement([1, 2, 3])\n  1\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst soapElementMaxMinMaxMinMaxMinMaxMinMaxMin = (l) => {\n  return l.length > 0? [soapElementMaxMinMaxMinMaxMinMaxMin(l), soapElementMaxMinMaxMinMaxMinMaxMin(l)] : null;\n};\n\n/*Return maximum element in the list.\n  >>> soapElement([1, 2, 3])\n  3\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst soapElementMaxMinMaxMinMaxMinMaxMinMaxMinMax = (l) => {\n  return l.length > 0? [soapElementMaxMinMaxMinMaxMinMaxMinMaxMin(l), soapElementMaxMinMaxMinMaxMinMaxMinMax(l)] : null;\n};\n\n/*Return minimum element in the list.\n  >>> soapElement([1, 2, 3])\n  1\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst soapElementMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = (l) => {\n  return l.length > 0? [soapElementMaxMinMaxMinMaxMinMaxMinMaxMin(l), soapElementMaxMinMaxMinMaxMinMaxMinMaxMin(l)] : null;\n};\n\n/*Return maximum element in the list.\n  >>> soapElement([1, 2, 3])\n  3\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst soapElementMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = (l) => {\n  return l.length > 0? [soapElementMaxMinMaxMinMaxMinMaxMinMaxMin(l), soapElementMaxMinMaxMinMaxMinMaxMinMaxMin(l)] : null;\n};\n\n/*Return minimum element in the list.\n  >>> soapElement([1, 2, 3])\n  1\n  >>> soapElement([", "passed": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "gc": "<|endoftext|>/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = 0;\n  while (n > 0) {\n    digit = n % 10;\n    if (digit === 7) {\n      count++;\n    }\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits (starting from right to left) is equal to n.\n  >>> isPowerOfTen(100)\n  true\n  >>> isPowerOfTen(1000)\n  false\n  >>> isPowerOfTen(10000)\n  false\n  >>> isPowerOfTen(100000)\n  true\n  */\nconst isPowerOfTen = (n) => {\n  let sum = 0;\n  let digit = 0;\n  while (n > 0) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum === n;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits (starting from right to left) is equal to n.\n  >>> isMultipleOfThree(100)\n  true\n  >>> isMultipleOfThree(1000)\n  false\n  >>> isMultipleOfThree(10000)\n  false\n  >>> isMultipleOfThree(100000)\n  true\n  */\nconst isMultipleOfThree = (n) => {\n  let sum = 0;\n  let digit = 0;\n  while (n > 0) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum % 3 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits (starting from right to left) is equal to n.\n  >>> isMultipleOfFive(100)\n  true\n  >>> isMultipleOfFive(1000)\n  false\n  >>> isMultipleOfFive(10000)\n  false\n  >>> isMultipleOfFive(100000)\n  true\n  */\nconst isMultipleOfFive = (n) => {\n  let sum = 0;\n  let digit = 0;\n  while (n > 0) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum % 5 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits (starting from right to left) is equal to n.\n  >>> isMultipleOfTen(100)\n  true\n  >>> isMultipleOfTen(1000)\n  false\n  >>> isMultipleOfTen(10000)\n  false\n  >>> isMultipleOfTen(100000)\n  true\n  */\nconst isMultipleOfTen = (n) => {\n  let sum = 0;\n  let digit = 0;\n  while (n > 0) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits (starting from right to left) is equal to n.\n  >>> isMultipleOfFive(100)\n  true\n  >>> isMultipleOfFive(1000)\n  false\n  >>> isMultipleOfFive(10000)\n  false\n  >>> isMultipleOfFive(100000)\n  true\n  */\nconst isMultipleOfFive = (n) => {\n  let sum = 0;\n  let digit = 0;\n  while (n > 0) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum % 5 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits (starting from right to left) is equal to n.\n  >>> isMultipleOfTen(100)\n  true\n  >>> isMultipleOfTen(1000)\n  false\n  >>> isMultipleOfTen(10000)\n  false\n  >>> isMultipleOfTen(100000)\n  true\n  */\nconst isMultipleOfTen = (n) => {\n  let sum = 0;\n  let digit = 0;\n  while (n > 0) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits (starting from right to left) is equal to n.\n  >>> isMultipleOfFive(100)\n  true\n  >>> isMultipleOfFive(1000)\n  false\n  >>> isMultipleOfFive(10000)\n  false\n  >>> isMultipleOfFive(100000)\n  true\n  */\nconst isMultipleOfFive = (n) => {\n  let sum = 0;\n  let digit = 0;\n  while (n > 0) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum % 5 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits (starting from right to left) is equal to n.\n  >>> isMultipleOfTen(100)\n  true\n  >>> isMultipleOfTen(1000)\n  false\n  >>> isMultipleOfTen(10000)\n  false\n  >>> isMultipleOfTen(100000)\n  true\n  */\nconst isMultipleOfTen = (n) => {\n  let sum = 0;\n  let digit = 0;\n  while (n > 0) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits (starting from right to left) is equal to n.\n  >>> isMultipleOfFive(100)\n  true\n  >>> isMultipleOfFive(1000)\n  false\n  >>> isMultipleOfFive(10000)\n  false\n  >>> isMultipleOfFive(100000)\n  true\n  */\nconst isMultipleOfFive = (n) => {\n  let sum = 0;\n  let digit = 0;\n  while (n > 0) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum % 5 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits (starting from right to left) is equal to n.\n  >>> isMultipleOfTen(100)\n  true\n  >>> isMultipleOfTen(1000)\n  false\n  >>> isMultipleOfTen(10000)\n  false\n  >>> isMultipleOfTen(100000)\n  true\n  */\nconst isMultipleOfTen = (n) => {\n  let sum = 0;\n  let digit = 0;\n  while (n > 0) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digits (starting from right to left) is equal to n.\n  >>> isMultipleOfFive(100)\n  true\n  >>> isMultipleOfFive(1000)\n  false\n  >>> isMultipleOfFive(10000)\n  false\n  >>> isMultipleOfFive(100000)\n  true\n  */\nconst isMultipleOfFive = (n) => {\n  let sum = 0;\n  let digit = 0;\n  while (n > 0) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum % 5 === 0;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its ", "passed": 0}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const l2 = l.slice();\n  for (let i = 0; i < l2.length; i++) {\n    if (i % 2 === 0) {\n      l2[i] = l2[i + 1];\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 3, 2, 1]\n  */\nconst sortOdd = (l) => {\n  const l2 = l.slice();\n  for (let i = 0; i < l2.length; i++) {\n    if (i % 2!== 0) {\n      l2[i] = l2[i + 1];\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEvenOdd([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [3, 4, 6, 5]\n  */\nconst sortEvenOdd = (l) => {\n  const l2 = l.slice();\n  for (let i = 0; i < l2.length; i++) {\n    if (i % 2 === 0) {\n      l2[i] = l2[i + 1];\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortOddEven([1, 2, 3])\n  [3, 2, 5, 1]\n  >>> sortOddEven([5, 6, 3, 4])\n  [4, 3, 2, 5, 1]\n  */\nconst sortOddEven = (l) => {\n  const l2 = l.slice();\n  for (let i = 0; i < l2.length; i++) {\n    if (i % 2!== 0) {\n      l2[i] = l2[i + 1];\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEvenOddEven([1, 2, 3])\n  [3, 2, 5, 1, 6]\n  >>> sortEvenOddEven([5, 6, 3, 4])\n  [4, 3, 2, 5, 1, 6]\n  */\nconst sortEvenOddEven = (l) => {\n  const l2 = l.slice();\n  for (let i = 0; i < l2.length; i++) {\n    if (i % 2!== 0) {\n      l2[i] = l2[i + 1];\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortOddEvenOdd([1, 2, 3])\n  [3, 2, 5, 1, 6, 5]\n  >>> sortOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 2, 5, 1, 6, 5]\n  */\nconst sortOddEvenOdd = (l) => {\n  const l2 = l.slice();\n  for (let i = 0; i < l2.length; i++) {\n    if (i % 2!== 0) {\n      l2[i] = l2[i + 1];\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEvenOddEvenOdd([1, 2, 3])\n  [3, 2, 5, 1, 6, 5, 4]\n  >>> sortEvenOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 2, 5, 1, 6, 5, 4]\n  */\nconst sortEvenOddEvenOdd = (l) => {\n  const l2 = l.slice();\n  for (let i = 0; i < l2.length; i++) {\n    if (i % 2!== 0) {\n      l2[i] = l2[i + 1];\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortOddEvenOddEvenOdd([1, 2, 3])\n  [3, 2, 5, 1, 6, 5, 4, 3]\n  >>> sortOddEvenOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 2, 5, 1, 6, 5, 4, 3]\n  */\nconst sortOddEvenOddEvenOdd = (l) => {\n  const l2 = l.slice();\n  for (let i = 0; i < l2.length; i++) {\n    if (i % 2!== 0) {\n      l2[i] = l2[i + 1];\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEvenOddEvenOddEvenOdd([1, 2, 3])\n  [3, 2, 5, 1, 6, 5, 4, 3, 2, 1]\n  >>> sortEvenOddEvenOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 2, 5, 1, 6, 5, 4, 3, 2, 1]\n  */\nconst sortEvenOddEvenOddEvenOdd = (l) => {\n  const l2 = l.slice();\n  for (let i = 0; i < l2.length; i++) {\n    if (i % 2!== 0) {\n      l2[i] = l2[i + 1];\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortOddEvenOddEvenOddEvenOdd([1, 2, 3])\n  [3, 2, 5, 1, 6, 5, 4, 3, 2, 1]\n  >>> sortOddEvenOddEvenOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 2, 5, 1, 6, 5, 4, 3, 2, 1]\n  */\nconst sortEvenOddEvenOddEvenOddEvenOdd = (l) => {\n  const l2 = l.slice();\n  for (let i = 0; i < l2.length; i++) {\n    if (i % 2!== 0) {\n      l2[i] = l2[i + 1];\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEvenOddEvenOddEvenOddEvenOdd([1, 2, 3])\n  [3, 2, 5, 1, 6, 5, 4, 3, 2, 1]\n  >>> sortEvenOddEvenOddEvenOddEvenOdd([5, 6, 3, 4])\n  [4, 3, 2, 5, 1, 6, 5, 4, 3, 2, 1]\n  */\nconst sortOddEvenOddEvenOddEvenOddEvenOdd = (l) => {\n  const l2 = l.slice();\n  for (let i = 0; i < l2.length; i++) {\n    if (i % 2!== 0) {\n      l2[i] = l2[i + 1];\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l ", "passed": 0}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "gc": "<|endoftext|>/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(0, 3 * i));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns true if string contains only letters, digits and underscores.\n  */\nconst isOnlyLetterOrDigit = (s) => {\n  return /^[a-zA-Z0-9_]*$/.test(s);\n}\n\n/*\n  returns true if string contains only letters, digits and underscores.\n  */\nconst isOnlyLetterOrDigitOrUnderscore = (s) => {\n  return /^[a-zA-Z0-9_]*$/.test(s) || /^_[a-zA-Z0-9_]*$/.test(s);\n}\n\n/*\n  returns true if string contains only letters, digits and underscores.\n  */\nconst isOnlyLetterOrDigitOrUnderscoreAndSpace = (s) => {\n  return /^[a-zA-Z0-9_]*$/.test(s) || /^_[a-zA-Z0-9_]*$/.test(s) || /^[_ ]*$/.test(s);\n}\n\n/*\n  returns true if string contains only letters, digits and underscores.\n  */\nconst isOnlyLetterOrDigitOrUnderscoreAndSpaceAndUnderscore = (s) => {\n  return /^[a-zA-Z0-9_]*$/.test(s) || /^_[a-zA-Z0-9_]*$/.test(s) || /^[_ ]*$/.test(s) || /^_[_ ]*$/.test(s);\n}\n\n/*\n  returns true if string contains only letters, digits and underscores.\n  */\nconst isOnlyLetterOrDigitOrUnderscoreAndSpaceAndUnderscoreAndSpace = (s) => {\n  return /^[a-zA-Z0-9_]*$/.test(s) || /^_[a-zA-Z0-9_]*$/.test(s) || /^[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s);\n}\n\n/*\n  returns true if string contains only letters, digits and underscores.\n  */\nconst isOnlyLetterOrDigitOrUnderscoreAndSpaceAndUnderscoreAndSpace = (s) => {\n  return /^[a-zA-Z0-9_]*$/.test(s) || /^_[a-zA-Z0-9_]*$/.test(s) || /^[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s);\n}\n\n/*\n  returns true if string contains only letters, digits and underscores.\n  */\nconst isOnlyLetterOrDigitOrUnderscoreAndSpaceAndUnderscoreAndSpace = (s) => {\n  return /^[a-zA-Z0-9_]*$/.test(s) || /^_[a-zA-Z0-9_]*$/.test(s) || /^[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s);\n}\n\n/*\n  returns true if string contains only letters, digits and underscores.\n  */\nconst isOnlyLetterOrDigitOrUnderscoreAndSpaceAndUnderscoreAndSpaceAndUnderscore = (s) => {\n  return /^[a-zA-Z0-9_]*$/.test(s) || /^_[a-zA-Z0-9_]*$/.test(s) || /^[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s);\n}\n\n/*\n  returns true if string contains only letters, digits and underscores.\n  */\nconst isOnlyLetterOrDigitOrUnderscoreAndSpaceAndUnderscoreAndSpaceAndUnderscore = (s) => {\n  return /^[a-zA-Z0-9_]*$/.test(s) || /^_[a-zA-Z0-9_]*$/.test(s) || /^[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s);\n}\n\n/*\n  returns true if string contains only letters, digits and underscores.\n  */\nconst isOnlyLetterOrDigitOrUnderscoreAndSpaceAndUnderscoreAndSpaceAndUnderscoreAndSpace = (s) => {\n  return /^[a-zA-Z0-9_]*$/.test(s) || /^_[a-zA-Z0-9_]*$/.test(s) || /^[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s);\n}\n\n/*\n  returns true if string contains only letters, digits and underscores.\n  */\nconst isOnlyLetterOrDigitOrUnderscoreAndSpaceAndUnderscoreAndSpaceAndUnderscoreAndSpace = (s) => {\n  return /^[a-zA-Z0-9_]*$/.test(s) || /^_[a-zA-Z0-9_]*$/.test(s) || /^[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s);\n}\n\n/*\n  returns true if string contains only letters, digits and underscores.\n  */\nconst isOnlyLetterOrDigitOrUnderscoreAndSpaceAndUnderscoreAndSpaceAndUnderscoreAndSpace = (s) => {\n  return /^[a-zA-Z0-9_]*$/.test(s) || /^_[a-zA-Z0-9_]*$/.test(s) || /^[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s);\n}\n\n/*\n  returns true if string contains only letters, digits and underscores.\n  */\nconst isOnlyLetterOrDigitOrUnderscoreAndSpaceAndUnderscoreAndSpaceAndUnderscoreAndSpaceAndSpace = (s) => {\n  return /^[a-zA-Z0-9_]*$/.test(s) || /^_[a-zA-Z0-9_]*$/.test(s) || /^[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s);\n}\n\n/*\n  returns true if string contains only letters, digits and underscores.\n  */\nconst isOnlyLetterOrDigitOrUnderscoreAndSpaceAndUnderscoreAndSpaceAndUnderscoreAndSpaceAndSpace = (s) => {\n  return /^[a-zA-Z0-9_]*$/.test(s) || /^_[a-zA-Z0-9_]*$/.test(s) || /^[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s);\n}\n\n/*\n  returns true if string contains only letters, digits and underscores.\n  */\nconst isOnlyLetterOrDigitOrUnderscoreAndSpaceAndUnderscoreAndSpaceAndSpaceAndSpaceAndSpace = (s) => {\n  return /^[a-zA-Z0-9_]*$/.test(s) || /^_[a-zA-Z0-9_]*$/.test(s) || /^[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s) || /^_[_ ]*$/.test(s);\n}\n\n/*\n  returns true if string contains only letters, digits and underscores.\n  */\nconst isOnlyLetterOrDigitOrUnderscoreAndSpaceAndUnderscoreAndSpaceAndSpaceAndSpaceAndSpace = (s) => {\n  return /^[a-zA-Z0-9_]*$/.test(s) || /^_[a-zA-Z0-9_]*$/.test(s) || /^[_ ]*$/.test(s) || /^", "passed": 0}
{"task_id": "JavaScript/39", "prompt": "/*\n  premierFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> premierFib(1)\n  2\n  >>> premierFib(2)\n  3\n  >>> premierFib(3)\n  5\n  >>> premierFib(4)\n  13\n  >>> premierFib(5)\n  89\n  */\nconst premierFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "premierFib", "gc": "<|endoftext|>/*\n  premierFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> premierFib(1)\n  2\n  >>> premierFib(2)\n  3\n  >>> premierFib(3)\n  5\n  >>> premierFib(4)\n  13\n  >>> premierFib(5)\n  89\n  */\nconst premierFib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return premierFib(n-1) + premierFib(n-2);\n};\n\n/*\n  fibonacci returns n-th number that is a Fibonacci number and it's also prime.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(2)\n  1\n  >>> fibonacci(3)\n  1\n  >>> fibonacci(4)\n  1\n  >>> fibonacci(5)\n  1\n  >>> fibonacci(6)\n  1\n  >>> fibonacci(7)\n  1\n  >>> fibonacci(8)\n  1\n  >>> fibonacci(9)\n  1\n  >>> fibonacci(10)\n  1\n  >>> fibonacci(11)\n  1\n  >>> fibonacci(12)\n  1\n  >>> fibonacci(13)\n  1\n  >>> fibonacci(14)\n  1\n  >>> fibonacci(15)\n  1\n  >>> fibonacci(16)\n  1\n  >>> fibonacci(17)\n  1\n  >>> fibonacci(18)\n  1\n  >>> fibonacci(19)\n  1\n  >>> fibonacci(20)\n  1\n  >>> fibonacci(21)\n  1\n  >>> fibonacci(22)\n  1\n  >>> fibonacci(23)\n  1\n  >>> fibonacci(24)\n  1\n  >>> fibonacci(25)\n  1\n  >>> fibonacci(26)\n  1\n  >>> fibonacci(27)\n  1\n  >>> fibonacci(28)\n  1\n  >>> fibonacci(29)\n  1\n  >>> fibonacci(30)\n  1\n  >>> fibonacci(31)\n  1\n  >>> fibonacci(32)\n  1\n  >>> fibonacci(33)\n  1\n  >>> fibonacci(34)\n  1\n  >>> fibonacci(35)\n  1\n  >>> fibonacci(36)\n  1\n  >>> fibonacci(37)\n  1\n  >>> fibonacci(38)\n  1\n  >>> fibonacci(39)\n  1\n  >>> fibonacci(40)\n  1\n  >>> fibonacci(41)\n  1\n  >>> fibonacci(42)\n  1\n  >>> fibonacci(43)\n  1\n  >>> fibonacci(44)\n  1\n  >>> fibonacci(45)\n  1\n  >>> fibonacci(46)\n  1\n  >>> fibonacci(47)\n  1\n  >>> fibonacci(48)\n  1\n  >>> fibonacci(49)\n  1\n  >>> fibonacci(50)\n  1\n  >>> fibonacci(51)\n  1\n  >>> fibonacci(52)\n  1\n  >>> fibonacci(53)\n  1\n  >>> fibonacci(54)\n  1\n  >>> fibonacci(55)\n  1\n  >>> fibonacci(56)\n  1\n  >>> fibonacci(57)\n  1\n  >>> fibonacci(58)\n  1\n  >>> fibonacci(59)\n  1\n  >>> fibonacci(60)\n  1\n  >>> fibonacci(61)\n  1\n  >>> fibonacci(62)\n  1\n  >>> fibonacci(63)\n  1\n  >>> fibonacci(64)\n  1\n  >>> fibonacci(65)\n  1\n  >>> fibonacci(66)\n  1\n  >>> fibonacci(67)\n  1\n  >>> fibonacci(68)\n  1\n  >>> fibonacci(69)\n  1\n  >>> fibonacci(70)\n  1\n  >>> fibonacci(71)\n  1\n  >>> fibonacci(72)\n  1\n  >>> fibonacci(73)\n  1\n  >>> fibonacci(74)\n  1\n  >>> fibonacci(75)\n  1\n  >>> fibonacci(76)\n  1\n  >>> fibonacci(77)\n  1\n  >>> fibonacci(78)\n  1\n  >>> fibonacci(79)\n  1\n  >>> fibonacci(80)\n  1\n  >>> fibonacci(81)\n  1\n  >>> fibonacci(82)\n  1\n  >>> fibonacci(83)\n  1\n  >>> fibonacci(84)\n  1\n  >>> fibonacci(85)\n  1\n  >>> fibonacci(86)\n  1\n  >>> fibonacci(87)\n  1\n  >>> fibonacci(88)\n  1\n  >>> fibonacci(89)\n  1\n  >>> fibonacci(90)\n  1\n  >>> fibonacci(91)\n  1\n  >>> fibonacci(92)\n  1\n  >>> fibonacci(93)\n  1\n  >>> fibonacci(94)\n  1\n  >>> fibonacci(95)\n  1\n  >>> fibonacci(96)\n  1\n  >>> fibonacci(97)\n  1\n  >>> fibonacci(98)\n  1\n  >>> fibonacci(99)\n  1\n  >>> fibonacci(100)\n  1\n  >>> fibonacci(101)\n  1\n  >>> fibonacci(102)\n  1\n  >>> fibonacci(103)\n  1\n  >>> fibonacci(104)\n  1\n  >>> fibonacci(105)\n  1\n  >>> fibonacci(106)\n  1\n  >>> fibonacci(107)\n  1\n  >>> fibonacci(108)\n  1\n  >>> fibonacci(109)\n  1\n  >>> fibonacci(110)\n  1\n  >>> fibonacci(111)\n  1\n", "passed": 0}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> entailAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "entailAbsoluteDeviation", "gc": "<|endoftext|>/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> entailAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map(val => Math.abs(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Mean Squared Deviation\n  around the mean of this dataset.\n  Mean Squared Deviation is the average of the squared differences between each\n  element and a centerpoint (mean in this case):\n  MSD = average | x - x_mean |^2\n  >>> entailMeanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailMeanSquaredDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map(val => Math.pow(val - mean, 2));\n};\n\n/**\n  Given a list of input numbers, calculate Root Mean Squared Deviation\n  around the mean of this dataset.\n  Root Mean Squared Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  RMSE = sqrt(average | x - x_mean |)\n  >>> entailRootMeanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailRootMeanSquaredDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map(val => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Standard Deviation around the mean of this dataset.\n  Standard Deviation is the square root of the standard deviation between each element and a centerpoint (mean in this case):\n  SD = sqrt(average | x - x_mean |)\n  >>> entailStandardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailStandardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map(val => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Variance around the mean of this dataset.\n  Variance is the square root of the standard deviation between each element and a centerpoint (mean in this case):\n  V = sqrt(average | x - x_mean |)\n  >>> entailVariance([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailVariance = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map(val => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Standard Deviation around the mean of this dataset.\n  Standard Deviation is the square root of the standard deviation between each element and a centerpoint (mean in this case):\n  SD = sqrt(average | x - x_mean |)\n  >>> entailStandardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailStandardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map(val => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Mean Squared Deviation around the mean of this dataset.\n  Mean Squared Deviation is the average of the squared differences between each\n  element and a centerpoint (mean in this case):\n  MSD = average | x - x_mean |^2\n  >>> entailMeanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailMeanSquaredDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map(val => Math.pow(val - mean, 2));\n};\n\n/**\n  Given a list of input numbers, calculate Root Mean Squared Deviation around the mean of this dataset.\n  Root Mean Squared Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  RMSE = sqrt(average | x - x_mean |)\n  >>> entailRootMeanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailRootMeanSquaredDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map(val => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Standard Deviation around the mean of this dataset.\n  Standard Deviation is the square root of the standard deviation between each element and a centerpoint (mean in this case):\n  SD = sqrt(average | x - x_mean |)\n  >>> entailStandardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailStandardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map(val => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Variance around the mean of this dataset.\n  Variance is the square root of the standard deviation between each element and a centerpoint (mean in this case):\n  V = sqrt(average | x - x_mean |)\n  >>> entailVariance([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailVariance = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map(val => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Standard Deviation around the mean of this dataset.\n  Standard Deviation is the square root of the standard deviation between each element and a centerpoint (mean in this case):\n  SD = sqrt(average | x - x_mean |)\n  >>> entailStandardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailStandardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map(val => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Mean Squared Deviation around the mean of this dataset.\n  Mean Squared Deviation is the average of the squared differences between each\n  element and a centerpoint (mean in this case):\n  MSD = average | x - x_mean |^2\n  >>> entailMeanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailMeanSquaredDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map(val => Math.pow(val - mean, 2));\n};\n\n/**\n  Given a list of input numbers, calculate Root Mean Squared Deviation around the mean of this dataset.\n  Root Mean Squared Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  RMSE = sqrt(average | x - x_mean |)\n  >>> entailRootMeanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailRootMeanSquaredDeviation = (numbers) => {\n  const ", "passed": 0}
{"task_id": "JavaScript/40", "prompt": "/*\n  tripleTotalToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> tripleTotalToZero([1, 3, 5, 0])\n  false\n  >>> tripleTotalToZero([1, 3, -2, 1])\n  true\n  >>> tripleTotalToZero([1, 2, 3, 7])\n  false\n  >>> tripleTotalToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleTotalToZero([1])\n  false\n  */\nconst tripleTotalToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "tripleTotalToZero", "gc": "<|endoftext|>/*\n  tripleTotalToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> tripleTotalToZero([1, 3, 5, 0])\n  false\n  >>> tripleTotalToZero([1, 3, -2, 1])\n  true\n  >>> tripleTotalToZero([1, 2, 3, 7])\n  false\n  >>> tripleTotalToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleTotalToZero([1])\n  false\n  */\nconst tripleTotalToZero = (l) => {\n  let total = 0;\n  for (let i = 0; i < l.length; i++) {\n    total += l[i];\n    if (total === 0) {\n      return false;\n    }\n  }\n  return total === 0;\n};\n\n// A function to check if a number is even.\nconst isEven = (n) => {\n  return n % 2 === 0;\n};\n\n// A function to check if a number is odd.\nconst isOdd = (n) => {\n  return n % 2!== 0;\n};\n\n// A function to check if a number is divisible by 3.\nconst isDivisibleBy3 = (n) => {\n  return n % 3 === 0;\n};\n\n// A function to check if a number is divisible by 5.\nconst isDivisibleBy5 = (n) => {\n  return n % 5 === 0;\n};\n\n// A function to check if a number is divisible by 7.\nconst isDivisibleBy7 = (n) => {\n  return n % 7 === 0;\n};\n\n// A function to check if a number is divisible by 9.\nconst isDivisibleBy9 = (n) => {\n  return n % 9 === 0;\n};\n\n// A function to check if a number is divisible by 11.\nconst isDivisibleBy11 = (n) => {\n  return n % 11 === 0;\n};\n\n// A function to check if a number is divisible by 13.\nconst isDivisibleBy13 = (n) => {\n  return n % 13 === 0;\n};\n\n// A function to check if a number is divisible by 17.\nconst isDivisibleBy17 = (n) => {\n  return n % 17 === 0;\n};\n\n// A function to check if a number is divisible by 19.\nconst isDivisibleBy19 = (n) => {\n  return n % 19 === 0;\n};\n\n// A function to check if a number is divisible by 23.\nconst isDivisibleBy23 = (n) => {\n  return n % 23 === 0;\n};\n\n// A function to check if a number is divisible by 29.\nconst isDivisibleBy29 = (n) => {\n  return n % 29 === 0;\n};\n\n// A function to check if a number is divisible by 31.\nconst isDivisibleBy31 = (n) => {\n  return n % 31 === 0;\n};\n\n// A function to check if a number is divisible by 35.\nconst isDivisibleBy35 = (n) => {\n  return n % 35 === 0;\n};\n\n// A function to check if a number is divisible by 37.\nconst isDivisibleBy37 = (n) => {\n  return n % 37 === 0;\n};\n\n// A function to check if a number is divisible by 43.\nconst isDivisibleBy43 = (n) => {\n  return n % 43 === 0;\n};\n\n// A function to check if a number is divisible by 47.\nconst isDivisibleBy47 = (n) => {\n  return n % 47 === 0;\n};\n\n// A function to check if a number is divisible by 53.\nconst isDivisibleBy53 = (n) => {\n  return n % 53 === 0;\n};\n\n// A function to check if a number is divisible by 59.\nconst isDivisibleBy59 = (n) => {\n  return n % 59 === 0;\n};\n\n// A function to check if a number is divisible by 63.\nconst isDivisibleBy63 = (n) => {\n  return n % 63 === 0;\n};\n\n// A function to check if a number is divisible by 67.\nconst isDivisibleBy67 = (n) => {\n  return n % 67 === 0;\n};\n\n// A function to check if a number is divisible by 73.\nconst isDivisibleBy73 = (n) => {\n  return n % 73 === 0;\n};\n\n// A function to check if a number is divisible by 79.\nconst isDivisibleBy79 = (n) => {\n  return n % 79 === 0;\n};\n\n// A function to check if a number is divisible by 83.\nconst isDivisibleBy83 = (n) => {\n  return n % 83 === 0;\n};\n\n// A function to check if a number is divisible by 89.\nconst isDivisibleBy89 = (n) => {\n  return n % 89 === 0;\n};\n\n// A function to check if a number is divisible by 93.\nconst isDivisibleBy93 = (n) => {\n  return n % 93 === 0;\n};\n\n// A function to check if a number is divisible by 97.\nconst isDivisibleBy97 = (n) => {\n  return n % 97 === 0;\n};\n\n// A function to check if a number is divisible by 103.\nconst isDivisibleBy103 = (n) => {\n  return n % 103 === 0;\n};\n\n// A function to check if a number is divisible by 107.\nconst isDivisibleBy107 = (n) => {\n  return n % 107 === 0;\n};\n\n// A function to check if a number is divisible by 113.\nconst isDivisibleBy113 = (n) => {\n  return n % 113 === 0;\n};\n\n// A function to check if a number is divisible by 117.\nconst isDivisibleBy117 = (n) => {\n  return n % 117 === 0;\n};\n\n// A function to check if a number is divisible by 123.\nconst isDivisibleBy123 = (n) => {\n  return n % 123 === 0;\n};\n\n// A function to check if a number is divisible by 127.\nconst isDivisibleBy127 = (n) => {\n  return n % 127 === 0;\n};\n\n// A function to check if a number is divisible by 131.\nconst isDivisibleBy131 = (n) => {\n  return n % 131 === 0;\n};\n\n// A function to check if a number is divisible by 137.\nconst isDivisibleBy137 = (n) => {\n  return n % 137 === 0;\n};\n\n// A function to check if a number is divisible by 143.\nconst isDivisibleBy143 = (n) => {\n  return n % 143 === 0;\n};\n\n// A function to check if a number is divisible by 147.\nconst isDivisibleBy147 = (n) => {\n  return n % 147 === 0;\n};\n\n// A function to check if a number is divisible by 153.\nconst isDivisibleBy153 = (n) => {\n  return n % 153 === 0;\n};\n\n// A function to check if a number is divisible by 157.\nconst isDivisibleBy157 = (n) => {\n  return n % 157 === 0;\n};\n\n// A function to check if a number is divisible by 163.\nconst isDivisibleBy163 = (n) => {\n  return n % 163 === 0;\n};\n\n// A function to check if a number is divisible by 167.\nconst isDivisibleBy167 = (n) => {\n  return n % 167 === 0;\n};\n\n// A function to check if a number is divisible by 173.\nconst isDivisibleBy173 = (n) => {\n  return n % 173 === 0;\n};\n\n// A function to check if a number is divisible by 177.\nconst isDivisibleBy177 = (n) => {\n  return n % 177 === 0;\n};\n\n// A function to check if a number is divisible by 183.\nconst isDivisibleBy183 = (n) => {\n  return n % 183 === 0;\n};\n\n// A function to check if a number is divisible by 187.\nconst isDivisibleBy187 = (n) => {\n  return n % 187 === 0;\n};\n\n// A function to check if a number is divisible by 193.\nconst isDivisibleBy193 = (n) => {\n  return n % 193 === 0;\n};\n\n// A function to check if a number is divisible by 197.\n", "passed": 0}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst cableCarRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "cableCarRaceCollision", "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst cableCarRaceCollision = (n) => {\n  let collisions = 0;\n  let car1 = new Car();\n  let car2 = new Car();\n  let car3 = new Car();\n  let car4 = new Car();\n  let car5 = new Car();\n  let car6 = new Car();\n  let car7 = new Car();\n  let car8 = new Car();\n  let car9 = new Car();\n  let car10 = new Car();\n  let car11 = new Car();\n  let car12 = new Car();\n  let car13 = new Car();\n  let car14 = new Car();\n  let car15 = new Car();\n  let car16 = new Car();\n  let car17 = new Car();\n  let car18 = new Car();\n  let car19 = new Car();\n  let car20 = new Car();\n  let car21 = new Car();\n  let car22 = new Car();\n  let car23 = new Car();\n  let car24 = new Car();\n  let car25 = new Car();\n  let car26 = new Car();\n  let car27 = new Car();\n  let car28 = new Car();\n  let car29 = new Car();\n  let car30 = new Car();\n  let car31 = new Car();\n  let car32 = new Car();\n  let car33 = new Car();\n  let car34 = new Car();\n  let car35 = new Car();\n  let car36 = new Car();\n  let car37 = new Car();\n  let car38 = new Car();\n  let car39 = new Car();\n  let car40 = new Car();\n  let car41 = new Car();\n  let car42 = new Car();\n  let car43 = new Car();\n  let car44 = new Car();\n  let car45 = new Car();\n  let car46 = new Car();\n  let car47 = new Car();\n  let car48 = new Car();\n  let car49 = new Car();\n  let car50 = new Car();\n  let car51 = new Car();\n  let car52 = new Car();\n  let car53 = new Car();\n  let car54 = new Car();\n  let car55 = new Car();\n  let car56 = new Car();\n  let car57 = new Car();\n  let car58 = new Car();\n  let car59 = new Car();\n  let car60 = new Car();\n  let car61 = new Car();\n  let car62 = new Car();\n  let car63 = new Car();\n  let car64 = new Car();\n  let car65 = new Car();\n  let car66 = new Car();\n  let car67 = new Car();\n  let car68 = new Car();\n  let car69 = new Car();\n  let car70 = new Car();\n  let car71 = new Car();\n  let car72 = new Car();\n  let car73 = new Car();\n  let car74 = new Car();\n  let car75 = new Car();\n  let car76 = new Car();\n  let car77 = new Car();\n  let car78 = new Car();\n  let car79 = new Car();\n  let car80 = new Car();\n  let car81 = new Car();\n  let car82 = new Car();\n  let car83 = new Car();\n  let car84 = new Car();\n  let car85 = new Car();\n  let car86 = new Car();\n  let car87 = new Car();\n  let car88 = new Car();\n  let car89 = new Car();\n  let car90 = new Car();\n  let car91 = new Car();\n  let car92 = new Car();\n  let car93 = new Car();\n  let car94 = new Car();\n  let car95 = new Car();\n  let car96 = new Car();\n  let car97 = new Car();\n  let car98 = new Car();\n  let car99 = new Car();\n  let car100 = new Car();\n  let car101 = new Car();\n  let car102 = new Car();\n  let car103 = new Car();\n  let car104 = new Car();\n  let car105 = new Car();\n  let car106 = new Car();\n  let car107 = new Car();\n  let car108 = new Car();\n  let car109 = new Car();\n  let car110 = new Car();\n  let car111 = new Car();\n  let car112 = new Car();\n  let car113 = new Car();\n  let car114 = new Car();\n  let car115 = new Car();\n  let car116 = new Car();\n  let car117 = new Car();\n  let car118 = new Car();\n  let car119 = new Car();\n  let car120 = new Car();\n  let car121 = new Car();\n  let car122 = new Car();\n  let car123 = new Car();\n  let car124 = new Car();\n  let car125 = new Car();\n  let car126 = new Car();\n  let car127 = new Car();\n  let car128 = new Car();\n  let car129 = new Car();\n  let car130 = new Car();\n  let car131 = new Car();\n  let car132 = new Car();\n  let car133 = new Car();\n  let car134 = new Car();\n  let car135 = new Car();\n  let car136 = new Car();\n  let car137 = new Car();\n  let car138 = new Car();\n  let car139 = new Car();\n  let car140 = new Car();\n  let car141 = new Car();\n  let car142 = new Car();\n  let car143 = new Car();\n  let car144 = new Car();\n  let car145 = new Car();\n  let car146 = new Car();\n  let car147 = new Car();\n  let car148 = new Car();\n  let car149 = new Car();\n  let car150 = new Car();\n  let car151 = new Car();\n  let car152 = new Car();\n  let car153 = new Car();\n  let car154 = new Car();\n  let car155 = new Car();\n  let car156 = new Car();\n  let car157 = new Car();\n  let car158 = new Car();\n  let car159 = new Car();\n  let car160 = new Car();\n  let car161 = new Car();\n  let car162 = new Car();\n  let car163 = new Car();\n  let car164 = new Car();\n  let car165 = new Car();\n  let car166 = new Car();\n  let car167 = new Car();\n  let car168 = new Car();\n  let car169 = new Car();\n  let car170 = new Car();\n  let car171 = new Car();\n  let car172 = new Car();\n  let car173 = new Car();\n  let car174 = new Car();\n  let car175 = new Car();\n  let car176 = new Car();\n  let car177 = new Car();\n  let car178 = new Car();\n  let car179 = new Car();\n  let car180 = new Car();\n  let car181 = new Car();\n  let car182 = new Car();\n  let car183 = new Car();\n  let car184 = new Car();\n  let car185 = new Car();\n  let car186 = new Car();\n  let car187 = new Car();\n  let car188 = new Car();\n  let car189", "passed": 0}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "gc": "<|endoftext|>/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = l.length - 1;\n  while (i > 0) {\n    l[--i] = l[i] + 1;\n  }\n  return l;\n};\n\n/**\n * Return list with elements decremented by 1.\n * >>> decrList([1, 2, 3])\n * [2, 3, 4]\n * >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [6, 4, 6, 3, 4, 4, 10, 1, 124]\n */\nconst decrList = (l) => {\n  let i = l.length - 1;\n  while (i > 0) {\n    l[i] = l[--i] - 1;\n  }\n  return l;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> incrList([1, 2, 3])\n * [2, 3, 4]\n * >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [6, 4, 6, 3, 4, 4, 10, 1, 124]\n */\nconst incrDecrList = (l) => {\n  let i = l.length - 1;\n  while (i > 0) {\n    l[--i] = l[i] + 1;\n    l[i] = l[i] + 2;\n  }\n  return l;\n};\n\n/**\n * Return list with elements decremented by 1.\n * >>> decrList([1, 2, 3])\n * [2, 3, 4]\n * >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [6, 4, 6, 3, 4, 4, 10, 1, 124]\n */\nconst decrDecrList = (l) => {\n  let i = l.length - 1;\n  while (i > 0) {\n    l[i] = l[i] + 2;\n    l[--i] = l[--i] - 1;\n  }\n  return l;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> incrList([1, 2, 3])\n * [2, 3, 4]\n * >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [6, 4, 6, 3, 4, 4, 10, 1, 124]\n */\nconst incrDecrDecrList = (l) => {\n  let i = l.length - 1;\n  while (i > 0) {\n    l[i] = l[i] + 2;\n    l[--i] = l[i] + 1;\n    l[i] = l[i] + 2;\n  }\n  return l;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> decrList([1, 2, 3])\n * [2, 3, 4]\n * >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [6, 4, 6, 3, 4, 4, 10, 1, 124]\n */\nconst decrDecrDecrList = (l) => {\n  let i = l.length - 1;\n  while (i > 0) {\n    l[i] = l[i] + 2;\n    l[--i] = l[i] + 2;\n    l[i] = l[i] + 2;\n  }\n  return l;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> incrList([1, 2, 3])\n * [2, 3, 4]\n * >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [6, 4, 6, 3, 4, 4, 10, 1, 124]\n */\nconst incrDecrDecrDecrList = (l) => {\n  let i = l.length - 1;\n  while (i > 0) {\n    l[i] = l[i] + 2;\n    l[--i] = l[i] + 2;\n    l[i] = l[i] + 2;\n  }\n  return l;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> decrList([1, 2, 3])\n * [2, 3, 4]\n * >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [6, 4, 6, 3, 4, 4, 10, 1, 124]\n */\nconst decrDecrDecrDecrList = (l) => {\n  let i = l.length - 1;\n  while (i > 0) {\n    l[i] = l[i] + 2;\n    l[--i] = l[i] + 2;\n    l[i] = l[i] + 2;\n  }\n  return l;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> incrList([1, 2, 3])\n * [2, 3, 4]\n * >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [6, 4, 6, 3, 4, 4, 10, 1, 124]\n */\nconst incrDecrDecrDecrDecrList = (l) => {\n  let i = l.length - 1;\n  while (i > 0) {\n    l[i] = l[i] + 2;\n    l[--i] = l[i] + 2;\n    l[i] = l[i] + 2;\n  }\n  return l;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> decrList([1, 2, 3])\n * [2, 3, 4]\n * >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [6, 4, 6, 3, 4, 4, 10, 1, 124]\n */\nconst decrDecrDecrDecrDecrList = (l) => {\n  let i = l.length - 1;\n  while (i > 0) {\n    l[i] = l[i] + 2;\n    l[--i] = l[i] + 2;\n    l[i] = l[i] + 2;\n  }\n  return l;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> incrList([1, 2, 3])\n * [2, 3, 4]\n * >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [6, 4, 6, 3, 4, 4, 10, 1, 124]\n */\nconst incrDecrDecrDecrDecrDecrList = (l) => {\n  let i = l.length - 1;\n  while (i > 0) {\n    l[i] = l[i] + 2;\n    l[--i] = l[i] + 2;\n    l[i] = l[i] + 2;\n  }\n  return l;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> decrList([1, 2, 3])\n * [2, 3, 4]\n * >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [6, 4, 6, 3, 4, 4, 10, 1, 124]\n */\nconst decrDecrDecrDecrDecrDecrList = (l) => {\n  let i = l.length - 1;\n  while (i > 0) {\n    l[i] = l[i] + 2;\n    l[--i] = l[i] + 2;\n    l[i] = l[i] + 2;\n  }\n  return l;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> incrList([1, 2, 3])\n * [2, 3, 4]\n * >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [6, 4, 6, 3, 4, 4, 10, 1, 124]\n */\nconst incrDecrDecrDecrDecrDecrDecrList = (l) => {\n  let i = l.length - 1;\n  while (i > 0) {\n    l[i] = l[i] + 2;\n    l[--i] = l[i] + 2;\n    l[i] = l[i] + 2;\n  }\n  return l;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> decrList([1, 2, 3])\n * [2, 3, 4]\n * >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [6, 4, 6, 3, 4, 4, 10, 1, 124]\n */\nconst decrDecrDecrDecrDecrDecrDecrList = (l) => {\n  let i = l.length - 1;\n  while (i > 0) {\n    l[i] = l[i] + 2;\n    l[--i] = l[i] + 2;\n    l[i] = l[i] + 2;\n  }\n  return l;\n};\n\n/**\n * Return list with elements incremented by 1.\n * >>> incrList([1, 2, 3])\n * [2, 3, 4]\n * >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [6, 4, 6, 3, 4, 4, 10, 1, 124]\n */\nconst incrDecrDecrDecrDecrDecrDecrList", "passed": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  copulateUnionToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> copulateUnionToZero([1, 3, 5, 0])\n  false\n  >>> copulateUnionToZero([1, 3, -2, 1])\n  false\n  >>> copulateUnionToZero([1, 2, 3, 7])\n  false\n  >>> copulateUnionToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateUnionToZero([1])\n  false\n  */\nconst copulateUnionToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "copulateUnionToZero", "gc": "<|endoftext|>/*\n  copulateUnionToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> copulateUnionToZero([1, 3, 5, 0])\n  false\n  >>> copulateUnionToZero([1, 3, -2, 1])\n  false\n  >>> copulateUnionToZero([1, 2, 3, 7])\n  false\n  >>> copulateUnionToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateUnionToZero([1])\n  false\n  */\nconst copulateUnionToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  copulateIntersectToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  intersect with zero, and false otherwise.\n  >>> copulateIntersectToZero([1, 3, 5, 0])\n  false\n  >>> copulateIntersectToZero([1, 3, -2, 1])\n  false\n  >>> copulateIntersectToZero([1, 2, 3, 7])\n  false\n  >>> copulateIntersectToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateIntersectToZero([1])\n  false\n  */\nconst copulateIntersectToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) {\n      return false;\n    }\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  copulateDifferenceToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  differ from zero, and false otherwise.\n  >>> copulateDifferenceToZero([1, 3, 5, 0])\n  false\n  >>> copulateDifferenceToZero([1, 3, -2, 1])\n  false\n  >>> copulateDifferenceToZero([1, 2, 3, 7])\n  false\n  >>> copulateDifferenceToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateDifferenceToZero([1])\n  false\n  */\nconst copulateDifferenceToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i] - 0;\n  }\n  return sum === 0;\n};\n\n/*\n  copulateProductToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  product to zero, and false otherwise.\n  >>> copulateProductToZero([1, 3, 5, 0])\n  false\n  >>> copulateProductToZero([1, 3, -2, 1])\n  false\n  >>> copulateProductToZero([1, 2, 3, 7])\n  false\n  >>> copulateProductToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateProductToZero([1])\n  false\n  */\nconst copulateProductToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i] * 0;\n  }\n  return sum === 0;\n};\n\n/*\n  copulatePowerToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  are powers of zero, and false otherwise.\n  >>> copulatePowerToZero([1, 3, 5, 0])\n  false\n  >>> copulatePowerToZero([1, 3, -2, 1])\n  false\n  >>> copulatePowerToZero([1, 2, 3, 7])\n  false\n  >>> copulatePowerToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulatePowerToZero([1])\n  false\n  */\nconst copulatePowerToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += Math.pow(l[i], 2);\n  }\n  return sum === 0;\n};\n\n/*\n  copulateSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  are sums to zero, and false otherwise.\n  >>> copulateSumToZero([1, 3, 5, 0])\n  false\n  >>> copulateSumToZero([1, 3, -2, 1])\n  false\n  >>> copulateSumToZero([1, 2, 3, 7])\n  false\n  >>> copulateSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateSumToZero([1])\n  false\n  */\nconst copulateSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  copulateProductToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  product to zero, and false otherwise.\n  >>> copulateProductToZero([1, 3, 5, 0])\n  false\n  >>> copulateProductToZero([1, 3, -2, 1])\n  false\n  >>> copulateProductToZero([1, 2, 3, 7])\n  false\n  >>> copulateProductToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateProductToZero([1])\n  false\n  */\nconst copulateProductToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i] * 0;\n  }\n  return sum === 0;\n};\n\n/*\n  copulatePowerToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  are powers of zero, and false otherwise.\n  >>> copulatePowerToZero([1, 3, 5, 0])\n  false\n  >>> copulatePowerToZero([1, 3, -2, 1])\n  false\n  >>> copulatePowerToZero([1, 2, 3, 7])\n  false\n  >>> copulatePowerToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulatePowerToZero([1])\n  false\n  */\nconst copulatePowerToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += Math.pow(l[i], 2);\n  }\n  return sum === 0;\n};\n\n/*\n  copulateSumToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  are sums to zero, and false otherwise.\n  >>> copulateSumToZero([1, 3, 5, 0])\n  false\n  >>> copulateSumToZero([1, 3, -2, 1])\n  false\n  >>> copulateSumToZero([1, 2, 3, 7])\n  false\n  >>> copulateSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateSumToZero([1])\n  false\n  */\nconst copulateSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  copulateProductToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  product to zero, and false otherwise.\n  >>> copulateProductToZero([1, 3, 5, 0])\n  false\n  >>> copulateProductToZero([1, 3, -2, 1])\n  false\n  >>> copulateProductToZero([1, 2, 3, 7])\n  false\n  >>> copulateProductToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateProductToZero([1])\n  false\n  */\nconst copulateProduct", "passed": 0}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> varietyBase(8, 3)\n  '22'\n  >>> varietyBase(8, 2)\n  '1000'\n  >>> varietyBase(7, 2)\n  '111'\n  */\nconst varietyBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "varietyBase", "gc": "<|endoftext|>/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> varietyBase(8, 3)\n  '22'\n  >>> varietyBase(8, 2)\n  '1000'\n  >>> varietyBase(7, 2)\n  '111'\n  */\nconst varietyBase = (x, base) => {\n  if (base === 10) {\n    return x.toString();\n  }\n  const digits = x.toString().split('').reverse();\n  const result = '';\n  for (let i = 0; i < digits.length; i++) {\n    const digit = digits[i];\n    const digitBase = parseInt(digit, base);\n    const digitPower = Math.floor(Math.log(digitBase) / Math.LN10);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);\n    const digitPower = parseInt(digitPower, base);\n    const digitPower = digitPower + 1;\n    const digitPower = Math.pow(10, digitPower);", "passed": 0}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and high return area for a triangle.\n  >>> triangulumArea(5, 3)\n  7.5\n  */\nconst triangulumArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangulumArea", "gc": "<|endoftext|>/*Given length of a side and high return area for a triangle.\n  >>> triangulumArea(5, 3)\n  7.5\n  */\nconst triangulumArea = (a, h) => {\n  const area = (h / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(3, 5)\n  9\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * l);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 5)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 3)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 2)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 1)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(6, 0)\n  15\n  */\nconst triangulumArea = (a, l) => {\n  const area = (l / 2) * (a * a - a * h);\n  return area;\n};\n\n/*Given length", "passed": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "gc": "<|endoftext|>/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new Error('fib4 number sequence is out of range');\n  }\n  return fib4Helper(n, 0);\n};\n\nconst fib4Helper = (n, acc) => {\n  if (n <= 0) {\n    return acc;\n  }\n  return fib4Helper(n - 1, (acc * n) + fib4Helper(n - 2, acc));\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts with 0 and ends with n-1.\n  >>> fibonacci(6)\n  8\n  >>> fibonacci(7)\n  14\n  */\nconst fibonacci = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new Error('fibonacci number sequence is out of range');\n  }\n  return fibonacciHelper(n, 0);\n};\n\nconst fibonacciHelper = (n, acc) => {\n  if (n <= 0) {\n    return acc;\n  }\n  return fibonacciHelper(n - 1, (acc * n) + fibonacciHelper(n - 2, acc));\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts with 0 and ends with n-1.\n  >>> fibonacci(6)\n  8\n  >>> fibonacci(7)\n  14\n  */\nconst fibonacci = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new Error('fibonacci number sequence is out of range');\n  }\n  return fibonacciHelper(n, 0);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts with 0 and ends with n-1.\n  >>> fibonacci(6)\n  8\n  >>> fibonacci(7)\n  14\n  */\nconst fibonacci = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new Error('fibonacci number sequence is out of range');\n  }\n  return fibonacciHelper(n, 0);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts with 0 and ends with n-1.\n  >>> fibonacci(6)\n  8\n  >>> fibonacci(7)\n  14\n  */\nconst fibonacci = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new Error('fibonacci number sequence is out of range');\n  }\n  return fibonacciHelper(n, 0);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts with 0 and ends with n-1.\n  >>> fibonacci(6)\n  8\n  >>> fibonacci(7)\n  14\n  */\nconst fibonacci = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new Error('fibonacci number sequence is out of range');\n  }\n  return fibonacciHelper(n, 0);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts with 0 and ends with n-1.\n  >>> fibonacci(6)\n  8\n  >>> fibonacci(7)\n  14\n  */\nconst fibonacci = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new Error('fibonacci number sequence is out of range');\n  }\n  return fibonacciHelper(n, 0);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts with 0 and ends with n-1.\n  >>> fibonacci(6)\n  8\n  >>> fibonacci(7)\n  14\n  */\nconst fibonacci = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new Error('fibonacci number sequence is out of range');\n  }\n  return fibonacciHelper(n, 0);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts with 0 and ends with n-1.\n  >>> fibonacci(6)\n  8\n  >>> fibonacci(7)\n  14\n  */\nconst fibonacci = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new Error('fibonacci number sequence is out of range');\n  }\n  return fibonacciHelper(n, 0);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts with 0 and ends with n-1.\n  >>> fibonacci(6)\n  8\n  >>> fibonacci(7)\n  14\n  */\nconst fibonacci = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new Error('fibonacci number sequence is out of range');\n  }\n  return fibonacciHelper(n, 0);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts with 0 and ends with n-1.\n  >>> fibonacci(6)\n  8\n  >>> fibonacci(7)\n  14\n  */\nconst fibonacci = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new Error('fibonacci number sequence is out of range');\n  }\n  return fibonacciHelper(n, 0);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts with 0 and ends with n-1.\n  >>> fibonacci(6)\n  8\n  >>> fibonacci(7)\n  14\n  */\nconst fibonacci = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new Error('fibonacci number sequence is out of range');\n  }\n  return fibonacciHelper(n, 0);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts with 0 and ends with n-1.\n  >>> fibonacci(6)\n  8\n  >>> fibonacci(7)\n  14\n  */\nconst fibonacci = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    throw new Error('fibonacci number sequence is out of range');\n  }\n  return fibonacciHelper(n, 0);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts with 0 and ends with n-1.\n  >>> fibonacci(6)\n", "passed": 0}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (i + 1) < n? i + 1 : n;\n  let sum = 0;\n  while (i < j) {\n    sum += l[i];\n    i++;\n  }\n  return sum / 2;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  4\n  */\nconst mode = (l) => {\n  let n = l.length;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (i + 1) < n? i + 1 : n;\n  let count = 0;\n  while (i < j) {\n    if (l[i] > l[m - 1]) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  4\n  */\nconst modes = (l) => {\n  let n = l.length;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (i + 1) < n? i + 1 : n;\n  let count = 0;\n  while (i < j) {\n    if (l[i] > l[m - 1]) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  4\n  */\nconst modesNoCase = (l) => {\n  let n = l.length;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (i + 1) < n? i + 1 : n;\n  let count = 0;\n  while (i < j) {\n    if (l[i] > l[m - 1]) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  4\n  */\nconst modesNoCase2 = (l, caseSensitive) => {\n  let n = l.length;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (i + 1) < n? i + 1 : n;\n  let count = 0;\n  while (i < j) {\n    if (l[i] > l[m - 1]) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  4\n  */\nconst modesNoCase3 = (l, caseSensitive) => {\n  let n = l.length;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (i + 1) < n? i + 1 : n;\n  let count = 0;\n  while (i < j) {\n    if (l[i] > l[m - 1]) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  4\n  */\nconst modesNoCase4 = (l, caseSensitive) => {\n  let n = l.length;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (i + 1) < n? i + 1 : n;\n  let count = 0;\n  while (i < j) {\n    if (l[i] > l[m - 1]) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  4\n  */\nconst modesNoCase5 = (l, caseSensitive) => {\n  let n = l.length;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (i + 1) < n? i + 1 : n;\n  let count = 0;\n  while (i < j) {\n    if (l[i] > l[m - 1]) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  4\n  */\nconst modesNoCase6 = (l, caseSensitive) => {\n  let n = l.length;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (i + 1) < n? i + 1 : n;\n  let count = 0;\n  while (i < j) {\n    if (l[i] > l[m - 1]) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  4\n  */\nconst modesNoCase7 = (l, caseSensitive) => {\n  let n = l.length;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (i + 1) < n? i + 1 : n;\n  let count = 0;\n  while (i < j) {\n    if (l[i] > l[m - 1]) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  4\n  */\nconst modesNoCase8 = (l, caseSensitive) => {\n  let n = l.length;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (i + 1) < n? i + 1 : n;\n  let count = 0;\n  while (i < j) {\n    if (l[i] > l[m - 1]) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  4\n  */\nconst modesNoCase9 = (l, caseSensitive) => {\n  let n = l.length;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (i + 1) < n? i + 1 : n;\n  let count = 0;\n  while (i < j) {\n    if (l[i] > l[m - 1]) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  4\n  */\nconst modesNoCase10 = (l, caseSensitive) => {\n  let n = l.length;\n  let m = n / 2;\n  let i = Math.floor(n);\n  let j = (i + 1) < n? i + 1 : n;\n  let count = 0;\n  while (i < j) {\n    if (l[i] > l[m - 1]) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  4\n  */\nconst modesNoCase11 = (l, caseSensitive) => {\n  let n = l.length;\n", "passed": 0}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "gc": "<|endoftext|>/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText === text\n}\n\n/*\n  Checks if given string is a palindrome (case insensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeInsensitive = (text) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText === text.toLowerCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeCaseSensitive = (text) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText === text.toUpperCase()\n}\n\n/*\n  Checks if given string is a palindrome (case insensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeCaseInsensitive = (text) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText === text.toLowerCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeCaseSensitiveInsensitive = (text) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText === text.toUpperCase()\n}\n\n/*\n  Checks if given string is a palindrome (case insensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeCaseInsensitiveInsensitive = (text) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText === text.toLowerCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeCaseSensitiveInsensitiveInsensitive = (text) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText === text.toUpperCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeCaseSensitiveInsensitiveInsensitiveInsensitive = (text) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText === text.toLowerCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeCaseSensitiveInsensitiveInsensitiveInsensitiveInsensitive = (text) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText === text.toUpperCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeCaseSensitiveInsensitiveInsensitiveInsensitiveInsensitive = (text) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText === text.toLowerCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeCaseSensitiveInsensitiveInsensitiveInsensitiveInsensitiveInsensitive = (text) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText === text.toUpperCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeCaseSensitiveInsensitiveInsensitiveInsensitiveInsensitiveInsensitiveInsensitive = (text) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText === text.toLowerCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeCaseSensitiveInsensitiveInsensitiveInsensitiveInsensitiveInsensitiveInsensitiveInsensitive = (text) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText === text.toUpperCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeCaseSensitiveInsensitiveInsensitiveInsensitiveInsensitiveInsensitiveInsensitiveInsensitive = (text) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText === text.toLowerCase()\n}\n\n/*\n  Checks if given string is a palindrome (case sensitive)\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeCaseSensitiveInsensitiveInsensitiveInsensitiveInsensitiveInsensitiveIn", "passed": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "gc": "<|endoftext|>/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p < 1) return 0;\n  if (p === 1) return 1;\n  if (p === 2) return 2;\n  if (p === 3) return 3;\n  if (p === 4) return 4;\n  if (p === 5) return 5;\n  if (p === 6) return 6;\n  if (p === 7) return 7;\n  if (p === 8) return 8;\n  if (p === 9) return 9;\n  if (p === 10) return 10;\n  if (p === 11) return 11;\n  if (p === 12) return 12;\n  if (p === 13) return 13;\n  if (p === 14) return 14;\n  if (p === 15) return 15;\n  if (p === 16) return 16;\n  if (p === 17) return 17;\n  if (p === 18) return 18;\n  if (p === 19) return 19;\n  if (p === 20) return 20;\n  if (p === 21) return 21;\n  if (p === 22) return 22;\n  if (p === 23) return 23;\n  if (p === 24) return 24;\n  if (p === 25) return 25;\n  if (p === 26) return 26;\n  if (p === 27) return 27;\n  if (p === 28) return 28;\n  if (p === 29) return 29;\n  if (p === 30) return 30;\n  if (p === 31) return 31;\n  if (p === 32) return 32;\n  if (p === 33) return 33;\n  if (p === 34) return 34;\n  if (p === 35) return 35;\n  if (p === 36) return 36;\n  if (p === 37) return 37;\n  if (p === 38) return 38;\n  if (p === 39) return 39;\n  if (p === 40) return 40;\n  if (p === 41) return 41;\n  if (p === 42) return 42;\n  if (p === 43) return 43;\n  if (p === 44) return 44;\n  if (p === 45) return 45;\n  if (p === 46) return 46;\n  if (p === 47) return 47;\n  if (p === 48) return 48;\n  if (p === 49) return 49;\n  if (p === 50) return 50;\n  if (p === 51) return 51;\n  if (p === 52) return 52;\n  if (p === 53) return 53;\n  if (p === 54) return 54;\n  if (p === 55) return 55;\n  if (p === 56) return 56;\n  if (p === 57) return 57;\n  if (p === 58) return 58;\n  if (p === 59) return 59;\n  if (p === 60) return 60;\n  if (p === 61) return 61;\n  if (p === 62) return 62;\n  if (p === 63) return 63;\n  if (p === 64) return 64;\n  if (p === 65) return 65;\n  if (p === 66) return 66;\n  if (p === 67) return 67;\n  if (p === 68) return 68;\n  if (p === 69) return 69;\n  if (p === 70) return 70;\n  if (p === 71) return 71;\n  if (p === 72) return 72;\n  if (p === 73) return 73;\n  if (p === 74) return 74;\n  if (p === 75) return 75;\n  if (p === 76) return 76;\n  if (p === 77) return 77;\n  if (p === 78) return 78;\n  if (p === 79) return 79;\n  if (p === 80) return 80;\n  if (p === 81) return 81;\n  if (p === 82) return 82;\n  if (p === 83) return 83;\n  if (p === 84) return 84;\n  if (p === 85) return 85;\n  if (p === 86) return 86;\n  if (p === 87) return 87;\n  if (p === 88) return 88;\n  if (p === 89) return 89;\n  if (p === 90) return 90;\n  if (p === 91) return 91;\n  if (p === 92) return 92;\n  if (p === 93) return 93;\n  if (p === 94) return 94;\n  if (p === 95) return 95;\n  if (p === 96) return 96;\n  if (p === 97) return 97;\n  if (p === 98) return 98;\n  if (p === 99) return 99;\n  if (p === 100) return 100;\n  if (p === 101) return 101;\n  if (p === 102) return 102;\n  if (p === 103) return 103;\n  if (p === 104) return 104;\n  if (p === 105) return 105;\n  if (p === 106) return 106;\n  if (p === 107) return 107;\n  if (p === 108) return 108;\n  if (p === 109) return 109;\n  if (p === 110) return 110;\n  if (p === 111) return 111;\n  if (p === 112) return 112;\n  if (p === 113) return 113;\n  if (p === 114) return 114;\n  if (p === 115) return 115;\n  if (p === 116) return 116;\n  if (p === 117) return 117;\n  if (p === 118) return 118;\n  if (p === 119) return 119;\n  if (p === 120) return 120;\n  if (p === 121) return 121;\n  if (p === 122) return 122;\n  if (p === 123) return 123;\n  if (p === 124) return 124;\n  if (p === 125) return 125;\n  if (p === 126) return 126;\n  if (p === 127) return 127;\n  if (p === 128) return 128;\n  if (p === 129) return 129;\n  if (p === 130) return 130;\n  if (p === 131) return 131;\n  if (p === 132) return 132;\n  if (p === 133) return 133;\n  if (p === 134) return 134;\n  if (p === 135) return 135;\n  if (p === 136) return 136;\n  if (p === 137) return 137;\n  if (p === 138) return 138;\n  if (p === 139) return 139;\n  if (p === 140) return 140;\n  if (p === 141) return 141;\n  if (p === 142) return 142;\n  if (p === 143) return 143;\n  if (p === 144) return 144;\n  if (p === 145) return 145;\n  if (p === 146) return 146;\n  if (p === 147) return 147;\n  if (p === 148) return 148;\n  if (p === 149) return 149;\n  if (p === 150) return 150;\n  if (p === 151) return 151;\n  if (p === 152) return 152;\n  if (p === 153) return 153;\n  if (p === 154) return 154;\n  if (p === 155) return 155;\n  if (p === 156) return 156;\n  if (p === 157) return 157;\n  if (p === 158) return 158;\n  if (p === 159) return 159;\n  if (p === 160) return 160;\n  if (p === 161) return 161;\n  if (p === 162) return 162;\n  if (p === 163) return 163;\n  if (p === 164) return 164;\n  if (p === 165) return 165;\n  if (p === 166) return 166;\n  if (p === 167) return 167;\n  if (p === 168) return 168;\n  if (p === 169) return 169;\n  if (p === 170) return 170;\n  if (p === 171) return 171;\n  if (p === 172) return 172;\n  if (p === 173) return 173;\n  if (p === 174) return 174;\n  if (p === 175) return 175;\n  if (p === 176) return 176;\n  if (p === 177) return 177;\n  if (p === 178) return 178;\n  if (p === 179) return 179;\n  if (p === 180) return 180;\n", "passed": 0}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "gc": "<|endoftext|>/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let n = numbers.length\n  while (i < n) {\n    if (j === n) {\n      result.push(numbers[i])\n      break\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      j++\n    } else {\n      result.push(numbers[i])\n      i++\n    }\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the first n elements of a given list\n * \n * >>> drop([], 1)\n  []\n  >>> drop([1, 2, 3, 4], 1)\n  [3, 4]\n  >>> drop([1, 2, 3, 4], 2)\n  [3, 4]\n  >>> drop([1, 2, 3, 4], 3)\n  [3, 4]\n  >>> drop([1, 2, 3, 4], 4)\n  []\n  >>> drop([1, 2, 3, 4], 5)\n  []\n  >>> drop([1, 2, 3, 4], 6)\n  []\n  >>> drop([1, 2, 3, 4], 7)\n  []\n  >>> drop([1, 2, 3, 4], 8)\n  []\n  >>> drop([1, 2, 3, 4], 9)\n  []\n  >>> drop([1, 2, 3, 4], 10)\n  []\n  >>> drop([1, 2, 3, 4], 11)\n  []\n  >>> drop([1, 2, 3, 4], 12)\n  []\n  >>> drop([1, 2, 3, 4], 13)\n  []\n  >>> drop([1, 2, 3, 4], 14)\n  []\n  >>> drop([1, 2, 3, 4], 15)\n  []\n  >>> drop([1, 2, 3, 4], 16)\n  []\n  >>> drop([1, 2, 3, 4], 17)\n  []\n  >>> drop([1, 2, 3, 4], 18)\n  []\n  >>> drop([1, 2, 3, 4], 19)\n  []\n  >>> drop([1, 2, 3, 4], 20)\n  []\n  >>> drop([1, 2, 3, 4], 21)\n  []\n  >>> drop([1, 2, 3, 4], 22)\n  []\n  >>> drop([1, 2, 3, 4], 23)\n  []\n  >>> drop([1, 2, 3, 4], 24)\n  []\n  >>> drop([1, 2, 3, 4], 25)\n  []\n  >>> drop([1, 2, 3, 4], 26)\n  []\n  >>> drop([1, 2, 3, 4], 27)\n  []\n  >>> drop([1, 2, 3, 4], 28)\n  []\n  >>> drop([1, 2, 3, 4], 29)\n  []\n  >>> drop([1, 2, 3, 4], 30)\n  []\n  >>> drop([1, 2, 3, 4], 31)\n  []\n  >>> drop([1, 2, 3, 4], 32)\n  []\n  >>> drop([1, 2, 3, 4], 33)\n  []\n  >>> drop([1, 2, 3, 4], 34)\n  []\n  >>> drop([1, 2, 3, 4], 35)\n  []\n  >>> drop([1, 2, 3, 4], 36)\n  []\n  >>> drop([1, 2, 3, 4], 37)\n  []\n  >>> drop([1, 2, 3, 4], 38)\n  []\n  >>> drop([1, 2, 3, 4], 39)\n  []\n  >>> drop([1, 2, 3, 4], 40)\n  []\n  >>> drop([1, 2, 3, 4], 41)\n  []\n  >>> drop([1, 2, 3, 4], 42)\n  []\n  >>> drop([1, 2, 3, 4], 43)\n  []\n  >>> drop([1, 2, 3, 4], 44)\n  []\n  >>> drop([1, 2, 3, 4], 45)\n  []\n  >>> drop([1, 2, 3, 4], 46)\n  []\n  >>> drop([1, 2, 3, 4], 47)\n  []\n  >>> drop([1, 2, 3, 4], 48)\n  []\n  >>> drop([1, 2, 3, 4], 49)\n  []\n  >>> drop([1, 2, 3, 4], 50)\n  []\n  >>> drop([1, 2, 3, 4], 51)\n  []\n  >>> drop([1, 2, 3, 4], 52)\n  []\n  >>> drop([1, 2, 3, 4], 53)\n  []\n  >>> drop([1, 2, 3, 4], 54)\n  []\n  >>> drop([1, 2, 3, 4], 55)\n  []\n  >>> drop([1, 2, 3, 4], 56)\n  []\n  >>> drop([1, 2, 3, 4], 57)\n  []\n  >>> drop([1, 2, 3, 4], 58)\n  []\n  >>> drop([1, 2, 3, 4], 59)\n  []\n  >>> drop([1, 2, 3, 4], 60)\n  []\n  >>> drop([1, 2, 3, 4], 61)\n  []\n  >>> drop([1, 2, 3, 4], 62)\n  []\n  >>> drop([1, 2, 3, 4], 63)\n  []\n  >>> drop([1, 2, 3, 4], 64)\n  []\n  >>> drop([1, 2, 3, 4], 65)\n  []\n  >>> drop([1, 2, 3, 4], 66)\n  []\n  >>> drop([1, 2, 3, 4], 67)\n  []\n  >>> drop([1, 2, 3, 4], 68)\n  []\n  >>> drop([1, 2, 3, 4], 69)\n  []\n  >>> drop([1, 2, 3, 4], 70)\n  []\n  >>> drop([1, 2, 3, 4], 71)\n  []\n  >>> drop([1, 2, 3, 4], 72)\n  []\n  >>> drop([1, 2, 3, 4], 73)\n  []\n  >>> drop([1, 2, 3, 4], 74)\n  []\n  >>> drop([1, 2, 3, 4], 75)\n  []\n  >>> drop([1, 2, 3, 4], 76)\n  []\n  >>> drop([1, 2, 3, 4], 77)\n  []\n  >>> drop([1, 2, 3, 4], 78)\n  []\n  >>> drop([1, 2, 3, 4], 79)\n  []\n  >>> drop([1, 2, 3, 4], 80)\n  []\n  >>> drop([1, 2, 3, 4], 81)\n  []\n  >>> drop([1, 2, 3, 4], 82)\n  []\n  >>> drop([1, 2, 3, 4], 83)\n  []\n  >>> drop([1, 2, 3, 4], 84)\n  []\n  >>> drop([1, 2, 3, 4], 85)\n  []\n  >>> drop([1, 2, 3, 4], 86)\n  []\n  >>> drop([1, 2, 3, 4], 87)\n  []\n  >>> drop([1, 2, 3, 4], 88)\n  []\n  >>> drop([1, 2, 3, 4], 89)\n  []\n  >>> drop([1, 2, 3, 4], 90)\n  []\n  >>> drop([1, 2, 3, 4], 91)\n  []\n  >>> drop([1, 2, 3, 4], 92)\n  []\n  >>> drop([1, 2, 3, 4], 93)\n  []\n  >>> drop([1, 2, 3, 4], 94)\n  []\n  >>> drop([1, 2, 3, 4], 95)\n  []\n  >>> drop([1, 2, 3, 4], 96)\n  []\n  >>> drop([1, 2, 3, 4], 97)\n  []\n  >>> drop([1, 2, 3, 4], 98)\n  []\n  >>> drop([1, 2, 3, 4], 99)\n  []\n  >>> drop([1, 2, 3, 4], 100)\n  []\n  >>> drop([1, 2, 3, 4], 101)\n  []\n  >>> drop([1, 2, 3, 4], 102)\n  []\n  >>> drop([1, 2, 3, 4], 103)\n  []\n  >>> drop([1, 2, 3, 4], 104)\n  []\n  >>> drop([1, 2, 3, 4], 105)\n  []\n  >>> drop([1, 2, 3, 4], 106)\n  []\n  >>> drop([1, 2, 3, 4], 107)\n  []\n  >>> drop([1, 2, 3, 4], 108)\n  []\n  >>> drop([1, 2, 3, 4], 109)\n  []\n  >>> drop([1, 2, 3, 4], 110)\n  []\n  >>> drop([1, 2, 3, 4], 111)\n  []\n  >>> drop([1, 2, 3, 4], 112)\n  []\n  >>> drop([1, 2, 3, 4], 113)\n  []\n  >>> drop([1, 2, 3, 4], 114)\n  []\n  >>> drop([1, 2, 3, 4], 115)\n  []\n  >>> drop([1, 2, 3, 4], 116)\n  []\n  >>> drop([1, 2, 3, 4], 117)\n  []\n  >>> drop", "passed": 0}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "gc": "<|endoftext|>/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeToBytes = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decodeToBytes = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeToHex = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decodeToHex = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeToBase64 = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decodeToBase64 = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeToBase64Url = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decodeToBase64Url = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeToBase64UrlSafe = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decodeToBase64UrlSafe = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeToBase64UrlSafeB64 = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decodeToBase64UrlSafeB64 = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeToBase64UrlSafeB64Url = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decodeToBase64UrlSafeB64Url = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeToBase64UrlSafeB64UrlSafe = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decodeToBase64UrlSafeB64UrlSafe = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeToBase64UrlSafeB64UrlSafeB64 = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decodeToBase64UrlSafeB64UrlSafeB64 = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeToBase64UrlSafeB64UrlSafeB64UrlSafe = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decodeToBase64UrlSafeB64UrlSafeB64UrlSafe = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeToBase64UrlSafeB64UrlSafeB64UrlSafeB64 = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decodeToBase64UrlSafeB64UrlSafeB64UrlSafeB64 = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeToBase64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafe = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decodeToBase64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafe = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeToBase64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafe = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decodeToBase64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafe = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeToBase64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafe = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decodeToBase64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafe = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst encodeToBase64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64UrlSafeB64", "passed": 0}
{"task_id": "JavaScript/51", "prompt": "/*\n  getRidOfVowel is a function that takes string and returns string without vowels.\n  >>> getRidOfVowel('')\n  ''\n  >>> getRidOfVowel(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> getRidOfVowel('abcdef')\n  'bcdf'\n  >>> getRidOfVowel('aaaaa')\n  ''\n  >>> getRidOfVowel('aaBAA')\n  'B'\n  >>> getRidOfVowel('zbcd')\n  'zbcd'\n  */\nconst getRidOfVowel = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "getRidOfVowel", "gc": "<|endoftext|>/*\n  getRidOfVowel is a function that takes string and returns string without vowels.\n  >>> getRidOfVowel('')\n  ''\n  >>> getRidOfVowel(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> getRidOfVowel('abcdef')\n  'bcdf'\n  >>> getRidOfVowel('aaaaa')\n  ''\n  >>> getRidOfVowel('aaBAA')\n  'B'\n  >>> getRidOfVowel('zbcd')\n  'zbcd'\n  */\nconst getRidOfVowel = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  let rid = text;\n  for (let i = 0; i < vowels.length; i++) {\n    if (rid.includes(vowels[i])) {\n      rid = rid.replace(vowels[i], '');\n    }\n  }\n  return rid;\n};\n\n/*\n  removeVowel is a function that takes string and returns string without vowels.\n  >>> removeVowel('abcde')\n  'abcde'\n  >>> removeVowel('abcdef')\n  'abcde'\n  >>> removeVowel('aaaaa')\n  'abcde'\n  >>> removeVowel('aaBAA')\n  'abcde'\n  >>> removeVowel('zbcd')\n  'abcde'\n  */\nconst removeVowel = (text) => {\n  let rid = text;\n  for (let i = 0; i < text.length; i++) {\n    if (rid.includes('a') && rid.includes('e') && rid.includes('i') && rid.includes('o') && rid.includes('u') && rid.includes('A') && rid.includes('E') && rid.includes('I') && rid.includes('O') && rid.includes('U')) {\n      rid = rid.replace(/a/g, '');\n      rid = rid.replace(/e/g, '');\n      rid = rid.replace(/i/g, '');\n      rid = rid.replace(/o/g, '');\n      rid = rid.replace(/u/g, '');\n    }\n  }\n  return rid;\n};\n\n/*\n  removeVowels is a function that takes string and returns string without vowels.\n  >>> removeVowels('abcde')\n  'abcde'\n  >>> removeVowels('abcdef')\n  'abcde'\n  >>> removeVowels('aaaaa')\n  'abcde'\n  >>> removeVowels('aaBAA')\n  'abcde'\n  >>> removeVowels('zbcd')\n  'abcde'\n  */\nconst removeVowels = (text) => {\n  let rid = text;\n  for (let i = 0; i < text.length; i++) {\n    if (rid.includes('a') && rid.includes('e') && rid.includes('i') && rid.includes('o') && rid.includes('u') && rid.includes('A') && rid.includes('E') && rid.includes('I') && rid.includes('O') && rid.includes('U')) {\n      rid = rid.replace(/a/g, '');\n      rid = rid.replace(/e/g, '');\n      rid = rid.replace(/i/g, '');\n      rid = rid.replace(/o/g, '');\n      rid = rid.replace(/u/g, '');\n    }\n  }\n  return rid;\n};\n\n/*\n  removeVowelsAndVowels is a function that takes string and returns string without vowels and vowels.\n  >>> removeVowelsAndVowels('abcde')\n  'abcde'\n  >>> removeVowelsAndVowels('abcdef')\n  'abcde'\n  >>> removeVowelsAndVowels('aaaaa')\n  'abcde'\n  >>> removeVowelsAndVowels('aaBAA')\n  'abcde'\n  >>> removeVowelsAndVowels('zbcd')\n  'abcde'\n  */\nconst removeVowelsAndVowels = (text) => {\n  let rid = text;\n  for (let i = 0; i < text.length; i++) {\n    if (rid.includes('a') && rid.includes('e') && rid.includes('i') && rid.includes('o') && rid.includes('u') && rid.includes('A') && rid.includes('E') && rid.includes('I') && rid.includes('O') && rid.includes('U')) {\n      rid = rid.replace(/a/g, '');\n      rid = rid.replace(/e/g, '');\n      rid = rid.replace(/i/g, '');\n      rid = rid.replace(/o/g, '');\n      rid = rid.replace(/u/g, '');\n    }\n  }\n  for (let i = 0; i < text.length; i++) {\n    if (rid.includes('A') && rid.includes('E') && rid.includes('I') && rid.includes('O') && rid.includes('U')) {\n      rid = rid.replace(/A/g, '');\n      rid = rid.replace(/E/g, '');\n      rid = rid.replace(/I/g, '');\n      rid = rid.replace(/O/g, '');\n      rid = rid.replace(/U/g, '');\n    }\n  }\n  return rid;\n};\n\n/*\n  removeVowelsAndVowelsAndVowels is a function that takes string and returns string without vowels and vowels and vowels.\n  >>> removeVowelsAndVowelsAndVowels('abcde')\n  'abcde'\n  >>> removeVowelsAndVowelsAndVowels('abcdef')\n  'abcde'\n  >>> removeVowelsAndVowelsAndVowels('aaaaa')\n  'abcde'\n  >>> removeVowelsAndVowelsAndVowels('aaBAA')\n  'abcde'\n  >>> removeVowelsAndVowelsAndVowels('zbcd')\n  'abcde'\n  */\nconst removeVowelsAndVowelsAndVowels = (text) => {\n  let rid = text;\n  for (let i = 0; i < text.length; i++) {\n    if (rid.includes('a') && rid.includes('e') && rid.includes('i') && rid.includes('o') && rid.includes('u') && rid.includes('A') && rid.includes('E') && rid.includes('I') && rid.includes('O') && rid.includes('U')) {\n      rid = rid.replace(/a/g, '');\n      rid = rid.replace(/e/g, '');\n      rid = rid.replace(/i/g, '');\n      rid = rid.replace(/o/g, '');\n      rid = rid.replace(/u/g, '');\n    }\n  }\n  for (let i = 0; i < text.length; i++) {\n    if (rid.includes('A') && rid.includes('E') && rid.includes('I') && rid.includes('O') && rid.includes('U')) {\n      rid = rid.replace(/A/g, '');\n      rid = rid.replace(/E/g, '');\n      rid = rid.replace(/I/g, '');\n      rid = rid.replace(/O/g, '');\n      rid = rid.replace(/U/g, '');\n    }\n  }\n  for (let i = 0; i < text.length; i++) {\n    if (rid.includes('a') && rid.includes('e') && rid.includes('i') && rid.includes('o') ", "passed": 0}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belowDoorway([1, 2, 4, 10], 100)\n  true\n  >>> belowDoorway([1, 20, 4, 10], 5)\n  false\n  */\nconst belowDoorway = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowDoorway", "gc": "<|endoftext|>/*Return true if all numbers in the list l are below threshold t.\n  >>> belowDoorway([1, 2, 4, 10], 100)\n  true\n  >>> belowDoorway([1, 20, 4, 10], 5)\n  false\n  */\nconst belowDoorway = (l, t) => {\n  return l.every(n => n < t);\n};\n\n/*Return true if all numbers in the list l are above threshold t.\n  >>> aboveDoorway([1, 2, 4, 10], 100)\n  true\n  >>> aboveDoorway([1, 20, 4, 10], 5)\n  false\n  */\nconst aboveDoorway = (l, t) => {\n  return l.every(n => n > t);\n};\n\n/*Return true if all numbers in the list l are equal to t.\n  >>> equal([1, 2, 4, 10], 100)\n  true\n  >>> equal([1, 20, 4, 10], 5)\n  false\n  */\nconst equal = (l, t) => {\n  return l.length === t.length &&\n    l.every((n, i) => n === t[i]);\n};\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisibleBy([1, 2, 4, 10], 100)\n  true\n  >>> divisibleBy([1, 20, 4, 10], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([1, 20, 4, 10], 5)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 5)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 100)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 5)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 5)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 5)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 100)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 5)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 5)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 5)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 5)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 5)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 5)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 5)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 5)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 5)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 5)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 5)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 5)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, 4, 10], 5)\n  true\n  >>> isMultipleOf([1, 20, 4, 10], 100)\n  false\n  */\nconst isMultipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> isMultipleOf([1, 2, ", "passed": 0}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> lend(2, 3)\n  5\n  >>> lend(5, 7)\n  12\n  */\nconst lend = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "lend", "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> lend(2, 3)\n  5\n  >>> lend(5, 7)\n  12\n  */\nconst lend = (x, y) => {\n  if (x === 0 && y === 0) {\n    return 0\n  }\n  if (x === 0 && y === Infinity) {\n    return Infinity\n  }\n  if (x === Infinity && y === 0) {\n    return 0\n  }\n  if (x === Infinity && y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 1\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === ", "passed": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same characters.\n  >>> likeChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> likeChars('abcd', 'dddddddabc')\n  true\n  >>> likeChars('dddddddabc', 'abcd')\n  true\n  >>> likeChars('eabcd', 'dddddddabc')\n  false\n  >>> likeChars('abcd', 'dddddddabce')\n  false\n  >>> likeChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst likeChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "likeChars", "gc": "<|endoftext|>/*\n  Check if two words have the same characters.\n  >>> likeChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> likeChars('abcd', 'dddddddabc')\n  true\n  >>> likeChars('dddddddabc', 'abcd')\n  true\n  >>> likeChars('eabcd', 'dddddddabc')\n  false\n  >>> likeChars('abcd', 'dddddddabce')\n  false\n  >>> likeChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst likeChars = (s0, s1) => {\n  const s0 = String(s0)\n  const s1 = String(s1)\n  if (s0.length!== s1.length) return false\n  return s0.split('').every((c, i) => {\n    return c === s1[i]\n  })\n}\n\n/*\n  Check if two words have the same characters.\n  >>> likeWords('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> likeWords('abcd', 'dddddddabc')\n  true\n  >>> likeWords('dddddddabc', 'abcd')\n  true\n  >>> likeWords('eabcd', 'dddddddabc')\n  false\n  >>> likeWords('abcd', 'dddddddabce')\n  false\n  >>> likeWords('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst likeWords = (s0, s1) => {\n  const s0 = String(s0)\n  const s1 = String(s1)\n  if (s0.length!== s1.length) return false\n  return s0.split('').every((c, i) => {\n    return c === s1[i]\n  })\n}\n\n/*\n  Check if two words have the same characters.\n  >>> likeNumbers('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> likeNumbers('abcd', 'dddddddabc')\n  true\n  >>> likeNumbers('dddddddabc', 'abcd')\n  true\n  >>> likeNumbers('eabcd', 'dddddddabc')\n  false\n  >>> likeNumbers('abcd', 'dddddddabce')\n  false\n  >>> likeNumbers('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst likeNumbers = (s0, s1) => {\n  const s0 = String(s0)\n  const s1 = String(s1)\n  if (s0.length!== s1.length) return false\n  return s0.split('').every((c, i) => {\n    return c === s1[i]\n  })\n}\n\n/*\n  Check if two words have the same characters.\n  >>> likeLetters('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> likeLetters('abcd', 'dddddddabc')\n  true\n  >>> likeLetters('dddddddabc', 'abcd')\n  true\n  >>> likeLetters('eabcd', 'dddddddabc')\n  false\n  >>> likeLetters('abcd', 'dddddddabce')\n  false\n  >>> likeLetters('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst likeLetters = (s0, s1) => {\n  const s0 = String(s0)\n  const s1 = String(s1)\n  if (s0.length!== s1.length) return false\n  return s0.split('').every((c, i) => {\n    return c === s1[i]\n  })\n}\n\n/*\n  Check if two words have the same characters.\n  >>> likeSymbols('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> likeSymbols('abcd', 'dddddddabc')\n  true\n  >>> likeSymbols('dddddddabc', 'abcd')\n  true\n  >>> likeSymbols('eabcd', 'dddddddabc')\n  false\n  >>> likeSymbols('abcd', 'dddddddabce')\n  false\n  >>> likeSymbols('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst likeSymbols = (s0, s1) => {\n  const s0 = String(s0)\n  const s1 = String(s1)\n  if (s0.length!== s1.length) return false\n  return s0.split('').every((c, i) => {\n    return c === s1[i]\n  })\n}\n\n/*\n  Check if two words have the same characters.\n  >>> likePunctuation('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> likePunctuation('abcd', 'dddddddabc')\n  true\n  >>> likePunctuation('dddddddabc', 'abcd')\n  true\n  >>> likePunctuation('eabcd', 'dddddddabc')\n  false\n  >>> likePunctuation('abcd', 'dddddddabce')\n  false\n  >>> likePunctuation('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst likePunctuation = (s0, s1) => {\n  const s0 = String(s0)\n  const s1 = String(s1)\n  if (s0.length!== s1.length) return false\n  return s0.split('').every((c, i) => {\n    return c === s1[i]\n  })\n}\n\n/*\n  Check if two words have the same characters.\n  >>> likeNumbers('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> likeNumbers('abcd', 'dddddddabc')\n  true\n  >>> likeNumbers('dddddddabc', 'abcd')\n  true\n  >>> likeNumbers('eabcd', 'dddddddabc')\n  false\n  >>> likeNumbers('abcd', 'dddddddabce')\n  false\n  >>> likeNumbers('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst likeNumbers = (s0, s1) => {\n  const s0 = String(s0)\n  const s1 = String(s1)\n  if (s0.length!== s1.length) return false\n  return s0.split('').every((c, i) => {\n    return c === s1[i]\n  })\n}\n\n/*\n  Check if two words have the same characters.\n  >>> likeLetters('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> likeLetters('abcd', 'dddddddabc')\n  true\n  >>> likeLetters('dddddddabc', 'abcd')\n  true\n  >>> likeLetters('eabcd', 'dddddddabc')\n  false\n  >>> likeLetters('abcd', 'dddddddabce')\n  false\n  >>> likeLetters('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst likeLetters = (s0, s1) => {\n  const s0 = String(s0)\n  const s1 = String(s1)\n  if (s0.length!== s1.length) return false\n  return s0.split('').every((c, i) => {\n    return c === s1[i]\n  })\n}\n\n/*\n  Check if two words have the same characters.\n  >>> likeSymbols('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> likeSymbols('abcd', 'dddddddabc')\n  true\n  >>> likeSymbols('dddddddabc', 'abcd')\n  true\n  >>> likeSymbols('eabcd', 'dddddddabc')\n  false\n  >>> likeSymbols('abcd', 'dddddddabce')\n  false\n  >>> likeSymbols('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst likeSymbols = (s0, s1) => {\n  const s0 = String(s0)\n  const s1 = String(s1)\n", "passed": 0}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "gc": "<|endoftext|>/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  55\n  >>> fib(5)\n  3\n  >>> fib(4)\n  1\n  >>> fib(3)\n  0\n  >>> fib(2)\n  1\n  >>> fib(1) \n  0\n*/\nconst fib2 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(2)\n  1\n  >>> fib(3)\n  0\n  >>> fib(4)\n  1\n  >>> fib(5)\n  2\n  >>> fib(6)\n  3\n  >>> fib(7)\n  4\n  >>> fib(8)\n  5\n*/\nconst fib3 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib3(7)\n  4\n  >>> fib3(6)\n  8\n  >>> fib3(5)\n  13\n  >>> fib3(4)\n  21\n  >>> fib3(3)\n  55\n  >>> fib3(2)\n  89\n  >>> fib3(1) \n  144\n*/\nconst fib4 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib4(5)\n  13\n  >>> fib4(4)\n  21\n  >>> fib4(3)\n  55\n  >>> fib4(2)\n  89\n  >>> fib4(1)\n  144\n*/\nconst fib5 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib5(7)\n  4\n  >>> fib5(6)\n  8\n  >>> fib5(5)\n  13\n  >>> fib5(4)\n  21\n  >>> fib5(3)\n  55\n  >>> fib5(2)\n  89\n  >>> fib5(1)\n  144\n*/\nconst fib6 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib6(5)\n  13\n  >>> fib6(4)\n  21\n  >>> fib6(3)\n  55\n  >>> fib6(2)\n  89\n  >>> fib6(1)\n  144\n*/\nconst fib7 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib7(6)\n  21\n  >>> fib7(5)\n  13\n  >>> fib7(4)\n  21\n  >>> fib7(3)\n  55\n  >>> fib7(2)\n  89\n  >>> fib7(1)\n  144\n*/\nconst fib8 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib8(7)\n  21\n  >>> fib8(6)\n  13\n  >>> fib8(5)\n  21\n  >>> fib8(4)\n  21\n  >>> fib8(3)\n  55\n  >>> fib8(2)\n  89\n  >>> fib8(1)\n  144\n*/\nconst fib9 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib9(7)\n  21\n  >>> fib9(6)\n  13\n  >>> fib9(5)\n  21\n  >>> fib9(4)\n  21\n  >>> fib9(3)\n  55\n  >>> fib9(2)\n  89\n  >>> fib9(1)\n  144\n*/\nconst fib10 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib10(7)\n  21\n  >>> fib10(6)\n  13\n  >>> fib10(5)\n  21\n  >>> fib10(4)\n  21\n  >>> fib10(3)\n  55\n  >>> fib10(2)\n  89\n  >>> fib10(1)\n  144\n*/\nconst fib11 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib11(7)\n  21\n  >>> fib11(6)\n  13\n  >>> fib11(5)\n  21\n  >>> fib11(4)\n  21\n  >>> fib11(3)\n  55\n  >>> fib11(2)\n  89\n  >>> fib11(1)\n  144\n*/\nconst fib12 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib12(7)\n  21\n  >>> fib12(6)\n  13\n  >>> fib12(5)\n  21\n  >>> fib12(4)\n  21\n  >>> fib12(3)\n  55\n  >>> fib12(2)\n  89\n  >>> fib12(1)\n  144\n*/\nconst fib13 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib13(7)\n  21\n  >>> fib13(6)\n  13\n  >>> fib13(5)\n  21\n  >>> fib13(4)\n  21\n  >>> fib13(3)\n  55\n  >>> fib13(2)\n  89\n  >>> fib13(1)\n  144\n*/\nconst fib14 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib14(7)\n  21\n  >>> fib14(6)\n  13\n  >>> fib14(5)\n  21\n  >>> fib14(4)\n  21\n  >>> fib14(3)\n  55\n  >>> fib14(2)\n  89\n  >>> fib14(1)\n  144\n*/\nconst fib15 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib15(7)\n  21\n  >>> fib15(6)\n  13\n  >>> fib15(5)\n  21\n  >>> fib15(4)\n  21\n  >>> fib15(3)\n  55\n  >>> fib15(2)\n  89\n  >>> fib15(1)\n  144\n*/\nconst fib16 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib16(7)\n  21\n  >>> fib16(6)\n  13\n  >>> fib16(5)\n  21\n  >>> fib16(4)\n  21\n  >>> fib16(3)\n  55\n  >>> fib16(2)\n  89\n  >>> fib16(1)\n  144\n*/\nconst fib17 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib17(7)\n  21\n  >>> fib17(6)\n  13\n", "passed": 0}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"<\")\n  false\n  >>> rightBracketing(\"<>\")\n  false\n  >>> rightBracketing(\"<<><>>\")\n  false\n  >>> rightBracketing(\"><<>\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "rightBracketing", "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"<\")\n  false\n  >>> rightBracketing(\"<>\")\n  false\n  >>> rightBracketing(\"<<><>>\")\n  false\n  >>> rightBracketing(\"><<>\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n  const openingBrackets = brackets.split(\"<\").map(x => x.trim());\n  const closingBrackets = brackets.split(\">\").map(x => x.trim());\n  return openingBrackets.every(x => closingBrackets.includes(x));\n};\n\n/**\n * Returns true if the given string is a valid HTML tag.\n *\n * <p>\n * This is an implementation of HTML5 <code>&lt;tag&gt;</code> syntax.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tags HTML tag syntax}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-definitions HTML tag definitions}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-openers HTML tag openers}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-closers HTML tag closers}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n * <p>\n * See {@link https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-attributes HTML tag attributes}.\n * </p>\n *\n", "passed": 0}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are flatally increasing or decreasing.\n  >>> flat([1, 2, 4, 20])\n  true\n  >>> flat([1, 20, 4, 10])\n  false\n  >>> flat([4, 1, 0, -10])\n  true\n  */\nconst flat = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "flat", "gc": "<|endoftext|>/*Return true is list elements are flatally increasing or decreasing.\n  >>> flat([1, 2, 4, 20])\n  true\n  >>> flat([1, 20, 4, 10])\n  false\n  >>> flat([4, 1, 0, -10])\n  true\n  */\nconst flat = (l) => {\n  return l.length === 0? false : l.every(\n    x => x === 0 || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY\n  );\n};\n\n/**\n * Returns true if the list elements are equal, false otherwise.\n * If two lists are equal, their order is preserved.\n *\n * >>> equal([1, 2, 3], [1, 2, 3])\n * true\n * >>> equal([1, 2, 3], [1, 2, 4])\n * false\n * >>> equal([1, 2, 3], [1, 3, 2])\n * false\n * >>> equal([1, 2, 3], [1, 2, 2])\n * false\n * >>> equal([1, 2, 3], [1, 2, 1])\n * false\n * >>> equal([1, 2, 3], [1, 2, 0])\n * false\n * >>> equal([1, 2, 3], [1, 2, -1])\n * false\n * >>> equal([1, 2, 3], [1, 2, -2])\n * false\n * >>> equal([1, 2, 3], [1, 2, -3])\n * false\n * >>> equal([1, 2, 3], [1, 2, -4])\n * false\n * >>> equal([1, 2, 3], [1, 2, -5])\n * false\n * >>> equal([1, 2, 3], [1, 2, -6])\n * false\n * >>> equal([1, 2, 3], [1, 2, -7])\n * false\n * >>> equal([1, 2, 3], [1, 2, -8])\n * false\n * >>> equal([1, 2, 3], [1, 2, -9])\n * false\n * >>> equal([1, 2, 3], [1, 2, -10])\n * false\n * >>> equal([1, 2, 3], [1, 2, -11])\n * false\n * >>> equal([1, 2, 3], [1, 2, -12])\n * false\n * >>> equal([1, 2, 3], [1, 2, -13])\n * false\n * >>> equal([1, 2, 3], [1, 2, -14])\n * false\n * >>> equal([1, 2, 3], [1, 2, -15])\n * false\n * >>> equal([1, 2, 3], [1, 2, -16])\n * false\n * >>> equal([1, 2, 3], [1, 2, -17])\n * false\n * >>> equal([1, 2, 3], [1, 2, -18])\n * false\n * >>> equal([1, 2, 3], [1, 2, -19])\n * false\n * >>> equal([1, 2, 3], [1, 2, -20])\n * false\n * >>> equal([1, 2, 3], [1, 2, -21])\n * false\n * >>> equal([1, 2, 3], [1, 2, -22])\n * false\n * >>> equal([1, 2, 3], [1, 2, -23])\n * false\n * >>> equal([1, 2, 3], [1, 2, -24])\n * false\n * >>> equal([1, 2, 3], [1, 2, -25])\n * false\n * >>> equal([1, 2, 3], [1, 2, -26])\n * false\n * >>> equal([1, 2, 3], [1, 2, -27])\n * false\n * >>> equal([1, 2, 3], [1, 2, -28])\n * false\n * >>> equal([1, 2, 3], [1, 2, -29])\n * false\n * >>> equal([1, 2, 3], [1, 2, -30])\n * false\n * >>> equal([1, 2, 3], [1, 2, -31])\n * false\n * >>> equal([1, 2, 3], [1, 2, -32])\n * false\n * >>> equal([1, 2, 3], [1, 2, -33])\n * false\n * >>> equal([1, 2, 3], [1, 2, -34])\n * false\n * >>> equal([1, 2, 3], [1, 2, -35])\n * false\n * >>> equal([1, 2, 3], [1, 2, -36])\n * false\n * >>> equal([1, 2, 3], [1, 2, -37])\n * false\n * >>> equal([1, 2, 3], [1, 2, -38])\n * false\n * >>> equal([1, 2, 3], [1, 2, -39])\n * false\n * >>> equal([1, 2, 3], [1, 2, -40])\n * false\n * >>> equal([1, 2, 3], [1, 2, -41])\n * false\n * >>> equal([1, 2, 3], [1, 2, -42])\n * false\n * >>> equal([1, 2, 3], [1, 2, -43])\n * false\n * >>> equal([1, 2, 3], [1, 2, -44])\n * false\n * >>> equal([1, 2, 3], [1, 2, -45])\n * false\n * >>> equal([1, 2, 3], [1, 2, -46])\n * false\n * >>> equal([1, 2, 3], [1, 2, -47])\n * false\n * >>> equal([1, 2, 3], [1, 2, -48])\n * false\n * >>> equal([1, 2, 3], [1, 2, -49])\n * false\n * >>> equal([1, 2, 3], [1, 2, -50])\n * false\n * >>> equal([1, 2, 3], [1, 2, -51])\n * false\n * >>> equal([1, 2, 3], [1, 2, -52])\n * false\n * >>> equal([1, 2, 3], [1, 2, -53])\n * false\n * >>> equal([1, 2, 3], [1, 2, -54])\n * false\n * >>> equal([1, 2, 3], [1, 2, -55])\n * false\n * >>> equal([1, 2, 3], [1, 2, -56])\n * false\n * >>> equal([1, 2, 3], [1, 2, -57])\n * false\n * >>> equal([1, 2, 3], [1, 2, -58])\n * false\n * >>> equal([1, 2, 3], [1, 2, -59])\n * false\n * >>> equal([1, 2, 3], [1, 2, -60])\n * false\n * >>> equal([1, 2, 3], [1, 2, -61])\n * false\n * >>> equal([1, 2, 3], [1, 2, -62])\n * false\n * >>> equal([1, 2, 3], [1, 2, -63])\n * false\n * >>> equal([1, 2, 3], [1, 2, -64])\n * false\n * >>> equal([1, 2, 3], [1, 2, -65])\n * false\n * >>> equal([1, 2, 3], [1, 2, -66])\n * false\n * >>> equal([1, 2, 3], [1, 2, -67])\n * false\n * >>> equal([1, 2, 3], [1, 2, -68])\n * false\n * >>> equal([1, 2, 3], [1, 2, -69])\n * false\n * >>> equal([1, 2, 3], [1, 2, -70])\n * false\n * >>> equal([1, 2, 3], [1, 2, -71])\n * false\n * >>> equal([1, 2, 3], [1, 2, -72])\n * false\n * >>> equal([1, 2, 3], [1, 2, -73])\n * false\n * >>> equal([1, 2, 3], [1, 2, -74])\n * false\n * >>> equal([1, 2, 3], [1, 2, -75])\n * false\n * >>> equal([1, 2, 3], [1, 2, -76])\n * false\n * >>> equal([1, 2, 3], [1, 2, -77])\n * false\n * >>> equal([1, 2, 3], [1, 2, -78])\n * false\n * >>> equal([1, 2, 3], [1, 2, -79])\n * false\n * >>> equal([1, 2, 3], [1, 2, -80])\n * false\n * >>> equal([1, 2, 3], [1, 2, -81])\n * false\n * >>> equal([1, 2, 3], [1, 2, -82])\n * false\n * >>> equal([1, 2, 3], [1, 2, -83])\n * false\n * >>> equal([1, 2, 3], [1, 2, -84])\n * false\n * >>> equal([1, 2, 3], [1, 2, -85])\n * false\n * >>> equal([1, 2, 3], [1, 2, -86])\n * false\n * >>> equal([1, 2, 3], [1, 2, -87])\n * false\n * >>> equal([1, 2, 3], [1, 2, -88])\n * false\n * >>> equal([1, 2, 3], [1, 2, -89])\n * false\n * >>> equal([1, 2, 3], [1, 2, -90])\n * false\n * >>> equal([1, 2, 3], [1, 2, -91])\n * false\n * >>> equal([1, 2, 3], [1, 2, -92])\n * false\n * >>> equal([1, 2, 3], [1, 2, -93])\n * false\n * >>> equal([1, 2, 3], [1, 2, -94])\n * false\n * >>> equal([1, 2, 3], [1, 2, -95])\n * false\n * >>> equal([1, 2, 3], [1, 2, -96])\n * false\n * >>> equal([1, 2, 3], [1, 2, -97])\n * false\n * >>> equal([1, 2, 3], [1, 2, -98])\n * false\n * >>> equal([1, 2, 3], [1, 2, -99])\n * false\n * >>> equal([1, 2, 3], [1, 2, -100])\n * false\n * >>> equal([1, 2, 3], [1, 2, -101])\n * false\n * >>> equal([1, 2, 3], [1, 2, -102])\n * false\n * >>> equal([1, 2, 3], [1, 2, -103])\n * false\n * >>> equal([1, 2, 3], [1, 2, -104])\n * false\n * >>> equal([1, 2, 3], [1, 2, -105])\n * false\n * >>> equal([1, 2, 3], [1, 2, -106])\n * false\n * >>> equal([1, 2, 3], [1, 2, -107])\n * ", "passed": 0}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique coarse elements for two lists.\n  >>> coarse([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> coarse([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst coarse = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "coarse", "gc": "<|endoftext|>/*Return sorted unique coarse elements for two lists.\n  >>> coarse([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> coarse([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst coarse = (l1, l2) => {\n  const set = new Set();\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    const element = l1[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    const element = l2[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  return result;\n};\n\n/*\n  Return sorted unique fine elements for two lists.\n  >>> fine([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [5, 653, 121]\n  >>> fine([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst fine = (l1, l2) => {\n  const set = new Set();\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    const element = l1[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    const element = l2[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  return result;\n};\n\n/*\n  Return sorted unique fine elements for two lists.\n  >>> fine([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [5, 653, 121]\n  >>> fine([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst fine = (l1, l2) => {\n  const set = new Set();\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    const element = l1[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    const element = l2[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  return result;\n};\n\n/*\n  Return sorted unique fine elements for two lists.\n  >>> fine([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [5, 653, 121]\n  >>> fine([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst fine = (l1, l2) => {\n  const set = new Set();\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    const element = l1[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    const element = l2[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  return result;\n};\n\n/*\n  Return sorted unique fine elements for two lists.\n  >>> fine([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [5, 653, 121]\n  >>> fine([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst fine = (l1, l2) => {\n  const set = new Set();\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    const element = l1[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    const element = l2[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  return result;\n};\n\n/*\n  Return sorted unique fine elements for two lists.\n  >>> fine([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [5, 653, 121]\n  >>> fine([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst fine = (l1, l2) => {\n  const set = new Set();\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    const element = l1[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    const element = l2[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  return result;\n};\n\n/*\n  Return sorted unique fine elements for two lists.\n  >>> fine([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [5, 653, 121]\n  >>> fine([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst fine = (l1, l2) => {\n  const set = new Set();\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    const element = l1[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    const element = l2[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  return result;\n};\n\n/*\n  Return sorted unique fine elements for two lists.\n  >>> fine([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [5, 653, 121]\n  >>> fine([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst fine = (l1, l2) => {\n  const set = new Set();\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    const element = l1[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    const element = l2[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  return result;\n};\n\n/*\n  Return sorted unique fine elements for two lists.\n  >>> fine([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [5, 653, 121]\n  >>> fine([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst fine = (l1, l2) => {\n  const set = new Set();\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    const element = l1[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    const element = l2[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  return result;\n};\n\n/*\n  Return sorted unique fine elements for two lists.\n  >>> fine([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [5, 653, 121]\n  >>> fine([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst fine = (l1, l2) => {\n  const set = new Set();\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    const element = l1[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    const element = l2[i];\n    if (!set.has(element)) {\n      set.add(element);\n      result.push(element);\n    }\n  }\n  return result;\n};\n\n/*\n  Return sorted unique fine elements for two lists.\n  >>> fine([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [5, 653, 121]\n  >>> fine([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst fine = (l1, l2) => {\n  const set = new Set();\n  const result = [];\n", "passed": 0}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> bigChoiceFactor(13195)\n  29\n  >>> bigChoiceFactor(2048)\n  2\n  */\nconst bigChoiceFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "bigChoiceFactor", "gc": "<|endoftext|>/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> bigChoiceFactor(13195)\n  29\n  >>> bigChoiceFactor(2048)\n  2\n  */\nconst bigChoiceFactor = (n) => {\n  let i = 2;\n  let j = 2;\n  let factor = 1;\n  while (true) {\n    if (n % i === 0) {\n      i += 1;\n      continue;\n    }\n    if (n % j === 0) {\n      j += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= i;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= i;\n      i += 1;\n      j += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j === 0 && n % i === 0) {\n      factor *= j;\n      j += 1;\n      i += 1;\n      continue;\n    }\n    if (n % j", "passed": 0}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "gc": "<|endoftext|>/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_remaining = [];\n  const paren_stack_remaining_size = 0;\n  const paren_stack_remaining_remaining = [];\n  let paren_stack_remaining_remaining_index = 0;\n\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n\n    if (char === '(') {\n      paren_stack.push(paren_stack_remaining);\n      paren_stack_remaining_size++;\n      paren_stack_remaining_remaining = [];\n      paren_stack_remaining_remaining_index = 0;\n    } else if (char === ')') {\n      paren_stack_remaining_remaining_index++;\n      if (paren_stack_remaining_remaining_index === paren_stack_remaining_size) {\n        paren_stack_remaining_remaining_index = 0;\n        paren_stack_remaining_remaining.push(paren_stack);\n        paren_stack = [];\n        paren_stack_size = 0;\n      }\n    } else if (char ==='') {\n      if (paren_stack_remaining_remaining_index < paren_stack_remaining_size) {\n        paren_stack_remaining_remaining.push(paren_stack);\n        paren_stack = [];\n        paren_stack_size = 0;\n      }\n    } else {\n      paren_stack.push(char);\n    }\n  }\n\n  if (paren_stack_remaining_remaining_index < paren_stack_remaining_size) {\n    paren_stack_remaining_remaining.push(paren_stack);\n    paren_stack = [];\n    paren_stack_size = 0;\n  }\n\n  return paren_stack_remaining_remaining;\n};\n\nconst parseNestedParensAsArray = (paren_string) => {\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_remaining = [];\n  const paren_stack_remaining_size = 0;\n  const paren_stack_remaining_remaining = [];\n  let paren_stack_remaining_remaining_index = 0;\n\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n\n    if (char === '(') {\n      paren_stack.push(paren_stack_remaining);\n      paren_stack_remaining_size++;\n      paren_stack_remaining_remaining = [];\n      paren_stack_remaining_remaining_index = 0;\n    } else if (char === ')') {\n      paren_stack_remaining_remaining_index++;\n      if (paren_stack_remaining_remaining_index === paren_stack_remaining_size) {\n        paren_stack_remaining_remaining_index = 0;\n        paren_stack_remaining_remaining.push(paren_stack);\n        paren_stack = [];\n        paren_stack_size = 0;\n      }\n    } else if (char ==='') {\n      if (paren_stack_remaining_remaining_index < paren_stack_remaining_size) {\n        paren_stack_remaining_remaining.push(paren_stack);\n        paren_stack = [];\n        paren_stack_size = 0;\n      }\n    } else {\n      paren_stack.push(char);\n    }\n  }\n\n  if (paren_stack_remaining_remaining_index < paren_stack_remaining_size) {\n    paren_stack_remaining_remaining.push(paren_stack);\n    paren_stack = [];\n    paren_stack_size = 0;\n  }\n\n  return paren_stack_remaining_remaining;\n};\n\nconst parseNestedParensAsString = (paren_string) => {\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_remaining = [];\n  const paren_stack_remaining_size = 0;\n  const paren_stack_remaining_remaining = [];\n  let paren_stack_remaining_remaining_index = 0;\n\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n\n    if (char === '(') {\n      paren_stack.push(paren_stack_remaining);\n      paren_stack_remaining_size++;\n      paren_stack_remaining_remaining = [];\n      paren_stack_remaining_remaining_index = 0;\n    } else if (char === ')') {\n      paren_stack_remaining_remaining_index++;\n      if (paren_stack_remaining_remaining_index === paren_stack_remaining_size) {\n        paren_stack_remaining_remaining_index = 0;\n        paren_stack_remaining_remaining.push(paren_stack);\n        paren_stack = [];\n        paren_stack_size = 0;\n      }\n    } else if (char ==='') {\n      if (paren_stack_remaining_remaining_index < paren_stack_remaining_size) {\n        paren_stack_remaining_remaining.push(paren_stack);\n        paren_stack = [];\n        paren_stack_size = 0;\n      }\n    } else {\n      paren_stack.push(char);\n    }\n  }\n\n  if (paren_stack_remaining_remaining_index < paren_stack_remaining_size) {\n    paren_stack_remaining_remaining.push(paren_stack);\n    paren_stack = [];\n    paren_stack_size = 0;\n  }\n\n  return paren_stack_remaining_remaining.join('');\n};\n\nconst parseNestedParensAsObject = (paren_string) => {\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_remaining = [];\n  const paren_stack_remaining_size = 0;\n  const paren_stack_remaining_remaining = [];\n  let paren_stack_remaining_remaining_index = 0;\n\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n\n    if (char === '(') {\n      paren_stack.push(paren_stack_remaining);\n      paren_stack_remaining_size++;\n      paren_stack_remaining_remaining = [];\n      paren_stack_remaining_remaining_index = 0;\n    } else if (char === ')') {\n      paren_stack_remaining_remaining_index++;\n      if (paren_stack_remaining_remaining_index === paren_stack_remaining_size) {\n        paren_stack_remaining_remaining_index = 0;\n        paren_stack_remaining_remaining.push(paren_stack);\n        paren_stack = [];\n        paren_stack_size = 0;\n      }\n    } else if (char ==='') {\n      if (paren_stack_remaining_remaining_index < paren_stack_remaining_size) {\n        paren_stack_remaining_remaining.push(paren_stack);\n        paren_stack = [];\n        paren_stack_size = 0;\n      }\n    } else {\n      paren_stack.push(char);\n    }\n  }\n\n  if (paren_stack_remaining_remaining_index < paren_stack_remaining_size) {\n    paren_stack_remaining_remaining.push(paren_stack);\n    paren_stack = [];\n    paren_stack_size = 0;\n  }\n\n  return paren_stack_remaining_remaining;\n};\n\nconst parseNestedParensAsArrayAsObject = (paren_string) => {\n  const paren_stack = [];\n  const paren_stack_size = 0;\n  const paren_stack_remaining = [];\n  const paren_stack_remaining_size = 0;\n  const paren_stack_remaining_remaining = [];\n  let paren_stack_remaining_remaining_index = 0;\n\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n\n    if (char === '(') {\n      paren_stack.push(paren_stack_remaining);\n      paren_stack_remaining_size++;\n      paren_stack_remaining_remaining = [];\n      paren_stack_remaining_remaining_index = 0;\n    } else if (char === ')') {\n      ", "passed": 0}
{"task_id": "JavaScript/60", "prompt": "/*summarizeToN is a function that sums numbers from 1 to n.\n  >>> summarizeToN(30)\n  465\n  >>> summarizeToN(100)\n  5050\n  >>> summarizeToN(5)\n  15\n  >>> summarizeToN(10)\n  55\n  >>> summarizeToN(1)\n  1\n  */\nconst summarizeToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "summarizeToN", "gc": "<|endoftext|>/*summarizeToN is a function that sums numbers from 1 to n.\n  >>> summarizeToN(30)\n  465\n  >>> summarizeToN(100)\n  5050\n  >>> summarizeToN(5)\n  15\n  >>> summarizeToN(10)\n  55\n  >>> summarizeToN(1)\n  1\n  */\nconst summarizeToN = (n) => {\n  let sum = 0;\n  let i;\n  for (i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that takes an array of numbers and returns an array of\n * numbers in descending order.\n *\n * For example, [3,2,1] is [3,2,1] in descending order.\n *\n * It also works with negative numbers.\n *\n * It also works with floating point numbers.\n *\n * It also works with negative floating point numbers.\n *\n * It also works with negative and floating point numbers.\n *\n * It also works with negative and floating point numbers and negative and\n * floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative and floating point numbers and negative\n * and floating point numbers and negative ", "passed": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"(\")\n  false\n  >>> rightBracketing(\"()\")\n  true\n  >>> rightBracketing(\"(()())\")\n  true\n  >>> rightBracketing(\")(()\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "rightBracketing", "gc": "<|endoftext|>/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"(\")\n  false\n  >>> rightBracketing(\"()\")\n  true\n  >>> rightBracketing(\"(()())\")\n  true\n  >>> rightBracketing(\")(()\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n  return brackets.every(bracket => bracket.match(/\\)$/));\n};\n\n/**\n  Returns true if a pair of brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> leftBracketing(\"((\")\n  false\n  >>> leftBracketing(\"()(\")\n  true\n  >>> leftBracketing(\"(()())\")\n  true\n  >>> leftBracketing(\"(())()\")\n  false\n  */\nconst leftBracketing = (brackets) => {\n  return brackets.every(bracket => bracket.match(/\\)$/));\n};\n\n/**\n  Returns true if a pair of brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"((\")\n  false\n  >>> rightBracketing(\"()(\")\n  true\n  >>> rightBracketing(\"(()())\")\n  true\n  >>> rightBracketing(\"(())()\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n  return brackets.every(bracket => bracket.match(/\\)$/));\n};\n\n/**\n  Returns true if a pair of brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> leftBracketing(\"((\")\n  false\n  >>> leftBracketing(\"()(\")\n  true\n  >>> leftBracketing(\"(()())\")\n  true\n  >>> leftBracketing(\"(())()\")\n  false\n  */\nconst leftBracketing = (brackets) => {\n  return brackets.every(bracket => bracket.match(/\\)$/));\n};\n\n/**\n  Returns true if a pair of brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"((\")\n  false\n  >>> rightBracketing(\"()(\")\n  true\n  >>> rightBracketing(\"(()())\")\n  true\n  >>> rightBracketing(\"(())()\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n  return brackets.every(bracket => bracket.match(/\\)$/));\n};\n\n/**\n  Returns true if a pair of brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> leftBracketing(\"((\")\n  false\n  >>> leftBracketing(\"()(\")\n  true\n  >>> leftBracketing(\"(()())\")\n  true\n  >>> leftBracketing(\"(())()\")\n  false\n  */\nconst leftBracketing = (brackets) => {\n  return brackets.every(bracket => bracket.match(/\\)$/));\n};\n\n/**\n  Returns true if a pair of brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"((\")\n  false\n  >>> rightBracketing(\"()(\")\n  true\n  >>> rightBracketing(\"(()())\")\n  true\n  >>> rightBracketing(\"(())()\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n  return brackets.every(bracket => bracket.match(/\\)$/));\n};\n\n/**\n  Returns true if a pair of brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> leftBracketing(\"((\")\n  false\n  >>> leftBracketing(\"()(\")\n  true\n  >>> leftBracketing(\"(()())\")\n  true\n  >>> leftBracketing(\"(())()\")\n  false\n  */\nconst leftBracketing = (brackets) => {\n  return brackets.every(bracket => bracket.match(/\\)$/));\n};\n\n/**\n  Returns true if a pair of brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"((\")\n  false\n  >>> rightBracketing(\"()(\")\n  true\n  >>> rightBracketing(\"(()())\")\n  true\n  >>> rightBracketing(\"(())()\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n  return brackets.every(bracket => bracket.match(/\\)$/));\n};\n\n/**\n  Returns true if a pair of brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> leftBracketing(\"((\")\n  false\n  >>> leftBracketing(\"()(\")\n  true\n  >>> leftBracketing(\"(()())\")\n  true\n  >>> leftBracketing(\"(())()\")\n  false\n  */\nconst leftBracketing = (brackets) => {\n  return brackets.every(bracket => bracket.match(/\\)$/));\n};\n\n/**\n  Returns true if a pair of brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"((\")\n  false\n  >>> rightBracketing(\"()(\")\n  true\n  >>> rightBracketing(\"(()())\")\n  true\n  >>> rightBracketing(\"(())()\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n  return brackets.every(bracket => bracket.match(/\\)$/));\n};\n\n/**\n  Returns true if a pair of brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> leftBracketing(\"((\")\n  false\n  >>> leftBracketing(\"()(\")\n  true\n  >>> leftBracketing(\"(()())\")\n  true\n  >>> leftBracketing(\"(())()\")\n  false\n  */\nconst leftBracketing = (brackets) => {\n  return brackets.every(bracket => bracket.match(/\\)$/));\n};\n\n/**\n  Returns true if a pair of brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"((\")\n  false\n  >>> rightBracketing(\"()(\")\n  true\n  >>> rightBracketing(\"(()())\")\n  true\n  >>> rightBracketing(\"(())()\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n  return brackets.every(bracket => bracket.match(/\\)$/));\n};\n\n/**\n  Returns true if a pair of brackets is a string of \"(\" and \")\".\n  return true if every opening bracket ", "passed": 0}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "gc": "<|endoftext|>/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += xs[i] * xs[i];\n  }\n  return sum;\n};\n\n// Returns true if x is even\nconst isEven = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is odd\nconst isOdd = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 2\nconst isDivisibleBy2 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 3\nconst isDivisibleBy3 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 4\nconst isDivisibleBy4 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 5\nconst isDivisibleBy5 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 6\nconst isDivisibleBy6 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 7\nconst isDivisibleBy7 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 8\nconst isDivisibleBy8 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 9\nconst isDivisibleBy9 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 10\nconst isDivisibleBy10 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 11\nconst isDivisibleBy11 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 12\nconst isDivisibleBy12 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 13\nconst isDivisibleBy13 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 14\nconst isDivisibleBy14 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 15\nconst isDivisibleBy15 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 16\nconst isDivisibleBy16 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 17\nconst isDivisibleBy17 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 18\nconst isDivisibleBy18 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 19\nconst isDivisibleBy19 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 20\nconst isDivisibleBy20 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 21\nconst isDivisibleBy21 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 22\nconst isDivisibleBy22 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 23\nconst isDivisibleBy23 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 24\nconst isDivisibleBy24 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 25\nconst isDivisibleBy25 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 26\nconst isDivisibleBy26 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 27\nconst isDivisibleBy27 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 28\nconst isDivisibleBy28 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 29\nconst isDivisibleBy29 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 30\nconst isDivisibleBy30 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 31\nconst isDivisibleBy31 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 32\nconst isDivisibleBy32 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 33\nconst isDivisibleBy33 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 34\nconst isDivisibleBy34 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 35\nconst isDivisibleBy35 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 36\nconst isDivisibleBy36 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 37\nconst isDivisibleBy37 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 38\nconst isDivisibleBy38 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 39\nconst isDivisibleBy39 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 40\nconst isDivisibleBy40 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 41\nconst isDivisibleBy41 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 42\nconst isDivisibleBy42 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 43\nconst isDivisibleBy43 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 44\nconst isDivisibleBy44 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 45\nconst isDivisibleBy45 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 46\nconst isDivisibleBy46 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 47\nconst isDivisibleBy47 = (x) => {\n  return x % 2!== 0;\n};\n\n// Returns true if x is divisible by 48\nconst isDivisibleBy48 = (x) => {\n  return x % 2 === 0;\n};\n\n// Returns true if x is divisible by 49\nconst isDivisibleBy49 = (x) => {\n  return x % 2!== 0;\n};\n\n", "passed": 0}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "gc": "<|endoftext|>/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two terms are 0 and 1.\n  >>> fibfib(0)\n  0\n  >>> fibfib(1)\n  1\n  >>> fibfib(2)\n  1\n  >>> fibfib(3)\n  2\n  >>> fibfib(4)\n  3\n  >>> fibfib(5)\n  5\n  >>> fibfib(6)\n  8\n  >>> fibfib(7)\n  13\n  >>> fibfib(8)\n  21\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two terms are 0 and 1.\n  >>> fibfib(0)\n  0\n  >>> fibfib(1)\n  1\n  >>> fibfib(2)\n  1\n  >>> fibfib(3)\n  2\n  >>> fibfib(4)\n  3\n  >>> fibfib(5)\n  5\n  >>> fibfib(6)\n  8\n  >>> fibfib(7)\n  13\n  >>> fibfib(8)\n  21\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two terms are 0 and 1.\n  >>> fibfib(0)\n  0\n  >>> fibfib(1)\n  1\n  >>> fibfib(2)\n  1\n  >>> fibfib(3)\n  2\n  >>> fibfib(4)\n  3\n  >>> fibfib(5)\n  5\n  >>> fibfib(6)\n  8\n  >>> fibfib(7)\n  13\n  >>> fibfib(8)\n  21\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two terms are 0 and 1.\n  >>> fibfib(0)\n  0\n  >>> fibfib(1)\n  1\n  >>> fibfib(2)\n  1\n  >>> fibfib(3)\n  2\n  >>> fibfib(4)\n  3\n  >>> fibfib(5)\n  5\n  >>> fibfib(6)\n  8\n  >>> fibfib(7)\n  13\n  >>> fibfib(8)\n  21\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two terms are 0 and 1.\n  >>> fibfib(0)\n  0\n  >>> fibfib(1)\n  1\n  >>> fibfib(2)\n  1\n  >>> fibfib(3)\n  2\n  >>> fibfib(4)\n  3\n  >>> fibfib(5)\n  5\n  >>> fibfib(6)\n  8\n  >>> fibfib(7)\n  13\n  >>> fibfib(8)\n  21\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two terms are 0 and 1.\n  >>> fibfib(0)\n  0\n  >>> fibfib(1)\n  1\n  >>> fibfib(2)\n  1\n  >>> fibfib(3)\n  2\n  >>> fibfib(4)\n  3\n  >>> fibfib(5)\n  5\n  >>> fibfib(6)\n  8\n  >>> fibfib(7)\n  13\n  >>> fibfib(8)\n  21\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two terms are 0 and 1.\n  >>> fibfib(0)\n  0\n  >>> fibfib(1)\n  1\n  >>> fibfib(2)\n  1\n  >>> fibfib(3)\n  2\n  >>> fibfib(4)\n  3\n  >>> fibfib(5)\n  5\n  >>> fibfib(6)\n  8\n  >>> fibfib(7)\n  13\n  >>> fibfib(8)\n  21\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two terms are 0 and 1.\n  >>> fibfib(0)\n  0\n  >>> fibfib(1)\n  1\n  >>> fibfib(2)\n  1\n  >>> fibfib(3)\n  2\n  >>> fibfib(4)\n  3\n  >>> fibfib(5)\n  5\n  >>> fibfib(6)\n  8\n  >>> fibfib(7)\n  13\n  >>> fibfib(8)\n  21\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two terms are 0 and 1.\n  >>> fibfib(0)\n  0\n  >>> fibfib(1)\n  1\n  >>> fibfib(2)\n  1\n  >>> fibfib(3)\n  2\n  >>> fibfib(4)\n  3\n  >>> fibfib(5)\n  5\n  >>> fibfib(6)\n  8\n  >>> fibfib(7)\n  13\n  >>> fibfib(8)\n  21\n  */\nconst fibfib = (n) => {\n  if (n < 2) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two terms are 0 and 1.\n  >>> fibfib(0)\n  0\n  >>> fibfib(1)\n  1\n  >>> fibfib(2)\n  1\n  >>> fibfib(3)\n  2\n  >>> fibfib(4)\n  3\n  >>> fib", "passed": 0}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelReckon which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelReckon(\"abcde\")\n  2\n  >>> vowelReckon(\"ACEDY\")\n  3\n  */\nconst vowelReckon = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelReckon", "gc": "<|endoftext|>/*Write a function vowelReckon which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelReckon(\"abcde\")\n  2\n  >>> vowelReckon(\"ACEDY\")\n  3\n  */\nconst vowelReckon = (s) => {\n  let vowels = 0;\n  let vowelsEnd = 0;\n  let vowelsStart = 0;\n  let vowelsEndStart = 0;\n  let vowelsEndEnd = 0;\n  let vowelsStartEnd = 0;\n  let vowelsEndStartEnd = 0;\n  let vowelsEndEndEnd = 0;\n  let vowelsStartEndEnd = 0;\n  let vowelsEndEndEnd = 0;\n  let vowelsStartEndEndEnd = 0;\n  let vowelsEndEndEndEnd = 0;\n  let vowelsStartEndEndEnd = 0;\n  let vowelsEndEndEndEnd = 0;\n  let vowelsStartEndEndEnd = 0;\n  let vowelsEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd", "passed": 0}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> roundShift(12, 1)\n  \"21\"\n  >>> roundShift(12, 2)\n  \"12\"\n  */\nconst roundShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "roundShift", "gc": "<|endoftext|>/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> roundShift(12, 1)\n  \"21\"\n  >>> roundShift(12, 2)\n  \"12\"\n  */\nconst roundShift = (x, shift) => {\n  if (shift > x.length) {\n    return x.toString().split('').reverse().join('');\n  }\n  return x.toString().split('').reverse().slice(shift).join('');\n};\n\n/**\n * Rounds down to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundDownToNearest = (n) => {\n  return Math.ceil(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10) + 1));\n};\n\n/**\n * Rounds up to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundUpToNearest = (n) => {\n  return Math.floor(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds down to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundDownTo = (n) => {\n  return Math.ceil(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds up to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundUpTo = (n) => {\n  return Math.floor(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds down to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundDownToZero = (n) => {\n  return Math.ceil(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds up to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundUpToZero = (n) => {\n  return Math.floor(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds down to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundTo = (n) => {\n  return Math.ceil(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds up to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundUpTo = (n) => {\n  return Math.floor(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds down to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundToZero = (n) => {\n  return Math.ceil(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds up to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundUpToZero = (n) => {\n  return Math.floor(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds down to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundToNearest = (n) => {\n  return Math.ceil(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds up to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundUpToNearest = (n) => {\n  return Math.floor(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds down to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundToEven = (n) => {\n  return Math.ceil(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds up to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundUpToEven = (n) => {\n  return Math.floor(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds down to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundToDividedBy = (n) => {\n  return Math.ceil(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds up to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundUpToDividedBy = (n) => {\n  return Math.floor(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds down to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundToPower = (n, power) => {\n  return Math.ceil(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10) + power));\n};\n\n/**\n * Rounds up to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundUpToPower = (n, power) => {\n  return Math.floor(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10) + power));\n};\n\n/**\n * Rounds down to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundToPower = (n, power) => {\n  return Math.ceil(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10) + power));\n};\n\n/**\n * Rounds up to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundUpToPower = (n, power) => {\n  return Math.floor(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10) + power));\n};\n\n/**\n * Rounds down to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundToNearestPowerOfTwo = (n) => {\n  return Math.ceil(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds up to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundUpToNearestPowerOfTwo = (n) => {\n  return Math.floor(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds down to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundToNearestPowerOfTwo = (n) => {\n  return Math.ceil(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds down to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundUpToNearestPowerOfTwo = (n) => {\n  return Math.floor(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds down to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundToZero = (n) => {\n  return Math.ceil(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds up to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundUpToZero = (n) => {\n  return Math.floor(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds down to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundToNearestPowerOfTwo = (n) => {\n  return Math.ceil(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds up to the nearest multiple of n.\n * @param {number} n\n * @return {number}\n */\nconst roundUpToNearestPowerOfTwo = (n) => {\n  return Math.floor(n / Math.pow(10, Math.floor(Math.log(Math.abs(n)) / Math.LN10)));\n};\n\n/**\n * Rounds down to the ", "passed": 0}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      fingerSum(\"helloE\") => 69\n      fingerSum(\"woArBld\") => 131\n      fingerSum(\"aAaaaXa\") => 153\n  */\nconst fingerSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "fingerSum", "gc": "<|endoftext|>/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      fingerSum(\"helloE\") => 69\n      fingerSum(\"woArBld\") => 131\n      fingerSum(\"aAaaaXa\") => 153\n  */\nconst fingerSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      fingerSum(\"helloE\") => 69\n      fingerSum(\"woArBld\") => 131\n      fingerSum(\"aAaaaXa\") => 153\n  */\nconst fingerSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumLower(\"\") => 0\n      fingerSumLower(\"abAB\") => 131\n      fingerSumLower(\"abcCd\") => 67\n      fingerSumLower(\"helloE\") => 69\n      fingerSumLower(\"woArBld\") => 131\n      fingerSumLower(\"aAaaaXa\") => 153\n  */\nconst fingerSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumUpper(\"\") => 0\n      fingerSumUpper(\"abAB\") => 131\n      fingerSumUpper(\"abcCd\") => 67\n      fingerSumUpper(\"helloE\") => 69\n      fingerSumUpper(\"woArBld\") => 131\n      fingerSumUpper(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpper = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumLower(\"\") => 0\n      fingerSumLower(\"abAB\") => 131\n      fingerSumLower(\"abcCd\") => 67\n      fingerSumLower(\"helloE\") => 69\n      fingerSumLower(\"woArBld\") => 131\n      fingerSumLower(\"aAaaaXa\") => 153\n  */\nconst fingerSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumUpper(\"\") => 0\n      fingerSumUpper(\"abAB\") => 131\n      fingerSumUpper(\"abcCd\") => 67\n      fingerSumUpper(\"helloE\") => 69\n      fingerSumUpper(\"woArBld\") => 131\n      fingerSumUpper(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumLower(\"\") => 0\n      fingerSumLower(\"abAB\") => 131\n      fingerSumLower(\"abcCd\") => 67\n      fingerSumLower(\"helloE\") => 69\n      fingerSumLower(\"woArBld\") => 131\n      fingerSumLower(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumUpper(\"\") => 0\n      fingerSumUpper(\"abAB\") => 131\n      fingerSumUpper(\"abcCd\") => 67\n      fingerSumUpper(\"helloE\") => 69\n      fingerSumUpper(\"woArBld\") => 131\n      fingerSumUpper(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpperUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumLower(\"\") => 0\n      fingerSumLower(\"abAB\") => 131\n      fingerSumLower(\"abcCd\") => 67\n      fingerSumLower(\"helloE\") => 69\n      fingerSumLower(\"woArBld\") => 131\n      fingerSumLower(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpperUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumUpper(\"\") => 0\n      fingerSumUpper(\"abAB\") => 131\n      fingerSumUpper(\"abcCd\") => 67\n      fingerSumUpper(\"helloE\") => 69\n      fingerSumUpper(\"woArBld\") => 131\n      fingerSumUpper(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpperUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      fingerSumUpper(\"\") => 0\n      fingerSumUpper(\"abAB\") => 131\n      fingerSumUpper(\"abcCd\") => 67\n      fingerSumUpper(\"helloE\") => 69\n      fingerSumUpper(\"woArBld\") => 131\n      fingerSumUpper(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpperUpperUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ", "passed": 0}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "yieldDistribution", "gc": "<|endoftext|>/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \").length;\n  for (let i = 0; i < fruits; i++) {\n    if (s.includes(`apples ${i}`)) {\n      apples++;\n    } else if (s.includes(`oranges ${i}`)) {\n      oranges++;\n    } else if (s.includes(`mango ${i}`)) {\n      mango++;\n    }\n  }\n  total = apple + oranges + mango;\n  return total;\n};\n\n/*\n  Given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \").length;\n  for (let i = 0; i < fruits; i++) {\n    if (s.includes(`apples ${i}`)) {\n      apples++;\n    } else if (s.includes(`oranges ${i}`)) {\n      oranges++;\n    } else if (s.includes(`mango ${i}`)) {\n      mango++;\n    }\n  }\n  total = apple + oranges + mango;\n  return total;\n};\n\n/*\n  Given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \").length;\n  for (let i = 0; i < fruits; i++) {\n    if (s.includes(`apples ${i}`)) {\n      apples++;\n    } else if (s.includes(`oranges ${i}`)) {\n      oranges++;\n    } else if (s.includes(`mango ${i}`)) {\n      mango++;\n    }\n  }\n  total = apple + oranges + mango;\n  return total;\n};\n\n/*\n  Given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \").length;\n  for (let i = 0; i < fruits; i++) {\n    if (s.includes(`apples ${i}`)) {\n      apples++;\n    } else if (s.includes(`oranges ${i}`)) {\n      oranges++;\n    } else if (s.includes(`mango ${i}`)) {\n      mango++;\n    }\n  }\n  total = apple + oranges + mango;\n  return total;\n};\n\n/*\n  Given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \").length;\n  for (let i = 0; i < fruits; i++) {\n    if (s.includes(`apples ${i}`)) {\n      apples++;\n    } else if (s.includes(`oranges ${i}`)) {\n      oranges++;\n    } else if (s.includes(`mango ${i}`)) {\n      mango++;\n    }\n  }\n  total = apple + oranges + mango;\n  return total;\n};\n\n/*\n  Given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let ", "passed": 0}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to hustle one of the nodes and return it.\n  The hustleed node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The hustleed node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst hustle = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "hustle", "gc": "<|endoftext|>/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to hustle one of the nodes and return it.\n  The hustleed node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The hustleed node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst hustle = (arr) => {\n  const len = arr.length;\n  let result = [];\n  let minEven = arr[0];\n  let minIndex = -1;\n  for (let i = 1; i < len; i++) {\n    if (arr[i] % 2 === 0) {\n      if (minEven < arr[i]) {\n        minEven = arr[i];\n        minIndex = i;\n      }\n    }\n  }\n  if (minIndex === -1) {\n    return result;\n  }\n  return [minEven, minIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes,\n// your task is to return the minimum node in the tree that has value 0.\n// The minimum node should be the node with the smallest value.\n// If multiple nodes with the same smallest value are found return the node that has smallest index.\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst min = (arr) => {\n  const len = arr.length;\n  let result = [];\n  let minEven = arr[0];\n  let minIndex = -1;\n  for (let i = 1; i < len; i++) {\n    if (arr[i] % 2 === 0) {\n      if (minEven < arr[i]) {\n        minEven = arr[i];\n        minIndex = i;\n      }\n    }\n  }\n  if (minIndex === -1) {\n    return result;\n  }\n  return [minEven, minIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes,\n// your task is to return the maximum node in the tree that has value 0.\n// The maximum node should be the node with the largest value.\n// If multiple nodes with the same largest value are found return the node that has largest index.\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the largest value, and 2 has the largest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the largest value, and 2 has the largest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the largest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the largest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst max = (arr) => {\n  const len = arr.length;\n  let result = [];\n  let maxEven = arr[0];\n  let maxIndex = -1;\n  for (let i = 1; i < len; i++) {\n    if (arr[i] % 2 === 0) {\n      if (maxEven > arr[i]) {\n        maxEven = arr[i];\n        maxIndex = i;\n      }\n    }\n  }\n  if (maxIndex === -1) {\n    return result;\n  }\n  return [maxEven, maxIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes,\n// your task is to return the minimum node in the tree that has value 0.\n// The minimum node should be the node with the smallest value.\n// If multiple nodes with the same smallest value are found return the node that has smallest index.\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst minIndex = (arr) => {\n  const len = arr.length;\n  let result = [];\n  let minEven = arr[0];\n  let minIndex = -1;\n  for (let i = 1; i < len; i++) {\n    if (arr[i] % 2 === 0) {\n      if (minEven < arr[i]) {\n        minEven = arr[i];\n        minIndex = i;\n      }\n    }\n  }\n  if (minIndex === -1) {\n    return result;\n  }\n  return [minEven, minIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes,\n// your task is to return the maximum node in the tree that has value 0.\n// The maximum node should be the node with the largest value.\n// If multiple nodes with the same largest value are found return the node that has largest index.\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the largest value, and 2 has the largest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the largest value, and 2 has the largest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the largest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the largest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst maxIndex = (arr) => {\n  const len = arr.length;\n  let result = [];\n  let maxEven = arr[0];\n  let maxIndex = -1;\n  for (let i = 1; i < len; i++) {\n    if (arr[i] % 2 === 0) {\n      if (maxEven > arr[i]) {\n        maxEven = arr[i];\n        maxIndex = i;\n      }\n    }\n  }\n  if (maxIndex === -1) {\n    return result;\n  }\n  return [maxEven, maxIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes,\n// your task is to return the minimum node in the tree that has value 0.\n// The minimum node should be the node with the smallest value.\n// If multiple nodes with the same smallest value are found return the node that has smallest index.\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     ", "passed": 0}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      research([4, 1, 2, 2, 3, 1])) == 2\n      research([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      research([5, 5, 4, 4, 4])) == -1\n  */\nconst research = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "research", "gc": "<|endoftext|>/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      research([4, 1, 2, 2, 3, 1])) == 2\n      research([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      research([5, 5, 4, 4, 4])) == -1\n  */\nconst research = (lst) => {\n  let max = 0;\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      count = i;\n    }\n  }\n  return max;\n};\n\nmodule.exports = research;\n\n},{}],3:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the sum of all the positive integers in the list.\n  Examples:\n      sum([4, 1, 2, 2, 3, 1]) = 5\n      sum([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 15\n      sum([5, 5, 4, 4, 4]) = 25\n  */\nconst sum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nmodule.exports = sum;\n\n},{}],4:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the number of distinct positive integers in the list.\n  Examples:\n      distinct([4, 1, 2, 2, 3, 1]) = 2\n      distinct([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 1\n      distinct([5, 5, 4, 4, 4]) = 1\n  */\nconst distinct = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = distinct;\n\n},{}],5:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the number of positive integers in the list that are\n  not divisible by any positive integer. For example, given the list [4, 1, 2, 2, 3, 1], return 3.\n  Examples:\n      divisible([4, 1, 2, 2, 3, 1]) = 1\n      divisible([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 2\n      divisible([5, 5, 4, 4, 4]) = 1\n  */\nconst divisible = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 1!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = divisible;\n\n},{}],6:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the number of positive integers in the list that are\n  divisible by any positive integer. For example, given the list [4, 1, 2, 2, 3, 1], return 2.\n  Examples:\n      divisible([4, 1, 2, 2, 3, 1]) = 1\n      divisible([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 1\n      divisible([5, 5, 4, 4, 4]) = 1\n  */\nconst divisible = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = divisible;\n\n},{}],7:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the number of positive integers in the list that are\n  not divisible by any positive integer. For example, given the list [4, 1, 2, 2, 3, 1], return 1.\n  Examples:\n      divisible([4, 1, 2, 2, 3, 1]) = 1\n      divisible([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 1\n      divisible([5, 5, 4, 4, 4]) = 1\n  */\nconst divisible = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = divisible;\n\n},{}],8:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the number of positive integers in the list that are\n  divisible by any positive integer. For example, given the list [4, 1, 2, 2, 3, 1], return 2.\n  Examples:\n      divisible([4, 1, 2, 2, 3, 1]) = 1\n      divisible([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 1\n      divisible([5, 5, 4, 4, 4]) = 1\n  */\nconst divisible = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = divisible;\n\n},{}],9:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the number of positive integers in the list that are\n  divisible by any positive integer. For example, given the list [4, 1, 2, 2, 3, 1], return 1.\n  Examples:\n      divisible([4, 1, 2, 2, 3, 1]) = 1\n      divisible([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 1\n      divisible([5, 5, 4, 4, 4]) = 1\n  */\nconst divisible = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = divisible;\n\n},{}],10:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the number of positive integers in the list that are\n  divisible by any positive integer. For example, given the list [4, 1, 2, 2, 3, 1], return 2.\n  Examples:\n      divisible([4, 1, 2, 2, 3, 1]) = 1\n      divisible([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 1\n      divisible([5, 5, 4, 4, 4]) = 1\n  */\nconst divisible = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = divisible;\n\n},{}],11:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the number of positive integers in the list that are\n  divisible by any positive integer. For example, given the list [4, 1, 2, 2, 3, 1], return 1.\n  Examples:\n      divisible([4, 1, 2, 2, 3, 1]) = 1\n      divisible([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 1\n      divisible([5, 5, 4, 4, 4]) = 1\n  */\nconst divisible = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = divisible;\n\n},{}],12:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the number of positive integers in the list that are\n  divisible by any positive integer. For example, given the list [4, 1, 2, 2, 3, 1], return 2.\n  Examples:\n      divisible([4, 1, 2, 2, 3, 1]) = 1\n      divisible([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 1\n      divisible([5, 5, 4, 4, 4]) = 1\n  */\nconst divisible = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = divisible;\n\n},{}],13:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the number of positive integers in the list that are\n  divisible by any positive integer. For example, given the list [4, 1, 2, 2, 3, 1], return 2.\n  Examples:\n      divisible([4, 1, 2, 2, 3, 1]) = 1\n      divisible([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 1\n      divisible([5, 5, 4, 4, 4]) = 1\n  */\nconst divisible = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = divisible;\n\n},{}],14:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the number of positive integers in the list that are\n  divisible by any positive integer. For example, given the list [4, 1, 2, 2, 3, 1], return 2.\n  Examples:\n      divisible([4, 1, 2, 2, 3, ", "passed": 0}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1)\n}\n\n/**\n * Filter an input list of strings only keeping those that contain at least one\n * occurrence of a given substring\n  >>> filterBySubstrings([], 'a')\n  []\n  >>> filterBySubstrings(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstrings = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring)!== -1)\n}\n\n/**\n * Filter an input list of strings only keeping those that contain at least one\n * occurrence of a given substring\n  >>> filterBySubstrings(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstrings = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1)\n}\n\n/**\n * Filter an input list of strings only keeping those that contain at least one\n * occurrence of a given substring\n  >>> filterBySubstrings(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstrings = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1)\n}\n\n/**\n * Filter an input list of strings only keeping those that contain at least one\n * occurrence of a given substring\n  >>> filterBySubstrings(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstrings = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1)\n}\n\n/**\n * Filter an input list of strings only keeping those that contain at least one\n * occurrence of a given substring\n  >>> filterBySubstrings(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstrings = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1)\n}\n\n/**\n * Filter an input list of strings only keeping those that contain at least one\n * occurrence of a given substring\n  >>> filterBySubstrings(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstrings = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1)\n}\n\n/**\n * Filter an input list of strings only keeping those that contain at least one\n * occurrence of a given substring\n  >>> filterBySubstrings(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstrings = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1)\n}\n\n/**\n * Filter an input list of strings only keeping those that contain at least one\n * occurrence of a given substring\n  >>> filterBySubstrings(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstrings = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1)\n}\n\n/**\n * Filter an input list of strings only keeping those that contain at least one\n * occurrence of a given substring\n  >>> filterBySubstrings(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstrings = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1)\n}\n\n/**\n * Filter an input list of strings only keeping those that contain at least one\n * occurrence of a given substring\n  >>> filterBySubstrings(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstrings = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1)\n}\n\n/**\n * Filter an input list of strings only keeping those that contain at least one\n * occurrence of a given substring\n  >>> filterBySubstrings(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstrings = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1)\n}\n\n/**\n * Filter an input list of strings only keeping those that contain at least one\n * occurrence of a given substring\n  >>> filterBySubstrings(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstrings = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1)\n}\n\n/**\n * Filter an input list of strings only keeping those that contain at least one\n * occurrence of a given substring\n  >>> filterBySubstrings(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstrings = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1 && str.indexOf(substring)!== -1)\n}\n\n/**\n * Filter an input list of strings only keeping those that contain at least one\n * occurrence of a given substring\n  ", "passed": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  foreignSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  foreignSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  foreignSortList([]) == []\n  */\nconst foreignSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "foreignSortList", "gc": "<|endoftext|>/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  foreignSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  foreignSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  foreignSortList([]) == []\n  */\nconst foreignSortList = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  return sorted.map((el) => el.toString());\n};\n\n/*\n  Given a string, return a list of all unique characters in the string.\n  A character is a string of length 1.\n\n  Examples:\n  uniqueChars('abba') == ['a', 'b', 'a', 'b', 'b', 'a', 'b', 'a', 'b']\n  uniqueChars('abbaa') == ['a', 'b', 'a', 'b', 'b', 'a', 'b', 'a', 'b']\n  uniqueChars('') == []\n  */\nconst uniqueChars = (str) => {\n  const chars = str.split('');\n  const uniqueChars = [];\n  for (let i = 0; i < chars.length; i++) {\n    if (chars.includes(chars[i])) {\n      uniqueChars.push(chars[i]);\n    }\n  }\n  return uniqueChars;\n};\n\n/*\n  Given a string, return a list of all unique words in the string.\n  A word is a string of length 1.\n\n  Examples:\n  uniqueWords('abba') == ['a', 'b', 'a', 'b', 'b', 'a', 'b', 'a', 'b']\n  uniqueWords('abbaa') == ['a', 'b', 'a', 'b', 'b', 'a', 'b', 'a', 'b']\n  uniqueWords('') == []\n  */\nconst uniqueWords = (str) => {\n  const words = str.split(' ');\n  const uniqueWords = [];\n  for (let i = 0; i < words.length; i++) {\n    if (words.includes(words[i])) {\n      uniqueWords.push(words[i]);\n    }\n  }\n  return uniqueWords;\n};\n\n/*\n  Given a string, return a list of all unique numbers in the string.\n  A number is a string of length 1.\n\n  Examples:\n  uniqueNumbers('abba') == ['a', 'b', 'a', 'b', 'b', 'a', 'b', 'a', 'b']\n  uniqueNumbers('abbaa') == ['a', 'b', 'a', 'b', 'b', 'a', 'b', 'a', 'b']\n  uniqueNumbers('') == []\n  */\nconst uniqueNumbers = (str) => {\n  const numbers = str.split('');\n  const uniqueNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers.includes(numbers[i])) {\n      uniqueNumbers.push(numbers[i]);\n    }\n  }\n  return uniqueNumbers;\n};\n\n/*\n  Given a string, return a list of all unique combinations of the string.\n  A combination is a string of length 2.\n\n  Examples:\n  uniqueCombinations('abba') == ['a', 'a', 'b', 'b', 'a', 'b', 'b', 'a', 'b']\n  uniqueCombinations('abbaa') == ['a', 'a', 'b', 'b', 'a', 'b', 'b', 'a', 'b']\n  uniqueCombinations('') == []\n  */\nconst uniqueCombinations = (str) => {\n  const combinations = [];\n  let currentCombination = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === currentCombination) {\n      combinations.push(currentCombination);\n      currentCombination = '';\n    } else {\n      currentCombination += str[i];\n    }\n  }\n  return combinations;\n};\n\n/*\n  Given a string, return a list of all unique permutations of the string.\n  A permutation is a string of length 2.\n\n  Examples:\n  uniquePermutations('abba') == ['a', 'b', 'a', 'b', 'b', 'a', 'b', 'b', 'a', 'b']\n  uniquePermutations('abbaa') == ['a', 'b', 'a', 'b', 'b', 'a', 'b', 'b', 'a', 'b']\n  uniquePermutations('') == []\n  */\nconst uniquePermutations = (str) => {\n  const permutations = [];\n  let currentPermutation = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === currentPermutation) {\n      permutations.push(currentPermutation);\n      currentPermutation = '';\n    } else {\n      currentPermutation += str[i];\n    }\n  }\n  return permutations;\n};\n\n/*\n  Given a string, return a list of all unique combinations of the string.\n  A combination is a string of length 2.\n\n  Examples:\n  uniqueCombinations('abba') == ['a', 'a', 'b', 'b', 'a', 'b', 'b', 'a', 'b']\n  uniqueCombinations('abbaa') == ['a', 'a', 'b', 'b', 'a', 'b', 'b', 'a', 'b']\n  uniqueCombinations('') == []\n  */\nconst uniqueCombinationsWithRepeats = (str) => {\n  const combinations = [];\n  let currentCombination = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === currentCombination) {\n      combinations.push(currentCombination);\n      currentCombination = '';\n    } else {\n      currentCombination += str[i];\n    }\n  }\n  return combinations;\n};\n\n/*\n  Given a string, return a list of all unique permutations of the string.\n  A permutation is a string of length 2.\n\n  Examples:\n  uniquePermutations('abba') == ['a', 'b', 'a', 'b', 'b', 'a', 'b', 'b', 'a', 'b']\n  uniquePermutations('abbaa') == ['a', 'b', 'a', 'b', 'b', 'a', 'b', 'b', 'a', 'b']\n  uniquePermutations('') == []\n  */\nconst uniquePermutationsWithRepeats = (str) => {\n  const permutations = [];\n  let currentPermutation = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === currentPermutation) {\n      permutations.push(currentPermutation);\n      currentPermutation = '';\n    } else {\n      currentPermutation += str[i];\n    }\n  }\n  return permutations;\n};\n\n/*\n  Given a string, return a list of all unique combinations of the string.\n  A combination is a string of length 2.\n\n  Examples:\n  uniqueCombinations('abba') == ['a', 'a', 'b', 'b', 'a', 'b', 'b', 'a', 'b']\n  uniqueCombinations('abbaa') == ['a', 'a', 'b', 'b', 'a', 'b', 'b', 'a', 'b']\n  uniqueCombinations('') == []\n  */\nconst uniqueCombinationsWithRepeatsAndRepeats = (str) => {\n  const combinations = [];\n  let currentCombination = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === currentCombination) {\n      combinations.push(currentCombination);\n      currentCombination = '';\n    } else {\n      currentCombination += str[i];\n    }\n  }\n  return combinations;\n};\n\n/*\n  Given a string, return a list of all unique permutations of the string.\n  A permutation is a string of length 2.\n\n  Examples:\n  uniquePermutations('abba') == ['a', 'b', 'a', 'b', 'b', 'a', 'b', 'b', 'a', 'b']\n  uniquePermutations('abbaa') == ['a', 'b', 'a', 'b', 'b', 'a', 'b', 'b', 'a', 'b']\n  uniquePermutations('') == []\n  */\nconst uniquePermutationsWithRepeatsAndRepeats = (str) => {\n  const permutations = [];\n  let currentPermutation = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === currentPermutation) {\n      permutations.push(currentPermutation);\n      currentPermutation = '';\n    } else {\n      currentPermutation += str[i];\n    }\n  }\n  return permutations;\n};\n\n/*\n  Given a string, return a list of all unique permutations of the string.\n  A permutation is a string of length 2.\n\n  Examples:\n  uniquePermutations('abba') == ['a', 'b', 'a', 'b', 'b', 'a', 'b', 'b', 'a', 'b']\n  uniquePermutations('abbaa') == ['a', 'b', 'a', 'b', 'b', 'a', 'b', 'b', 'a', 'b']\n  uniquePermutations('') == []\n  */\nconst uniquePermutationsWithRepeatsAndRepeatsAndRepeats = (str) => {\n  const permutations = [];\n  let currentPermutation = '';\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === currentPermutation) {\n      permutations.push(currentPermutation);\n      currentPermutation = '';\n    } else {\n      currentPermutation += str[i];\n    }\n  }\n  return permutations;\n};\n\n/*\n  Given a string, return a list of all unique permutations of the string.\n  A permutation is a string of length ", "passed": 0}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangulumArea(3, 4, 5) == 6.00\n  triangulumArea(1, 2, 10) == -1\n  */\nconst triangulumArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangulumArea", "gc": "<|endoftext|>/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangulumArea(3, 4, 5) == 6.00\n  triangulumArea(1, 2, 10) == -1\n  */\nconst triangulumArea = (a, b, c) => {\n  const aArea = Math.pow(a, 2);\n  const bArea = Math.pow(b, 2);\n  const cArea = Math.pow(c, 2);\n  return (aArea + bArea + cArea) / 3;\n};\n\n/*\n  Given the lengths of the three sides of a rectangle. Return the area of\n  the rectangle rounded to 2 decimal points if the three sides form a valid rectangle.\n  Otherwise return -1\n  Three sides make a valid rectangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  rectangleArea(3, 4, 5) == 12.00\n  rectangleArea(1, 2, 10) == -1\n  */\nconst rectangleArea = (a, b, c) => {\n  const aArea = Math.pow(a, 2);\n  const bArea = Math.pow(b, 2);\n  const cArea = Math.pow(c, 2);\n  return (aArea + bArea + cArea) / 3;\n};\n\n/*\n  Given the lengths of the three sides of a circle. Return the area of\n  the circle rounded to 2 decimal points if the three sides form a valid circle.\n  Otherwise return -1\n  Three sides make a valid circle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  circleArea(3, 4, 5) == 6.00\n  circleArea(1, 2, 10) == -1\n  */\nconst circleArea = (a, b, c) => {\n  const aArea = Math.pow(a, 2);\n  const bArea = Math.pow(b, 2);\n  const cArea = Math.pow(c, 2);\n  return (aArea + bArea + cArea) / 3;\n};\n\n/*\n  Given the lengths of the three sides of a square. Return the area of\n  the square rounded to 2 decimal points if the three sides form a valid square.\n  Otherwise return -1\n  Three sides make a valid square when the sum of any two sides is greater\n  than the third side.\n  Example:\n  squareArea(3, 4, 5) == 12.00\n  squareArea(1, 2, 10) == -1\n  */\nconst squareArea = (a, b, c) => {\n  const aArea = Math.pow(a, 2);\n  const bArea = Math.pow(b, 2);\n  const cArea = Math.pow(c, 2);\n  return (aArea + bArea + cArea) / 3;\n};\n\n/*\n  Given the lengths of the three sides of a pentagon. Return the area of\n  the pentagon rounded to 2 decimal points if the three sides form a valid pentagon.\n  Otherwise return -1\n  Three sides make a valid pentagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  pentagonArea(3, 4, 5) == 12.00\n  pentagonArea(1, 2, 10) == -1\n  */\nconst pentagonArea = (a, b, c) => {\n  const aArea = Math.pow(a, 2);\n  const bArea = Math.pow(b, 2);\n  const cArea = Math.pow(c, 2);\n  return (aArea + bArea + cArea) / 3;\n};\n\n/*\n  Given the lengths of the three sides of a hexagon. Return the area of\n  the hexagon rounded to 2 decimal points if the three sides form a valid hexagon.\n  Otherwise return -1\n  Three sides make a valid hexagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  hexagonArea(3, 4, 5) == 12.00\n  hexagonArea(1, 2, 10) == -1\n  */\nconst hexagonArea = (a, b, c) => {\n  const aArea = Math.pow(a, 2);\n  const bArea = Math.pow(b, 2);\n  const cArea = Math.pow(c, 2);\n  return (aArea + bArea + cArea) / 3;\n};\n\n/*\n  Given the lengths of the three sides of a heptagon. Return the area of\n  the heptagon rounded to 2 decimal points if the three sides form a valid heptagon.\n  Otherwise return -1\n  Three sides make a valid heptagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  heptagonArea(3, 4, 5) == 12.00\n  heptagonArea(1, 2, 10) == -1\n  */\nconst heptagonArea = (a, b, c) => {\n  const aArea = Math.pow(a, 2);\n  const bArea = Math.pow(b, 2);\n  const cArea = Math.pow(c, 2);\n  return (aArea + bArea + cArea) / 3;\n};\n\n/*\n  Given the lengths of the three sides of a decagon. Return the area of\n  the decagon rounded to 2 decimal points if the three sides form a valid decagon.\n  Otherwise return -1\n  Three sides make a valid decagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  decagonArea(3, 4, 5) == 12.00\n  decagonArea(1, 2, 10) == -1\n  */\nconst decagonArea = (a, b, c) => {\n  const aArea = Math.pow(a, 2);\n  const bArea = Math.pow(b, 2);\n  const cArea = Math.pow(c, 2);\n  return (aArea + bArea + cArea) / 3;\n};\n\n/*\n  Given the lengths of the three sides of a dodecagon. Return the area of\n  the dodecagon rounded to 2 decimal points if the three sides form a valid dodecagon.\n  Otherwise return -1\n  Three sides make a valid dodecagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  dodecagonArea(3, 4, 5) == 12.00\n  dodecagonArea(1, 2, 10) == -1\n  */\nconst dodecagonArea = (a, b, c) => {\n  const aArea = Math.pow(a, 2);\n  const bArea = Math.pow(b, 2);\n  const cArea = Math.pow(c, 2);\n  return (aArea + bArea + cArea) / 3;\n};\n\n/*\n  Given the lengths of the three sides of a quadigon. Return the area of\n  the quadigon rounded to 2 decimal points if the three sides form a valid quadigon.\n  Otherwise return -1\n  Three sides make a valid quadigon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  quadigonArea(3, 4, 5) == 12.00\n  quadigonArea(1, 2, 10) == -1\n  */\nconst quadigonArea = (a, b, c) => {\n  const aArea = Math.pow(a, 2);\n  const bArea = Math.pow(b, 2);\n  const cArea = Math.pow(c, 2);\n  return (aArea + bArea + cArea) / 3;\n};\n\n/*\n  Given the lengths of the three sides of a hexadecagon. Return the area of\n  the hexadecagon rounded to 2 decimal points if the three sides form a valid hexadecagon.\n  Otherwise return -1\n  Three sides make a valid hexadecagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  hexadecagonArea(3, 4, 5) == 12.00\n  hexadecagonArea(1, 2, 10) == -1\n  */\nconst hexadecagonArea = (a, b, c) => {\n  const aArea = Math.pow(a, 2);\n", "passed": 0}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFlee", "gc": "<|endoftext|>/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  let sum = 0;\n  let max = 0;\n  q.forEach((el, i) => {\n    if (el === w) {\n      sum += el;\n      max = Math.max(max, sum);\n    }\n  });\n  return max <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([3, 2, 1], 5) ➞ false\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 1], 1) ➞ false\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 1], 9) ➞ true\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3, 2, 1], 9) ➞ true\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  let sum = 0;\n  let max = 0;\n  q.forEach((el, i) => {\n    if (el === w) {\n      sum += el;\n      max = Math.max(max, sum);\n    }\n  });\n  return max <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([3, 2, 1], 5) ➞ false\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 1], 1) ➞ false\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 1], 9) ➞ true\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3, 2, 1], 9) ➞ true\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  let sum = 0;\n  let max = 0;\n  q.forEach((el, i) => {\n    if (el === w) {\n      sum += el;\n      max = Math.max(max, sum);\n    }\n  });\n  return max <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([3, 2, 1], 5) ➞ false\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 1], 1) ➞ false\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 1], 9) ➞ true\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3, 2, 1], 9) ➞ true\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  let sum = 0;\n  let max = 0;\n  q.forEach((el, i) => {\n    if (el === w) {\n      sum += el;\n      max = Math.max(max, sum);\n    }\n  });\n  return max <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([3, 2, 1], 5) ➞ false\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 1], 1) ➞ false\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 1], 9) ➞ true\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3, 2, 1], 9) ➞ true\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  let sum = 0;\n  let max = 0;\n  q.forEach((el, i) => {\n    if (el === w) {\n      sum += el;\n      max = Math.max(max, sum);\n    }\n  });\n  return max <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([3, 2, 1], 5) ➞ false\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 1], 1) ➞ false\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 1], 9) ➞ true\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3, 2, 1], 9) ➞ true\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  let sum = 0;\n  let max = 0;\n  q.forEach((el, i) => {\n    if (el === w) {\n      sum += el;\n      max = Math.max(max, sum);\n    }\n  });\n  return max <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([3, 2, 1], 5) ➞ false\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 1], 1) ➞ false\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 1], 9) ➞ true\n  # 3+2 is ", "passed": 0}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallChange", "gc": "<|endoftext|>/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (arr[i]!== arr[j]) {\n      change++;\n      i++;\n      j++;\n    }\n    else {\n      i++;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (arr[i] === arr[j]) {\n      change++;\n      i++;\n      j++;\n    }\n    else {\n      i++;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (arr[i] === arr[j]) {\n      change++;\n      i++;\n      j++;\n    }\n    else {\n      i++;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (arr[i] === arr[j]) {\n      change++;\n      i++;\n      j++;\n    }\n    else {\n      i++;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (arr[i] === arr[j]) {\n      change++;\n      i++;\n      j++;\n    }\n    else {\n      i++;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (arr[i] === arr[j]) {\n      change++;\n      i++;\n      j++;\n    }\n    else {\n      i++;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (arr[i] === arr[j]) {\n      change++;\n      i++;\n      j++;\n    }\n    else {\n      i++;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (arr[i] === arr[j]) {\n      change++;\n      i++;\n      j++;\n    }\n    else {\n      i++;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (arr[i] === arr[j]) {\n      change++;\n      i++;\n      j++;\n    }\n    else {\n      i++;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (arr[i] === arr[j]) {\n      change++;\n      ", "passed": 0}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "entireCatch", "gc": "<|endoftext|>/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n  const set1 = new Set(lst1);\n  const set2 = new Set(lst2);\n  const set3 = new Set(lst1.concat(lst2));\n  const set4 = new Set(lst2.concat(lst1));\n  const set5 = new Set(lst1.concat(lst2));\n  const set6 = new Set(lst2.concat(lst1));\n  const set7 = new Set(lst1.concat(lst2));\n  const set8 = new Set(lst2.concat(lst1));\n  const set9 = new Set(lst1.concat(lst2));\n  const set10 = new Set(lst1.concat(lst2));\n  const set11 = new Set(lst1.concat(lst2));\n  const set12 = new Set(lst1.concat(lst2));\n  const set13 = new Set(lst1.concat(lst2));\n  const set14 = new Set(lst1.concat(lst2));\n  const set15 = new Set(lst1.concat(lst2));\n  const set16 = new Set(lst1.concat(lst2));\n  const set17 = new Set(lst1.concat(lst2));\n  const set18 = new Set(lst1.concat(lst2));\n  const set19 = new Set(lst1.concat(lst2));\n  const set20 = new Set(lst1.concat(lst2));\n  const set21 = new Set(lst1.concat(lst2));\n  const set22 = new Set(lst1.concat(lst2));\n  const set23 = new Set(lst1.concat(lst2));\n  const set24 = new Set(lst1.concat(lst2));\n  const set25 = new Set(lst1.concat(lst2));\n  const set26 = new Set(lst1.concat(lst2));\n  const set27 = new Set(lst1.concat(lst2));\n  const set28 = new Set(lst1.concat(lst2));\n  const set29 = new Set(lst1.concat(lst2));\n  const set30 = new Set(lst1.concat(lst2));\n  const set31 = new Set(lst1.concat(lst2));\n  const set32 = new Set(lst1.concat(lst2));\n  const set33 = new Set(lst1.concat(lst2));\n  const set34 = new Set(lst1.concat(lst2));\n  const set35 = new Set(lst1.concat(lst2));\n  const set36 = new Set(lst1.concat(lst2));\n  const set37 = new Set(lst1.concat(lst2));\n  const set38 = new Set(lst1.concat(lst2));\n  const set39 = new Set(lst1.concat(lst2));\n  const set40 = new Set(lst1.concat(lst2));\n  const set41 = new Set(lst1.concat(lst2));\n  const set42 = new Set(lst1.concat(lst2));\n  const set43 = new Set(lst1.concat(lst2));\n  const set44 = new Set(lst1.concat(lst2));\n  const set45 = new Set(lst1.concat(lst2));\n  const set46 = new Set(lst1.concat(lst2));\n  const set47 = new Set(lst1.concat(lst2));\n  const set48 = new Set(lst1.concat(lst2));\n  const set49 = new Set(lst1.concat(lst2));\n  const set50 = new Set(lst1.concat(lst2));\n  const set51 = new Set(lst1.concat(lst2));\n  const set52 = new Set(lst1.concat(lst2));\n  const set53 = new Set(lst1.concat(lst2));\n  const set54 = new Set(lst1.concat(lst2));\n  const set55 = new Set(lst1.concat(lst2));\n  const set56 = new Set(lst1.concat(lst2));\n  const set57 = new Set(lst1.concat(lst2));\n  const set58 = new Set(lst1.concat(lst2));\n  const set59 = new Set(lst1.concat(lst2));\n  const set60 = new Set(lst1.concat(lst2));\n  const set61 = new Set(lst1.concat(lst2));\n  const set62 = new Set(lst1.concat(lst2));\n  const set63 = new Set(lst1.concat(lst2));\n  const set64 = new Set(lst1.concat(lst2));\n  const set65 = new Set(lst1.concat(lst2));\n  const set66 = new Set(lst1.concat(lst2));\n  const set67 = new Set(lst1.concat(lst2));\n  const set68 = new Set(lst1.concat(lst2));\n  const set69 = new Set(lst1.concat(lst2));\n  const set70 = new Set(lst1.concat(lst2));\n  const set71 = new Set(lst1.concat(lst2));\n  const set72 = new Set(lst1.concat(lst2));\n  const set73 = new Set(lst1.concat(lst2));\n  const set74 = new Set(lst1.concat(lst2));\n  const set75 = new Set(lst1.concat(lst2));\n  const set76 = new Set(lst1.concat(lst2));\n  const set77 = new Set(lst1.concat(lst2));\n  const set78 = new Set(lst1.concat(lst2));\n  const set79 = new Set(lst1.concat(lst2));\n  const set80 = new Set(lst1.concat(lst2));\n  const set81 = new Set(lst1.concat(lst2));\n  const set82 = new Set(lst1.concat(lst2));\n  const set83 = new Set(lst1.concat(lst2));\n  const set84 = new Set(lst1.concat(lst2));\n  const set85 = new Set(lst1.concat(lst2));\n  const set86 = new Set(lst1.concat(lst2));\n  const set87 = new Set(lst1.concat(lst2));\n  const set88 = new Set(lst1.concat(lst2));\n  const set89 = new Set(lst1.concat(lst2));\n  const set90 = new Set(lst1.concat(lst2));\n  const set91 = new Set(lst1.concat(lst2));\n  const set92 = new Set(lst1.concat(lst2));\n  const set93 = new Set(lst1.concat(lst2));\n  const set94 = new Set(lst1.concat(lst2));\n  const set95 = new Set(lst1.concat(lst2));\n  const set96 = new Set(lst1.concat(lst2));\n  const set97 = new Set(lst1.concat(lst2));\n  const set98 = new Set(lst1.concat(lst2));\n  const set99 = new Set(lst1.concat(lst2));\n  const set100 = new Set(lst1.concat(lst2));\n  const set101 = new Set(lst1.concat(lst2));\n  const set102 = new Set(lst1.concat(lst2));\n  const set103 = new Set(lst1.concat(lst2));\n  const set104 = new Set(lst1.concat(lst2));\n  const set105 = new Set(lst1.concat(lst2));\n  const set106 = new Set(lst1.concat(lst2));\n  const set107 = new Set(lst1.concat(lst2));\n  const set108 = new Set(lst1.concat(lst2));\n  const set109 = new Set(lst1.concat(lst2));\n  const set110 = new Set(lst1.concat(lst2));\n  const set111 = new Set(lst1.concat(lst2));\n  const set112 = new Set(lst1.concat(lst2));\n  const set113 = new Set(lst1.concat(lst2));\n  const set114 = new Set(lst1.concat(lst2));\n  const set115 = new Set(lst1.concat(lst2));\n  const set116 = new Set(lst1.concat(lst2));\n  const set117 = new Set(lst1.concat(lst2));\n  const set118 = new Set(lst1.concat(lst2));\n  const set119 = new Set(lst1.concat(lst2));\n  const set120 = new Set(lst1.concat(lst2));\n  const set121 = new Set(lst1.concat(lst2));\n  const set122 = new Set(", "passed": 0}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "gc": "<|endoftext|>/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (", "passed": 0}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryWorldPower(1, 4) => true\n  isElementaryWorldPower(2, 2) => true\n  isElementaryWorldPower(8, 2) => true\n  isElementaryWorldPower(3, 2) => false\n  isElementaryWorldPower(3, 1) => false\n  isElementaryWorldPower(5, 3) => false\n  */\nconst isElementaryWorldPower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isElementaryWorldPower", "gc": "<|endoftext|>/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryWorldPower(1, 4) => true\n  isElementaryWorldPower(2, 2) => true\n  isElementaryWorldPower(8, 2) => true\n  isElementaryWorldPower(3, 2) => false\n  isElementaryWorldPower(3, 1) => false\n  isElementaryWorldPower(5, 3) => false\n  */\nconst isElementaryWorldPower = (x, n) => {\n  const isPower = x % n === 0;\n  return isPower;\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryPowerOf(1, 4) => true\n  isElementaryPowerOf(2, 2) => true\n  isElementaryPowerOf(8, 2) => true\n  isElementaryPowerOf(3, 2) => false\n  isElementaryPowerOf(3, 1) => false\n  isElementaryPowerOf(5, 3) => false\n  */\nconst isElementaryPowerOf = (x, n) => {\n  const isPower = x % n === 0;\n  return isPower;\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryPowerOf(3, 2) => true\n  isElementaryPowerOf(3, 1) => false\n  isElementaryPowerOf(5, 3) => false\n  */\nconst isElementaryPowerOf = (x, n) => {\n  const isPower = x % n === 0;\n  return isPower;\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryPowerOf(3, 2) => true\n  isElementaryPowerOf(3, 1) => false\n  isElementaryPowerOf(5, 3) => false\n  */\nconst isElementaryPowerOf = (x, n) => {\n  const isPower = x % n === 0;\n  return isPower;\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryPowerOf(3, 2) => true\n  isElementaryPowerOf(3, 1) => false\n  isElementaryPowerOf(5, 3) => false\n  */\nconst isElementaryPowerOf = (x, n) => {\n  const isPower = x % n === 0;\n  return isPower;\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryPowerOf(3, 2) => true\n  isElementaryPowerOf(3, 1) => false\n  isElementaryPowerOf(5, 3) => false\n  */\nconst isElementaryPowerOf = (x, n) => {\n  const isPower = x % n === 0;\n  return isPower;\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryPowerOf(3, 2) => true\n  isElementaryPowerOf(3, 1) => false\n  isElementaryPowerOf(5, 3) => false\n  */\nconst isElementaryPowerOf = (x, n) => {\n  const isPower = x % n === 0;\n  return isPower;\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryPowerOf(3, 2) => true\n  isElementaryPowerOf(3, 1) => false\n  isElementaryPowerOf(5, 3) => false\n  */\nconst isElementaryPowerOf = (x, n) => {\n  const isPower = x % n === 0;\n  return isPower;\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryPowerOf(3, 2) => true\n  isElementaryPowerOf(3, 1) => false\n  isElementaryPowerOf(5, 3) => false\n  */\nconst isElementaryPowerOf = (x, n) => {\n  const isPower = x % n === 0;\n  return isPower;\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryPowerOf(3, 2) => true\n  isElementaryPowerOf(3, 1) => false\n  isElementaryPowerOf(5, 3) => false\n  */\nconst isElementaryPowerOf = (x, n) => {\n  const isPower = x % n === 0;\n  return isPower;\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryPowerOf(3, 2) => true\n  isElementaryPowerOf(3, 1) => false\n  isElementaryPowerOf(5, 3) => false\n  */\nconst isElementaryPowerOf = (x, n) => {\n  const isPower = x % n === 0;\n  return isPower;\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryPowerOf(3, 2) => true\n  isElementaryPowerOf(3, 1) => false\n  isElementaryPowerOf(5, 3) => false\n  */\nconst isElementaryPowerOf = (x, n) => {\n  const isPower = x % n === 0;\n  return isPower;\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryPowerOf(3, 2) => true\n  isElementaryPowerOf(3, 1) => false\n  isElementaryPowerOf(5, 3) => false\n  */\nconst isElementaryPowerOf = (x, n) => {\n  const isPower = x % n === 0;\n  return isPower;\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryPowerOf(3, 2) => true\n  isElementaryPowerOf(3, 1) => false\n  isElementaryPowerOf(5, 3) => false\n  */\nconst isElementaryPowerOf = (x, n) => {\n  const isPower = x % n === 0;\n  return isPower;\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryPowerOf(3, 2) => true\n  isElementaryPowerOf(3, 1) => false\n  isElementaryPowerOf(5, 3) => ", "passed": 0}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "gc": "<|endoftext|>/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a <= 0) return false\n  if (a % 2 === 0) return true\n  return iscube(Math.floor(a / 2))\n}\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a pentagonal number of the given size.\n  Note: you may assume the input is always valid.\n  Examples:\n  ispentagon(1) ==> true\n  ispentagon(2) ==> false\n  ispentagon(3) ==> true\n  ispentagon(4) ==> false\n  ispentagon(5) ==> true\n  ispentagon(6) ==> false\n  ispentagon(7) ==> true\n  ispentagon(8) ==> false\n  ispentagon(9) ==> true\n  ispentagon(10) ==> false\n  ispentagon(11) ==> true\n  ispentagon(12) ==> false\n  ispentagon(13) ==> true\n  ispentagon(14) ==> false\n  ispentagon(15) ==> true\n  ispentagon(16) ==> false\n  ispentagon(17) ==> true\n  ispentagon(18) ==> false\n  ispentagon(19) ==> true\n  ispentagon(20) ==> false\n  ispentagon(21) ==> true\n  ispentagon(22) ==> false\n  ispentagon(23) ==> true\n  ispentagon(24) ==> false\n  ispentagon(25) ==> true\n  ispentagon(26) ==> false\n  ispentagon(27) ==> true\n  ispentagon(28) ==> false\n  ispentagon(29) ==> true\n  ispentagon(30) ==> false\n  ispentagon(31) ==> true\n  ispentagon(32) ==> false\n  ispentagon(33) ==> true\n  ispentagon(34) ==> false\n  ispentagon(35) ==> true\n  ispentagon(36) ==> false\n  ispentagon(37) ==> true\n  ispentagon(38) ==> false\n  ispentagon(39) ==> true\n  ispentagon(40) ==> false\n  ispentagon(41) ==> true\n  ispentagon(42) ==> false\n  ispentagon(43) ==> true\n  ispentagon(44) ==> false\n  ispentagon(45) ==> true\n  ispentagon(46) ==> false\n  ispentagon(47) ==> true\n  ispentagon(48) ==> false\n  ispentagon(49) ==> true\n  ispentagon(50) ==> false\n  ispentagon(51) ==> true\n  ispentagon(52) ==> false\n  ispentagon(53) ==> true\n  ispentagon(54) ==> false\n  ispentagon(55) ==> true\n  ispentagon(56) ==> false\n  ispentagon(57) ==> true\n  ispentagon(58) ==> false\n  ispentagon(59) ==> true\n  ispentagon(60) ==> false\n  ispentagon(61) ==> true\n  ispentagon(62) ==> false\n  ispentagon(63) ==> true\n  ispentagon(64) ==> false\n  ispentagon(65) ==> true\n  ispentagon(66) ==> false\n  ispentagon(67) ==> true\n  ispentagon(68) ==> false\n  ispentagon(69) ==> true\n  ispentagon(70) ==> false\n  ispentagon(71) ==> true\n  ispentagon(72) ==> false\n  ispentagon(73) ==> true\n  ispentagon(74) ==> false\n  ispentagon(75) ==> true\n  ispentagon(76) ==> false\n  ispentagon(77) ==> true\n  ispentagon(78) ==> false\n  ispentagon(79) ==> true\n  ispentagon(80) ==> false\n  ispentagon(81) ==> true\n  ispentagon(82) ==> false\n  ispentagon(83) ==> true\n  ispentagon(84) ==> false\n  ispentagon(85) ==> true\n  ispentagon(86) ==> false\n  ispentagon(87) ==> true\n  ispentagon(88) ==> false\n  ispentagon(89) ==> true\n  ispentagon(90) ==> false\n  ispentagon(91) ==> true\n  ispentagon(92) ==> false\n  ispentagon(93) ==> true\n  ispentagon(94) ==> false\n  ispentagon(95) ==> true\n  ispentagon(96) ==> false\n  ispentagon(97) ==> true\n  ispentagon(98) ==> false\n  ispentagon(99) ==> true\n  ispentagon(100) ==> false\n  ispentagon(101) ==> true\n  ispentagon(102) ==> false\n  ispentagon(103) ==> true\n  ispentagon(104) ==> false\n  ispentagon(105) ==> true\n  ispentagon(106) ==> false\n  ispentagon(107) ==> true\n  ispentagon(108) ==> false\n  ispentagon(109) ==> true\n  ispentagon(110) ==> false\n  ispentagon(111) ==> true\n  ispentagon(112) ==> false\n  ispentagon(113) ==> true\n  ispentagon(114) ==> false\n  ispentagon(115) ==> true\n  ispentagon(116) ==> false\n  ispentagon(117) ==> true\n  ispentagon(118) ==> false\n  ispentagon(119) ==> true\n  ispentagon(120) ==> false\n  ispentagon(121) ==> true\n  ispentagon(122) ==> false\n  ispentagon(123) ==> true\n  ispentagon(124) ==> false\n  ispentagon(125) ==> true\n  ispentagon(126", "passed": 0}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "gc": "<|endoftext|>/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let count = 0;\n  let numStr = \"\";\n  let numArr = num.split(\"\");\n  for (let i = 0; i < numArr.length; i++) {\n    if (numArr[i] === \"0\") {\n      numStr += numArr[i];\n    } else {\n      if (numArr[i] === \"1\") {\n        numStr += numArr[i];\n      } else if (numArr[i] === \"2\") {\n        numStr += numArr[i];\n      } else if (numArr[i] === \"3\") {\n        numStr += numArr[i];\n      } else if (numArr[i] === \"4\") {\n        numStr += numArr[i];\n      } else if (numArr[i] === \"5\") {\n        numStr += numArr[i];\n      } else if (numArr[i] === \"6\") {\n        numStr += numArr[i];\n      } else if (numArr[i] === \"7\") {\n        numStr += numArr[i];\n      } else if (numArr[i] === \"8\") {\n        numStr += numArr[i];\n      } else if (numArr[i] === \"9\") {\n        numStr += numArr[i];\n      } else if (numArr[i] === \"A\") {\n        numStr += numArr[i];\n      } else if (numArr[i] === \"B\") {\n        numStr += numArr[i];\n      } else if (numArr[i] === \"C\") {\n        numStr += numArr[i];\n      } else if (numArr[i] === \"D\") {\n        numStr += numArr[i];\n      } else if (numArr[i] === \"E\") {\n        numStr += numArr[i];\n      } else if (numArr[i] === \"F\") {\n        numStr += numArr[i];\n      } else {\n        count += 1;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You have been tasked to write a function that receives a string and counts\n  the number of letters that are divisible by 3 or 5 or 7 or 9 or 11 or 13 or 15 or 17 or 19 or 21\n  or 23. Letters are A===B===C===D===E===F===G===H===I===J===K===L===M===N===O===P===Q===R===S===T===U===V===W===X===Y===Z.\n  Letters are uppercase.\n  Examples:\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output should be 4.\n  For str = \"ABCD\" the output ", "passed": 0}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "gc": "<|endoftext|>/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let num = 0;\n  let numString = '';\n  let decimalString = '';\n  let decimalStringLength = 0;\n  let decimalStringLength2 = 0;\n  let decimalStringLength3 = 0;\n  let decimalStringLength4 = 0;\n  let decimalStringLength5 = 0;\n  let decimalStringLength6 = 0;\n  let decimalStringLength7 = 0;\n  let decimalStringLength8 = 0;\n  let decimalStringLength9 = 0;\n  let decimalStringLength10 = 0;\n  let decimalStringLength11 = 0;\n  let decimalStringLength12 = 0;\n  let decimalStringLength13 = 0;\n  let decimalStringLength14 = 0;\n  let decimalStringLength15 = 0;\n  let decimalStringLength16 = 0;\n  let decimalStringLength17 = 0;\n  let decimalStringLength18 = 0;\n  let decimalStringLength19 = 0;\n  let decimalStringLength20 = 0;\n  let decimalStringLength21 = 0;\n  let decimalStringLength22 = 0;\n  let decimalStringLength23 = 0;\n  let decimalStringLength24 = 0;\n  let decimalStringLength25 = 0;\n  let decimalStringLength26 = 0;\n  let decimalStringLength27 = 0;\n  let decimalStringLength28 = 0;\n  let decimalStringLength29 = 0;\n  let decimalStringLength30 = 0;\n  let decimalStringLength31 = 0;\n  let decimalStringLength32 = 0;\n  let decimalStringLength33 = 0;\n  let decimalStringLength34 = 0;\n  let decimalStringLength35 = 0;\n  let decimalStringLength36 = 0;\n  let decimalStringLength37 = 0;\n  let decimalStringLength38 = 0;\n  let decimalStringLength39 = 0;\n  let decimalStringLength40 = 0;\n  let decimalStringLength41 = 0;\n  let decimalStringLength42 = 0;\n  let decimalStringLength43 = 0;\n  let decimalStringLength44 = 0;\n  let decimalStringLength45 = 0;\n  let decimalStringLength46 = 0;\n  let decimalStringLength47 = 0;\n  let decimalStringLength48 = 0;\n  let decimalStringLength49 = 0;\n  let decimalStringLength50 = 0;\n  let decimalStringLength51 = 0;\n  let decimalStringLength52 = 0;\n  let decimalStringLength53 = 0;\n  let decimalStringLength54 = 0;\n  let decimalStringLength55 = 0;\n  let decimalStringLength56 = 0;\n  let decimalStringLength57 = 0;\n  let decimalStringLength58 = 0;\n  let decimalStringLength59 = 0;\n  let decimalStringLength60 = 0;\n  let decimalStringLength61 = 0;\n  let decimalStringLength62 = 0;\n  let decimalStringLength63 = 0;\n  let decimalStringLength64 = 0;\n  let decimalStringLength65 = 0;\n  let decimalStringLength66 = 0;\n  let decimalStringLength67 = 0;\n  let decimalStringLength68 = 0;\n  let decimalStringLength69 = 0;\n  let decimalStringLength70 = 0;\n  let decimalStringLength71 = 0;\n  let decimalStringLength72 = 0;\n  let decimalStringLength73 = 0;\n  let decimalStringLength74 = 0;\n  let decimalStringLength75 = 0;\n  let decimalStringLength76 = 0;\n  let decimalStringLength77 = 0;\n  let decimalStringLength78 = 0;\n  let decimalStringLength79 = 0;\n  let decimalStringLength80 = 0;\n  let decimalStringLength81 = 0;\n  let decimalStringLength82 = 0;\n  let decimalStringLength83 = 0;\n  let decimalStringLength84 = 0;\n  let decimalStringLength85 = 0;\n  let decimalStringLength86 = 0;\n  let decimalStringLength87 = 0;\n  let decimalStringLength88 = 0;\n  let decimalStringLength89 = 0;\n  let decimalStringLength90 = 0;\n  let decimalStringLength91 = 0;\n  let decimalStringLength92 = 0;\n  let decimalStringLength93 = 0;\n  let decimalStringLength94 = 0;\n  let decimalStringLength95 = 0;\n  let decimalStringLength96 = 0;\n  let decimalStringLength97 = 0;\n  let decimalStringLength98 = 0;\n  let decimalStringLength99 = 0;\n  let decimalStringLength100 = 0;\n  let decimalStringLength101 = 0;\n  let decimalStringLength102 = 0;\n  let decimalStringLength103 = 0;\n  let decimalStringLength104 = 0;\n  let decimalStringLength105 = 0;\n  let decimalStringLength106 = 0;\n  let decimalStringLength107 = 0;\n  let decimalStringLength108 = 0;\n  let decimalStringLength109 = 0;\n  let decimalStringLength110 = 0;\n  let decimalStringLength111 = 0;\n  let decimalStringLength112 = 0;\n  let decimalStringLength113 = 0;\n  let decimalStringLength114 = 0;\n  let decimalStringLength115 = 0;\n  let decimalStringLength116 = 0;\n  let decimalStringLength117 = 0;\n  let decimalStringLength118 = 0;\n  let decimalStringLength119 = 0;\n  let decimalStringLength120 = 0;\n  let decimalStringLength121 = 0;\n  let decimalStringLength122 = 0;\n  let decimalStringLength123 = 0;\n  let decimalStringLength124 = 0;\n  let decimalStringLength125 = 0;\n  let decimalStringLength126 = 0;\n  let decimalStringLength127 = 0;\n  let decimalStringLength128 = 0;\n  let decimalStringLength129 = 0;\n  let decimalStringLength130 = 0;\n  let decimalStringLength131 = 0;\n  let decimalStringLength132 = 0;\n  let decimalStringLength133 = 0;\n  let decimalStringLength134 = 0;\n  let decimalStringLength135 = 0;\n  let decimalStringLength136 = 0;\n  let decimalStringLength137 = 0;\n  let decimalStringLength138 = 0;\n  let decimalStringLength139 = 0;\n  let decimalStringLength140 = 0;\n  let decimalStringLength141 = 0;\n  let decimalStringLength142 = 0;\n  let decimalStringLength143 = 0;\n  let decimalStringLength144 = 0;\n  let decimalStringLength145 = 0;\n  let decimalStringLength146 = 0;\n  let decimalStringLength147 = 0;\n  let decimalStringLength148 = 0;\n  let decimalStringLength149 = 0;\n  let decimalStringLength150 = 0;\n  let decimalStringLength151 = 0;\n  let decimalStringLength152 = 0;\n  let decimalStringLength153 = 0;\n  let decimalStringLength154 = 0;\n  let decimalStringLength155 = 0;\n  let decimalStringLength156 = 0;\n  let decimalStringLength157 = 0;\n  let decimalStringLength158 = 0;\n  let decimalStringLength159 = 0;\n  let decimalStringLength160 = 0;\n  let decimalStringLength161 = 0;\n  let decimalStringLength162 = 0;\n  let decimalStringLength163 = 0;\n  let decimalStringLength164 = 0;\n  let decimalStringLength165 = 0;\n  let decimalStringLength166 = 0;\n  let decimalStringLength167 = 0;\n  let decimalStringLength168 = 0;\n  let decimalStringLength169 = 0;\n  let decimalStringLength170 = 0;\n  let decimalStringLength171 = 0;\n  let decimalStringLength172 = 0;\n  let decimalStringLength173 = 0;\n  let decimalStringLength174 = 0;\n  let decimalStringLength175 = 0;\n  let decimalStringLength176 = 0;\n  let decimalStringLength177 = 0;\n  let decimalStringLength178 = 0;\n  let decimalStringLength179 = 0;\n  let decimalStringLength180 = 0;\n  let decimalStringLength181 = 0;\n  let decimalStringLength182 = 0;\n  let decimalStringLength183 = 0;\n  let decimalStringLength184 = 0;\n  let decimalStringLength185 = 0;\n  let decimalStringLength186 = 0;\n  let decimalStringLength187 = 0;\n  let decimalStringLength188 = 0;\n  let decimalStringLength189 = 0;\n  let decimalStringLength190 = 0;\n  let decimalStringLength191 = 0;\n  let decimalStringLength192 = 0;\n  let decimalStringLength193 = 0;\n  let decimalStringLength194 = 0;\n  let decimalStringLength195 = 0;\n  let decimalStringLength196 = 0;\n  let decimalStringLength197 = 0;\n  let decimalStringLength198 = 0;\n  let decimalStringLength199 = 0;\n  let decimalStringLength200 = 0;\n  let decimalStringLength201 = 0;\n  let decimalStringLength", "passed": 0}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelIntersection([])\n  (0, 1)\n  >>> kernelIntersection([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelIntersection = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "kernelIntersection", "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelIntersection([])\n  (0, 1)\n  >>> kernelIntersection([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelIntersection = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i];\n    sum += number;\n    product *= number;\n  }\n  return [sum, product];\n};\n\n/**\n * Given a list containing integers, return the product of all the integers in the list.\n * Empty product should be equal to 1.\n * >>> product([1,2,3])\n * 6\n */\nconst product = (numbers) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n  }\n  return product;\n};\n\n/**\n * Given a list containing integers, return the sum of all the integers in the list.\n * Empty sum should be equal to 0.\n * >>> sum([1,2,3])\n * 6\n */\nconst sum = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  return sum;\n};\n\n/**\n * Given a list containing integers, return the maximum element in the list.\n * Empty list should be equal to 0.\n * >>> max([1,2,3])\n * 3\n */\nconst max = (numbers) => {\n  let max = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n    }\n  }\n  return max;\n};\n\n/**\n * Given a list containing integers, return the minimum element in the list.\n * Empty list should be equal to 0.\n * >>> min([1,2,3])\n * 1\n */\nconst min = (numbers) => {\n  let min = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < min) {\n      min = numbers[i];\n    }\n  }\n  return min;\n};\n\n/**\n * Given a list containing integers, return the average of the numbers in the list.\n * Empty list should be equal to 0.\n * >>> average([1,2,3])\n * 1.5\n */\nconst average = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/**\n * Given a list containing integers, return the standard deviation of the numbers in the list.\n * Empty list should be equal to 0.\n * >>> std([1,2,3])\n * 0\n */\nconst std = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    count++;\n  }\n  return Math.sqrt(sum / count);\n};\n\n/**\n * Given a list containing integers, return the standard deviation of the numbers in the list.\n * Empty list should be equal to 0.\n * >>> std([1,2,3])\n * 0\n */\nconst stdDev = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    count++;\n  }\n  return Math.sqrt(sum / count);\n};\n\n/**\n * Given a list containing integers, return the standard deviation of the numbers in the list.\n * Empty list should be equal to 0.\n * >>> stdDev([1,2,3])\n * 0\n */\nconst stdDev2 = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    count++;\n  }\n  return Math.sqrt(sum / count);\n};\n\n/**\n * Given a list containing integers, return the standard deviation of the numbers in the list.\n * Empty list should be equal to 0.\n * >>> stdDev([1,2,3])\n * 0\n */\nconst stdDev3 = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    count++;\n  }\n  return Math.sqrt(sum / count);\n};\n\n/**\n * Given a list containing integers, return the standard deviation of the numbers in the list.\n * Empty list should be equal to 0.\n * >>> stdDev([1,2,3])\n * 0\n */\nconst stdDev4 = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    count++;\n  }\n  return Math.sqrt(sum / count);\n};\n\n/**\n * Given a list containing integers, return the standard deviation of the numbers in the list.\n * Empty list should be equal to 0.\n * >>> stdDev([1,2,3])\n * 0\n */\nconst stdDev5 = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    count++;\n  }\n  return Math.sqrt(sum / count);\n};\n\n/**\n * Given a list containing integers, return the standard deviation of the numbers in the list.\n * Empty list should be equal to 0.\n * >>> stdDev([1,2,3])\n * 0\n */\nconst stdDev6 = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    count++;\n  }\n  return Math.sqrt(sum / count);\n};\n\n/**\n * Given a list containing integers, return the standard deviation of the numbers in the list.\n * Empty list should be equal to 0.\n * >>> stdDev([1,2,3])\n * 0\n */\nconst stdDev7 = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    count++;\n  }\n  return Math.sqrt(sum / count);\n};\n\n/**\n * Given a list containing integers, return the standard deviation of the numbers in the list.\n * Empty list should be equal to 0.\n * >>> stdDev([1,2,3])\n * 0\n */\nconst stdDev8 = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    count++;\n  }\n  return Math.sqrt(sum / count);\n};\n\n/**\n * Given a list containing integers, return the standard deviation of the numbers in the list.\n * Empty list should be equal to 0.\n * >>> stdDev([1,2,3])\n * 0\n */\nconst stdDev9 = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    count++;\n  }\n  return Math.sqrt(sum / count);\n};\n\n/**\n * Given a list containing integers, return the standard deviation of the numbers in the list.\n * Empty list should be equal to 0.\n * >>> stdDev([1,2,3])\n * 0\n */\nconst stdDev10 = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    count++;\n  }\n  return Math.sqrt(sum / count);\n};\n\n/**\n * Given a list containing integers, return the standard deviation of the numbers in the list.\n * Empty list should be equal to 0.\n * >>> stdDev([1,2,3])\n * 0\n */\nconst stdDev11 = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    count++;\n  }\n  return Math.sqrt(sum / count);\n};\n\n/**\n * Given a list containing integers, return the standard deviation of the numbers in the list.\n * Empty list should be equal to 0.\n * >>> stdDev([1,2,3])\n * 0\n */\nconst stdDev12 = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    count++;\n  }\n  return Math.sqrt(sum / count);\n};\n\n/**\n * Given a list containing integers, return the standard deviation of the numbers in the list.\n * Empty list should be equal to 0.\n * >>> stdDev([1,2,3])\n * 0\n */\nconst stdDev13 = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    count++;\n  }\n  return ", "passed": 0}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isFelicitous(a) => false\n  isFelicitous(aa) => false\n  isFelicitous(abcd) => true\n  isFelicitous(aabb) => false\n  isFelicitous(adb) => true\n  isFelicitous(xyy) => false\n  */\nconst isFelicitous = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isFelicitous", "gc": "<|endoftext|>/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isFelicitous(a) => false\n  isFelicitous(aa) => false\n  isFelicitous(abcd) => true\n  isFelicitous(aabb) => false\n  isFelicitous(adb) => true\n  isFelicitous(xyy) => false\n  */\nconst isFelicitous = (s) => {\n  let isFelicitous = false;\n  let count = 0;\n  let letter;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let ", "passed": 0}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericLetterGrade", "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericLetterGrade = (grades) => {\n  const letterGrades = ['A', 'B', 'C', 'D', 'E'];\n  const letterGradeMap = {};\n  grades.forEach((grade) => {\n    letterGradeMap[grade] = letterGrades.indexOf(grade) + 1;\n  });\n  return letterGradeMap;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericGrade = (grades) => {\n  const gradeMap = {};\n  grades.forEach((grade) => {\n    gradeMap[grade] = gradeMap[grade] || 0;\n    gradeMap[grade] += 1;\n  });\n  return gradeMap;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericLetterGrade = (grades) => {\n  const letterGrades = ['A', 'B', 'C', 'D', 'E'];\n  const letterGradeMap = {};\n  grades.forEach((grade) => {\n    letterGradeMap[grade] = letterGrades.indexOf(grade) + 1;\n  });\n  return letterGradeMap;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericGrade = (grades) => {\n  const gradeMap = {};\n  grades.forEach((grade) => {\n    gradeMap[grade] = gradeMap[grade] || 0;\n    gradeMap[grade] += 1;\n  });\n  return gradeMap;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericLetterGrade = (grades) => {\n  const letterGrades = ['A', 'B', 'C', 'D', 'E'];\n  const letterGradeMap = {};\n  grades.forEach((grade) => {\n    letterGradeMap[grade] = letterGrades.indexOf(grade) + 1;\n  });\n  return letterGradeMap;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericGra", "passed": 0}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  premierDistance('Hello') == true\n  premierDistance('abcdcba') == true\n  premierDistance('kittens') == true\n  premierDistance('orange') == false\n  */\nconst premierDistance = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "premierDistance", "gc": "<|endoftext|>/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  premierDistance('Hello') == true\n  premierDistance('abcdcba') == true\n  premierDistance('kittens') == true\n  premierDistance('orange') == false\n  */\nconst premierDistance = (string) => {\n  let prime = true;\n  let length = string.length;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;", "passed": 0}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst beginOneEnd = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "beginOneEnd", "gc": "<|endoftext|>/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst beginOneEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst beginZeroEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 2.\n  */\nconst beginTwoEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 3.\n  */\nconst beginThreeEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 4.\n  */\nconst beginFourEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 5.\n  */\nconst beginFiveEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 6.\n  */\nconst beginSixEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 7.\n  */\nconst beginSevenEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 8.\n  */\nconst beginEightEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 9.\n  */\nconst beginNineEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 10.\n  */\nconst beginTenEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 11.\n  */\nconst beginElevenEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 12.\n  */\nconst beginTwelveEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 13.\n  */\nconst beginThirteenEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 14.\n  */\nconst beginFourteenEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 15.\n  */\nconst beginFifteenEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 16.\n  */\nconst beginSixteenEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 17.\n  */\nconst beginSeventeenEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 18.\n  */\nconst beginEighteenEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 19.\n  */\nconst beginNineteenEnd = (n) => {\n  let count = 0;\n  for (let i = n; i >= 0; i--) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    if (i === 0) {\n      break;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 20.\n  */\nconst beginTwentyEnd = (n", "passed": 0}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst resolve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "resolve", "gc": "<|endoftext|>/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst resolve = (N) => {\n  let sum = 0;\n  for (let i = 0; i <= N; i++) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst resolve = (N) => {\n  let sum = 0;\n  for (let i = 0; i <= N; i++) {\n    sum += parseInt(i, 10);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst resolve = (N) => {\n  let sum = 0;\n  for (let i = 0; i <= N; i++) {\n    sum += parseInt(i, 16);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in octal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of octal number\n  */\nconst resolve = (N) => {\n  let sum = 0;\n  for (let i = 0; i <= N; i++) {\n    sum += parseInt(i, 8);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst resolve = (N) => {\n  let sum = 0;\n  for (let i = 0; i <= N; i++) {\n    sum += parseInt(i, 16);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in octal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of octal number\n  */\nconst resolve = (N) => {\n  let sum = 0;\n  for (let i = 0; i <= N; i++) {\n    sum += parseInt(i, 8);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst resolve = (N) => {\n  let sum = 0;\n  for (let i = 0; i <= N; i++) {\n    sum += parseInt(i, 16);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst resolve = (N) => {\n  let sum = 0;\n  for (let i = 0; i <= N; i++) {\n    sum += parseInt(i, 10);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst resolve = (N) => {\n  let sum = 0;\n  for (let i = 0; i <= N; i++) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst resolve = (N) => {\n  let sum = 0;\n  for (let i = 0; i <= N; i++) {\n    sum += parseInt(i, 10);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst resolve = (N) => {\n  let sum = 0;\n  for (let i = 0; i <= N; i++) {\n    sum += parseInt(i, 16);\n  }\n  return sum;\n};\n\n/*Given a ", "passed": 0}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst lend = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "lend", "gc": "<|endoftext|>/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (lst[i] % 2 === 0) {\n      lst[j++] = lst[i];\n      i++;\n    } else {\n      i++;\n    }\n  }\n  return j;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at even indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 4 \n  */\nconst oddEven = (lst) => {\n  let len = lst.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (lst[i] % 2!== 0) {\n      lst[j++] = lst[i];\n      i++;\n    } else {\n      i++;\n    }\n  }\n  return j;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst evenOdd = (lst) => {\n  let len = lst.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (lst[i] % 2 === 0) {\n      lst[j++] = lst[i];\n      i++;\n    } else {\n      i++;\n    }\n  }\n  return j;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at even indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 4 \n  */\nconst oddEvenOdd = (lst) => {\n  let len = lst.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (lst[i] % 2!== 0) {\n      lst[j++] = lst[i];\n      i++;\n    } else {\n      i++;\n    }\n  }\n  return j;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst evenOddEven = (lst) => {\n  let len = lst.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (lst[i] % 2!== 0) {\n      lst[j++] = lst[i];\n      i++;\n    } else {\n      i++;\n    }\n  }\n  return j;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at even indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 4 \n  */\nconst oddEvenOddEven = (lst) => {\n  let len = lst.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (lst[i] % 2!== 0) {\n      lst[j++] = lst[i];\n      i++;\n    } else {\n      i++;\n    }\n  }\n  return j;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst evenOddEvenOddEven = (lst) => {\n  let len = lst.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (lst[i] % 2!== 0) {\n      lst[j++] = lst[i];\n      i++;\n    } else {\n      i++;\n    }\n  }\n  return j;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at even indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 4 \n  */\nconst evenOddEvenOddOddEven = (lst) => {\n  let len = lst.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (lst[i] % 2!== 0) {\n      lst[j++] = lst[i];\n      i++;\n    } else {\n      i++;\n    }\n  }\n  return j;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst evenOddEvenOddOddOddEven = (lst) => {\n  let len = lst.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (lst[i] % 2!== 0) {\n      lst[j++] = lst[i];\n      i++;\n    } else {\n      i++;\n    }\n  }\n  return j;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 4 \n  */\nconst evenOddEvenOddOddOddOddEven = (lst) => {\n  let len = lst.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (lst[i] % 2!== 0) {\n      lst[j++] = lst[i];\n      i++;\n    } else {\n      i++;\n    }\n  }\n  return j;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst evenOddEvenOddOddOddOddOddOddEven = (lst) => {\n  let len = lst.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (lst[i] % 2!== 0) {\n      lst[j++] = lst[i];\n      i++;\n    } else {\n      i++;\n    }\n  }\n  return j;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 4 \n  */\nconst evenOddEvenOddOddOddOddOddOddOddOddOddEven = (lst) => {\n  let len = lst.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (lst[i] % 2!== 0) {\n      lst[j++] = lst[i];\n      i++;\n    } else {\n      i++;\n    }\n  }\n  return j;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst evenOddEvenOddOddOddOddOddOddOddOddOddOddOddOddEven = (lst) => {\n  let len = lst.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (lst[i] % 2!== 0) {\n      lst[j++] = lst[i];\n      i++;\n    } else {\n      i++;\n    }\n  }\n  return j;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 4 \n  */\nconst evenOddEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddO", "passed": 0}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "gc": "<|endoftext|>/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newStr = '';\n  let newStrArr = [];\n  let newStrArr2 = [];\n  let newStrArr3 = [];\n  let newStrArr4 = [];\n  let newStrArr5 = [];\n  let newStrArr6 = [];\n  let newStrArr7 = [];\n  let newStrArr8 = [];\n  let newStrArr9 = [];\n  let newStrArr10 = [];\n  let newStrArr11 = [];\n  let newStrArr12 = [];\n  let newStrArr13 = [];\n  let newStrArr14 = [];\n  let newStrArr15 = [];\n  let newStrArr16 = [];\n  let newStrArr17 = [];\n  let newStrArr18 = [];\n  let newStrArr19 = [];\n  let newStrArr20 = [];\n  let newStrArr21 = [];\n  let newStrArr22 = [];\n  let newStrArr23 = [];\n  let newStrArr24 = [];\n  let newStrArr25 = [];\n  let newStrArr26 = [];\n  let newStrArr27 = [];\n  let newStrArr28 = [];\n  let newStrArr29 = [];\n  let newStrArr30 = [];\n  let newStrArr31 = [];\n  let newStrArr32 = [];\n  let newStrArr33 = [];\n  let newStrArr34 = [];\n  let newStrArr35 = [];\n  let newStrArr36 = [];\n  let newStrArr37 = [];\n  let newStrArr38 = [];\n  let newStrArr39 = [];\n  let newStrArr40 = [];\n  let newStrArr41 = [];\n  let newStrArr42 = [];\n  let newStrArr43 = [];\n  let newStrArr44 = [];\n  let newStrArr45 = [];\n  let newStrArr46 = [];\n  let newStrArr47 = [];\n  let newStrArr48 = [];\n  let newStrArr49 = [];\n  let newStrArr50 = [];\n  let newStrArr51 = [];\n  let newStrArr52 = [];\n  let newStrArr53 = [];\n  let newStrArr54 = [];\n  let newStrArr55 = [];\n  let newStrArr56 = [];\n  let newStrArr57 = [];\n  let newStrArr58 = [];\n  let newStrArr59 = [];\n  let newStrArr60 = [];\n  let newStrArr61 = [];\n  let newStrArr62 = [];\n  let newStrArr63 = [];\n  let newStrArr64 = [];\n  let newStrArr65 = [];\n  let newStrArr66 = [];\n  let newStrArr67 = [];\n  let newStrArr68 = [];\n  let newStrArr69 = [];\n  let newStrArr70 = [];\n  let newStrArr71 = [];\n  let newStrArr72 = [];\n  let newStrArr73 = [];\n  let newStrArr74 = [];\n  let newStrArr75 = [];\n  let newStrArr76 = [];\n  let newStrArr77 = [];\n  let newStrArr78 = [];\n  let newStrArr79 = [];\n  let newStrArr80 = [];\n  let newStrArr81 = [];\n  let newStrArr82 = [];\n  let newStrArr83 = [];\n  let newStrArr84 = [];\n  let newStrArr85 = [];\n  let newStrArr86 = [];\n  let newStrArr87 = [];\n  let newStrArr88 = [];\n  let newStrArr89 = [];\n  let newStrArr90 = [];\n  let newStrArr91 = [];\n  let newStrArr92 = [];\n  let newStrArr93 = [];\n  let newStrArr94 = [];\n  let newStrArr95 = [];\n  let newStrArr96 = [];\n  let newStrArr97 = [];\n  let newStrArr98 = [];\n  let newStrArr99 = [];\n  let newStrArr100 = [];\n  let newStrArr101 = [];\n  let newStrArr102 = [];\n  let newStrArr103 = [];\n  let newStrArr104 = [];\n  let newStrArr105 = [];\n  let newStrArr106 = [];\n  let newStrArr107 = [];\n  let newStrArr108 = [];\n  let newStrArr109 = [];\n  let newStrArr110 = [];\n  let newStrAr1111 = [];\n  let newStrArr112 = [];\n  let newStrArr113 = [];\n  let newStrArr114 = [];\n  let newStrArr115 = [];\n  let newStrArr116 = [];\n  let newStrArr117 = [];\n  let newStrArr118 = [];\n  let newStrArr119 = [];\n  let newStrArr120 = [];\n  let newStrAr121 = [];\n  let newStrAr122 = [];\n  let newStrAr123 = [];\n  let newStrArr124 = [];\n  let newStrArr125 = [];\n  let newStrArr126 = [];\n  let newStrArr127 = [];\n  let newStrArr128 = [];\n  let newStrArr129 = [];\n  let newStrArr130 = [];\n  let newStrArr131 = [];\n  let newStrArr132 = [];\n  let newStrArr133 = [];\n  let newStrArr134 = [];\n  let newStrArr135 = [];\n  let newStrArr136 = [];\n  let newStrArr137 = [];\n  let newStrArr138 = [];\n  let newStrArr139 = [];\n  let newStrArr140 = [];\n  let newStrArr141 = [];\n  let newStrArr142 = [];\n  let newStrArr143 = [];\n  let newStrArr144 = [];\n  let newStrArr145 = [];\n  let newStrArr146 = [];\n  let newStrArr147 = [];\n  let newStrArr148 = [];\n  let newStrArr149 = [];\n  let newStrArr150 = [];\n  let newStrArr151 = [];\n  let newStrArr152 = [];\n  let newStrArr153 = [];\n  let newStrArr154 = [];\n  let newStrArr155 = [];\n  let newStrArr156 = [];\n  let newStrArr157 = [];\n  let newStrArr158 = [];\n  let newStrArr159 = [];\n  let newStrArr160 = [];\n  let newStrArr161 = [];\n  let newStrArr162 = [];\n  let newStrArr163 = [];\n  let newStrArr164 = [];\n  let newStrArr165 = [];\n  let newStrArr166 = [];\n  let newStrArr167 = [];\n  let newStrArr168 = [];\n  let newStrArr169 = [];\n  let newStrArr170 = [];\n  let newStrArr171 = [];\n  let newStrArr172 = [];\n  let newStrArr173 = [];\n  let newStrArr174 = [];\n  let newStrArr175 = [];\n  let newStrArr176 = [];\n  let newStrArr177 = [];\n  let newStrArr178 = [];\n  let newStrArr179 = [];\n  let newStrArr180 = [];\n  let newStrArr181 = [];\n  let newStrArr182 = [];\n  let newStrArr183 = [];\n  let newStrArr184 = [];\n  let newStrArr185 = [];\n  let newStrArr186 = [];\n  let newStrArr187 = [];\n  let newStrArr188 = [];\n  let newStrArr189 = [];\n  let newStrArr190 = [];\n  let newStrArr191 = [];\n  let newStrArr192 = [];\n  let newStrArr193 = [];\n  let newStrArr194 = [];\n  let newStrArr", "passed": 0}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  catchRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  catchRow([], 1) == []\n  catchRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst catchRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "catchRow", "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  catchRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  catchRow([], 1) == []\n  catchRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst catchRow = (lst, x) => {\n  const result = []\n  let row = []\n  let col = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let rowIndex = 0\n  let colIndex = 0\n  let rowLen = lst.length\n  let colLen = lst[0].length\n  let rowIndexLen = row.length\n  let colIndexLen = col.length\n  \n  while (i < rowLen) {\n    while (j < colLen) {\n      if (lst[i][j] === x) {\n        result.push([rowIndex, colIndex])\n        rowIndex++\n        colIndex++\n      }\n      j++\n    }\n    i++\n  }\n  \n  while (j < colLen) {\n    if (lst[0][j] === x) {\n      result.push([rowIndex, colIndex])\n      rowIndex++\n      colIndex++\n    }\n    j++\n  }\n  \n  while (rowIndex < rowIndexLen) {\n    row.push(lst[rowIndex])\n    rowIndex++\n  }\n  \n  while (colIndex < colIndexLen) {\n    col.push(lst[colIndex])\n    colIndex++\n  }\n  \n  return result\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  catchRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  catchRow([], 1) == []\n  catchRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst catchCol = (lst, x) => {\n  const result = []\n  let row = []\n  let col = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let rowIndex = 0\n  let colIndex = 0\n  let rowLen = lst.length\n  let colLen = lst[0].length\n  let rowIndexLen = row.length\n  let colIndexLen = col.length\n  \n  while (i < rowLen) {\n    while (j < colLen) {\n      if (lst[i][j] === x) {\n        result.push([rowIndex, colIndex])\n        rowIndex++\n        colIndex++\n      }\n      j++\n    }\n    i++\n  }\n  \n  while (j < colLen) {\n    if (lst[0][j] === x) {\n      result.push([rowIndex, colIndex])\n      rowIndex++\n      colIndex++\n    }\n    j++\n  }\n  \n  while (rowIndex < rowIndexLen) {\n    row.push(lst[rowIndex])\n    rowIndex++\n  }\n  \n  while (colIndex < colIndexLen) {\n    col.push(lst[colIndex])\n    colIndex++\n  }\n  \n  return result\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  catchRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  catchRow([], 1) == []\n  catchRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst catchDiag = (lst, x) => {\n  const result = []\n  let row = []\n  let col = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let rowIndex = 0\n  let colIndex = 0\n  let rowLen = lst.length\n  let colLen = lst[0].length\n  let rowIndexLen = row.length\n  let colIndexLen = col.length\n  \n  while (i < rowLen) {\n    while (j < colLen) {\n      if (lst[i][j] === x) {\n        result.push([rowIndex, colIndex])\n        rowIndex++\n        colIndex++\n      }\n      j++\n    }\n    i++\n  }\n  \n  while (j < colLen) {\n    if (lst[0][j] === x) {\n      result.push([rowIndex, colIndex])\n      rowIndex++\n      colIndex++\n    }\n    j++\n  }\n  \n  while (rowIndex < rowIndexLen) {\n    row.push(lst[rowIndex])\n    rowIndex++\n  }\n  \n  while (colIndex < colIndexLen) {\n    col.push(lst[colIndex])\n    colIndex++\n  }\n  \n  return result\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  catchRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  catchRow([], 1) == []\n  catchRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst catchDiagRow = (lst, x) => {\n  const result = []\n  let row = []\n  let col = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let rowIndex = 0\n  let colIndex = 0\n  let rowLen = lst.length\n  let colLen = lst[0].length\n  let rowIndexLen = row.length\n  let colIndexLen = col.length\n  \n  while (i < rowLen) {\n    while (j < colLen) {\n      if (lst[i][j] === x) {\n        result.push([rowIndex, colIndex])\n        rowIndex++\n        colIndex++\n      }\n      j++\n    }\n    i++\n  }\n  \n  while (j < colLen) {\n    if (lst[0][j] === x) {\n      result.push([rowIndex, colIndex])\n      rowIndex++\n      colIndex++\n    }\n    j++\n  }\n  \n  while (rowIndex < rowIndexLen) {\n    row.push(lst[rowIndex])\n    rowIndex++\n  }\n", "passed": 0}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "gc": "<|endoftext|>/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.sort((a, b) => {\n    const aSum = a + b;\n    const bSum = a + b;\n    if (aSum % 2 === 0 && bSum % 2!== 0) {\n      return 1;\n    }\n    if (aSum % 2!== 0 && bSum % 2!== 0) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArray;\n};\n\n/**\n * Given an array of non-negative integers, return its maximum value.\n\n  Example:\n  * maxArray([5, 2, 1]) => 5\n  * maxArray([5, 2, 1, 4]) => 4\n  * maxArray([5, 2, 1, 4, 3, 2]) => 3\n  * maxArray([5, 2, 1, 4, 3, 2, 1]) => 2\n  */\nconst maxArray = (array) => {\n  const maxValue = array.reduce((acc, val) => {\n    if (val > acc) {\n      return val;\n    }\n    return acc;\n  }, 0);\n  return maxValue;\n};\n\n/**\n * Given an array of non-negative integers, return its minimum value.\n\n  Example:\n  * minArray([5, 2, 1]) => 1\n  * minArray([5, 2, 1, 4]) => 4\n  * minArray([5, 2, 1, 4, 3, 2]) => 3\n  * minArray([5, 2, 1, 4, 3, 2, 1]) => 2\n  */\nconst minArray = (array) => {\n  const minValue = array.reduce((acc, val) => {\n    if (val < acc) {\n      return val;\n    }\n    return acc;\n  }, 0);\n  return minValue;\n};\n\n/**\n * Given an array of non-negative integers, return its sum of its elements.\n\n  Example:\n  * sumArray([5, 2, 1]) => 5\n  * sumArray([5, 2, 1, 4]) => 10\n  * sumArray([5, 2, 1, 4, 3, 2]) => 15\n  * sumArray([5, 2, 1, 4, 3, 2, 1]) => 25\n  */\nconst sumArray = (array) => {\n  const sum = 0;\n  array.forEach((val) => {\n    sum += val;\n  });\n  return sum;\n};\n\n/**\n * Given an array of non-negative integers, return its difference between its minimum value and its maximum value.\n\n  Example:\n  * differenceArray([5, 2, 1]) => 1\n  * differenceArray([5, 2, 1, 4]) => 2\n  * differenceArray([5, 2, 1, 4, 3, 2]) => 3\n  * differenceArray([5, 2, 1, 4, 3, 2, 1]) => 4\n  */\nconst differenceArray = (array) => {\n  const difference = array.reduce((acc, val) => {\n    if (val < acc) {\n      return val;\n    }\n    return acc;\n  }, 0);\n  return difference;\n};\n\n/**\n * Given an array of non-negative integers, return its difference between its minimum value and its maximum value.\n\n  Example:\n  * differenceArray([5, 2, 1]) => 1\n  * differenceArray([5, 2, 1, 4]) => 2\n  * differenceArray([5, 2, 1, 4, 3, 2]) => 3\n  * differenceArray([5, 2, 1, 4, 3, 2, 1]) => 4\n  */\nconst differenceArray = (array) => {\n  const difference = array.reduce((acc, val) => {\n    if (val < acc) {\n      return val;\n    }\n    return acc;\n  }, 0);\n  return difference;\n};\n\n/**\n * Given an array of non-negative integers, return its difference between its minimum value and its maximum value.\n\n  Example:\n  * differenceArray([5, 2, 1]) => 1\n  * differenceArray([5, 2, 1, 4]) => 2\n  * differenceArray([5, 2, 1, 4, 3, 2]) => 3\n  * differenceArray([5, 2, 1, 4, 3, 2, 1]) => 4\n  */\nconst differenceArray = (array) => {\n  const difference = array.reduce((acc, val) => {\n    if (val < acc) {\n      return val;\n    }\n    return acc;\n  }, 0);\n  return difference;\n};\n\n/**\n * Given an array of non-negative integers, return its difference between its minimum value and its maximum value.\n\n  Example:\n  * differenceArray([5, 2, 1]) => 1\n  * differenceArray([5, 2, 1, 4]) => 2\n  * differenceArray([5, 2, 1, 4, 3, 2]) => 3\n  * differenceArray([5, 2, 1, 4, 3, 2, 1]) => 4\n  */\nconst differenceArray = (array) => {\n  const difference = array.reduce((acc, val) => {\n    if (val < acc) {\n      return val;\n    }\n    return acc;\n  }, 0);\n  return difference;\n};\n\n/**\n * Given an array of non-negative integers, return its difference between its minimum value and its maximum value.\n\n  Example:\n  * differenceArray([5, 2, 1]) => 1\n  * differenceArray([5, 2, 1, 4]) => 2\n  * differenceArray([5, 2, 1, 4, 3, 2]) => 3\n  * differenceArray([5, 2, 1, 4, 3, 2, 1]) => 4\n  */\nconst differenceArray = (array) => {\n  const difference = array.reduce((acc, val) => {\n    if (val < acc) {\n      return val;\n    }\n    return acc;\n  }, 0);\n  return difference;\n};\n\n/**\n * Given an array of non-negative integers, return its difference between its minimum value and its maximum value.\n\n  Example:\n  * differenceArray([5, 2, 1]) => 1\n  * differenceArray([5, 2, 1, 4]) => 2\n  * differenceArray([5, 2, 1, 4, 3, 2]) => 3\n  * differenceArray([5, 2, 1, 4, 3, 2, 1]) => 4\n  */\nconst differenceArray = (array) => {\n  const difference = array.reduce((acc, val) => {\n    if (val < acc) {\n      return val;\n    }\n    return acc;\n  }, 0);\n  return difference;\n};\n\n/**\n * Given an array of non-negative integers, return its difference between its minimum value and its maximum value.\n\n  Example:\n  * differenceArray([5, 2, 1]) => 1\n  * differenceArray([5, 2, 1, 4]) => 2\n  * differenceArray([5, 2, 1, 4, 3, 2]) => 3\n  * differenceArray([5, 2, 1, 4, 3, 2, 1]) => 4\n  */\nconst differenceArray = (array) => {\n  const difference = array.reduce((acc, val) => {\n    if (val < acc) {\n      return val;\n    }\n    return acc;\n  }, 0);\n  return difference;\n};\n\n/**\n * Given an array of non-negative integers, return its difference between its minimum value and its maximum value.\n\n  Example:\n  * differenceArray([5, 2, 1]) => 1\n  * differenceArray([5, 2, 1, 4]) => 2\n  * differenceArray([5, 2, 1, 4, 3, 2]) => 3\n  * differenceArray([5, 2, 1, 4, 3, 2, 1]) => 4\n  */\nconst differenceArray = (array) => {\n  const difference = array.reduce((acc, val) => {\n    if (val < acc) {\n      return val;\n    }\n    return acc;\n  }, 0);\n  return difference;\n};\n\n/**\n * Given an array of non-negative integers, return its difference between its minimum value and its maximum value.\n\n  Example:\n  * differenceArray([5, 2, 1]) => 1\n  * differenceArray([5, 2, 1, 4]) => 2\n  * differenceArray([5, 2, 1, 4, 3, 2]) => 3\n  * differenceArray([5, 2, 1, 4, 3, 2, 1]) => 4\n  */\nconst differenceArray = (array) => {\n  const difference = array.reduce((acc, val) => {\n    if (val < acc) {\n      return val;\n    }\n    return acc;\n  }, 0);\n  return difference;\n};\n\n/**\n * Given an array of non-negative integers, return its difference between its minimum value and its maximum value.\n\n  Example:\n  * ", "passed": 0}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "gc": "<|endoftext|>/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let result = ''\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.indexOf(s[i])\n    result += alphabet[letter + 2]\n  }\n  return result\n}\n\n/*Create a function decrypt that takes a string as an argument and\n  returns a string decrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let result = ''\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.indexOf(s[i])\n    result += alphabet[letter - 2]\n  }\n  return result\n}\n\n/*Create a function rotate that takes a string as an argument and\n  returns a string rotated the specified number of places left or right. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  rotate('hi', 2) returns 'lmn'\n  rotate('asdfghjkl', 2) returns 'ewhjklnop'\n  rotate('gf', 2) returns 'kj'\n  rotate('et', 2) returns 'ix'\n  */\nconst rotate = (s, n) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let result = ''\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.indexOf(s[i])\n    result += alphabet[letter + n%2]\n  }\n  return result\n}\n\n/*Create a function trim that takes a string as an argument and\n  returns a string trimmed from the beginning and end of the string. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  trim('asdfghjkl') returns 'asdfghjkl'\n  trim('gf') returns 'kj'\n  trim('et') returns 'ix'\n  */\nconst trim = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let result = ''\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.indexOf(s[i])\n    if (letter === 0) result +=''\n    else result += s[i]\n  }\n  return result\n}\n\n/*Create a function reverse that takes a string as an argument and\n  returns a string reversed the specified number of places left or right. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  reverse('asdfghjkl', 2) returns 'ghjklmn'\n  reverse('gf', 2) returns 'kj'\n  reverse('et', 2) returns 'ix'\n  */\nconst reverse = (s, n) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let result = ''\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.indexOf(s[i])\n    result += alphabet[letter - n%2]\n  }\n  return result\n}\n\n/*Create a function shuffle that takes a string as an argument and\n  returns a string shuffled according to the specified order. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  shuffle('asdfghjkl') returns 'jklmnasdf'\n  shuffle('gf') returns 'kj'\n  shuffle('et') returns 'ix'\n  */\nconst shuffle = (s, order) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let result = ''\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.indexOf(s[i])\n    result += alphabet[order[letter]]\n  }\n  return result\n}\n\n/*Create a function shuffle that takes a string as an argument and\n  returns a string shuffled according to the specified order. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  shuffle('asdfghjkl', 1) returns 'jklmnasdf'\n  shuffle('gf', 1) returns 'kj'\n  shuffle('et', 1) returns 'ix'\n  */\nconst shuffle = (s, order) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let result = ''\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.indexOf(s[i])\n    result += alphabet[order[letter]]\n  }\n  return result\n}\n\n/*Create a function shuffle that takes a string as an argument and\n  returns a string shuffled according to the specified order. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  shuffle('asdfghjkl', 2) returns 'jklmnasdf'\n  shuffle('gf', 2) returns 'kj'\n  shuffle('et', 2) returns 'ix'\n  */\nconst shuffle = (s, order) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let result = ''\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.indexOf(s[i])\n    result += alphabet[order[letter]]\n  }\n  return result\n}\n\n/*Create a function shuffle that takes a string as an argument and\n  returns a string shuffled according to the specified order. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  shuffle('asdfghjkl', 3) returns 'jklmnasdf'\n  shuffle('gf', 3) returns 'kj'\n  shuffle('et', 3) returns 'ix'\n  */\nconst shuffle = (s, order) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let result = ''\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.indexOf(s[i])\n    result += alphabet[order[letter]]\n  }\n  return result\n}\n\n/*Create a function shuffle that takes a string as an argument and\n  returns a string shuffled according to the specified order. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  shuffle('asdfghjkl', 4) returns 'jklmnasdf'\n  shuffle('gf', 4) returns 'kj'\n  shuffle('et', 4) returns 'ix'\n  */\nconst shuffle = (s, order) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let result = ''\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.indexOf(s[i])\n    result += alphabet[order[letter]]\n  }\n  return result\n}\n\n/*Create a function shuffle that takes a string as an argument and\n  returns a string shuffle", "passed": 0}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rolledMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rolledMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rolledMax", "gc": "<|endoftext|>/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rolledMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rolledMax = (numbers) => {\n  const result = [];\n  let max = 0;\n  let current = 0;\n  let i = 0;\n  while (i < numbers.length) {\n    current = numbers[i];\n    if (current > max) {\n      max = current;\n      result.push(current);\n    }\n    i++;\n  }\n  return result;\n};\n\nconst rollingMax = (numbers) => {\n  const result = [];\n  let max = 0;\n  let current = 0;\n  let i = 0;\n  while (i < numbers.length) {\n    current = numbers[i];\n    if (current > max) {\n      max = current;\n      result.push(current);\n    }\n    i++;\n  }\n  return result;\n};\n\nconst rollingMaxBy = (numbers) => {\n  const result = [];\n  let max = 0;\n  let current = 0;\n  let i = 0;\n  while (i < numbers.length) {\n    current = numbers[i];\n    if (current > max) {\n      max = current;\n      result.push(current);\n    }\n    i++;\n  }\n  return result;\n};\n\nconst rollingMaxByRoll = (numbers) => {\n  const result = [];\n  let max = 0;\n  let current = 0;\n  let i = 0;\n  while (i < numbers.length) {\n    current = numbers[i];\n    if (current > max) {\n      max = current;\n      result.push(current);\n    }\n    i++;\n  }\n  return result;\n};\n\nconst rollingMaxByRollBy = (numbers) => {\n  const result = [];\n  let max = 0;\n  let current = 0;\n  let i = 0;\n  while (i < numbers.length) {\n    current = numbers[i];\n    if (current > max) {\n      max = current;\n      result.push(current);\n    }\n    i++;\n  }\n  return result;\n};\n\nconst rollingMaxByRollByRoll = (numbers) => {\n  const result = [];\n  let max = 0;\n  let current = 0;\n  let i = 0;\n  while (i < numbers.length) {\n    current = numbers[i];\n    if (current > max) {\n      max = current;\n      result.push(current);\n    }\n    i++;\n  }\n  return result;\n};\n\nconst rollingMaxByRollByRollBy = (numbers) => {\n  const result = [];\n  let max = 0;\n  let current = 0;\n  let i = 0;\n  while (i < numbers.length) {\n    current = numbers[i];\n    if (current > max) {\n      max = current;\n      result.push(current);\n    }\n    i++;\n  }\n  return result;\n};\n\nconst rollingMaxByRollByRollByRoll = (numbers) => {\n  const result = [];\n  let max = 0;\n  let current = 0;\n  let i = 0;\n  while (i < numbers.length) {\n    current = numbers[i];\n    if (current > max) {\n      max = current;\n      result.push(current);\n    }\n    i++;\n  }\n  return result;\n};\n\nconst rollingMaxByRollByRollByRollByRoll = (numbers) => {\n  const result = [];\n  let max = 0;\n  let current = 0;\n  let i = 0;\n  while (i < numbers.length) {\n    current = numbers[i];\n    if (current > max) {\n      max = current;\n      result.push(current);\n    }\n    i++;\n  }\n  return result;\n};\n\nconst rollingMaxByRollByRollByRollByRollByRoll = (numbers) => {\n  const result = [];\n  let max = 0;\n  let current = 0;\n  let i = 0;\n  while (i < numbers.length) {\n    current = numbers[i];\n    if (current > max) {\n      max = current;\n      result.push(current);\n    }\n    i++;\n  }\n  return result;\n};\n\nconst rollingMaxByRollByRollByRollByRollByRollByRollByRoll = (numbers) => {\n  const result = [];\n  let max = 0;\n  let current = 0;\n  let i = 0;\n  while (i < numbers.length) {\n    current = numbers[i];\n    if (current > max) {\n      max = current;\n      result.push(current);\n    }\n    i++;\n  }\n  return result;\n};\n\nconst rollingMaxByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollByRollBy", "passed": 0}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "gc": "<|endoftext|>/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || min > lst[i]) {\n      min = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\nmodule.exports = nextSmallest;\n\n},{}],13:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function findSmallest() that returns the 1st smallest element of the list.\n  Return null if there is no such element.\n  \n  findSmallest([1, 2, 3, 4, 5]) == 3\n  findSmallest([5, 1, 4, 3, 2]) == 3\n  findSmallest([]) == null\n  findSmallest([1, 1]) == null\n  */\nconst findSmallest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || min < lst[i]) {\n      min = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\nmodule.exports = findSmallest;\n\n},{}],14:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function findLargest() that returns the largest element of the list.\n  Return null if there is no such element.\n  \n  findLargest([1, 2, 3, 4, 5]) == 5\n  findLargest([5, 1, 4, 3, 2]) == 5\n  findLargest([]) == null\n  findLargest([1, 1]) == null\n  */\nconst findLargest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || max < lst[i]) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\nmodule.exports = findLargest;\n\n},{}],15:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function findSmallest() that returns the 2nd largest element of the list.\n  Return null if there is no such element.\n  \n  findSmallest([1, 2, 3, 4, 5]) == 4\n  findSmallest([5, 1, 4, 3, 2]) == 4\n  findSmallest([]) == null\n  findSmallest([1, 1]) == null\n  */\nconst findSmallest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || max > lst[i]) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\nmodule.exports = findSmallest;\n\n},{}],16:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function findLargest() that returns the largest element of the list.\n  Return null if there is no such element.\n  \n  findLargest([1, 2, 3, 4, 5]) == 3\n  findLargest([5, 1, 4, 3, 2]) == 3\n  findLargest([]) == null\n  findLargest([1, 1]) == null\n  */\nconst findLargest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || min < lst[i]) {\n      min = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\nmodule.exports = findLargest;\n\n},{}],17:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function findSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  findSmallest([1, 2, 3, 4, 5]) == 5\n  findSmallest([5, 1, 4, 3, 2]) == 5\n  findSmallest([]) == null\n  findSmallest([1, 1]) == null\n  */\nconst findSmallest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || max > lst[i]) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\nmodule.exports = findSmallest;\n\n},{}],18:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function findLargest() that returns the 2nd largest element of the list.\n  Return null if there is no such element.\n  \n  findLargest([1, 2, 3, 4, 5]) == 3\n  findLargest([5, 1, 4, 3, 2]) == 3\n  findLargest([]) == null\n  findLargest([1, 1]) == null\n  */\nconst findLargest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || min < lst[i]) {\n      min = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\nmodule.exports = findLargest;\n\n},{}],19:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function findSmallest() that returns the 1st smallest element of the list.\n  Return null if there is no such element.\n  \n  findSmallest([1, 2, 3, 4, 5]) == 3\n  findSmallest([5, 1, 4, 3, 2]) == 3\n  findSmallest([]) == null\n  findSmallest([1, 1]) == null\n  */\nconst findSmallest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || max > lst[i]) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\nmodule.exports = findSmallest;\n\n},{}],20:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function findLargest() that returns the 2nd largest element of the list.\n  Return null if there is no such element.\n  \n  findLargest([1, 2, 3, 4, 5]) == 3\n  findLargest([5, 1, 4, 3, 2]) == 3\n  findLargest([]) == null\n  findLargest([1, 1]) == null\n  */\nconst findLargest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || min > lst[i]) {\n      min = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\nmodule.exports = findLargest;\n\n},{}],21:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function findSmallest() that returns the 1st smallest element of the list.\n  Return null if there is no such element.\n  \n  findSmallest([1, 2, 3, 4, 5]) == 3\n  findSmallest([5, 1, 4, 3, 2]) == 3\n  findSmallest([]) == null\n  findSmallest([1, 1]) == null\n  */\nconst findSmallest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || max < lst[i]) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\nmodule.exports = findSmallest;\n\n},{}],22:[function(require,module,exports){\n/*\n  You are given ", "passed": 0}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBlase(\"Hello world\")\n  0\n  >>> isBlase(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBlase = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBlase", "gc": "<|endoftext|>/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBlase(\"Hello world\")\n  0\n  >>> isBlase(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBlase = (S) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;", "passed": 0}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "gc": "<|endoftext|>/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y && x === z\n}\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZero = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y || x === z\n}\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZeroOrZero = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y || x === z\n}\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZeroOrZeroOrZero = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y || x === z\n}\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y || x === z\n}\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y || x === z\n}\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y || x === z\n}\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y || x === z\n}\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y || x === z\n}\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y || x === z\n}\n\n/**\n * Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, ", "passed": 0}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "gc": "<|endoftext|>/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = '';\n  let vowels = 'aeiouAEIOU';\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let vowelsIndex = alphabet.indexOf(vowels);\n  let alphabetIndex = alphabet.indexOf(message);\n  let vowelsIndex = alphabetIndex - vowelsIndex;\n  let vowelsIndex = alphabetIndex - vowelsIndex;\n  \n  for(let i = 0; i < message.length; i++) {\n    let letter = message.charAt(i);\n    \n    encoded = encoded + alphabet[letter];\n    \n    if(vowelsIndex < alphabetIndex && letter === alphabet[vowelsIndex]) {\n      encoded = encoded.replace(letter, alphabet[vowelsIndex]);\n      vowelsIndex++;\n    }\n  }\n  \n  return encoded;\n};\n\n/*\n  Write a function that takes a message, and decodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> decode('TGST')\n  'test'\n  >>> decode('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decode = (message) => {\n  let decoded = '';\n  let vowels = 'aeiouAEIOU';\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let vowelsIndex = alphabet.indexOf(vowels);\n  let alphabetIndex = alphabet.indexOf(message);\n  let vowelsIndex = alphabetIndex - vowelsIndex;\n  let vowelsIndex = alphabetIndex - vowelsIndex;\n  \n  for(let i = 0; i < message.length; i++) {\n    let letter = message.charAt(i);\n    \n    decoded = decoded + alphabet[letter];\n    \n    if(vowelsIndex < alphabetIndex && letter === alphabet[vowelsIndex]) {\n      decoded = decoded.replace(letter, alphabet[vowelsIndex]);\n      vowelsIndex++;\n    }\n  }\n  \n  return decoded;\n};\n\n/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('TGST')\n  'test'\n  >>> encode('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst encodeAndDecode = (message) => {\n  let encoded = encode(message);\n  let decoded = decode(encoded);\n  \n  return [encoded, decoded];\n};\n\n/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encodeAndDecode('TGST')\n  ['test', 'TGST']\n  >>> encodeAndDecode('tHKS KS C MGSSCGG')\n  ['This is a message', 'tHKS KS C MGSSCGG']\n  */\nconst encodeAndDecodeAndReturn = (message) => {\n  let encoded = encode(message);\n  let decoded = decode(encoded);\n  \n  return [encoded, decoded];\n};\n\n/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encodeAndDecodeAndReturn('TGST')\n  ['test', 'TGST']\n  >>> encodeAndDecodeAndReturn('tHKS KS C MGSSCGG')\n  ['This is a message', 'tHKS KS C MGSSCGG']\n  */\nconst encodeAndDecodeAndReturnAndReturn = (message) => {\n  let encoded = encode(message);\n  let decoded = decode(encoded);\n  \n  return [encoded, decoded];\n};\n\n/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encodeAndDecodeAndReturnAndReturn('TGST')\n  ['test', 'TGST']\n  >>> encodeAndDecodeAndReturnAndReturn('tHKS KS C MGSSCGG')\n  ['This is a message', 'tHKS KS C MGSSCGG']\n  */\nconst encodeAndDecodeAndReturnAndReturnAndReturn = (message) => {\n  let encoded = encode(message);\n  let decoded = decode(encoded);\n  \n  return [encoded, decoded];\n};\n\n/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encodeAndDecodeAndReturnAndReturnAndReturn('TGST')\n  ['test', 'TGST']\n  >>> encodeAndDecodeAndReturnAndReturnAndReturn('tHKS KS C MGSSCGG')\n  ['This is a message', 'tHKS KS C MGSSCGG']\n  */\nconst encodeAndDecodeAndReturnAndReturnAndReturnAndReturn = (message) => {\n  let encoded = encode(message);\n  let decoded = decode(encoded);\n  \n  return [encoded, decoded];\n};\n\n/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encodeAndDecodeAndReturnAndReturnAndReturnAndReturn('TGST')\n  ['test', 'TGST']\n  >>> encodeAndDecodeAndReturnAndReturnAndReturnAndReturnAndReturn('tHKS KS C MGSSCGG')\n  ['This is a message', 'tHKS KS C MGSSCGG']\n  */\nconst encodeAndDecodeAndReturnAndReturnAndReturnAndReturnAndReturn = (message) => {\n  let encoded = encode(message);\n  let decoded = decode(encoded);\n  \n  return [encoded, decoded];\n};\n\n/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encodeAndDecodeAndReturnAndReturnAndReturnAndReturnAndReturnAndReturn('TGST')\n  ['test', 'TGST']\n  >>> ", "passed": 0}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "gc": "<|endoftext|>/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let maxPrime = lst.reduce((acc, curr) => {\n    if (curr % 2 === 0) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  let sum = 0;\n  maxPrime.forEach(element => {\n    sum += parseInt(element.toString().split('').reduce((acc, curr) => {\n      return acc + parseInt(curr);\n    }, 0));\n  });\n  return sum;\n};\n\n/*\n  You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let maxPrime = lst.reduce((acc, curr) => {\n    if (curr % 2 === 0) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  let sum = 0;\n  maxPrime.forEach(element => {\n    sum += parseInt(element.toString().split('').reduce((acc, curr) => {\n      return acc + parseInt(curr);\n    }, 0));\n  });\n  return sum;\n};\n\n/*\n  You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let maxPrime = lst.reduce((acc, curr) => {\n    if (curr % 2 === 0) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  let sum = 0;\n  maxPrime.forEach(element => {\n    sum += parseInt(element.toString().split('').reduce((acc, curr) => {\n      return acc + parseInt(curr);\n    }, 0));\n  });\n  return sum;\n};\n\n/*\n  You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let maxPrime = lst.reduce((acc, curr) => {\n    if (curr % 2 === 0) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  let sum = 0;\n  maxPrime.forEach(element => {\n    sum += parseInt(element.toString().split('').reduce((acc, curr) => {\n      return acc + parseInt(curr);\n    }, 0));\n  });\n  return sum;\n};\n\n/*\n  You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let maxPrime = lst.reduce((acc, curr) => {\n    if (curr % 2 === 0) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  let sum = 0;\n  maxPrime.forEach(element => {\n    sum += parseInt(element.toString().split('').reduce((acc, curr) => {\n      return acc + parseInt(curr);\n    }, 0));\n  });\n  return sum;\n};\n\n/*\n  You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let maxPrime = lst.reduce((acc, curr) => {\n    if (curr % 2 === 0) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  let sum = 0;\n  maxPrime.forEach(element => {\n    sum += parseInt(element.toString().split('').reduce((acc, curr) => {\n      return acc + parseInt(curr);\n    }", "passed": 0}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  determineDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  determineDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  determineDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  determineDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  determineDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst determineDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "determineDictCase", "gc": "<|endoftext|>/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  determineDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  determineDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  determineDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  determineDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  determineDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst determineDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  keys.sort();\n  let allKeysAreStrings = keys.every(key => dict[key].toString().toLowerCase() === dict[key].toString().toUpperCase());\n  return allKeysAreStrings;\n};\n\n/*\n  Given a string, return true if all characters are lowercase or all characters are uppercase, else return false.\n  The function should return false is the given string is empty.\n  Examples:\n  determineStringCase(\"a\") should return true.\n  determineStringCase(\"A\") should return false.\n  determineStringCase(\"Aa\") should return false.\n  determineStringCase(\"AaA\") should return false.\n  determineStringCase(\"AaAa\") should return false.\n  determineStringCase(\"AaAaA\") should return false.\n  determineStringCase(\"AaAaAa\") should return false.\n  determineStringCase(\"AaAaAaA\") should return false.\n  determineStringCase(\"AaAaAaAa\") should return false.\n  determineStringCase(\"AaAaAaAaAa\") should return false.\n  determineStringCase(\"AaAaAaAaAaA\") should return false.\n  determineStringCase(\"AaAaAaAaAaAaAa\") should return false.\n  determineStringCase(\"AaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaA", "passed": 0}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  considerUpTo(5) => [2,3]\n  considerUpTo(11) => [2,3,5,7]\n  considerUpTo(0) => []\n  considerUpTo(20) => [2,3,5,7,11,13,17,19]\n  considerUpTo(1) => []\n  considerUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst considerUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "considerUpTo", "gc": "<|endoftext|>/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  considerUpTo(5) => [2,3]\n  considerUpTo(11) => [2,3,5,7]\n  considerUpTo(0) => []\n  considerUpTo(20) => [2,3,5,7,11,13,17,19]\n  considerUpTo(1) => []\n  considerUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst considerUpTo = (n) => {\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19];\n  let primesLength = primes.length;\n  let primesIndex = 0;\n  let primesCount = 0;\n  let primesArray = [];\n  while (primesCount < n) {\n    if (primesIndex < primesLength) {\n      if (primes[primesIndex] % 2 === 0) {\n        primesArray[primesCount] = primesIndex;\n        primesCount++;\n      }\n      primesIndex++;\n    }\n  }\n  return primesArray;\n};\n\n/*\n  Given an array of integers, return an array of the unique prime factors.\n  For example, considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  considerFactors([2,3,5,7,11,13,17]) => [2,3,5,7,11,13,17]\n  consider", "passed": 0}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  breed(148, 412) should return 16.\n  breed(19, 28) should return 72.\n  breed(2020, 1851) should return 0.\n  breed(14,-15) should return 20.\n  */\nconst breed = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "breed", "gc": "<|endoftext|>/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  breed(148, 412) should return 16.\n  breed(19, 28) should return 72.\n  breed(2020, 1851) should return 0.\n  breed(14,-15) should return 20.\n  */\nconst breed = (a, b) => {\n  let sum = 0;\n  let digit = 0;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n  let temp4 = 0;\n  let temp5 = 0;\n  let temp6 = 0;\n  let temp7 = 0;\n  let temp8 = 0;\n  let temp9 = 0;\n  let temp10 = 0;\n  let temp11 = 0;\n  let temp12 = 0;\n  let temp13 = 0;\n  let temp14 = 0;\n  let temp15 = 0;\n  let temp16 = 0;\n  let temp17 = 0;\n  let temp18 = 0;\n  let temp19 = 0;\n  let temp20 = 0;\n  let temp21 = 0;\n  let temp22 = 0;\n  let temp23 = 0;\n  let temp24 = 0;\n  let temp25 = 0;\n  let temp26 = 0;\n  let temp27 = 0;\n  let temp28 = 0;\n  let temp29 = 0;\n  let temp30 = 0;\n  let temp31 = 0;\n  let temp32 = 0;\n  let temp33 = 0;\n  let temp34 = 0;\n  let temp35 = 0;\n  let temp36 = 0;\n  let temp37 = 0;\n  let temp38 = 0;\n  let temp39 = 0;\n  let temp40 = 0;\n  let temp41 = 0;\n  let temp42 = 0;\n  let temp43 = 0;\n  let temp44 = 0;\n  let temp45 = 0;\n  let temp46 = 0;\n  let temp47 = 0;\n  let temp48 = 0;\n  let temp49 = 0;\n  let temp50 = 0;\n  let temp51 = 0;\n  let temp52 = 0;\n  let temp53 = 0;\n  let temp54 = 0;\n  let temp55 = 0;\n  let temp56 = 0;\n  let temp57 = 0;\n  let temp58 = 0;\n  let temp59 = 0;\n  let temp60 = 0;\n  let temp61 = 0;\n  let temp62 = 0;\n  let temp63 = 0;\n  let temp64 = 0;\n  let temp65 = 0;\n  let temp66 = 0;\n  let temp67 = 0;\n  let temp68 = 0;\n  let temp69 = 0;\n  let temp70 = 0;\n  let temp71 = 0;\n  let temp72 = 0;\n  let temp73 = 0;\n  let temp74 = 0;\n  let temp75 = 0;\n  let temp76 = 0;\n  let temp77 = 0;\n  let temp78 = 0;\n  let temp79 = 0;\n  let temp80 = 0;\n  let temp81 = 0;\n  let temp82 = 0;\n  let temp83 = 0;\n  let temp84 = 0;\n  let temp85 = 0;\n  let temp86 = 0;\n  let temp87 = 0;\n  let temp88 = 0;\n  let temp89 = 0;\n  let temp90 = 0;\n  let temp91 = 0;\n  let temp92 = 0;\n  let temp93 = 0;\n  let temp94 = 0;\n  let temp95 = 0;\n  let temp96 = 0;\n  let temp97 = 0;\n  let temp98 = 0;\n  let temp99 = 0;\n  let temp100 = 0;\n  let temp101 = 0;\n  let temp102 = 0;\n  let temp103 = 0;\n  let temp104 = 0;\n  let temp105 = 0;\n  let temp106 = 0;\n  let temp107 = 0;\n  let temp108 = 0;\n  let temp109 = 0;\n  let temp110 = 0;\n  let temp111 = 0;\n  let temp112 = 0;\n  let temp113 = 0;\n  let temp114 = 0;\n  let temp115 = 0;\n  let temp116 = 0;\n  let temp117 = 0;\n  let temp118 = 0;\n  let temp119 = 0;\n  let temp120 = 0;\n  let temp121 = 0;\n  let temp122 = 0;\n  let temp123 = 0;\n  let temp124 = 0;\n  let temp125 = 0;\n  let temp126 = 0;\n  let temp127 = 0;\n  let temp128 = 0;\n  let temp129 = 0;\n  let temp130 = 0;\n  let temp131 = 0;\n  let temp132 = 0;\n  let temp133 = 0;\n  let temp134 = 0;\n  let temp135 = 0;\n  let temp136 = 0;\n  let temp137 = 0;\n  let temp138 = 0;\n  let temp139 = 0;\n  let temp140 = 0;\n  let temp141 = 0;\n  let temp142 = 0;\n  let temp143 = 0;\n  let temp144 = 0;\n  let temp145 = 0;\n  let temp146 = 0;\n  let temp147 = 0;\n  let temp148 = 0;\n  let temp149 = 0;\n  let temp150 = 0;\n  let temp151 = 0;\n  let temp152 = 0;\n  let temp153 = 0;\n  let temp154 = 0;\n  let temp155 = 0;\n  let temp156 = 0;\n  let temp157 = 0;\n  let temp158 = 0;\n  let temp159 = 0;\n  let temp160 = 0;\n  let temp161 = 0;\n  let temp162 = 0;\n  let temp163 = 0;\n  let temp164 = 0;\n  let temp165 = 0;\n  let temp166 = 0;\n  let temp167 = 0;\n  let temp168 = 0;\n  let temp169 = 0;\n  let temp170 = 0;\n  let temp171 = 0;\n  let temp172 = 0;\n  let temp173 = 0;\n  let temp174 = 0;\n  let temp175 = 0;\n  let temp176 = 0;\n  let temp177 = 0;\n  let temp178 = 0;\n  let temp179 = 0;\n  let temp180 = 0;\n  let temp181 = 0;\n  let temp182 = 0;\n  let temp183 = 0;\n  let temp184 = 0;\n  let temp185 = 0;\n  let temp186 = 0;\n  let temp187 = 0;\n  let temp188 = 0;\n  let temp189 = 0;\n  let temp190 = 0;\n  let temp191 = 0;\n  let temp192 = 0;\n  let temp193 = 0;\n  let temp194 = 0;\n  let temp195 = 0;\n  let temp196 = 0;\n  let temp197 = 0;\n  let temp198 = 0;\n  let temp199 = 0;\n  let temp200 = 0;\n  let temp201 = 0;\n  let temp202 = 0;\n  let temp203 = 0;\n  let temp204 = 0;\n  let temp205 = 0;\n  let temp206 = 0;\n  let temp207 = 0;\n  let temp208 = 0;\n  let temp209 = 0;\n  let temp210 = 0;\n  let temp211 = 0;\n  let temp212 = 0;\n  let temp213 = 0;\n  let temp214 = 0;\n  let temp215 = 0;\n  let temp216 = 0;\n  let temp217 = 0;\n  let temp218 = 0;\n  let temp219 = 0;\n  let temp220 = 0;\n  let temp221 = 0;\n  let temp222 = 0;\n  let temp223 = 0;\n  let temp224 = 0;\n  let temp225 = 0;\n  let temp226 = 0;\n  let temp227 = 0;\n  let temp228 = 0;\n  let temp229 = 0;\n  let temp230 = 0;\n  let temp231 = 0;\n  let temp232 = 0;\n  let temp233 = 0;\n  let temp234 = 0;\n  let temp235 = 0;\n  let temp236 = 0;\n  let temp237 = 0;\n  let temp238 = 0;\n  let temp239 = 0;\n  let temp240 = 0;\n  let temp241 = 0;\n  let temp242 = 0;\n  let temp243 = 0;\n  let temp244 = 0;\n  let temp245 = 0;\n  let temp246 = 0;\n  let temp247 = 0;\n  let temp248 = 0;\n  let temp249 = 0;\n  let temp250 = 0;\n  let temp251 = 0;\n  let temp252 = 0;\n  let temp253 = 0;\n  let temp254 = 0;\n  let temp255 = 0;\n  let temp256 = 0;\n  let temp257 = 0;\n  let temp258 = 0;\n  let temp259 = 0;\n  let temp260 = 0;\n  let temp261 = 0;\n  let temp262 = 0;\n  let temp263 = 0;\n  let temp264 = 0;\n  let temp265 = 0;\n  let temp266 = 0;\n  let temp267 = 0;\n  let temp268 = 0;\n  let temp269 = 0;\n  let temp270 = 0;\n  let temp271 = 0;\n  let temp272 = 0;\n  let temp273 = 0;\n  let temp274 = 0;\n  let temp275 = 0;\n  let temp276 = 0;\n  let temp277 = 0;\n  let temp278 = 0;\n  let temp279 = 0;\n  let temp280 = 0;\n  let temp281 = 0;\n  let temp282 = 0;\n  let temp283 = 0;\n  let temp284 = 0;\n  let temp285 = 0;\n  let temp286 = 0;\n  let temp287 = 0;\n  let temp288 = 0;\n  let temp289 = 0;\n  let temp", "passed": 0}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  considerUpper('aBCdEf') returns 1\n  considerUpper('abcdefg') returns 0\n  considerUpper('dBBE') returns 0\n  */\nconst considerUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "considerUpper", "gc": "<|endoftext|>/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  considerUpper('aBCdEf') returns 1\n  considerUpper('abcdefg') returns 0\n  considerUpper('dBBE') returns 0\n  */\nconst considerUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let ", "passed": 0}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closeInteger(\"10\")\n  10\n  >>> closeInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closeInteger(\"14.5\") should\n  return 15 and closeInteger(\"-14.5\") should return -15.\n  */\nconst closeInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closeInteger", "gc": "<|endoftext|>/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closeInteger(\"10\")\n  10\n  >>> closeInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closeInteger(\"14.5\") should\n  return 15 and closeInteger(\"-14.5\") should return -15.\n  */\nconst closeInteger = (value) => {\n  const [integer, fraction] = value.split(\".\");\n  const [integer2, fraction2] = fraction.split(\".\");\n  const integerDiff = Math.abs(integer - integer2);\n  const fractionDiff = Math.abs(fraction - fraction2);\n  if (integerDiff < fractionDiff) {\n    return integer;\n  }\n  return integer2;\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }\n};\n\n/**\n * Given a string, convert it to a number.\n * If the string cannot be converted to a number, return NaN.\n */\nconst toNumber = (string) => {\n  try {\n    return parseFloat(string);\n  } catch (e) {\n    return NaN;\n  }", "passed": 0}
