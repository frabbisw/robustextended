{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hadClosestElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hadClosestElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hadClosestElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hadClosestElements", "gc": "<|endoftext|>/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hadClosestElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hadClosestElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hadClosestElements = (numbers, threshold) => {\n  const closest = numbers.reduce((acc, curr) => {\n    const diff = curr - acc;\n    if (diff < Math.abs(diff)) {\n      return curr;\n    }\n    return acc;\n  }, 0);\n  return Math.abs(closest - threshold) < Math.abs(closest);\n};\n\n/**\n * Check if given number is in given list of numbers.\n * If given number is in given list of numbers, return true.\n * If given number is not in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is not in given list of numbers and given number is\n * in given list of numbers, return true.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given number is not\n * in given list of numbers, return false.\n * If given number is in given list of numbers and given ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroup('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroup = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroup", "gc": "<|endoftext|>/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroup('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroup = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]*)\\)/gi);\n  const paren_group_strings = [];\n  let paren_group_string = '';\n  for (let i = 0; i < paren_groups.length; i++) {\n    paren_group_string += paren_groups[i];\n    if (paren_groups[i].match(/\\)/)) {\n      paren_group_strings.push(paren_group_string);\n      paren_group_string = '';\n    }\n  }\n  if (paren_group_string) {\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return the list of those groups as a\n  string separated by commas.\n  >>> separateParenGroup('( ) (( )) (( )( ))')\n  '()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "gc": "<|endoftext|>/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromePrefix = '';\n  let longestPalindromeSuffix = '';\n  let palindromeLength = 0;\n  let palindromePrefix = '';\n  let palindromeSuffix = '';\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;\n  let palindromeSuffixIndex = 0;\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n  let palindromePrefixIndex = 0;", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> madeAPiles(3)\n  [3, 5, 7]\n  */\nconst madeAPiles = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "madeAPiles", "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> madeAPiles(3)\n  [3, 5, 7]\n  */\nconst madeAPiles = (n) => {\n  const stones = [];\n  let level = 1;\n  while (level < n) {\n    const nextLevel = level + 2;\n    if (nextLevel % 2 === 0) {\n      stones.push(nextLevel);\n    } else {\n      stones.push(nextLevel + 1);\n    }\n    level = nextLevel;\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> madeAPiles(3)\n  [3, 5, 7]\n  */\nconst madeAPiles2 = (n) => {\n  const stones = [];\n  let level = 1;\n  while (level < n) {\n    const nextLevel = level + 2;\n    if (nextLevel % 2 === 0) {\n      stones.push(nextLevel);\n    } else {\n      stones.push(nextLevel + 1);\n    }\n    level = nextLevel;\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> madeAPiles(3)\n  [3, 5, 7]\n  */\nconst madeAPiles3 = (n) => {\n  const stones = [];\n  let level = 1;\n  while (level < n) {\n    const nextLevel = level + 2;\n    if (nextLevel % 2 === 0) {\n      stones.push(nextLevel);\n    } else {\n      stones.push(nextLevel + 1);\n    }\n    level = nextLevel;\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> madeAPiles(3)\n  [3, 5, 7]\n  */\nconst madeAPiles4 = (n) => {\n  const stones = [];\n  let level = 1;\n  while (level < n) {\n    const nextLevel = level + 2;\n    if (nextLevel % 2 === 0) {\n      stones.push(nextLevel);\n    } else {\n      stones.push(nextLevel + 1);\n    }\n    level = nextLevel;\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> madeAPiles(3)\n  [3, 5, 7]\n  */\nconst madeAPiles5 = (n) => {\n  const stones = [];\n  let level = 1;\n  while (level < n) {\n    const nextLevel = level + 2;\n    if (nextLevel % 2 === 0) {\n      stones.push(nextLevel);\n    } else {\n      stones.push(nextLevel + 1);\n    }\n    level = nextLevel;\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> madeAPiles(3)\n  [3, 5, 7]\n  */\nconst madeAPiles6 = (n) => {\n  const stones = [];\n  let level = 1;\n  while (level < n) {\n    const nextLevel = level + 2;\n    if (nextLevel % 2 === 0) {\n      stones.push(nextLevel);\n    } else {\n      stones.push(nextLevel + 1);\n    }\n    level = nextLevel;\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> madeAPiles(3)\n  [3, 5, 7]\n  */\nconst madeAPiles7 = (n) => {\n  const stones = [];\n  let level = 1;\n  while (level < n) {\n    const nextLevel = level + 2;\n    if (nextLevel % 2 === 0) {\n      stones.push(nextLevel);\n    } else {\n      stones.push(nextLevel + 1);\n    }\n    level = nextLevel;\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> madeAPiles(3)\n  [3, 5, 7]\n  */\nconst madeAPiles8 = (n) => {\n  const stones = [];\n  let level = 1;\n  while (level < n) {\n    const nextLevel = level + 2;\n    if (nextLevel % 2 === 0) {\n      stones.push(nextLevel);\n    } else {\n      stones.push(nextLevel + 1);\n    }\n    level = nextLevel;\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> madeAPiles(3)\n  [3, 5, 7]\n  */\nconst madeAPiles9 = (n) => {\n  const stones = [];\n  let level = 1;\n  while (level < n) {\n    const nextLevel = level + 2;\n    if (nextLevel % 2 === 0) {\n      stones.push(nextLevel);\n    } else {\n      stones.push(nextLevel + 1);\n    }\n    level = nextLevel;\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordString", "gc": "<|endoftext|>/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordString = (s) => {\n  let words = s.split(/,|\\s/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordString = (s) => {\n  let words = s.split(/,|\\s/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordString = (s) => {\n  let words = s.split(/,|\\s/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordString = (s) => {\n  let words = s.split(/,|\\s/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordString = (s) => {\n  let words = s.split(/,|\\s/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordString = (s) => {\n  let words = s.split(/,|\\s/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordString = (s) => {\n  let words = s.split(/,|\\s/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordString = (s) => {\n  let words = s.split(/,|\\s/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordString = (s) => {\n  let words = s.split(/,|\\s/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordString = (s) => {\n  let words = s.split(/,|\\s/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordString = (s) => {\n  let words = s.split(/,|\\s/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordString = (s) => {\n  let words = s.split(/,|\\s/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordString = (s) => {\n  let words = s.split(/,|\\s/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "gc": "<|endoftext|>/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest odd integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(x, y);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(x, y);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(x, y);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(x, y);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(x, y);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(x, y);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(x, y);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(x, y);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return chooseNum(x, y);\n  }\n  return -1;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundingAvg(1, 5) => \"0b11\"\n  roundingAvg(7, 5) => -1\n  roundingAvg(10, 20) => \"0b1111\"\n  roundingAvg(20, 33) => \"0b11010\"\n  */\nconst roundingAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundingAvg", "gc": "<|endoftext|>/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundingAvg(1, 5) => \"0b11\"\n  roundingAvg(7, 5) => -1\n  roundingAvg(10, 20) => \"0b1111\"\n  roundingAvg(20, 33) => \"0b11010\"\n  */\nconst roundingAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  let decimal = 0;\n  let decimalString = \"\";\n  let decimalString2 = \"\";\n  let decimalString3 = \"\";\n  let decimalString4 = \"\";\n  let decimalString5 = \"\";\n  let decimalString6 = \"\";\n  let decimalString7 = \"\";\n  let decimalString8 = \"\";\n  let decimalString9 = \"\";\n  let decimalString10 = \"\";\n  let decimalString11 = \"\";\n  let decimalString12 = \"\";\n  let decimalString13 = \"\";\n  let decimalString14 = \"\";\n  let decimalString15 = \"\";\n  let decimalString16 = \"\";\n  let decimalString17 = \"\";\n  let decimalString18 = \"\";\n  let decimalString19 = \"\";\n  let decimalString20 = \"\";\n  let decimalString21 = \"\";\n  let decimalString22 = \"\";\n  let decimalString23 = \"\";\n  let decimalString24 = \"\";\n  let decimalString25 = \"\";\n  let decimalString26 = \"\";\n  let decimalString27 = \"\";\n  let decimalString28 = \"\";\n  let decimalString29 = \"\";\n  let decimalString30 = \"\";\n  let decimalString31 = \"\";\n  let decimalString32 = \"\";\n  let decimalString33 = \"\";\n  let decimalString34 = \"\";\n  let decimalString35 = \"\";\n  let decimalString36 = \"\";\n  let decimalString37 = \"\";\n  let decimalString38 = \"\";\n  let decimalString39 = \"\";\n  let decimalString40 = \"\";\n  let decimalString41 = \"\";\n  let decimalString42 = \"\";\n  let decimalString43 = \"\";\n  let decimalString44 = \"\";\n  let decimalString45 = \"\";\n  let decimalString46 = \"\";\n  let decimalString47 = \"\";\n  let decimalString48 = \"\";\n  let decimalString49 = \"\";\n  let decimalString50 = \"\";\n  let decimalString51 = \"\";\n  let decimalString52 = \"\";\n  let decimalString53 = \"\";\n  let decimalString54 = \"\";\n  let decimalString55 = \"\";\n  let decimalString56 = \"\";\n  let decimalString57 = \"\";\n  let decimalString58 = \"\";\n  let decimalString59 = \"\";\n  let decimalString60 = \"\";\n  let decimalString61 = \"\";\n  let decimalString62 = \"\";\n  let decimalString63 = \"\";\n  let decimalString64 = \"\";\n  let decimalString65 = \"\";\n  let decimalString66 = \"\";\n  let decimalString67 = \"\";\n  let decimalString68 = \"\";\n  let decimalString69 = \"\";\n  let decimalString70 = \"\";\n  let decimalString71 = \"\";\n  let decimalString72 = \"\";\n  let decimalString73 = \"\";\n  let decimalString74 = \"\";\n  let decimalString75 = \"\";\n  let decimalString76 = \"\";\n  let decimalString77 = \"\";\n  let decimalString78 = \"\";\n  let decimalString79 = \"\";\n  let decimalString80 = \"\";\n  let decimalString81 = \"\";\n  let decimalString82 = \"\";\n  let decimalString83 = \"\";\n  let decimalString84 = \"\";\n  let decimalString85 = \"\";\n  let decimalString86 = \"\";\n  let decimalString87 = \"\";\n  let decimalString88 = \"\";\n  let decimalString89 = \"\";\n  let decimalString90 = \"\";\n  let decimalString91 = \"\";\n  let decimalString92 = \"\";\n  let decimalString93 = \"\";\n  let decimalString94 = \"\";\n  let decimalString95 = \"\";\n  let decimalString96 = \"\";\n  let decimalString97 = \"\";\n  let decimalString98 = \"\";\n  let decimalString99 = \"\";\n  let decimalString100 = \"\";\n  let decimalString101 = \"\";\n  let decimalString102 = \"\";\n  let decimalString103 = \"\";\n  let decimalString104 = \"\";\n  let decimalString105 = \"\";\n  let decimalString106 = \"\";\n  let decimalString107 = \"\";\n  let decimalString108 = \"\";\n  let decimalString109 = \"\";\n  let decimalString110 = \"\";\n  let decimalString111 = \"\";\n  let decimalString112 = \"\";\n  let decimalString113 = \"\";\n  let decimalString114 = \"\";\n  let decimalString115 = \"\";\n  let decimalString116 = \"\";\n  let decimalString117 = \"\";\n  let decimalString118 = \"\";\n  let decimalString119 = \"\";\n  let decimalString120 = \"\";\n  let decimalString121 = \"\";\n  let decimalString122 = \"\";\n  let decimalString123 = \"\";\n  let decimalString124 = \"\";\n  let decimalString125 = \"\";\n  let decimalString126 = \"\";\n  let decimalString127 = \"\";\n  let decimalString128 = \"\";\n  let decimalString129 = \"\";\n  let decimalString130 = \"\";\n  let decimalString131 = \"\";\n  let decimalString132 = \"\";\n  let decimalString133 = \"\";\n  let decimalString134 = \"\";\n  let decimalString135 = \"\";\n  let decimalString136 = \"\";\n  let decimalString137 = \"\";\n  let decimalString138 = \"\";\n  let decimalString139 = \"\";\n  let decimalString140 = \"\";\n  let decimalString141 = \"\";\n  let decimalString142 = \"\";\n  let decimalString143 = \"\";\n  let decimalString144 = \"\";\n  let decimalString145 = \"\";\n  let decimalString146 = \"\";\n  let decimalString147 = \"\";\n  let decimalString148 = \"\";\n  let decimalString149 = \"\";\n  let decimalString150 = \"\";\n  let decimalString151 = \"\";\n  let decimalString152 = \"\";\n  let decimalString153 = \"\";\n  let decimalString154 = \"\";\n  let decimalString155 = \"\";\n  let decimalString156 = \"\";\n  let decimalString157 = \"\";\n  let decimalString158 = \"\";\n  let decimalString159 = \"\";\n  let decimalString160 = \"\";\n  let decimalString161 = \"\";\n  let decimalString162 = \"\";\n  let decimalString163 = \"\";\n  let decimalString164 = \"\";\n  let decimalString165 = \"\";\n  let decimalString166 = \"\";\n  let decimalString167 = \"\";\n  let decimalString168 = \"\";\n  let decimalString169 = \"\";\n  let decimalString170 = \"\";\n  let decimalString171 = \"\";\n  let decimalString172 = \"\";\n  let decimalString173 = \"\";\n  let decimalString174 = \"\";\n  let decimalString175 = \"\";\n  let decimalString176 = \"\";\n  let decimalString177 = \"\";\n  let decimalString178 = \"\";\n  let decimalString179 = \"\";\n  let decimalString180 = \"\";\n  let decimalString181 = \"\";\n  let decimalString182 = \"\";\n  let decimalString183 = \"\";\n  let decimalString184 = \"\";\n  let decimalString185 = \"\";\n  let decimalString186 = \"\";\n  let decimalString187 = \"\";\n  let decimalString188 = \"\";\n  let decimalString189 = \"\";\n  let decimalString190 = \"\";\n  let decimalString191 = \"\";\n  let decimalString192 = \"\";\n  let decimalString193 = \"\";\n  let decimalString194 = \"\";\n  let decimalString195 = \"\";\n  let decimalString196 = \"\";\n  let decimalString197 = \"\";\n  let decimalString198 = \"\";\n  let decimalString199 = \"\";\n  let decimalString200 = \"\";\n  let decimalString201 = \"\";\n  let decimalString202 = \"\";\n  let decimalString203 = \"\";\n  let decimalString204 = \"\";\n  let decimalString205 = \"\";\n  let decimalString206 = \"\";\n  let decimalString207 = \"\";\n  let decimalString208 = \"\";\n  let decimalString209 = \"\";\n  let decimalString210 = \"\";\n  let decimalString211 = \"\";\n  let decimalString212 = \"\";\n  let decimalString213 = \"\";\n  let decimalString214 = \"\";\n  let decimalString215 = \"\";\n  let decimalString216 = \"\";\n  let decimalString217 = \"\";\n  let decimalString218 = \"\";\n  let decimalString219 = \"\";\n  let decimalString220 = \"\";\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigit([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigit([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigit = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigit", "gc": "<|endoftext|>/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigit([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigit([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  let flag = true;\n  while (flag) {\n    digit = parseInt(x[0], 10);\n    if (digit % 2 === 0) {\n      result.push(digit);\n      flag = false;\n    } else {\n      x[0] = x[0].slice(1);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigit([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueDigit([152, 323, 1422, 10])\n  [1422, 10, 152]\n  */\nconst uniqueOddDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  let flag = true;\n  while (flag) {\n    digit = parseInt(x[0], 10);\n    if (digit % 2 === 0) {\n      result.push(digit);\n      flag = false;\n    } else {\n      x[0] = x[0].slice(1);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueOddDigit([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueOddDigit([152, 323, 1422, 10])\n  [1422, 10, 152]\n  */\nconst uniqueEvenDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  let flag = true;\n  while (flag) {\n    digit = parseInt(x[0], 10);\n    if (digit % 2 === 0) {\n      result.push(digit);\n      flag = false;\n    } else {\n      x[0] = x[0].slice(1);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueOddEvenDigit([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueOddEvenDigit([152, 323, 1422, 10])\n  [1422, 10, 152]\n  */\nconst uniqueOddEvenDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  let flag = true;\n  while (flag) {\n    digit = parseInt(x[0], 10);\n    if (digit % 2 === 0 || digit % 2 === 1) {\n      result.push(digit);\n      flag = false;\n    } else {\n      x[0] = x[0].slice(1);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueOddEvenDigit([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueOddEvenDigit([152, 323, 1422, 10])\n  [1422, 10, 152]\n  */\nconst uniqueOddEvenOddDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  let flag = true;\n  while (flag) {\n    digit = parseInt(x[0], 10);\n    if (digit % 2 === 0 || digit % 2 === 1) {\n      result.push(digit);\n      flag = false;\n    } else {\n      x[0] = x[0].slice(1);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueOddEvenOddDigit([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueOddEvenOddDigit([152, 323, 1422, 10])\n  [1422, 10, 152]\n  */\nconst uniqueOddEvenOddOddDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  let flag = true;\n  while (flag) {\n    digit = parseInt(x[0], 10);\n    if (digit % 2 === 0 || digit % 2 === 1) {\n      result.push(digit);\n      flag = false;\n    } else {\n      x[0] = x[0].slice(1);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueOddEvenOddOddDigit([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueOddEvenOddOddDigit([152, 323, 1422, 10])\n  [1422, 10, 152]\n  */\nconst uniqueOddEvenOddOddOddDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  let flag = true;\n  while (flag) {\n    digit = parseInt(x[0], 10);\n    if (digit % 2 === 0 || digit % 2 === 1) {\n      result.push(digit);\n      flag = false;\n    } else {\n      x[0] = x[0].slice(1);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueOddEvenOddOddOddDigit([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueOddEvenOddOddOddDigit([152, 323, 1422, 10])\n  [1422, 10, 152]\n  */\nconst uniqueOddEvenOddOddOddOddDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  let flag = true;\n  while (flag) {\n    digit = parseInt(x[0], 10);\n    if (digit % 2 === 0 || digit % 2 === 1) {\n      result.push(digit);\n      flag = false;\n    } else {\n      x[0] = x[0].slice(1);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueOddEvenOddOddOddOddDigit([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueOddEvenOddOddOddOddDigit([152, 323, 1422, 10])\n  [1422, 10, 152]\n  */\nconst uniqueOddEvenOddOddOddOddOddDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  let flag = true;\n  while (flag) {\n    digit = parseInt(x[0], 10);\n    if (digit % 2 === 0 || digit % 2 === 1) {\n      result.push(digit);\n      flag = false;\n    } else {\n      x[0] = x[0].slice(1);\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueOddEvenOddOddOddOddOddOddDigit([15, 33, 1422, ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "gc": "<|endoftext|>/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  const len = arr.length;\n  let reversed = arr.slice().reverse();\n  for (let i = 0; i < len; i++) {\n    reversed[i] = reversed[len - i - 1] + arr[len - i - 1];\n  }\n  return reversed;\n};\n\n/**\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byName = (arr) => {\n  const len = arr.length;\n  let reversed = arr.slice().reverse();\n  for (let i = 0; i < len; i++) {\n    reversed[i] = reversed[len - i - 1] + arr[len - i - 1];\n  }\n  return reversed;\n};\n\n/**\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byNameAndLength = (arr) => {\n  const len = arr.length;\n  let reversed = arr.slice().reverse();\n  for (let i = 0; i < len; i++) {\n    reversed[i] = reversed[len - i - 1] + arr[len - i - 1];\n  }\n  return reversed;\n};\n\n/**\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byNameAndLength = (arr) => {\n  const len = arr.length;\n  let reversed = arr.slice().reverse();\n  for (let i = 0; i < len; i++) {\n    reversed[i] = reversed[len - i - 1] + arr[len - i - 1];\n  }\n  return reversed;\n};\n\n/**\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byNameAndName = (arr) => {\n  const len = arr.length;\n  let reversed = arr.slice().reverse();\n  for (let i = 0; i < len; i++) {\n    reversed[i] = reversed[len - i - 1] + arr[len - i - 1];\n  }\n  return reversed;\n};\n\n/**\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byNameAndNameAndLength = (arr) => {\n  const len = arr.length;\n  let reversed = arr.slice().reverse();\n  for (let i = 0; i < len; i++) {\n    reversed[i] = reversed[len - i - 1] + arr[len - i - 1];\n  }\n  return reversed;\n};\n\n/**\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "gc": "<|endoftext|>/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, val) => acc + val * i, 1));\n    }\n  }\n  return result;\n};\n\n/* Implement the function g that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  g(5) == [1, 1, 2, 6, 24]\n  */\nconst g = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, val) => acc + val % i, 1));\n    }\n  }\n  return result;\n};\n\n/* Implement the function h that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  h(5) == [1, 1, 2, 6, 24]\n  */\nconst h = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, val) => acc + val % i, 1));\n    }\n  }\n  return result;\n};\n\n/* Implement the function i that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  i(5) == [1, 1, 2, 6, 24]\n  */\nconst i = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, val) => acc + val % i, 1));\n    }\n  }\n  return result;\n};\n\n/* Implement the function j that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  j(5) == [1, 1, 2, 6, 24]\n  */\nconst j = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, val) => acc + val % i, 1));\n    }\n  }\n  return result;\n};\n\n/* Implement the function k that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  k(5) == [1, 1, 2, 6, 24]\n  */\nconst k = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, val) => acc + val % i, 1));\n    }\n  }\n  return result;\n};\n\n/* Implement the function l that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  l(5) == [1, 1, 2, 6, 24]\n  */\nconst l = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, val) => acc + val % i, 1));\n    }\n  }\n  return result;\n};\n\n/* Implement the function m that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  m(5) == [1, 1, 2, 6, 24]\n  */\nconst m = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, val) => acc + val % i, 1));\n    }\n  }\n  return result;\n};\n\n/* Implement the function n that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  n(5) == [1, 1, 2, 6, 24]\n  */\nconst n = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, val) => acc + val % i, 1));\n    }\n  }\n  return result;\n};\n\n/* Implement the function o that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  o(5) == [1, 1, 2, 6, 24]\n  */\nconst o = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, val) => acc + val % i, 1));\n    }\n  }\n  return result;\n};\n\n/* Implement the function p that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i start", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOdderPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOdderPalindrome", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOdderPalindrome = (n) => {\n  const oddPalindromes = Array.from({ length: n }, (_, i) => i + 1);\n  const evenPalindromes = Array.from({ length: n }, (_, i) => i - 1);\n\n  oddPalindromes.forEach((value, index) => {\n    if (value % 2 === 0) {\n      evenPalindromes[index] = value;\n    }\n  });\n\n  const evenPalindromePairs = evenPalindromes.map((value, index) => {\n    const oddPalindrome = oddPalindromes[index];\n    const evenPalindrome = evenPalindromes[index];\n    const oddPalindromePair = oddPalindrome + evenPalindrome;\n    return { oddPalindromePair, evenPalindromePair };\n  });\n\n  return evenPalindromePairs;\n};\n\n// Given a positive integer n, return an array containing all possible palindromes that\n// are formed from the given string.\n// For example,\n// Given \"ab\", return [\"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"ab\", \"ba\", \"", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "gc": "<|endoftext|>/*\n  Write a function countNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) count++;\n  }\n  return count;\n};\n\n/*\n  Write a function countZeros which takes an array of integers and returns\n  the number of elements which has a sum of digits == 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countZeros([]) == 0\n  >>> countZeros([-1, 11, -11]) == 1\n  >>> countZeros([1, 1, 2]) == 3\n  */\nconst countZeros = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) count++;\n  }\n  return count;\n};\n\n/*\n  Write a function countEvens which takes an array of integers and returns\n  the number of elements which has a sum of digits % 2 == 0.\n  >>> countEvens([]) == 0\n  >>> countEvens([-1, 11, -11]) == 1\n  >>> countEvens([1, 1, 2]) == 3\n  */\nconst countEvens = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) count++;\n  }\n  return count;\n};\n\n/*\n  Write a function countOdds which takes an array of integers and returns\n  the number of elements which has a sum of digits % 2!= 0.\n  >>> countOdds([]) == 0\n  >>> countOdds([-1, 11, -11]) == 1\n  >>> countOdds([1, 1, 2]) == 3\n  */\nconst countOdds = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2!== 0) count++;\n  }\n  return count;\n};\n\n/*\n  Write a function countDivisibleBy which takes an array of integers and\n  returns an array of integers whose sum of digits is divisible by the\n  given integer.\n  >>> countDivisibleBy([], 2) == []\n  >>> countDivisibleBy([1, 1, 2], 2) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 3) == []\n  >>> countDivisibleBy([1, 1, 2], 4) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 5) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 6) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 7) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 8) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 9) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 10) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 11) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 12) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 13) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 14) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 15) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 16) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 17) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 18) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 19) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 20) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 21) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 22) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 23) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 24) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 25) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 26) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 27) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 28) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 29) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 30) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 31) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 32) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 33) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 34) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 35) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 36) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 37) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 38) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 39) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 40) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 41) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 42) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 43) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 44) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 45) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 46) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 47) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 48) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 49) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 50) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 51) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 52) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 53) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 54) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 55) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 56) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 57) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 58) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 59) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 60) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 61) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 62) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 63) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 64) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 65) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 66) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 67) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 68) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 69) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 70) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 71) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 72) == [1, 1, 2]\n  >>> countDivisibleBy([1, 1, 2], 73) == [1, 1, 2]\n  >>> count", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  movingOneBalls([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  movingOneBalls([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst movingOneBalls = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "movingOneBalls", "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  movingOneBalls([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  movingOneBalls([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst movingOneBalls = (arr) => {\n  let arr1 = arr.slice();\n  let arr2 = arr1.slice();\n  let arr3 = arr1.slice();\n  let arr4 = arr1.slice();\n  let arr5 = arr1.slice();\n  let arr6 = arr1.slice();\n  let arr7 = arr1.slice();\n  let arr8 = arr1.slice();\n  let arr9 = arr1.slice();\n  let arr10 = arr1.slice();\n  let arr11 = arr1.slice();\n  let arr12 = arr1.slice();\n  let arr13 = arr1.slice();\n  let arr14 = arr1.slice();\n  let arr15 = arr1.slice();\n  let arr16 = arr1.slice();\n  let arr17 = arr1.slice();\n  let arr18 = arr1.slice();\n  let arr19 = arr1.slice();\n  let arr20 = arr1.slice();\n  let arr21 = arr1.slice();\n  let arr22 = arr1.slice();\n  let arr23 = arr1.slice();\n  let arr24 = arr1.slice();\n  let arr25 = arr1.slice();\n  let arr26 = arr1.slice();\n  let arr27 = arr1.slice();\n  let arr28 = arr1.slice();\n  let arr29 = arr1.slice();\n  let arr30 = arr1.slice();\n  let arr31 = arr1.slice();\n  let arr32 = arr1.slice();\n  let arr33 = arr1.slice();\n  let arr34 = arr1.slice();\n  let arr35 = arr1.slice();\n  let arr36 = arr1.slice();\n  let arr37 = arr1.slice();\n  let arr38 = arr1.slice();\n  let arr39 = arr1.slice();\n  let arr40 = arr1.slice();\n  let arr41 = arr1.slice();\n  let arr42 = arr1.slice();\n  let arr43 = arr1.slice();\n  let arr44 = arr1.slice();\n  let arr45 = arr1.slice();\n  let arr46 = arr1.slice();\n  let arr47 = arr1.slice();\n  let arr48 = arr1.slice();\n  let arr49 = arr1.slice();\n  let arr50 = arr1.slice();\n  let arr51 = arr1.slice();\n  let arr52 = arr1.slice();\n  let arr53 = arr1.slice();\n  let arr54 = arr1.slice();\n  let arr55 = arr1.slice();\n  let arr56 = arr1.slice();\n  let arr57 = arr1.slice();\n  let arr58 = arr1.slice();\n  let arr59 = arr1.slice();\n  let arr60 = arr1.slice();\n  let arr61 = arr1.slice();\n  let arr62 = arr1.slice();\n  let arr63 = arr1.slice();\n  let arr64 = arr1.slice();\n  let arr65 = arr1.slice();\n  let arr66 = arr1.slice();\n  let arr67 = arr1.slice();\n  let arr68 = arr1.slice();\n  let arr69 = arr1.slice();\n  let arr70 = arr1.slice();\n  let arr71 = arr1.slice();\n  let arr72 = arr1.slice();\n  let arr73 = arr1.slice();\n  let arr74 = arr1.slice();\n  let arr75 = arr1.slice();\n  let arr76 = arr1.slice();\n  let arr77 = arr1.slice();\n  let arr78 = arr1.slice();\n  let arr79 = arr1.slice();\n  let arr80 = arr1.slice();\n  let arr81 = arr1.slice();\n  let arr82 = arr1.slice();\n  let arr83 = arr1.slice();\n  let arr84 = arr1.slice();\n  let arr85 = arr1.slice();\n  let arr86 = arr1.slice();\n  let arr87 = arr1.slice();\n  let arr88 = arr1.slice();\n  let arr89 = arr1.slice();\n  let arr90 = arr1.slice();\n  let arr91 = arr1.slice();\n  let arr92 = arr1.slice();\n  let arr93 = arr1.slice();\n  let arr94 = arr1.slice();\n  let arr95 = arr1.slice();\n  let arr96 = arr1.slice();\n  let arr97 = arr1.slice();\n  let arr98 = arr1.slice();\n  let arr99 = arr1.slice();\n  let arr100 = arr1.slice();\n  let arr101 = arr1.slice();\n  let arr102 = arr1.slice();\n  let arr103 = arr1.slice();\n  let arr104 = arr1.slice();\n  let arr105 = arr1.slice();\n  let arr106 = arr1.slice();\n  let arr107 = arr1.slice();\n  let arr108 = arr1.slice();\n  let arr109 = arr1.slice();\n  let arr110 = arr1.slice();\n  let arr111 = arr1.slice();\n  let arr112 = arr1.slice();\n  let arr113 = arr1.slice();\n  let arr114 = arr1.slice();\n  let arr115 = arr1.slice();\n  let arr116 = arr1.slice();\n  let arr117 = arr1.slice();\n  let arr118 = arr1.slice();\n  let arr119 = arr1.slice();\n  let arr120 = arr1.slice();\n  let arr121 = arr1.slice();\n  let arr122 = arr1.slice();\n  let arr123 = arr1.slice();\n  let arr124 = arr1.slice();\n  let arr125 = arr1.slice();\n  let arr126 = arr1.slice();\n  let arr127 = arr1.slice();\n  let arr128 = arr1.slice();\n  let arr129 = arr1.slice();\n  let arr130 = arr1.slice();\n  let arr131 = arr1.slice();\n  let arr132 = arr1.slice();\n  let arr133 = arr1.slice();\n  let arr134 = arr1.slice();\n  let arr135 = arr1.slice();\n  let arr136 = arr1.slice();\n  let arr137 = arr1.slice();\n  let arr138 = arr1.slice();\n  let arr139 = arr1.slice();\n  let arr140 = arr1.slice();\n  let arr141 = arr1.slice();\n  let arr142 = arr1.slice();\n  let arr143 = arr1.slice();\n  let arr144 = arr1.slice();\n  let arr14", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "gc": "<|endoftext|>/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] ^ b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] & b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] | b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] ^ b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] & b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] | b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] ^ b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] & b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] | b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] ^ b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] & b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] | b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] ^ b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] & b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] | b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] ^ b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> stringAnd('010', '110')\n  '100'\n  */\nconst stringAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] & b[i]);\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> stringOr('010', '110')\n  '100'\n  */\nconst stringOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] | b[i]);\n  }\n  return result;\n};\n\n/* Input are two string", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an exchanges of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of exchangesd elements between lst1 and lst2.\n  If it is possible to exchanges elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchanges([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchanges([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchanges = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchanges", "gc": "<|endoftext|>/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an exchanges of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of exchangesd elements between lst1 and lst2.\n  If it is possible to exchanges elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchanges([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchanges([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchanges = (lst1, lst2) => {\n  let result = \"NO\";\n  if (lst1.length === 0 || lst2.length === 0) return \"NO\";\n  if (lst1.length === lst2.length) return \"YES\";\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== lst2[i] % 2) return \"NO\";\n  }\n  return \"YES\";\n};\n\n/*\n  Write a function that takes as input two lists of numbers and returns the\n  number of pairs of numbers that sum to zero, such that the sum is even.\n  For example:\n  pairs([1, 2], [3, 4]) => 2\n  pairs([1, 2], [1, 2]) => 1\n  pairs([1, 2], [1, 1]) => 0\n  It is assumed that the input lists will be non-empty.\n  */\nconst pairs = (lst1, lst2) => {\n  let result = 0;\n  if (lst1.length === 0 || lst2.length === 0) return 0;\n  if (lst1.length === lst2.length) return 1;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) result += 1;\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) result += 1;\n  }\n  return result;\n};\n\n/*\n  Write a function that takes as input two lists of numbers and returns the\n  number of pairs of numbers that sum to zero, such that the sum is odd.\n  For example:\n  pairs([1, 2], [3, 4]) => 1\n  pairs([1, 2], [1, 2]) => 0\n  pairs([1, 2], [1, 1]) => 2\n  It is assumed that the input lists will be non-empty.\n  */\nconst pairsOdd = (lst1, lst2) => {\n  let result = 0;\n  if (lst1.length === 0 || lst2.length === 0) return 0;\n  if (lst1.length === lst2.length) return 1;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== 0) result += 1;\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2!== 0) result += 1;\n  }\n  return result;\n};\n\n/*\n  Write a function that takes as input two lists of numbers and returns the\n  number of pairs of numbers that sum to zero, such that the sum is odd.\n  For example:\n  pairs([1, 2], [3, 4]) => 1\n  pairs([1, 2], [1, 2]) => 0\n  pairs([1, 2], [1, 1]) => 2\n  It is assumed that the input lists will be non-empty.\n  */\nconst pairsEven = (lst1, lst2) => {\n  let result = 0;\n  if (lst1.length === 0 || lst2.length === 0) return 0;\n  if (lst1.length === lst2.length) return 1;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) result += 1;\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2!== 0) result += 1;\n  }\n  return result;\n};\n\n/*\n  Write a function that takes as input two lists of numbers and returns the\n  number of pairs of numbers that sum to zero, such that the sum is odd.\n  For example:\n  pairs([1, 2], [3, 4]) => 1\n  pairs([1, 2], [1, 2]) => 0\n  pairs([1, 2], [1, 1]) => 2\n  It is assumed that the input lists will be non-empty.\n  */\nconst pairsOddEven = (lst1, lst2) => {\n  let result = 0;\n  if (lst1.length === 0 || lst2.length === 0) return 0;\n  if (lst1.length === lst2.length) return 1;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) result += 1;\n    if (lst2[i] % 2 === 0) result += 1;\n  }\n  return result;\n};\n\n/*\n  Write a function that takes as input two lists of numbers and returns the\n  number of pairs of numbers that sum to zero, such that the sum is odd.\n  For example:\n  pairs([1, 2], [3, 4]) => 1\n  pairs([1, 2], [1, 2]) => 0\n  pairs([1, 2], [1, 1]) => 2\n  It is assumed that the input lists will be non-empty.\n  */\nconst pairsEvenOdd = (lst1, lst2) => {\n  let result = 0;\n  if (lst1.length === 0 || lst2.length === 0) return 0;\n  if (lst1.length === lst2.length) return 1;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) result += 1;\n    if (lst2[i] % 2 === 0) result += 1;\n  }\n  return result;\n};\n\n/*\n  Write a function that takes as input two lists of numbers and returns the\n  number of pairs of numbers that sum to zero, such that the sum is odd.\n  For example:\n  pairs([1, 2], [3, 4]) => 1\n  pairs([1, 2], [1, 2]) => 0\n  pairs([1, 2], [1, 1]) => 2\n  It is assumed that the input lists will be non-empty.\n  */\nconst pairsOddEvenOdd = (lst1, lst2) => {\n  let result = 0;\n  if (lst1.length === 0 || lst2.length === 0) return 0;\n  if (lst1.length === lst2.length) return 1;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) result += 1;\n    if (lst2[i] % 2 === 0) result += 1;\n  }\n  return result;\n};\n\n/*\n  Write a function that takes as input two lists of numbers and returns the\n  number of pairs of numbers that sum to zero, such that the sum is odd.\n  For example:\n  pairs([1, 2], [3, 4]) => 1\n  pairs([1, 2], [1, 2]) => 0\n  pairs([1, 2], [1, 1]) => 2\n  It is assumed that the input lists will be non-empty.\n  */\nconst pairsOddEvenEvenOdd = (lst1, lst2) => {\n  let result = 0;\n  if (lst1.length === 0 || lst2.length === 0) return 0;\n  if (lst1.length === lst2.length) return 1;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) result += 1;\n    if (lst2[i] % 2 === 0) result += 1;\n  }\n  return result;\n};\n\n/*\n  Write a function that takes as input two lists of numbers and returns the\n  number of pairs of numbers that sum to zero, such that the sum is odd.\n  For example:\n  pairs([1, 2], [3, 4]) => 1\n  pairs([1, 2], [1, 2]) => 0\n  pairs([1, 2], [1, 1]) => 2\n  It is assumed that the input lists will be non-empty.\n  */\nconst pairsOddEvenEvenEvenOdd = (lst1, lst2) => {\n  let result = 0;\n  if (lst1.length === 0 || lst2.length === 0) return 0;\n  if (lst1.length === lst2.length) return 1;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) result += 1;\n    if (lst2[i] % 2 === 0) result += 1;\n  }\n  return result;\n};\n\n/*\n  Write a function that takes as input two lists of numbers and returns the\n  number of pairs of numbers that sum to zero, such that the sum is odd.\n  For example:\n  pairs([1, 2], [3, 4]) => 1\n  pairs([1, 2], [1, 2]) => 0\n  pairs([1, 2], [1, 1]) => 2\n  It is assumed that the input lists will be non-empty.\n  */\nconst pairsOddEvenEvenEvenEvenO", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histograms('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histograms('a b b a') == {'a': 2, 'b': 2}\n  histograms('a b c a b') == {'a': 2, 'b': 2}\n  histograms('b b b b a') == {'b': 4}\n  histograms('') == {}\n\n  */\nconst histograms = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histograms", "gc": "<|endoftext|>/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histograms('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histograms('a b b a') == {'a': 2, 'b': 2}\n  histograms('a b c a b') == {'a': 2, 'b': 2}\n  histograms('b b b b a') == {'b': 4}\n  histograms('') == {}\n\n  */\nconst histograms = (test) => {\n  const letters = test.split(' ');\n  const letterMap = {};\n  let letterCounts = {};\n  letters.forEach((letter) => {\n    letterMap[letter] = letterCounts[letter] = 0;\n  });\n  letters.forEach((letter) => {\n    letterCounts[letter]++;\n  });\n  return letterMap;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histograms('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histograms('a b b a') == {'a': 2, 'b': 2}\n  histograms('a b c a b') == {'a': 2, 'b': 2}\n  histograms('b b b b a') == {'b': 4}\n  histograms('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ');\n  const letterMap = {};\n  let letterCounts = {};\n  letters.forEach((letter) => {\n    letterMap[letter] = letterCounts[letter] = 0;\n  });\n  letters.forEach((letter) => {\n    letterCounts[letter]++;\n  });\n  return letterCounts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histograms('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histograms('a b b a') == {'a': 2, 'b': 2}\n  histograms('a b c a b') == {'a': 2, 'b': 2}\n  histograms('b b b b a') == {'b': 4}\n  histograms('') == {}\n\n  */\nconst histograms = (test) => {\n  const letters = test.split(' ');\n  const letterMap = {};\n  let letterCounts = {};\n  letters.forEach((letter) => {\n    letterMap[letter] = letterCounts[letter] = 0;\n  });\n  letters.forEach((letter) => {\n    letterCounts[letter]++;\n  });\n  return letterMap;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histograms('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histograms('a b b a') == {'a': 2, 'b': 2}\n  histograms('a b c a b') == {'a': 2, 'b': 2}\n  histograms('b b b b a') == {'b': 4}\n  histograms('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ');\n  const letterMap = {};\n  let letterCounts = {};\n  letters.forEach((letter) => {\n    letterMap[letter] = letterCounts[letter] = 0;\n  });\n  letters.forEach((letter) => {\n    letterCounts[letter]++;\n  });\n  return letterCounts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histograms('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histograms('a b b a') == {'a': 2, 'b': 2}\n  histograms('a b c a b') == {'a': 2, 'b': 2}\n  histograms('b b b b a') == {'b': 4}\n  histograms('') == {}\n\n  */\nconst histograms = (test) => {\n  const letters = test.split(' ');\n  const letterMap = {};\n  let letterCounts = {};\n  letters.forEach((letter) => {\n    letterMap[letter] = letterCounts[letter] = 0;\n  });\n  letters.forEach((letter) => {\n    letterCounts[letter]++;\n  });\n  return letterMap;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histograms('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histograms('a b b a') == {'a': 2, 'b': 2}\n  histograms('a b c a b') == {'a': 2, 'b': 2}\n  histograms('b b b b a') == {'b': 4}\n  histograms('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ');\n  const letterMap = {};\n  let letterCounts = {};\n  letters.forEach((letter) => {\n    letterMap[letter] = letterCounts[letter] = 0;\n  });\n  letters.forEach((letter) => {\n    letterCounts[letter]++;\n  });\n  return letterCounts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histograms('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histograms('a b b a') == {'a': 2, 'b': 2}\n  histograms('a b c a b') == {'a': 2, 'b': 2}\n  histograms('b b b b a') == {'b': 4}\n  histograms('') == {}\n\n  */\nconst histograms = (test) => {\n  const letters = test.split(' ');\n  const letterMap = {};\n  let letterCounts = {};\n  letters.forEach((letter) => {\n    letterMap[letter] = letterCounts[letter] = 0;\n  });\n  letters.forEach((letter) => {\n    letterCounts[letter]++;\n  });\n  return letterMap;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histograms('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histograms('a b b a') == {'a': 2, 'b': 2}\n  histograms('a b c a b') == {'a': 2, 'b': 2}\n  histograms('b b b b a') == {'b': 4}\n  histograms('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ');\n  const letterMap = {};\n  let letterCounts = {};\n  letters.forEach((letter) => {\n    letterMap[letter] = letterCounts[letter] = 0;\n  });\n  letters.forEach((letter) => {\n    letterCounts[letter]++;\n  });\n  return letterCounts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reversesDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reversesDelete", "gc": "<|endoftext|>/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reversesDelete = (s, c) => {\n  let result = '';\n  let reverse = '';\n  let reversed = '';\n  let reversedReverse = '';\n  let reversedReversed = '';\n  let reversedReversedReverse = '';\n  let reversedReversedReversed = '';\n  let reversedReversedReversedReversed = '';\n  let reversedReversedReversedReversedReversed = '';\n  let reversedReversedReversedReversedReversedReversed = '';\n  let reversedReversedReversedReversedReversedReversedReversed = '';\n  let reversedReversedReversedReversedReversedReversedReversedReversed = '';\n  let reversedReversedReversedReversedReversedReversedReversedReversedReversed = '';\n  let reversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = '';\n  let reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = '';\n  let reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = '';\n  let reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> odderCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> odderCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst odderCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "odderCount", "gc": "<|endoftext|>/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> odderCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> odderCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst odderCount = (lst) => {\n  let result = [];\n  lst.forEach((str) => {\n    let oddCount = 0;\n    for (let i = 0; i < str.length; i++) {\n      if (i % 2 === 0) {\n        oddCount++;\n      }\n    }\n    result.push(oddCount);\n  });\n  return result;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let result = [];\n  lst.forEach((str) => {\n    let evenCount = 0;\n    for (let i = 0; i < str.length; i++) {\n      if (i % 2!== 0) {\n        evenCount++;\n      }\n    }\n    result.push(evenCount);\n  });\n  return result;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbered elements.\n  Where the pairs of adjacent even-numbered elements are the pairs of adjacent odd-numbered elements.\n  Where the pairs of adjacent odd-numbered elements are the pairs of adjacent even-numbe", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubsArraySums([2, 3, 4, 1, 2, 4]) == 1\n  minSubsArraySums([-1, -2, -3]) == -6\n  */\nconst minSubsArraySums = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubsArraySums", "gc": "<|endoftext|>/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubsArraySums([2, 3, 4, 1, 2, 4]) == 1\n  minSubsArraySums([-1, -2, -3]) == -6\n  */\nconst minSubsArraySums = (nums) => {\n  const numsLen = nums.length;\n  let sum = 0;\n  for (let i = 0; i < numsLen; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      return sum;\n    }\n  }\n  return numsLen;\n};\n\n// Given an array of integers nums, find the maximum sum of any non-empty sub-array\n// of nums.\n// Example\n// maxSubsArraySums([2, 3, 4, 1, 2, 4]) == 4\n// maxSubsArraySums([-1, -2, -3]) == -3\nconst maxSubsArraySums = (nums) => {\n  const numsLen = nums.length;\n  let sum = 0;\n  for (let i = 0; i < numsLen; i++) {\n    sum += nums[i];\n    if (sum < 0) {\n      return sum;\n    }\n  }\n  return numsLen;\n};\n\n// Given an array of integers nums, find the minimum difference between any two numbers\n// in nums.\n// Example\n// minDiff([2, 3, 4, 1, 2, 4]) == 3\n// minDiff([-1, -2, -3]) == -1\nconst minDiff = (nums) => {\n  const numsLen = nums.length;\n  let diff = 0;\n  for (let i = 0; i < numsLen; i++) {\n    diff += Math.abs(nums[i] - nums[i + 1]);\n    if (diff < 0) {\n      return diff;\n    }\n  }\n  return numsLen;\n};\n\n// Given an array of integers nums, find the maximum difference between any two numbers\n// in nums.\n// Example\n// maxDiff([2, 3, 4, 1, 2, 4]) == 3\n// maxDiff([-1, -2, -3]) == -3\nconst maxDiff = (nums) => {\n  const numsLen = nums.length;\n  let diff = 0;\n  for (let i = 0; i < numsLen; i++) {\n    diff += Math.abs(nums[i] - nums[i + 1]);\n    if (diff > 0) {\n      return diff;\n    }\n  }\n  return numsLen;\n};\n\n// Given an array of integers nums, find the difference between any two numbers\n// in nums.\n// Example\n// diff([2, 3, 4, 1, 2, 4]) == 3\n// diff([-1, -2, -3]) == -1\nconst diff = (nums) => {\n  const numsLen = nums.length;\n  let diff = 0;\n  for (let i = 0; i < numsLen; i++) {\n    diff += Math.abs(nums[i] - nums[i + 1]);\n  }\n  return diff;\n};\n\n// Given an array of integers nums, find the difference between any two numbers\n// in nums.\n// Example\n// diff([2, 3, 4, 1, 2, 4]) == 3\n// diff([-1, -2, -3]) == -3\nconst diff2 = (nums) => {\n  const numsLen = nums.length;\n  let diff = 0;\n  for (let i = 0; i < numsLen; i++) {\n    diff += Math.abs(nums[i] - nums[i + 1]);\n  }\n  return diff;\n};\n\n// Given an array of integers nums, find the difference between any two numbers\n// in nums.\n// Example\n// diff([2, 3, 4, 1, 2, 4]) == 3\n// diff([-1, -2, -3]) == -3\nconst diff3 = (nums) => {\n  const numsLen = nums.length;\n  let diff = 0;\n  for (let i = 0; i < numsLen; i++) {\n    diff += Math.abs(nums[i] - nums[i + 1]);\n  }\n  return diff;\n};\n\n// Given an array of integers nums, find the difference between any two numbers\n// in nums.\n// Example\n// diff([2, 3, 4, 1, 2, 4]) == 3\n// diff([-1, -2, -3]) == -3\nconst diff4 = (nums) => {\n  const numsLen = nums.length;\n  let diff = 0;\n  for (let i = 0; i < numsLen; i++) {\n    diff += Math.abs(nums[i] - nums[i + 1]);\n  }\n  return diff;\n};\n\n// Given an array of integers nums, find the difference between any two numbers\n// in nums.\n// Example\n// diff([2, 3, 4, 1, 2, 4]) == 3\n// diff([-1, -2, -3]) == -3\nconst diff5 = (nums) => {\n  const numsLen = nums.length;\n  let diff = 0;\n  for (let i = 0; i < numsLen; i++) {\n    diff += Math.abs(nums[i] - nums[i + 1]);\n  }\n  return diff;\n};\n\n// Given an array of integers nums, find the difference between any two numbers\n// in nums.\n// Example\n// diff([2, 3, 4, 1, 2, 4]) == 3\n// diff([-1, -2, -3]) == -3\nconst diff6 = (nums) => {\n  const numsLen = nums.length;\n  let diff = 0;\n  for (let i = 0; i < numsLen; i++) {\n    diff += Math.abs(nums[i] - nums[i + 1]);\n  }\n  return diff;\n};\n\n// Given an array of integers nums, find the difference between any two numbers\n// in nums.\n// Example\n// diff([2, 3, 4, 1, 2, 4]) == 3\n// diff([-1, -2, -3]) == -3\nconst diff7 = (nums) => {\n  const numsLen = nums.length;\n  let diff = 0;\n  for (let i = 0; i < numsLen; i++) {\n    diff += Math.abs(nums[i] - nums[i + 1]);\n  }\n  return diff;\n};\n\n// Given an array of integers nums, find the difference between any two numbers\n// in nums.\n// Example\n// diff([2, 3, 4, 1, 2, 4]) == 3\n// diff([-1, -2, -3]) == -3\nconst diff8 = (nums) => {\n  const numsLen = nums.length;\n  let diff = 0;\n  for (let i = 0; i < numsLen; i++) {\n    diff += Math.abs(nums[i] - nums[i + 1]);\n  }\n  return diff;\n};\n\n// Given an array of integers nums, find the difference between any two numbers\n// in nums.\n// Example\n// diff([2, 3, 4, 1, 2, 4]) == 3\n// diff([-1, -2, -3]) == -3\nconst diff9 = (nums) => {\n  const numsLen = nums.length;\n  let diff = 0;\n  for (let i = 0; i < numsLen; i++) {\n    diff += Math.abs(nums[i] - nums[i + 1]);\n  }\n  return diff;\n};\n\n// Given an array of integers nums, find the difference between any two numbers\n// in nums.\n// Example\n// diff([2, 3, 4, 1, 2, 4]) == 3\n// diff([-1, -2, -3]) == -3\nconst diff10 = (nums) => {\n  const numsLen = nums.length;\n  let diff = 0;\n  for (let i = 0; i < numsLen; i++) {\n    diff += Math.abs(nums[i] - nums[i + 1]);\n  }\n  return diff;\n};\n\n// Given an array of integers nums, find the difference between any two numbers\n// in nums.\n// Example\n// diff([2, 3, 4, 1, 2, 4]) == 3\n// diff([-1, -2, -3]) == -3\nconst diff11 = (nums) => {\n  const numsLen = nums.length;\n  let diff = 0;\n  for (let i = 0; i < numsLen; i++) {\n    diff += Math.abs(nums[i] - nums[i + 1]);\n  }\n  return diff;\n};\n\n// Given an array of integers nums, find the difference between any two numbers\n// in nums.\n// Example\n// diff([2, 3, 4, 1, 2, 4]) == 3\n// diff([-1, -2, -3]) == -3\nconst diff12 = (nums) => {\n  const numsLen = nums.length;\n  let diff = 0;\n  for (let i = 0; i < numsLen; i++) {\n    diff += Math.abs(nums[i] - nums[i + 1]);\n  }\n  return diff;\n};\n\n// Given an array of integers nums, find the difference between any two numbers\n// in nums.\n// Example\n// diff([2, 3, 4, 1, 2, 4]", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = new Array(n).fill(0);\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                result[i] += 1;\n                if (result[i] >= capacity) {\n                    result[i] = 0;\n                }\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Given a rectangular grid of wells and a bucket capacity, \n * return how many units of water you need to fill the grid to make all wells empty.\n * \n * Example 1:\n * \n * Input: \n * grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n * bucket_capacity : 1\n * \n * Output: 6\n * \n * Example 2:\n * \n * Input: \n * grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n * bucket_capacity : 2\n * \n * Output: 5\n * \n * Example 3:\n * \n * Input: \n * grid : [[0,0,0], [0,0,0]]\n * bucket_capacity : 5\n * \n * Output: 0\n * \n * Constraints:\n * \n * 1 <= grid.length <= 10^2\n * 1 <= grid[:,1].length <= 10^2\n * grid[i][j] -> 0 | 1\n * 1 <= capacity <= 10\n */\nconst maxEmpty = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = new Array(n).fill(0);\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                result[i] += 1;\n                if (result[i] >= capacity) {\n                    result[i] = 0;\n                }\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Given a rectangular grid of wells and a bucket capacity, \n * return how many units of water you need to fill the grid to make all wells empty.\n * \n * Example 1:\n * \n * Input: \n * grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n * bucket_capacity : 1\n * \n * Output: 6\n * \n * Example 2:\n * \n * Input: \n * grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n * bucket_capacity : 2\n * \n * Output: 5\n * \n * Example 3:\n * \n * Input: \n * grid : [[0,0,0], [0,0,0]]\n * bucket_capacity : 5\n * \n * Output: 0\n * \n * Constraints:\n * \n * 1 <= grid.length <= 10^2\n * 1 <= grid[:,1].length <= 10^2\n * grid[i][j] -> 0 | 1\n * 1 <= capacity <= 10\n */\nconst maxEmpty2d = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = new Array(n).fill(0);\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                result[i] += 1;\n                if (result[i] >= capacity) {\n                    result[i] = 0;\n                }\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Given a rectangular grid of wells and a bucket capacity, \n * return how many units of water you need to fill the grid to make all wells empty.\n * \n * Example 1:\n * \n * Input: \n * grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n * bucket_capacity : 1\n * \n * Output: 6\n * \n * Example 2:\n * \n * Input: \n * grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n * bucket_capacity : 2\n * \n * Output: 5\n * \n * Example 3:\n * \n * Input: \n * grid : [[0,0,0], [0,0,0]]\n * bucket_capacity : 5\n * \n * Output: 0\n * \n * Constraints:\n * \n * 1 <= grid.length <= 10^2\n * 1 <= grid[:,1].length <= 10^2\n * grid[i][j] -> 0 | 1\n * 1 <= capacity <= 10\n */\nconst maxEmpty3d = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = new Array(n).fill(0);\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                result[i] += 1;\n                if (result[i] >= capacity) {\n                    result[i] = 0;\n                }\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Given a rectangular grid of wells and a bucket capacity, \n * return how many units of water you need to fill the grid to make all wells empty.\n * \n * Example 1:\n * \n * Input: \n * grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n * bucket_capacity : 1\n * \n * Output: 6\n * \n * Example 2:\n * \n * Input: \n * grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n * bucket_capacity : 2\n * \n * Output: 5\n * \n * Example 3:\n * \n * Input: \n * grid : [[0,0,0], [0,0,0]]\n * bucket_capacity : 5\n * \n * Output: 0\n * \n * Constraints:\n * \n * 1 <= grid.length <= 10^2\n * 1 <= grid[:,1].length <= 10^2\n * grid[i][j] -> 0 | 1\n * 1 <= capacity <= 10\n */\nconst maxEmpty4d = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = new Array(n).fill(0);\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                result[i] += 1;\n                if (result[i] >= capacity) {\n                    result[i] = 0;\n                }\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Given a rectangular grid of wells and a bucket capacity, \n * return how many units of water you need to fill the grid to make all wells empty.\n * \n * Example 1:\n * \n * Input: \n * grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n * bucket_capacity : 1\n * \n * Output: 6\n * \n * Example 2:\n * \n * Input: \n * grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n * bucket_capacity : 2\n * \n * Output: 5\n * \n * Example 3:\n * \n * Input: \n * grid : [[0,0,0], [0,0,0]]\n * bucket_capacity : 5\n * \n * Output: 0\n * \n * Constraints:\n * \n * 1 <= grid.length <= 10^2\n * 1 <= ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortsArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortsArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortsArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortsArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortsArray", "gc": "<|endoftext|>/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortsArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortsArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortsArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortsArray = (arr) => {\n  let sortedArr = [];\n  let numOnes = 0;\n  let numZeros = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 1) {\n      numOnes++;\n    } else {\n      numZeros++;\n    }\n  }\n  if (numOnes > numZeros) {\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] === 0) {\n        sortedArr.push(arr[i]);\n      }\n    }\n    return sortedArr;\n  }\n  return arr;\n};\n\n/**\n * Given an array of non-negative integers, return an array with non-negative\n * integers sorted in ascending order.\n *\n * It must be implemented like this:\n * >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n * >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\nconst sortArray = (arr) => {\n  let sortedArr = [];\n  let numOnes = 0;\n  let numZeros = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 1) {\n      numOnes++;\n    } else {\n      numZeros++;\n    }\n  }\n  if (numOnes > numZeros) {\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] === 0) {\n        sortedArr.push(arr[i]);\n      }\n    }\n    return sortedArr;\n  }\n  return arr;\n};\n\n/**\n * Given an array of non-negative integers, return an array with non-negative\n * integers sorted in descending order.\n *\n * It must be implemented like this:\n * >>> sortDescArray([1, 5, 2, 3, 4]) == [5, 4, 3, 2, 1]\n * >>> sortDescArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> sortDescArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\nconst sortDescArray = (arr) => {\n  let sortedArr = [];\n  let numOnes = 0;\n  let numZeros = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 1) {\n      numOnes++;\n    } else {\n      numZeros++;\n    }\n  }\n  if (numOnes > numZeros) {\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] === 0) {\n        sortedArr.push(arr[i]);\n      }\n    }\n    return sortedArr;\n  }\n  return arr;\n};\n\n/**\n * Given an array of non-negative integers, return an array with non-negative\n * integers sorted in ascending order and with zeros removed.\n *\n * It must be implemented like this:\n * >>> sortZeroArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n * >>> sortZeroArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> sortZeroArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\nconst sortZeroArray = (arr) => {\n  let sortedArr = [];\n  let numOnes = 0;\n  let numZeros = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      sortedArr.push(arr[i]);\n    }\n  }\n  if (numOnes > numZeros) {\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] === 1) {\n        numOnes++;\n      }\n    }\n    return sortedArr;\n  }\n  return arr;\n};\n\n/**\n * Given an array of non-negative integers, return an array with non-negative\n * integers sorted in descending order and with zeros removed.\n *\n * It must be implemented like this:\n * >>> sortZeroDescArray([1, 5, 2, 3, 4]) == [5, 4, 3, 2, 1]\n * >>> sortZeroDescArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> sortZeroDescArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\nconst sortZeroDescArray = (arr) => {\n  let sortedArr = [];\n  let numOnes = 0;\n  let numZeros = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      sortedArr.push(arr[i]);\n    }\n  }\n  if (numOnes > numZeros) {\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] === 1) {\n        numOnes++;\n      }\n    }\n    return sortedArr;\n  }\n  return arr;\n};\n\n/**\n * Given an array of non-negative integers, return an array with non-negative\n * integers sorted in ascending order and with ones in their binary representation\n * removed.\n *\n * It must be implemented like this:\n * >>> removeOnesArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n * >>> removeOnesArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> removeOnesArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\nconst removeOnesArray = (arr) => {\n  let sortedArr = [];\n  let numOnes = 0;\n  let numZeros = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 1) {\n      numOnes++;\n    } else {\n      numZeros++;\n    }\n  }\n  if (numOnes > numZeros) {\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] === 0) {\n        sortedArr.push(arr[i]);\n      }\n    }\n    return sortedArr;\n  }\n  return arr;\n};\n\n/**\n * Given an array of non-negative integers, return an array with non-negative\n * integers sorted in descending order and with ones in their binary representation\n * removed.\n *\n * It must be implemented like this:\n * >>> removeOnesDescArray([1, 5, 2, 3, 4]) == [5, 4, 3, 2, 1]\n * >>> removeOnesDescArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> removeOnesDescArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\nconst removeOnesDescArray = (arr) => {\n  let sortedArr = [];\n  let numOnes = 0;\n  let numZeros = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 1) {\n      numOnes++;\n    } else {\n      numZeros++;\n    }\n  }\n  if (numOnes > numZeros) {\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] === 0) {\n        sortedArr.push(arr[i]);\n      }\n    }\n    return sortedArr;\n  }\n  return arr;\n};\n\n/**\n * Given an array of non-negative integers, return an array with non-negative\n * integers sorted in ascending order and with zeros removed.\n *\n * It must be implemented like this:\n * >>> removeZeroArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n * >>> removeZeroArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> removeZeroArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\nconst removeZeroArray = (arr) => {\n  let sortedArr = [];\n  let numOnes = 0;\n  let numZeros = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 0) {\n      sortedArr.push(arr[i]);\n    }\n  }\n  if (numOnes > numZeros) {\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] === 1) {\n        numOnes++;\n      }\n    }\n    return sortedArr;\n  }\n  return arr;\n};\n\n/**\n * Given an array of non-negative integers, return an array with non-negative\n * integers sorted in descending order and with zeros removed.\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWord(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWord(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWord(\"simple white space\", 2) ==> []\n  selectWord(\"Hello world\", 4) ==> [\"world\"]\n  selectWord(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWord = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWord", "gc": "<|endoftext|>/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWord(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWord(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWord(\"simple white space\", 2) ==> []\n  selectWord(\"Hello world\", 4) ==> [\"world\"]\n  selectWord(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWord = (s, n) => {\n  let words = []\n  let word = ''\n  let wordCount = 0\n  let wordLength = 0\n  let wordIndex = 0\n  let wordLengthIndex = 0\n  let wordLengthIndex2 = 0\n  let wordLengthIndex3 = 0\n  let wordLengthIndex4 = 0\n  let wordLengthIndex5 = 0\n  let wordLengthIndex6 = 0\n  let wordLengthIndex7 = 0\n  let wordLengthIndex8 = 0\n  let wordLengthIndex9 = 0\n  let wordLengthIndex10 = 0\n  let wordLengthIndex11 = 0\n  let wordLengthIndex12 = 0\n  let wordLengthIndex13 = 0\n  let wordLengthIndex14 = 0\n  let wordLengthIndex15 = 0\n  let wordLengthIndex16 = 0\n  let wordLengthIndex17 = 0\n  let wordLengthIndex18 = 0\n  let wordLengthIndex19 = 0\n  let wordLengthIndex20 = 0\n  let wordLengthIndex21 = 0\n  let wordLengthIndex22 = 0\n  let wordLengthIndex23 = 0\n  let wordLengthIndex24 = 0\n  let wordLengthIndex25 = 0\n  let wordLengthIndex26 = 0\n  let wordLengthIndex27 = 0\n  let wordLengthIndex28 = 0\n  let wordLengthIndex29 = 0\n  let wordLengthIndex30 = 0\n  let wordLengthIndex31 = 0\n  let wordLengthIndex32 = 0\n  let wordLengthIndex33 = 0\n  let wordLengthIndex34 = 0\n  let wordLengthIndex35 = 0\n  let wordLengthIndex36 = 0\n  let wordLengthIndex37 = 0\n  let wordLengthIndex38 = 0\n  let wordLengthIndex39 = 0\n  let wordLengthIndex40 = 0\n  let wordLengthIndex41 = 0\n  let wordLengthIndex42 = 0\n  let wordLengthIndex43 = 0\n  let wordLengthIndex44 = 0\n  let wordLengthIndex45 = 0\n  let wordLengthIndex46 = 0\n  let wordLengthIndex47 = 0\n  let wordLengthIndex48 = 0\n  let wordLengthIndex49 = 0\n  let wordLengthIndex50 = 0\n  let wordLengthIndex51 = 0\n  let wordLengthIndex52 = 0\n  let wordLengthIndex53 = 0\n  let wordLengthIndex54 = 0\n  let wordLengthIndex55 = 0\n  let wordLengthIndex56 = 0\n  let wordLengthIndex57 = 0\n  let wordLengthIndex58 = 0\n  let wordLengthIndex59 = 0\n  let wordLengthIndex60 = 0\n  let wordLengthIndex61 = 0\n  let wordLengthIndex62 = 0\n  let wordLengthIndex63 = 0\n  let wordLengthIndex64 = 0\n  let wordLengthIndex65 = 0\n  let wordLengthIndex66 = 0\n  let wordLengthIndex67 = 0\n  let wordLengthIndex68 = 0\n  let wordLengthIndex69 = 0\n  let wordLengthIndex70 = 0\n  let wordLengthIndex71 = 0\n  let wordLengthIndex72 = 0\n  let wordLengthIndex73 = 0\n  let wordLengthIndex74 = 0\n  let wordLengthIndex75 = 0\n  let wordLengthIndex76 = 0\n  let wordLengthIndex77 = 0\n  let wordLengthIndex78 = 0\n  let wordLengthIndex79 = 0\n  let wordLengthIndex80 = 0\n  let wordLengthIndex81 = 0\n  let wordLengthIndex82 = 0\n  let wordLengthIndex83 = 0\n  let wordLengthIndex84 = 0\n  let wordLengthIndex85 = 0\n  let wordLengthIndex86 = 0\n  let wordLengthIndex87 = 0\n  let wordLengthIndex88 = 0\n  let wordLengthIndex89 = 0\n  let wordLengthIndex90 = 0\n  let wordLengthIndex91 = 0\n  let wordLengthIndex92 = 0\n  let wordLengthIndex93 = 0\n  let wordLengthIndex94 = 0\n  let wordLengthIndex95 = 0\n  let wordLengthIndex96 = 0\n  let wordLengthIndex97 = 0\n  let wordLengthIndex98 = 0\n  let wordLengthIndex99 = 0\n  let wordLengthIndex100 = 0\n  let wordLengthIndex101 = 0\n  let wordLengthIndex102 = 0\n  let wordLengthIndex103 = 0\n  let wordLengthIndex104 = 0\n  let wordLengthIndex105 = 0\n  let wordLengthIndex106 = 0\n  let wordLengthIndex107 = 0\n  let wordLengthIndex108 = 0\n  let wordLengthIndex109 = 0\n  let wordLengthIndex110 = 0\n  let wordLengthIndex111 = 0\n  let wordLengthIndex112 = 0\n  let wordLengthIndex113 = 0\n  let wordLengthIndex114 = 0\n  let wordLengthIndex115 = 0\n  let wordLengthIndex116 = 0\n  let wordLengthIndex117 = 0\n  let wordLengthIndex118 = 0\n  let wordLengthIndex119 = 0\n  let wordLengthIndex120 = 0\n  let wordLengthIndex121 = 0\n  let wordLengthIndex122 = 0\n  let wordLengthIndex123 = 0\n  let wordLengthIndex124 = 0\n  let wordLengthIndex125 = 0\n  let wordLengthIndex126 = 0\n  let wordLengthIndex127 = 0\n  let wordLengthIndex128 = 0\n  let wordLengthIndex129 = 0\n  let wordLengthIndex130 = 0\n  let wordLengthIndex131 = 0\n  let wordLengthIndex132 = 0\n  let wordLengthIndex133 = 0\n  let wordLengthIndex134 = 0\n  let wordLengthIndex135 = 0\n  let wordLengthIndex136 = 0\n  let wordLengthIndex137 = 0\n  let wordLengthIndex138 = 0\n  let wordLengthIndex139 = 0\n  let wordLengthIndex140 = 0\n  let wordLengthIndex141 = 0\n  let wordLengthIndex142 = 0\n  let wordLengthIndex143 = 0\n  let wordLengthIndex144 = 0\n  let wordLengthIndex145 = 0\n  let wordLengthIndex146 = 0\n  let wordLengthIndex147 = 0\n  let wordLengthIndex148 = 0\n  let wordLengthIndex149 = 0\n  let wordLengthIndex150 = 0\n  let wordLengthIndex151 = 0\n  let wordLengthIndex152 = 0\n  let wordLengthIndex153 = 0\n  let wordLengthIndex154 = 0\n  let wordLengthIndex155 = 0\n  let wordLengthIndex156 = 0\n  let wordLengthIndex157 = 0\n  let wordLengthIndex158 = 0\n  let wordLengthIndex159 = 0\n  let wordLengthIndex160 = 0\n  let wordLengthIndex161 = 0\n  let wordLengthIndex162 = 0\n  let wordLengthIndex163 = 0\n  let wordLengthIndex164 = 0\n  let wordLengthIndex165 = 0\n  let wordLengthIndex166 = 0\n  let wordLengthIndex167 = 0\n  let wordLengthIndex168 = 0\n  let wordLengthIndex169 = 0\n  let wordLengthIndex170 = 0\n  let wordLengthIndex171 = 0\n  let wordLengthIndex172 = 0\n  let wordLengthIndex173 = 0\n  let wordLengthIndex174 = 0\n  let wordLengthIndex175 = 0\n  let wordLengthIndex176 = 0\n  let wordLengthIndex177 = 0\n  let wordLengthIndex178 = 0\n  let wordLengthIndex179 = 0\n  let wordLengthIndex180 = 0\n  let wordLengthIndex181 = 0\n  let wordLengthIndex182 = 0\n  let wordLengthIndex183 = 0\n  let wordLengthIndex184 = 0\n  let wordLengthIndex185 = 0\n  let wordLengthIndex186 = 0\n  let wordLengthIndex187 = 0\n  let wordLengthIndex188 = 0\n  let wordLengthIndex189 = 0\n  let wordLengthIndex190 = 0\n  let wordLengthIndex191", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  gottenCloserVowel(\"yogurt\") ==> \"u\"\n  gottenCloserVowel(\"FULL\") ==> \"U\"\n  gottenCloserVowel(\"quick\") ==> \"\"\n  gottenCloserVowel(\"ab\") ==> \"\"\n  */\nconst gottenCloserVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "gottenCloserVowel", "gc": "<|endoftext|>/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  gottenCloserVowel(\"yogurt\") ==> \"u\"\n  gottenCloserVowel(\"FULL\") ==> \"U\"\n  gottenCloserVowel(\"quick\") ==> \"\"\n  gottenCloserVowel(\"ab\") ==> \"\"\n  */\nconst gottenCloserVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  const vowelsArray = vowels.map(v => v.toLowerCase());\n  const vowelsArrayLength = vowelsArray.length;\n  const vowelsArrayIndexes = [];\n  let vowelsArrayIndex = 0;\n  let vowelsArrayIndexes = 0;\n  let vowelsArrayIndexes2 = 0;\n  let vowelsArrayIndexes3 = 0;\n  let vowelsArrayIndexes4 = 0;\n  let vowelsArrayIndexes5 = 0;\n  let vowelsArrayIndexes6 = 0;\n  let vowelsArrayIndexes7 = 0;\n  let vowelsArrayIndexes8 = 0;\n  let vowelsArrayIndexes9 = 0;\n  let vowelsArrayIndexes10 = 0;\n  let vowelsArrayIndexes11 = 0;\n  let vowelsArrayIndexes12 = 0;\n  let vowelsArrayIndexes13 = 0;\n  let vowelsArrayIndexes14 = 0;\n  let vowelsArrayIndexes15 = 0;\n  let vowelsArrayIndexes16 = 0;\n  let vowelsArrayIndexes17 = 0;\n  let vowelsArrayIndexes18 = 0;\n  let vowelsArrayIndexes19 = 0;\n  let vowelsArrayIndexes20 = 0;\n  let vowelsArrayIndexes21 = 0;\n  let vowelsArrayIndexes22 = 0;\n  let vowelsArrayIndexes23 = 0;\n  let vowelsArrayIndexes24 = 0;\n  let vowelsArrayIndexes25 = 0;\n  let vowelsArrayIndexes26 = 0;\n  let vowelsArrayIndexes27 = 0;\n  let vowelsArrayIndexes28 = 0;\n  let vowelsArrayIndexes29 = 0;\n  let vowelsArrayIndexes30 = 0;\n  let vowelsArrayIndexes31 = 0;\n  let vowelsArrayIndexes32 = 0;\n  let vowelsArrayIndexes33 = 0;\n  let vowelsArrayIndexes34 = 0;\n  let vowelsArrayIndexes35 = 0;\n  let vowelsArrayIndexes36 = 0;\n  let vowelsArrayIndexes37 = 0;\n  let vowelsArrayIndexes38 = 0;\n  let vowelsArrayIndexes39 = 0;\n  let vowelsArrayIndexes40 = 0;\n  let vowelsArrayIndexes41 = 0;\n  let vowelsArrayIndexes42 = 0;\n  let vowelsArrayIndexes43 = 0;\n  let vowelsArrayIndexes44 = 0;\n  let vowelsArrayIndexes45 = 0;\n  let vowelsArrayIndexes46 = 0;\n  let vowelsArrayIndexes47 = 0;\n  let vowelsArrayIndexes48 = 0;\n  let vowelsArrayIndexes49 = 0;\n  let vowelsArrayIndexes50 = 0;\n  let vowelsArrayIndexes51 = 0;\n  let vowelsArrayIndexes52 = 0;\n  let vowelsArrayIndexes53 = 0;\n  let vowelsArrayIndexes54 = 0;\n  let vowelsArrayIndexes55 = 0;\n  let vowelsArrayIndexes56 = 0;\n  let vowelsArrayIndexes57 = 0;\n  let vowelsArrayIndexes58 = 0;\n  let vowelsArrayIndexes59 = 0;\n  let vowelsArrayIndexes60 = 0;\n  let vowelsArrayIndexes61 = 0;\n  let vowelsArrayIndexes62 = 0;\n  let vowelsArrayIndexes63 = 0;\n  let vowelsArrayIndexes64 = 0;\n  let vowelsArrayIndexes65 = 0;\n  let vowelsArrayIndexes66 = 0;\n  let vowelsArrayIndexes67 = 0;\n  let vowelsArrayIndexes68 = 0;\n  let vowelsArrayIndexes69 = 0;\n  let vowelsArrayIndexes70 = 0;\n  let vowelsArrayIndexes71 = 0;\n  let vowelsArrayIndexes72 = 0;\n  let vowelsArrayIndexes73 = 0;\n  let vowelsArrayIndexes74 = 0;\n  let vowelsArrayIndexes75 = 0;\n  let vowelsArrayIndexes76 = 0;\n  let vowelsArrayIndexes77 = 0;\n  let vowelsArrayIndexes78 = 0;\n  let vowelsArrayIndexes79 = 0;\n  let vowelsArrayIndexes80 = 0;\n  let vowelsArrayIndexes81 = 0;\n  let vowelsArrayIndexes82 = 0;\n  let vowelsArrayIndexes83 = 0;\n  let vowelsArrayIndexes84 = 0;\n  let vowelsArrayIndexes85 = 0;\n  let vowelsArrayIndexes86 = 0;\n  let vowelsArrayIndexes87 = 0;\n  let vowelsArrayIndexes88 = 0;\n  let vowelsArrayIndexes89 = 0;\n  let vowelsArrayIndexes90 = 0;\n  let vowelsArrayIndexes91 = 0;\n  let vowelsArrayIndexes92 = 0;\n  let vowelsArrayIndexes93 = 0;\n  let vowelsArrayIndexes94 = 0;\n  let vowelsArrayIndexes95 = 0;\n  let vowelsArrayIndexes96 = 0;\n  let vowelsArrayIndexes97 = 0;\n  let vowelsArrayIndexes98 = 0;\n  let vowelsArrayIndexes99 = 0;\n  let vowelsArrayIndexes100 = 0;\n  let vowelsArrayIndexes101 = 0;\n  let vowelsArrayIndexes102 = 0;\n  let vowelsArrayIndexes103 = 0;\n  let vowelsArrayIndexes104 = 0;\n  let vowelsArrayIndexes105 = 0;\n  let vowelsArrayIndexes106 = 0;\n  let vowelsArrayIndexes107 = 0;\n  let vowelsArrayIndexes108 = 0;\n  let vowelsArrayIndexes109 = 0;\n  let vowelsArrayIndexes110 = 0;\n  let vowelsArrayIndexes111 = 0;\n  let vowelsArrayIndexes112 = 0;\n  let vowelsArrayIndexes113 = 0;\n  let vowelsArrayIndexes114 = 0;\n  let vowelsArrayIndexes115 = 0;\n  let vowelsArrayIndexes116 = 0;\n  let vowelsArrayIndexes117 = 0;\n  let vowelsArrayIndexes118 = 0;\n  let vowelsArrayIndexes119 = 0;\n  let vowelsArrayIndexes120 = 0;\n  let vowelsArrayIndexes121 = 0;\n  let vowelsArrayIndexes122 = 0;\n  let vowelsArrayIndexes123 = 0;\n  let vowelsArrayIndexes124 = 0;\n  let vowelsArrayIndexes125 = 0;\n  let vowelsArrayIndexes126 = 0;\n  let vowelsArrayIndexes127 = 0;\n  let vowelsArrayIndexes128 = 0;\n  let vowelsArrayIndexes129 = 0;\n  let vowelsArrayIndexes130 = 0;\n  let vowelsArrayIndexes131 = 0;\n  let vowelsArrayIndexes132 = 0;\n  let vowelsArrayIndexes133 = 0;\n  let vowelsArrayIndexes134 = 0;\n  let vowelsArrayIndexes135 = 0;\n  let vowelsArrayIndexes136 = 0;\n  let vowelsArrayIndexes137 = 0;\n  let vowelsArrayIndexes138 = 0;\n  let vowelsArrayIndexes139 = 0;\n  let vowelsArrayIndexes140 = 0;\n  let vowelsArrayIndexes141 = 0;\n  let vowelsArrayIndexes142 = 0;\n  let vowelsArrayIndexes143 = 0;\n  let vowelsArrayIndexes144 = 0;\n  let vowelsArrayIndexes145 = 0;\n  let vowelsArrayIndexes146 = 0;\n  let vowelsArrayIndexes147 = 0;\n  let vowelsArrayIndexes148 = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "gc": "<|endoftext|>/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let res = []\n  let len = lst.length\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longer one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longer([])\n\n  >>> longer(['a', 'b', 'c'])\n  'a'\n  >>> longer(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longer = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longer", "gc": "<|endoftext|>/* Out of list of strings, return the longer one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longer([])\n\n  >>> longer(['a', 'b', 'c'])\n  'a'\n  >>> longer(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longer = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null\n  }\n  const length = strings.length\n  let longest = 0\n  let longestLength = 0\n  for (let i = 0; i < length; i++) {\n    const string = strings[i]\n    const length = string.length\n    if (length > longestLength) {\n      longestLength = length\n      longest = string\n    }\n  }\n  return longest\n}\n\n/**\n  Converts string to lowercase.\n\n  >>> lowercase('hello')\n  'hello'\n  >>> lowercase('HELLO')\n  'hello'\n  >>> lowercase('HELLO WORLD')\n  'hello world'\n  */\nconst lowercase = (string) => {\n  return string.toLowerCase()\n}\n\n/**\n  Converts string to uppercase.\n\n  >>> uppercase('hello')\n  'HELLO'\n  >>> uppercase('HELLO')\n  'HELLO'\n  >>> uppercase('HELLO WORLD')\n  'HELLO WORLD'\n  */\nconst uppercase = (string) => {\n  return string.toUpperCase()\n}\n\n/**\n  Converts string to uppercase and removes trailing whitespace.\n\n  >>> trim('  hello  ')\n  'hello'\n  >>> trim('  hello  ')\n  'hello'\n  >>> trim('  hello  ')\n  'hello'\n  >>> trim('  hello  ')\n  'hello'\n  >>> trim('  hello  ')\n  'hello'\n  */\nconst trim = string => {\n  return string.replace(/^\\s+|\\s+$/g, '')\n}\n\n/**\n  Converts string to uppercase and removes trailing whitespace.\n\n  >>> trim('  hello  ')\n  'HELLO'\n  >>> trim('  hello  ')\n  'HELLO'\n  >>> trim('  hello  ')\n  'HELLO'\n  >>> trim('  hello  ')\n  'HELLO'\n  >>> trim('  hello  ')\n  'HELLO'\n  */\nconst trimEnd = string => {\n  return string.replace(/^\\s+|\\s+$/g, '')\n}\n\n/**\n  Converts string to uppercase and removes trailing whitespace.\n\n  >>> trimEnd('  hello  ')\n  'HELLO'\n  >>> trimEnd('  hello  ')\n  'HELLO'\n  >>> trimEnd('  hello  ')\n  'HELLO'\n  >>> trimEnd('  hello  ')\n  'HELLO'\n  >>> trimEnd('  hello  ')\n  'HELLO'\n  */\nconst trimStart = string => {\n  return string.replace(/^\\s+|\\s+$/g, '')\n}\n\n/**\n  Converts string to uppercase and removes trailing whitespace.\n\n  >>> trimStart('  hello  ')\n  'HELLO'\n  >>> trimStart('  hello  ')\n  'HELLO'\n  >>> trimStart('  hello  ')\n  'HELLO'\n  >>> trimStart('  hello  ')\n  'HELLO'\n  >>> trimStart('  hello  ')\n  'HELLO'\n  */\nconst trimBoth = string => {\n  return string.replace(/^\\s+|\\s+$/g, '')\n}\n\n/**\n  Converts string to uppercase and removes trailing whitespace.\n\n  >>> trimBoth('  hello  ')\n  'HELLO'\n  >>> trimBoth('  hello  ')\n  'HELLO'\n  >>> trimBoth('  hello  ')\n  'HELLO'\n  >>> trimBoth('  hello  ')\n  'HELLO'\n  >>> trimBoth('  hello  ')\n  'HELLO'\n  */\nconst trimBothEnd = string => {\n  return string.replace(/^\\s+|\\s+$/g, '')\n}\n\n/**\n  Converts string to uppercase and removes trailing whitespace.\n\n  >>> trimBothEnd('  hello  ')\n  'HELLO'\n  >>> trimBothEnd('  hello  ')\n  'HELLO'\n  >>> trimBothEnd('  hello  ')\n  'HELLO'\n  >>> trimBothEnd('  hello  ')\n  'HELLO'\n  >>> trimBothEnd('  hello  ')\n  'HELLO'\n  */\nconst trimBothStart = string => {\n  return string.replace(/^\\s+|\\s+$/g, '')\n}\n\n/**\n  Converts string to uppercase and removes trailing whitespace.\n\n  >>> trimBothStart('  hello  ')\n  'HELLO'\n  >>> trimBothStart('  hello  ')\n  'HELLO'\n  >>> trimBothStart('  hello  ')\n  'HELLO'\n  >>> trimBothStart('  hello  ')\n  'HELLO'\n  >>> trimBothStart('  hello  ')\n  'HELLO'\n  */\nconst trimEnd = string => {\n  return string.replace(/^\\s+|\\s+$/g, '')\n}\n\n/**\n  Converts string to uppercase and removes trailing whitespace.\n\n  >>> trimEnd('  hello  ')\n  'HELLO'\n  >>> trimEnd('  hello  ')\n  'HELLO'\n  >>> trimEnd('  hello  ')\n  'HELLO'\n  >>> trimEnd('  hello  ')\n  'HELLO'\n  >>> trimEnd('  hello  ')\n  'HELLO'\n  */\nconst trimStart = string => {\n  return string.replace(/^\\s+|\\s+$/g, '')\n}\n\n/**\n  Converts string to uppercase and removes trailing whitespace.\n\n  >>> trimStart('  hello  ')\n  'HELLO'\n  >>> trimStart('  hello  ')\n  'HELLO'\n  >>> trimStart('  hello  ')\n  'HELLO'\n  >>> trimStart('  hello  ')\n  'HELLO'\n  >>> trimStart('  hello  ')\n  'HELLO'\n  >>> trimStart('  hello  ')\n  'HELLO'\n  */\nconst trimBoth = string => {\n  return string.replace(/^\\s+|\\s+$/g, '')\n}\n\n/**\n  Converts string to uppercase and removes trailing whitespace.\n\n  >>> trimBoth('  hello  ')\n  'HELLO'\n  >>> trimBoth('  hello  ')\n  'HELLO'\n  >>> trimBoth('  hello  ')\n  'HELLO'\n  >>> trimBoth('  hello  ')\n  'HELLO'\n  >>> trimBoth('  hello  ')\n  'HELLO'\n  >>> trimBoth('  hello  ')\n  'HELLO'\n  */\nconst trimBothEnd = string => {\n  return string.replace(/^\\s+|\\s+$/g, '')\n}\n\n/**\n  Converts string to uppercase and removes trailing whitespace.\n\n  >>> trimBothEnd('  hello  ')\n  'HELLO'\n  >>> trimBothEnd('  hello  ')\n  'HELLO'\n  >>> trimBothEnd('  hello  ')\n  'HELLO'\n  >>> trimBothEnd('  hello  ')\n  'HELLO'\n  >>> trimBothEnd('  hello  ')\n  'HELLO'\n  */\nconst trimBothStart = string => {\n  return string.replace(/^\\s+|\\s+$/g, '')\n}\n\n/**\n  Converts string to uppercase and remove", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maximums k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximums = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximums", "gc": "<|endoftext|>/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maximums k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximums = (arr, k) => {\n  const result = [];\n  let max = 0;\n  let min = -1000;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      result.push(max);\n      max = arr[i];\n    }\n    if (arr[i] < min) {\n      result.push(min);\n      min = arr[i];\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-pairs-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctPairs = function (nums) {\n  let count = 0;\n  let pairs = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === nums[i + 1]) {\n      pairs.push(nums[i]);\n      count++;\n    }\n  }\n  return pairs.length;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbers = function (nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === num) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersII = function (nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === num) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersIII = function (nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === num) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersIV = function (nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === num) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersV = function (nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === num) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersW = function (nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === num) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersX = function (nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === num) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersY = function (nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === num) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersZ = function (nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === num) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersAA = function (nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === num) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersAB = function (nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === num) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersAC = function (nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === num) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersAD = function (nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === num) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersAE = function (nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === num) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersAF = function (nums) {\n  let count = 0;\n  let num = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === num) {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solutions([5, 8, 7, 1]) ==> 12\n  solutions([3, 3, 3, 3, 3]) ==> 9\n  solutions([30, 13, 24, 321]) ==>0\n  */\nconst solutions = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solutions", "gc": "<|endoftext|>/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solutions([5, 8, 7, 1]) ==> 12\n  solutions([3, 3, 3, 3, 3]) ==> 9\n  solutions([30, 13, 24, 321]) ==>0\n  */\nconst solutions = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solutions,\n};\n\n},{}],3:[function(require,module,exports){\n/*\n  Implement a function to find the sum of all even numbers in a given list.\n\n  Examples\n  evenSum([5, 8, 7, 1]) ==> 12\n  evenSum([3, 3, 3, 3, 3]) ==> 9\n  evenSum([30, 13, 24, 321]) ==> 0\n  */\nconst evenSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  evenSum,\n};\n\n},{}],4:[function(require,module,exports){\n/*\n  Implement a function to find the sum of all odd numbers in a given list.\n\n  Examples\n  oddSum([5, 8, 7, 1]) ==> 12\n  oddSum([3, 3, 3, 3, 3]) ==> 9\n  oddSum([30, 13, 24, 321]) ==> 0\n  */\nconst oddSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  oddSum,\n};\n\n},{}],5:[function(require,module,exports){\n/*\n  Implement a function to find the sum of all even numbers in a given list.\n\n  Examples\n  evenSum([5, 8, 7, 1]) ==> 12\n  evenSum([3, 3, 3, 3, 3]) ==> 9\n  evenSum([30, 13, 24, 321]) ==> 0\n  */\nconst evenSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  evenSum,\n};\n\n},{}],6:[function(require,module,exports){\n/*\n  Implement a function to find the sum of all odd numbers in a given list.\n\n  Examples\n  oddSum([5, 8, 7, 1]) ==> 12\n  oddSum([3, 3, 3, 3, 3]) ==> 9\n  oddSum([30, 13, 24, 321]) ==> 0\n  */\nconst oddSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  oddSum,\n};\n\n},{}],7:[function(require,module,exports){\n/*\n  Implement a function to find the sum of all even numbers in a given list.\n\n  Examples\n  evenSum([5, 8, 7, 1]) ==> 12\n  evenSum([3, 3, 3, 3, 3]) ==> 9\n  evenSum([30, 13, 24, 321]) ==> 0\n  */\nconst evenSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  evenSum,\n};\n\n},{}],8:[function(require,module,exports){\n/*\n  Implement a function to find the sum of all odd numbers in a given list.\n\n  Examples\n  oddSum([5, 8, 7, 1]) ==> 12\n  oddSum([3, 3, 3, 3, 3]) ==> 9\n  oddSum([30, 13, 24, 321]) ==> 0\n  */\nconst oddSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  oddSum,\n};\n\n},{}],9:[function(require,module,exports){\n/*\n  Implement a function to find the sum of all even numbers in a given list.\n\n  Examples\n  evenSum([5, 8, 7, 1]) ==> 12\n  evenSum([3, 3, 3, 3, 3]) ==> 9\n  evenSum([30, 13, 24, 321]) ==> 0\n  */\nconst evenSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  evenSum,\n};\n\n},{}],10:[function(require,module,exports){\n/*\n  Implement a function to find the sum of all odd numbers in a given list.\n\n  Examples\n  oddSum([5, 8, 7, 1]) ==> 12\n  oddSum([3, 3, 3, 3, 3]) ==> 9\n  oddSum([30, 13, 24, 321]) ==> 0\n  */\nconst oddSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  oddSum,\n};\n\n},{}],11:[function(require,module,exports){\n/*\n  Implement a function to find the sum of all even numbers in a given list.\n\n  Examples\n  evenSum([5, 8, 7, 1]) ==> 12\n  evenSum([3, 3, 3, 3, 3]) ==> 9\n  evenSum([30, 13, 24, 321]) ==> 0\n  */\nconst evenSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  evenSum,\n};\n\n},{}],12:[function(require,module,exports){\n/*\n  Implement a function to find the sum of all odd numbers in a given list.\n\n  Examples\n  oddSum([5, 8, 7, 1]) ==> 12\n  oddSum([3, 3, 3, 3, 3]) ==> 9\n  oddSum([30, 13, 24, 321]) ==> 0\n  */\nconst oddSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  oddSum,\n};\n\n},{}],13:[function(require,module,exports){\n/*\n  Implement a function to find the sum of all even numbers in a given list.\n\n  Examples\n  evenSum([5, 8, 7, 1]) ==> 12\n  evenSum([3, 3, 3, 3, 3]) ==> 9\n  evenSum([30, 13, 24, 321]) ==> 0\n  */\nconst evenSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  evenSum,\n};\n\n},{}],14:[function(require,module,exports){\n/*\n  Implement a function to find the sum of all odd numbers in a given list.\n\n  Examples\n  oddSum([5, 8, 7, 1]) ==> 12\n  oddSum([3, 3, 3, 3, 3]) ==> 9\n  oddSum([30, 13, 24, 321]) ==> 0\n  */\nconst oddSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "gc": "<|endoftext|>/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % k === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n// https://leetcode.com/problems/remove-duplicates-from-sorted-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar removeDuplicates = function(head) {\n  let curr = head;\n  let prev = head;\n  let next = head;\n  while (curr) {\n    if (curr.next === prev) {\n      prev.next = next;\n    } else {\n      prev.next = curr.next;\n    }\n    prev = curr;\n    curr = curr.next;\n  }\n  return head;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySum = function(head) {\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  return sum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumFromHead = function(head) {\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  return sum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumFromTail = function(head) {\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  return sum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumFromHeadAndTail = function(head) {\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  return sum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumFromHeadAndTailAndTail = function(head) {\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  return sum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumFromHeadAndTailAndTail = function(head) {\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  return sum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumFromHeadAndTailAndTailAndTail = function(head) {\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  return sum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumFromHeadAndTailAndTailAndTailAndTail = function(head) {\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  return sum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumFromHeadAndTailAndTailAndTailAndTailAndTail = function(head) {\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  return sum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumFromHeadAndTailAndTailAndTailAndTailAndTail = function(head) {\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  return sum;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumFromHeadAndTailAndTailAndTailAndTailAndTail = function(head) {\n  let sum = 0;\n  let ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  gottenOdderCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst gottenOdderCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "gottenOdderCollatz", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  gottenOdderCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst gottenOdderCollatz = (n) => {\n  let collatz = [];\n  let num = 1;\n  while (num < n) {\n    if (n % 2 === 0) {\n      collatz.push(num);\n      num += 1;\n    } else {\n      num += 3;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  gottenEvenCollatz(5) returns [1, 5, 3] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], \n  so the even numbers are only 1, 5, and 3.\n  */\nconst gottenEvenCollatz = (n) => {\n  let collatz = [];\n  let num = 1;\n  while (num < n) {\n    if (n % 2 === 0) {\n      collatz.push(num);\n      num += 1;\n    } else {\n      num += 3;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  gottenPrimeCollatz(5) returns [1, 3, 5, 7, 9, 11] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], \n  so the prime numbers are only 1, 3, 5, 7, 9, 11. \n  */\nconst gottenPrimeCollatz = (n) => {\n  let collatz = [];\n  let num = 1;\n  while (num < n) {\n    if (n % 2 === 0) {\n      collatz.push(num);\n      num += 1;\n    } else {\n      num += 3;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the natural numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  gottenNaturalCollatz(5) returns [1, 3, 5, 7, 9, 11] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], \n  so the natural numbers are only 1, 3, 5, 7, 9, 11. \n  */\nconst gottenNaturalCollatz = (n) => {\n  let collatz = [];\n  let num = 1;\n  while (num < n) {\n    if (n % 2 === 0) {\n      collatz.push(num);\n      num += 1;\n    } else {\n      num += 3;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  gottenPrimeNaturalCollatz(5) returns [1, 3, 5, 7, 9, 11] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], \n  so the prime numbers are only 1, 3, 5, 7, 9, 11. \n  */\nconst gottenPrimeNaturalCollatz = (n) => {\n  let collatz = [];\n  let num = 1;\n  while (num < n) {\n    if (n % 2 === 0) {\n      collatz.push(num);\n      num += 1;\n    } else {\n      num += 3;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the natural numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  gottenNaturalPrimeCollatz(5) returns [1, 3, 5, 7, 9, 11] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], \n  so the natural numbers are only 1, 3, 5, 7, 9, 11. \n  */\nconst gottenNaturalPrimeCollatz = (n) => {\n  let collatz = [];\n  let num = 1;\n  while (num < n) {\n    if (n % 2 === 0) {\n      collatz.push(num);\n      num += 1;\n    } else {\n      num += 3;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the natural numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDates('03-11-2000') => true\n\n  validDates('15-01-2012') => false\n\n  validDates('04-0-2040') => false\n\n  validDates('06-04-2020') => true\n\n  validDates('06/04/2020') => false\n  */\nconst validDates = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDates", "gc": "<|endoftext|>/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDates('03-11-2000') => true\n\n  validDates('15-01-2012') => false\n\n  validDates('04-0-2040') => false\n\n  validDates('06-04-2020') => true\n\n  validDates('06/04/2020') => false\n  */\nconst validDates = (date) => {\n  const dateArray = date.split('-');\n  const monthArray = dateArray[0].split('-');\n  const dayArray = dateArray[1].split('-');\n  const year = dateArray[2];\n  const monthNumber = monthArray[0];\n  const dayNumber = dayArray[0];\n  const monthName = monthArray[1];\n  const dayName = dayArray[1];\n  const isValid = year >= 1900 &&\n    monthNumber >= 1 &&\n    dayNumber >= 1 &&\n    monthName === 'January' &&\n    dayName === '1';\n  return isValid;\n};\n\n/**\n * Given a date string and a format string, this function returns a date object\n * that represents the date in the format specified by the format string.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format string does not match the date string,\n * this function returns null.\n * If the date string is not valid or if the format ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWord(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWord(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWord(\"abcdef\") == 3\n  */\nconst splitWord = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWord", "gc": "<|endoftext|>/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWord(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWord(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWord(\"abcdef\") == 3\n  */\nconst splitWord = (txt) => {\n  let words = txt.split(\" \");\n  let wordCount = 0;\n  let wordList = [];\n  let word;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I;\n  let J;\n  let K;\n  let L;\n  let M;\n  let N;\n  let O;\n  let P;\n  let Q;\n  let R;\n  let S;\n  let T;\n  let U;\n  let V;\n  let W;\n  let X;\n  let Y;\n  let Z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let A;\n  let B;\n  let C;\n  let D;\n  let E;\n  let F;\n  let G;\n  let H;\n  let I", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSort([5])  true\n  isSort([1, 2, 3, 4, 5])  true\n  isSort([1, 3, 2, 4, 5])  false\n  isSort([1, 2, 3, 4, 5, 6])  true\n  isSort([1, 2, 3, 4, 5, 6, 7])  true\n  isSort([1, 3, 2, 4, 5, 6, 7])  false\n  isSort([1, 2, 2, 3, 3, 4])  true\n  isSort([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSort = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSort", "gc": "<|endoftext|>/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSort([5])  true\n  isSort([1, 2, 3, 4, 5])  true\n  isSort([1, 3, 2, 4, 5])  false\n  isSort([1, 2, 3, 4, 5, 6])  true\n  isSort([1, 2, 3, 4, 5, 6, 7])  true\n  isSort([1, 3, 2, 4, 5, 6, 7])  false\n  isSort([1, 2, 2, 3, 3, 4])  true\n  isSort([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSort = (lst) => {\n  let sorted = false\n  let i = 0\n  let j = 0\n  while (i < lst.length) {\n    if (lst[i] > lst[j]) {\n      sorted = true\n      break\n    }\n    if (lst[i] === lst[j]) {\n      i++\n      j++\n    } else {\n      i++\n      j++\n    }\n  }\n  return sorted\n}\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n * in descending order. If list has more than 1 duplicate of the same\n * number, return false. Assume no negative numbers and only integers.\n * Examples\n  isSort([5, 6, 7])  false\n  isSort([6, 5, 7])  true\n  isSort([6, 5, 7, 4])  true\n  isSort([6, 5, 7, 4, 3])  false\n  isSort([6, 5, 7, 4, 3, 2])  true\n  isSort([6, 5, 7, 4, 3, 2, 1])  false\n  */\nconst isDesc = (lst) => {\n  let sorted = false\n  let i = 0\n  let j = 0\n  while (i < lst.length) {\n    if (lst[i] < lst[j]) {\n      sorted = true\n      break\n    }\n    if (lst[i] === lst[j]) {\n      i++\n      j++\n    } else {\n      i++\n      j++\n    }\n  }\n  return sorted\n}\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n * in ascending order and in descending order. If list has more than 1 duplicate\n * of the same number, return false. Assume no negative numbers and only\n * integers.\n * Examples\n  isSorted([5, 6, 7])  true\n  isSorted([6, 5, 7])  false\n  isSorted([6, 5, 7, 4])  true\n  isSorted([6, 5, 7, 4, 3])  false\n  isSorted([6, 5, 7, 4, 3, 2])  false\n  isSorted([6, 5, 7, 4, 3, 2, 1])  true\n  */\nconst isSortedDesc = (lst) => {\n  let sorted = false\n  let i = 0\n  let j = 0\n  while (i < lst.length) {\n    if (lst[i] > lst[j]) {\n      sorted = true\n      break\n    }\n    if (lst[i] === lst[j]) {\n      i++\n      j++\n    } else {\n      i++\n      j++\n    }\n  }\n  return sorted\n}\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n * in ascending order and in descending order and in ascending order\n * and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n * order and in descending order and in ascending order and in descending\n * order and in ascending order and in descending order and in ascending\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "gc": "<|endoftext|>/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  let start1 = interval1[0];\n  let end1 = interval1[1];\n  let start2 = interval2[0];\n  let end2 = interval2[1];\n  let result = [];\n  if (start1 < end1 && start2 < end2) {\n    if (start1 > end2) {\n      result.push(start1);\n      start1 = end2;\n    }\n    if (start2 > end1) {\n      result.push(start2);\n      start2 = end1;\n    }\n  }\n  if (start1 > end2) {\n    result.push(start1);\n    start1 = end2;\n  }\n  if (start2 > end1) {\n    result.push(start2);\n    start2 = end1;\n  }\n  if (start1 < end2 && start2 < end1) {\n    if (start1 > end2) {\n      result.push(start1);\n      start1 = end2;\n    }\n    if (start2 > end1) {\n      result.push(start2);\n      start2 = end1;\n    }\n  }\n  if (start1 > end2) {\n    result.push(start1);\n    start1 = end2;\n  }\n  if (start2 > end1) {\n    result.push(start2);\n    start2 = end1;\n  }\n  if (start1 < end2 && start2 < end1) {\n    if (start1 > end2) {\n      result.push(start1);\n      start1 = end2;\n    }\n    if (start2 > end1) {\n      result.push(start2);\n      start2 = end1;\n    }\n  }\n  if (start1 > end2) {\n    result.push(start1);\n    start1 = end2;\n  }\n  if (start2 > end1) {\n    result.push(start2);\n    start2 = end1;\n  }\n  if (start1 < end2 && start2 < end1) {\n    if (start1 > end2) {\n      result.push(start1);\n      start1 = end2;\n    }\n    if (start2 > end1) {\n      result.push(start2);\n      start2 = end1;\n    }\n  }\n  if (start1 > end2) {\n    result.push(start1);\n    start1 = end2;\n  }\n  if (start2 > end1) {\n    result.push(start2);\n    start2 = end1;\n  }\n  if (start1 < end2 && start2 < end1) {\n    if (start1 > end2) {\n      result.push(start1);\n      start1 = end2;\n    }\n    if (start2 > end1) {\n      result.push(start2);\n      start2 = end1;\n    }\n  }\n  if (start1 > end2) {\n    result.push(start1);\n    start1 = end2;\n  }\n  if (start2 > end1) {\n    result.push(start2);\n    start2 = end1;\n  }\n  if (start1 < end2 && start2 < end1) {\n    if (start1 > end2) {\n      result.push(start1);\n      start1 = end2;\n    }\n    if (start2 > end1) {\n      result.push(start2);\n      start2 = end1;\n    }\n  }\n  if (start1 > end2) {\n    result.push(start1);\n    start1 = end2;\n  }\n  if (start2 > end1) {\n    result.push(start2);\n    start2 = end1;\n  }\n  if (start1 < end2 && start2 < end1) {\n    if (start1 > end2) {\n      result.push(start1);\n      start1 = end2;\n    }\n    if (start2 > end1) {\n      result.push(start2);\n      start2 = end1;\n    }\n  }\n  if (start1 > end2) {\n    result.push(start1);\n    start1 = end2;\n  }\n  if (start2 > end1) {\n    result.push(start2);\n    start2 = end1;\n  }\n  if (start1 < end2 && start2 < end1) {\n    if (start1 > end2) {\n      result.push(start1);\n      start1 = end2;\n    }\n    if (start2 > end1) {\n      result.push(start2);\n      start2 = end1;\n    }\n  }\n  if (start1 > end2) {\n    result.push(start1);\n    start1 = end2;\n  }\n  if (start2 > end1) {\n    result.push(start2);\n    start2 = end1;\n  }\n  if (start1 < end2 && start2 < end1) {\n    if (start1 > end2) {\n      result.push(start1);\n      start1 = end2;\n    }\n    if (start2 > end1) {\n      result.push(start2);\n      start2 = end1;\n    }\n  }\n  if (start1 > end2) {\n    result.push(start1);\n    start1 = end2;\n  }\n  if (start2 > end1) {\n    result.push(start2);\n    start2 = end1;\n  }\n  if (start1 < end2 && start2 < end1) {\n    if (start1 > end2) {\n      result.push(start1);\n      start1 = end2;\n    }\n    if (start2 > end1) {\n      result.push(start2);\n      start2 = end1;\n    }\n  }\n  if (start1 > end2) {\n    result.push(start1);\n    start1 = end2;\n  }\n  if (start2 > end1) {\n    result.push(start2);\n    start2 = end1;\n  }\n  if (start1 < end2 && start2 < end1) {\n    if (start1 > end2) {\n      result.push(start1);\n      start1 = end2;\n    }\n    if (start2 > end1) {\n      result.push(start2);\n      start2 = end1;\n    }\n  }\n  if (start1 > end2) {\n    result.push(start1);\n    start1 = end2;\n  }\n  if (start2 > end1) {\n    result.push(start2);\n    start2 = end1;\n  }\n  if (start1 < end2 && start2 < end1) {\n    if (start1 > end2) {\n      result.push(start1);\n      start1 = end2;\n    }\n    if (start2 > end1) {\n      result.push(start2);\n      start2 = end1;\n    }\n  }\n  if (start1 > end2) {\n    result.push(start1);\n    start1 = end2;\n  }\n  if (start2 > end1) {\n    result.push(start2);\n    start2 = end1;\n  }\n  if (start1 < end2 && start2 < end1) {\n    if (start1 > end2) {\n      result.push(start1);\n      start1 = end2;\n    }\n    if (start2 > end1) {\n      result.push(start2);\n      start2 = end1;\n    }\n  }\n  if (start1 > end2) {\n    result.push(start1);\n    start1 = end2;\n  }\n  if (start2 > end1) {\n    result.push(start2);\n    start2 = end1;\n  }\n  if (start1 < end2 && start2 < end1) {\n    if (start1 > end2) {\n      result.push(start1);\n      start1 = end2;\n    }\n    if (start2 > end1) {\n      result.push(start2);\n      start2 = end1;\n    }\n  }\n  if (start1 > end2) {\n    result.push(start1);\n    start1 = end2;\n  }\n  if (start2 > end1) {\n    result.push(start2);\n    start2 = end1;\n  }\n  if (start1 < end2 && start2 < end1) {\n    if (start1 > end2) {\n      ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodsSign([1, 2, 2, -4]) == -9\n  >>> prodsSign([0, 1]) == 0\n  >>> prodsSign([]) == null\n  */\nconst prodsSign = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodsSign", "gc": "<|endoftext|>/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodsSign([1, 2, 2, -4]) == -9\n  >>> prodsSign([0, 1]) == 0\n  >>> prodsSign([]) == null\n  */\nconst prodsSign = (arr) => {\n  if (!arr || arr.length === 0) {\n    return null\n  }\n\n  let sum = 0\n  let sign = 1\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sign = -1\n    }\n    sum += sign * arr[i]\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodsSign([1, 2, 2, -4]) == -9\n  >>> prodsSign([0, 1]) == 0\n  >>> prodsSign([]) == null\n  */\nconst prodsSign2d = (arr) => {\n  if (!arr || arr.length === 0) {\n    return null\n  }\n\n  let sum = 0\n  let sign = 1\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sign = -1\n    }\n    sum += sign * arr[i]\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodsSign([0, 1, -1, 4]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prodsSign([0, -1, 4, 1]) == 4\n  >>> prods", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPaths = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPaths", "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPaths = (grid, k) => {\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  const lst_C = new Array(grid.length).fill(0);\n  const lst_D = new Array(grid.length).fill(0);\n\n  for (let i = 0; i < grid.length; i++) {\n    const row = grid[i];\n    for (let j = 0; j < row.length; j++) {\n      const val = row[j];\n      if (lst_A[j] < lst_B[j]) {\n        lst_A[j] = lst_B[j];\n      }\n      if (lst_A[j] < lst_C[j]) {\n        lst_A[j] = lst_C[j];\n      }\n      if (lst_A[j] < lst_D[j]) {\n        lst_A[j] = lst_D[j];\n      }\n      if (lst_B[j] < lst_A[j]) {\n        lst_B[j] = lst_A[j];\n      }\n      if (lst_B[j] < lst_C[j]) {\n        lst_B[j] = lst_C[j];\n      }\n      if (lst_B[j] < lst_D[j]) {\n        lst_B[j] = lst_D[j];\n      }\n      if (lst_C[j] < lst_A[j]) {\n        lst_C[j] = lst_A[j];\n      }\n      if (lst_C[j] < lst_B[j]) {\n        lst_C[j] = lst_B[j];\n      }\n      if (lst_C[j] < lst_D[j]) {\n        lst_C[j] = lst_D[j];\n      }\n      if (lst_D[j] < lst_A[j]) {\n        lst_D[j] = lst_A[j];\n      }\n      if (lst_D[j] < lst_B[j]) {\n        lst_D[j] = lst_B[j];\n      }\n      if (lst_D[j] < lst_C[j]) {\n        lst_D[j] = lst_C[j];\n      }\n      if (lst_D[j] < lst_D[j]) {\n        lst_D[j] = lst_D[j];\n      }\n    }\n  }\n\n  const lst_A1 = new Array(grid.length).fill(0);\n  const lst_B1 = new Array(grid.length).fill(0);\n  const lst_C1 = new Array(grid.length).fill(0);\n  const lst_D1 = new Array(grid.length).fill(0);\n\n  for (let i = 0; i < grid.length; i++) {\n    const row = grid[i];\n    for (let j = 0; j < row.length; j++) {\n      const val = row[j];\n      if (lst_A[j] < lst_B[j]) {\n        lst_A1[j] = lst_B[j];\n      }\n      if (lst_A[j] < lst_C[j]) {\n        lst_A1[j] = lst_C[j];\n      }\n      if (lst_A[j] < lst_D[j]) {\n        lst_A1[j] = lst_D[j];\n      }\n      if (lst_B[j] < lst_A[j]) {\n        lst_B1[j] = lst_A[j];\n      }\n      if (lst_B[j] < lst_C[j]) {\n        lst_B1[j] = lst_C[j];\n      }\n      if (lst_B[j] < lst_D[j]) {\n        lst_B1[j] = lst_D[j];\n      }\n      if (lst_C[j] < lst_A[j]) {\n        lst_C1[j] = lst_A[j];\n      }\n      if (lst_C[j] < lst_B[j]) {\n        lst_C1[j] = lst_B[j];\n      }\n      if (lst_C[j] < lst_D[j]) {\n        lst_C1[j] = lst_D[j];\n      }\n      if (lst_D[j] < lst_A[j]) {\n        lst_D1[j] = lst_A[j];\n      }\n      if (lst_D[j] < lst_B[j]) {\n        lst_D1[j] = lst_B[j];\n      }\n      if (lst_D[j] < lst_C[j]) {\n        lst_D1[j] = lst_C[j];\n      }\n      if (lst_D[j] < lst_D[j]) {\n        lst_D1[j] = lst_D[j];\n      }\n    }\n  }\n\n  const lst_A2 = new Array(grid.length).fill(0);\n  const lst_B2 = new Array(grid.length).fill(0);\n  const lst_C2 = new Array(grid.length).fill(0);\n  const lst_D2 = new Array(grid.length).fill(0);\n\n  for (let i = 0; i < grid.length; i++) {\n    const row = grid[i];\n    for (let j = 0; j < row.length; j++) {\n      const val = row[j];\n      if (lst_A[j] < lst_B[j]) {\n        lst_A2[j] = lst_B[j];\n      }\n      if (lst_A[j] < lst_C[j]) {\n        lst_A2[j] = lst_C[j];\n      }\n      if (lst_A[j] < lst_D[j]) {\n        lst_A2[j] = lst_D[j];\n      }\n      if (lst_B[j] < lst_A[j]) {\n        lst_B2[j] = lst_A[j];\n      }\n      if (lst_B[j] < lst_C[j]) {\n        lst_B2[j] = lst_C[j];\n      }\n      if (lst_B[j] < lst_D[j]) {\n        lst_B2[j] = lst_D[j];\n      }\n      if (lst_C[j] < lst_A[j]) {\n        lst_C2[j] = lst_A[j];\n      }\n      if (lst_C[j] < lst_B[j]) {\n        lst_C2[j] = lst_B[j];\n      }\n      if (lst_C[j] < lst_D[j]) {\n        lst_C2[j] = lst_D[j];\n      }\n      if (lst_D[j] < lst_A[j]) {\n        lst_D2[j] = lst_A[j];\n      }\n      if (lst_D[j] < lst_B[j]) {\n        lst_D2[j] = lst_B[j];\n      }\n      if (lst_D[j] < lst_C[j]) {\n        lst_D2[j] = lst_C[j];\n      }\n      if (lst_D[j] < lst_D[j]) {\n        lst_D2[j] = lst_D[j];\n      }\n    }\n  }\n\n  const lst_A3 = new Array(grid.length).fill(0);\n  const lst_B3 = new Array(grid.length).fill(0);\n  const l", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest common divisor of two integers a and b\n  >>> greaterCommonDivisors(3, 5)\n  1\n  >>> greaterCommonDivisors(25, 15)\n  5\n  */\nconst greaterCommonDivisors = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greaterCommonDivisors", "gc": "<|endoftext|>/* Return a greatest common divisor of two integers a and b\n  >>> greaterCommonDivisors(3, 5)\n  1\n  >>> greaterCommonDivisors(25, 15)\n  5\n  */\nconst greaterCommonDivisors = (a, b) => {\n  if (a < b) {\n    return b\n  }\n  if (a > b) {\n    return a\n  }\n  return gcd(a, b) // gcd(a, b)\n}\n\n/**\n * Given a number x, return its prime factorization\n * https://en.wikipedia.org/wiki/Prime_factorization\n * >>> primeFactorization(1)\n * []\n * >>> primeFactorization(2)\n * [2, 2, 2]\n * >>> primeFactorization(3)\n * [2, 2, 2, 3, 3]\n * >>> primeFactorization(5)\n * [2, 2, 2, 3, 5, 5]\n * >>> primeFactorization(7)\n * [2, 2, 2, 3, 5, 7, 7]\n * >>> primeFactorization(11)\n * [2, 2, 2, 3, 5, 7, 11, 11]\n * >>> primeFactorization(13)\n * [2, 2, 2, 3, 5, 7, 11, 13, 13]\n * >>> primeFactorization(15)\n * [2, 2, 2, 3, 5, 7, 11, 13, 15, 15]\n * >>> primeFactorization(17)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 17]\n * >>> primeFactorization(19)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 19]\n * >>> primeFactorization(21)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 21]\n * >>> primeFactorization(23)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 23]\n * >>> primeFactorization(25)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 25]\n * >>> primeFactorization(27)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 27]\n * >>> primeFactorization(31)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 31]\n * >>> primeFactorization(33)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 33]\n * >>> primeFactorization(35)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35]\n * >>> primeFactorization(37)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37]\n * >>> primeFactorization(39)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39]\n * >>> primeFactorization(41)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41]\n * >>> primeFactorization(43)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43]\n * >>> primeFactorization(45)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45]\n * >>> primeFactorization(47)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47]\n * >>> primeFactorization(51)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51]\n * >>> primeFactorization(53)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51, 53]\n * >>> primeFactorization(55)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51, 53, 55]\n * >>> primeFactorization(57)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51, 53, 55, 57]\n * >>> primeFactorization(59)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51, 53, 55, 57, 59]\n * >>> primeFactorization(61)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51, 53, 55, 57, 59, 61]\n * >>> primeFactorization(63)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51, 53, 55, 57, 59, 61, 63]\n * >>> primeFactorization(65)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51, 53, 55, 57, 59, 61, 63, 65]\n * >>> primeFactorization(67)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51, 53, 55, 57, 59, 61, 63, 65, 67]\n * >>> primeFactorization(69)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 69]\n * >>> primeFactorization(71)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 69, 71]\n * >>> primeFactorization(73)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 69, 71, 73]\n * >>> primeFactorization(75)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 69, 71, 73, 75, 75]\n * >>> primeFactorization(77)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 69, 71, 73, 75, 75, 76, 76, 77, 77]\n * >>> primeFactorization(79)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 69, 71, 73, 75, 75, 76, 76, 77, 77, 79]\n * >>> primeFactorization(81)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 69, 71, 73, 75, 75, 76, 76, 77, 77, 79, 79]\n * >>> primeFactorization(83)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, 39, 41, 43, 45, 47, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 69, 71, 73, 75, 75, 76, 76, 77, 77, 79, 79, 83, 83]\n * >>> primeFactorization(85)\n * [2, 2, 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 25, 27, 31, 33, 35, 35, 37, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "gc": "<|endoftext|>/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [];\n  if (n <= 1) {\n    return arr;\n  }\n  arr.push(1);\n  arr.push(2);\n  arr.push(3);\n  arr.push(4);\n  arr.push(5);\n  arr.push(6);\n  arr.push(7);\n  arr.push(8);\n  arr.push(9);\n  arr.push(10);\n  arr.push(11);\n  arr.push(12);\n  arr.push(13);\n  arr.push(14);\n  arr.push(15);\n  arr.push(16);\n  arr.push(17);\n  arr.push(18);\n  arr.push(19);\n  arr.push(20);\n  arr.push(21);\n  arr.push(22);\n  arr.push(23);\n  arr.push(24);\n  arr.push(25);\n  arr.push(26);\n  arr.push(27);\n  arr.push(28);\n  arr.push(29);\n  arr.push(30);\n  arr.push(31);\n  arr.push(32);\n  arr.push(33);\n  arr.push(34);\n  arr.push(35);\n  arr.push(36);\n  arr.push(37);\n  arr.push(38);\n  arr.push(39);\n  arr.push(40);\n  arr.push(41);\n  arr.push(42);\n  arr.push(43);\n  arr.push(44);\n  arr.push(45);\n  arr.push(46);\n  arr.push(47);\n  arr.push(48);\n  arr.push(49);\n  arr.push(50);\n  arr.push(51);\n  arr.push(52);\n  arr.push(53);\n  arr.push(54);\n  arr.push(55);\n  arr.push(56);\n  arr.push(57);\n  arr.push(58);\n  arr.push(59);\n  arr.push(60);\n  arr.push(61);\n  arr.push(62);\n  arr.push(63);\n  arr.push(64);\n  arr.push(65);\n  arr.push(66);\n  arr.push(67);\n  arr.push(68);\n  arr.push(69);\n  arr.push(70);\n  arr.push(71);\n  arr.push(72);\n  arr.push(73);\n  arr.push(74);\n  arr.push(75);\n  arr.push(76);\n  arr.push(77);\n  arr.push(78);\n  arr.push(79);\n  arr.push(80);\n  arr.push(81);\n  arr.push(82);\n  arr.push(83);\n  arr.push(84);\n  arr.push(85);\n  arr.push(86);\n  arr.push(87);\n  arr.push(88);\n  arr.push(89);\n  arr.push(90);\n  arr.push(91);\n  arr.push(92);\n  arr.push(93);\n  arr.push(94);\n  arr.push(95);\n  arr.push(96);\n  arr.push(97);\n  arr.push(98);\n  arr.push(99);\n  arr.push(100);\n  arr.push(101);\n  arr.push(102);\n  arr.push(103);\n  arr.push(104);\n  arr.push(105);\n  arr.push(106);\n  arr.push(107);\n  arr.push(108);\n  arr.push(109);\n  arr.push(110);\n  arr.push(111);\n  arr.push(112);\n  arr.push(113);\n  arr.push(114);\n  arr.push(115);\n  arr.push(116);\n  arr.push(117);\n  arr.push(118);\n  arr.push(119);\n  arr.push(120);\n  arr.push(121);\n  arr.push(122);\n  arr.push(123);\n  arr.push(124);\n  arr.push(125);\n  arr.push(126);\n  arr.push(127);\n  arr.push(128);\n  arr.push(129);\n  arr.push(130);\n  arr.push(131);\n  arr.push(132);\n  arr.push(133);\n  arr.push(134);\n  arr.push(135);\n  arr.push(136);\n  arr.push(137);\n  arr.push(138);\n  arr.push(139);\n  arr.push(140);\n  arr.push(141);\n  arr.push(142);\n  arr.push(143);\n  arr.push(144);\n  arr.push(145);\n  arr.push(146);\n  arr.push(147);\n  arr.push(148);\n  arr.push(149);\n  arr.push(150);\n  arr.push(151);\n  arr.push(152);\n  arr.push(153);\n  arr.push(154);\n  arr.push(155);\n  arr.push(156);\n  arr.push(157);\n  arr.push(158);\n  arr.push(159);\n  arr.push(160);\n  arr.push(161);\n  arr.push(162);\n  arr.push(163);\n  arr.push(164);\n  arr.push(165);\n  arr.push(166);\n  arr.push(167);\n  arr.push(168);\n  arr.push(169);\n  arr.push(170);\n  arr.push(171);\n  arr.push(172);\n  arr.push(173);\n  arr.push(174);\n  arr.push(175);\n  arr.push(176);\n  arr.push(177);\n  arr.push(178);\n  arr.push(179);\n  arr.push(180);\n  arr.push(181);\n  arr.push(182);\n  arr.push(183);\n  arr.push(184);\n  arr.push(185);\n  arr.push(186);\n  arr.push(187);\n  arr.push(188);\n  arr.push(189);\n  arr.push(190);\n  arr.push(191);\n  arr.push(192);\n  arr.push(193);\n  arr.push(194);\n  arr.push(195);\n  arr.push(196);\n  arr.push(197);\n  arr.push(198);\n  arr.push(199);\n  arr.push(200);\n  arr.push(201);\n  arr.push(202);\n  arr.push(203);\n  arr.push(204);\n  arr.push(205);\n  arr.push(206);\n  arr.push(207);\n  arr.push(208);\n  arr.push(209);\n  arr.push(210);\n  arr.push(211);\n  arr.push(212);\n  arr.push(213);\n  arr.push(214);\n  arr.push(215);\n  arr.push(216);\n  arr.push(217);\n  arr.push(218);\n  arr.push(219);\n  arr.push(220);\n  arr.push(221);\n  arr.push(222);\n  arr.push(223);\n  arr.push(224);\n  arr.push(225);\n  arr.push(226);\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd digit.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digit = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digit", "gc": "<|endoftext|>/*Given a positive integer n, return the product of the odd digit.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digit = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    sum += n % 10 * Math.pow(10, i % 2);\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the even digit.\n  Return 0 if all digit are odd.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitEven = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    sum += n % 10 * Math.pow(10, i % 2);\n    n /= 10;\n  }\n  return sum % 2 === 0;\n};\n\n/*Given a positive integer n, return the sum of its digits.\n  Return 0 if n is 0.\n  For example:\n  digit(5) == 5\n  digit(10) == 10\n  digit(15) == 15\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    sum += n % 10 * Math.pow(10, i % 2);\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits modulo 10.\n  Return 0 if n is 0.\n  For example:\n  digitSum(5) == 5\n  digitSum(10) == 10\n  digitSum(15) == 15\n  */\nconst digitSumMod10 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    sum += n % 10 * Math.pow(10, i % 2);\n    n /= 10;\n  }\n  return sum % 10!== 0;\n};\n\n/*Given a positive integer n, return the sum of its digits modulo 100.\n  Return 0 if n is 0.\n  For example:\n  digitSumMod10(5) == 5\n  digitSumMod10(10) == 10\n  digitSumMod10(15) == 15\n  */\nconst digitSumMod100 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    sum += n % 10 * Math.pow(10, i % 2);\n    n /= 10;\n  }\n  return sum % 100!== 0;\n};\n\n/*Given a positive integer n, return the sum of its digits modulo 1000.\n  Return 0 if n is 0.\n  For example:\n  digitSumMod100(5) == 5\n  digitSumMod100(10) == 10\n  digitSumMod100(15) == 15\n  */\nconst digitSumMod1000 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    sum += n % 10 * Math.pow(10, i % 2);\n    n /= 10;\n  }\n  return sum % 1000!== 0;\n};\n\n/*Given a positive integer n, return the sum of its digits modulo 10000.\n  Return 0 if n is 0.\n  For example:\n  digitSumMod1000(5) == 5\n  digitSumMod1000(10) == 10\n  digitSumMod1000(15) == 15\n  */\nconst digitSumMod10000 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    sum += n % 10 * Math.pow(10, i % 2);\n    n /= 10;\n  }\n  return sum % 10000!== 0;\n};\n\n/*Given a positive integer n, return the sum of its digits modulo 100000.\n  Return 0 if n is 0.\n  For example:\n  digitSumMod10000(5) == 5\n  digitSumMod10000(10) == 10\n  digitSumMod10000(15) == 15\n  */\nconst digitSumMod100000 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    sum += n % 10 * Math.pow(10, i % 2);\n    n /= 10;\n  }\n  return sum % 100000!== 0;\n};\n\n/*Given a positive integer n, return the sum of its digits modulo 1000000.\n  Return 0 if n is 0.\n  For example:\n  digitSumMod10000(5) == 5\n  digitSumMod10000(10) == 10\n  digitSumMod10000(15) == 15\n  */\nconst digitSumMod1000000 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    sum += n % 10 * Math.pow(10, i % 2);\n    n /= 10;\n  }\n  return sum % 1000000!== 0;\n};\n\n/*Given a positive integer n, return the sum of its digits modulo 10000000.\n  Return 0 if n is 0.\n  For example:\n  digitSumMod1000000(5) == 5\n  digitSumMod1000000(10) == 10\n  digitSumMod1000000(15) == 15\n  */\nconst digitSumMod10000000 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    sum += n % 10 * Math.pow(10, i % 2);\n    n /= 10;\n  }\n  return sum % 10000000!== 0;\n};\n\n/*Given a positive integer n, return the sum of its digits modulo 100000000.\n  Return 0 if n is 0.\n  For example:\n  digitSumMod10000000(5) == 5\n  digitSumMod10000000(10) == 10\n  digitSumMod10000000(15) == 15\n  */\nconst digitSumMod100000000 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    sum += n % 10 * Math.pow(10, i % 2);\n    n /= 10;\n  }\n  return sum % 100000000!== 0;\n};\n\n/*Given a positive integer n, return the sum of its digits modulo 1000000000.\n  Return 0 if n is 0.\n  For example:\n  digitSumMod100000000(5) == 5\n  digitSumMod100000000(10) == 10\n  digitSumMod100000000(15) == 15\n  */\nconst digitSumMod1000000000 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    sum += n % 10 * Math.pow(10, i % 2);\n    n /= 10;\n  }\n  return sum % 1000000000!== 0;\n};\n\n/*Given a positive integer n, return the sum of its digits modulo 10000000000.\n  Return 0 if n is 0.\n  For example:\n  digitSumMod1000000000(5) == 5\n  digitSumMod1000000000(10) == 10\n  digitSumMod1000000000(15) == 15\n  */\nconst digitSumMod10000000000 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    sum += n % 10 * Math.pow(10, i % 2);\n    n /= 10;\n  }\n  return sum % 10000000000!== 0;\n};\n\n/*Given a positive integer n, return the sum of its digits modulo 100000000000.\n  Return 0 if n is 0.\n  For example:\n  digitSumMod100000000000(5) == 5\n  digitSumMod100000000000(10) == 10\n  digitSumMod100000000000(15) == 15\n  */\nconst digitSumMod100000000000 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    sum += n % 10 * Math.pow(10, i % 2);\n    n /= 10;\n  }\n  return sum % 100000000000!== 0;\n};\n\n/*Given a positive integer n, return the sum of its digits modulo 1000000000000.\n  Return 0 if n is 0.\n  For example:\n  digitSumMod1000000000000(5) == 5\n  digitSumMod1000000000000(10) == 10\n  digit", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]')  true\n  isNest('[]]]]]]][[[[[]')  false\n  isNest('[][]')  false\n  isNest('[]')  false\n  isNest('[[][]]')  true\n  isNest('[[]][[')  true\n  */\nconst isNest = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNest", "gc": "<|endoftext|>/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]')  true\n  isNest('[]]]]]]][[[[[]')  false\n  isNest('[][]')  false\n  isNest('[]')  false\n  isNest('[[][]]')  true\n  isNest('[[]][[')  true\n  */\nconst isNest = (string) => {\n  const nestingRegex = /[\\[\\]]/g;\n  return nestingRegex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]')  true\n  isNest('[]]]]]]][[[[[]')  false\n  isNest('[][]')  false\n  isNest('[]')  false\n  isNest('[[][]]')  true\n  isNest('[[]][[')  true\n  */\nconst isNest = (string) => {\n  const nestingRegex = /[\\[\\]]/g;\n  return nestingRegex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]')  true\n  isNest('[]]]]]]][[[[[]')  false\n  isNest('[][]')  false\n  isNest('[]')  false\n  isNest('[[][]]')  true\n  isNest('[[]][[')  true\n  */\nconst isNest = (string) => {\n  const nestingRegex = /[\\[\\]]/g;\n  return nestingRegex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]')  true\n  isNest('[]]]]]]][[[[[]')  false\n  isNest('[][]')  false\n  isNest('[]')  false\n  isNest('[[][]]')  true\n  isNest('[[]][[')  true\n  */\nconst isNest = (string) => {\n  const nestingRegex = /[\\[\\]]/g;\n  return nestingRegex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]')  true\n  isNest('[]]]]]]][[[[[]')  false\n  isNest('[][]')  false\n  isNest('[]')  false\n  isNest('[[][]]')  true\n  isNest('[[]][[')  true\n  */\nconst isNest = (string) => {\n  const nestingRegex = /[\\[\\]]/g;\n  return nestingRegex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]')  true\n  isNest('[]]]]]]][[[[[]')  false\n  isNest('[][]')  false\n  isNest('[]')  false\n  isNest('[[][]]')  true\n  isNest('[[]][[')  true\n  */\nconst isNest = (string) => {\n  const nestingRegex = /[\\[\\]]/g;\n  return nestingRegex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]')  true\n  isNest('[]]]]]]][[[[[]')  false\n  isNest('[][]')  false\n  isNest('[]')  false\n  isNest('[[][]]')  true\n  isNest('[[]][[')  true\n  */\nconst isNest = (string) => {\n  const nestingRegex = /[\\[\\]]/g;\n  return nestingRegex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]')  true\n  isNest('[]]]]]]][[[[[]')  false\n  isNest('[][]')  false\n  isNest('[]')  false\n  isNest('[[][]]')  true\n  isNest('[[]][[')  true\n  */\nconst isNest = (string) => {\n  const nestingRegex = /[\\[\\]]/g;\n  return nestingRegex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]')  true\n  isNest('[]]]]]]][[[[[]')  false\n  isNest('[][]')  false\n  isNest('[]')  false\n  isNest('[[][]]')  true\n  isNest('[[]][[')  true\n  */\nconst isNest = (string) => {\n  const nestingRegex = /[\\[\\]]/g;\n  return nestingRegex.test(string);\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]')  true\n  isNest('[]]]]]]][[[[[]')  false\n  isNest('[][]')  false\n  isNest('[]') ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumsSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumsSquares", "gc": "<|endoftext|>/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumsSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 24\n  For lst = [-2.4,1,1] the output should be 24\n  */\nconst sumsCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 24\n  For lst = [-2.4,1,1] the output should be 24\n  */\nconst sumsCubesRound = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 24\n  For lst = [-2.4,1,1] the output should be 24\n  */\nconst sumsCubesRound2 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 24\n  For lst = [-2.4,1,1] the output should be 24\n  */\nconst sumsCubesRound3 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 24\n  For lst = [-2.4,1,1] the output should be 24\n  */\nconst sumsCubesRound4 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 24\n  For lst = [-2.4,1,1] the output should be 24\n  */\nconst sumsCubesRound5 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 24\n  For lst = [-2.4,1,1] the output should be 24\n  */\nconst sumsCubesRound6 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 24\n  For lst = [-2.4,1,1] the output should be 24\n  */\nconst sumsCubesRound7 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 24\n  For lst = [-2.4,1,1] the output should be 24\n  */\nconst sumsCubesRound8 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 24\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 24\n  For lst = [-2.4,1,1] the output should be 24\n  */\nconst sumsCubesRound9 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 3);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the ", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharsIsALetter(\"apple pie\")  false\n  checkIfLastCharsIsALetter(\"apple pi e\")  true\n  checkIfLastCharsIsALetter(\"apple pi e \")  false\n  checkIfLastCharsIsALetter(\"\")  false\n  */\nconst checkIfLastCharsIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharsIsALetter", "gc": "<|endoftext|>/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharsIsALetter(\"apple pie\")  false\n  checkIfLastCharsIsALetter(\"apple pi e\")  true\n  checkIfLastCharsIsALetter(\"apple pi e \")  false\n  checkIfLastCharsIsALetter(\"\")  false\n  */\nconst checkIfLastCharsIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar && lastChar!=='' && lastChar!== '-' && lastChar!== '_';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharsIsALetter(\"apple pie\")  false\n  checkIfLastCharsIsALetter(\"apple pie e\")  true\n  checkIfLastCharsIsALetter(\"apple pie e \")  false\n  checkIfLastCharsIsALetter(\"\")  false\n  */\nconst checkIfLastCharsIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar && lastChar!=='' && lastChar!== '-' && lastChar!== '_' && lastChar!== '.';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharsIsALetter(\"apple pie\")  false\n  checkIfLastCharsIsALetter(\"apple pie e\")  true\n  checkIfLastCharsIsALetter(\"apple pie e \")  false\n  checkIfLastCharsIsALetter(\"\")  false\n  */\nconst checkIfLastCharsIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar && lastChar!=='' && lastChar!== '-' && lastChar!== '_' && lastChar!== '.' && lastChar!== '/';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharsIsALetter(\"apple pie\")  false\n  checkIfLastCharsIsALetter(\"apple pie e\")  true\n  checkIfLastCharsIsALetter(\"apple pie e \")  false\n  checkIfLastCharsIsALetter(\"\")  false\n  */\nconst checkIfLastCharsIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar && lastChar!=='' && lastChar!== '-' && lastChar!== '_' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharsIsALetter(\"apple pie\")  false\n  checkIfLastCharsIsALetter(\"apple pie e\")  true\n  checkIfLastCharsIsALetter(\"apple pie e \")  false\n  checkIfLastCharsIsALetter(\"\")  false\n  */\nconst checkIfLastCharsIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar && lastChar!=='' && lastChar!== '-' && lastChar!== '_' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharsIsALetter(\"apple pie\")  false\n  checkIfLastCharsIsALetter(\"apple pie e\")  true\n  checkIfLastCharsIsALetter(\"apple pie e \")  false\n  checkIfLastCharsIsALetter(\"\")  false\n  */\nconst checkIfLastCharsIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar && lastChar!=='' && lastChar!== '-' && lastChar!== '_' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-' && lastChar!== '.' && lastChar!== '/' && lastChar!== '+' && lastChar!== '-' && lastChar!== '.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canArranging([1,2,4,3,5]) = 3\n  canArranging([1,2,3]) = -1\n  */\nconst canArranging = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArranging", "gc": "<|endoftext|>/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canArranging([1,2,4,3,5]) = 3\n  canArranging([1,2,3]) = -1\n  */\nconst canArranging = (arr) => {\n  let max = 0;\n  let index = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[max]) {\n      max = i;\n      index = i;\n    }\n  }\n  return index;\n};\n\n/*\n  Given an array of integers, return an array which contains all possible pairs\n  of integers such that each pair contains at least one element from arr and\n  no duplicates.\n\n  Examples:\n  pairs([1,2,3]) = [[1,2], [1,3], [2,3], [2,4], [3,4]]\n  pairs([1,2,3,4,5,6]) = [[1,2], [1,3], [2,3], [2,4], [3,4], [4,5], [5,6]]\n  pairs([1,2,3,4,5,6,7,8]) = [[1,2], [1,3], [2,3], [2,4], [3,4], [4,5], [5,6], [6,7], [7,8]]\n  pairs([1,2,3,4,5,6,7,8,9]) = [[1,2], [1,3], [2,3], [2,4], [3,4], [4,5], [5,6], [6,7], [7,8], [8,9]]\n  pairs([1,2,3,4,5,6,7,8,9,10]) = [[1,2], [1,3], [2,3], [2,4], [3,4], [4,5], [5,6], [6,7], [7,8], [8,9], [9,10]]\n  pairs([1,2,3,4,5,6,7,8,9,10,11,12]) = [[1,2], [1,3], [2,3], [2,4], [3,4], [4,5], [5,6], [6,7], [7,8], [8,9], [9,10], [10,11], [11,12]]\n  pairs([1,2,3,4,5,6,7,8,9,10,11,12,13,14]) = [[1,2], [1,3], [2,3], [2,4], [3,4], [4,5], [5,6], [6,7], [7,8], [8,9], [9,10], [10,11], [11,12], [12,13], [13,14]]\n  pairs([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) = [[1,2], [1,3], [2,3], [2,4], [3,4], [4,5], [5,6], [6,7], [7,8], [8,9], [9,10], [10,11], [11,12], [12,13], [13,14], [14,15], [15,16]]\n  pairs([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]) = [[1,2], [1,3], [2,3], [2,4], [3,4], [4,5], [5,6], [6,7], [7,8], [8,9], [9,10], [10,11], [11,12], [12,13], [13,14], [14,15], [15,16], [16,17], [17,18], [18,19]]\n  pairs([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,49", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  largerSmallerIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largerSmallerIntegers([]) == (null, null)\n  largerSmallerIntegers([0]) == (null, null)\n  */\nconst largerSmallerIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largerSmallerIntegers", "gc": "<|endoftext|>/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  largerSmallerIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largerSmallerIntegers([]) == (null, null)\n  largerSmallerIntegers([0]) == (null, null)\n  */\nconst largerSmallerIntegers = (lst) => {\n  let maxNum = lst.reduce((acc, x) => Math.max(acc, x), 0);\n  let minNum = lst.reduce((acc, x) => Math.min(acc, x), 0);\n  return lst.map((x) => x - minNum).map((x) => x - maxNum);\n};\n\n/* Create a function that returns true if the given list contains a\n  negative integer.\n  Examples:\n  containNegativeIntegers([2, 4, 1, 3, 5, 7]) == true\n  containNegativeIntegers([]) == true\n  containNegativeIntegers([0]) == true\n  */\nconst containNegativeIntegers = (lst) => {\n  return lst.some((x) => x < 0);\n};\n\n/* Create a function that returns true if the given list contains a\n  positive integer.\n  Examples:\n  containPositiveIntegers([2, 4, 1, 3, 5, 7]) == true\n  containPositiveIntegers([]) == true\n  containPositiveIntegers([0]) == true\n  */\nconst containPositiveIntegers = (lst) => {\n  return lst.some((x) => x > 0);\n};\n\n/* Create a function that returns true if the given list contains a\n  positive integer that is greater than the largest positive integer\n  in the list.\n  Examples:\n  greaterThanPositiveIntegers([2, 4, 1, 3, 5, 7]) == true\n  greaterThanPositiveIntegers([]) == true\n  greaterThanPositiveIntegers([0]) == true\n  */\nconst greaterThanPositiveIntegers = (lst) => {\n  return lst.some((x) => x > maxPositiveInteger);\n};\n\n/* Create a function that returns true if the given list contains a\n  positive integer that is less than the smallest positive integer\n  in the list.\n  Examples:\n  lessThanPositiveIntegers([2, 4, 1, 3, 5, 7]) == true\n  lessThanPositiveIntegers([]) == true\n  lessThanPositiveIntegers([0]) == true\n  */\nconst lessThanPositiveIntegers = (lst) => {\n  return lst.some((x) => x < minPositiveInteger);\n};\n\n/* Create a function that returns true if the given list contains a\n  positive integer that is less than or equal to the largest positive\n  integer in the list.\n  Examples:\n  lessOrEqualThanPositiveIntegers([2, 4, 1, 3, 5, 7]) == true\n  lessOrEqualThanPositiveIntegers([]) == true\n  lessOrEqualThanPositiveIntegers([0]) == true\n  */\nconst lessOrEqualThanPositiveIntegers = (lst) => {\n  return lst.some((x) => x <= maxPositiveInteger);\n};\n\n/* Create a function that returns true if the given list contains a\n  positive integer that is greater than or equal to the smallest positive\n  integer in the list.\n  Examples:\n  greaterOrEqualThanPositiveIntegers([2, 4, 1, 3, 5, 7]) == true\n  greaterOrEqualThanPositiveIntegers([]) == true\n  greaterOrEqualThanPositiveIntegers([0]) == true\n  */\nconst greaterOrEqualThanPositiveIntegers = (lst) => {\n  return lst.some((x) => x >= minPositiveInteger);\n};\n\n/* Create a function that returns true if the given list contains a\n  positive integer that is equal to the largest positive integer\n  in the list.\n  Examples:\n  equalToPositiveIntegers([2, 4, 1, 3, 5, 7]) == true\n  equalToPositiveIntegers([]) == true\n  equalToPositiveIntegers([0]) == true\n  */\nconst equalToPositiveIntegers = (lst) => {\n  return lst.every((x) => x == maxPositiveInteger);\n};\n\n/* Create a function that returns true if the given list contains a\n  positive integer that is equal to the smallest positive integer\n  in the list.\n  Examples:\n  equalToPositiveIntegers([2, 4, 1, 3, 5, 7]) == true\n  equalToPositiveIntegers([]) == true\n  equalToPositiveIntegers([0]) == true\n  */\nconst equalToPositiveIntegers = (lst) => {\n  return lst.every((x) => x == minPositiveInteger);\n};\n\n/* Create a function that returns true if the given list contains a\n  positive integer that is equal to the largest positive integer\n  in the list.\n  Examples:\n  equalToPositiveIntegers([2, 4, 1, 3, 5, 7]) == true\n  equalToPositiveIntegers([]) == true\n  equalToPositiveIntegers([0]) == true\n  */\nconst equalToPositiveIntegers = (lst) => {\n  return lst.every((x) => x == maxPositiveInteger);\n};\n\n/* Create a function that returns true if the given list contains a\n  positive integer that is greater than or equal to the smallest positive\n  integer in the list.\n  Examples:\n  greaterOrEqualToPositiveIntegers([2, 4, 1, 3, 5, 7]) == true\n  greaterOrEqualToPositiveIntegers([]) == true\n  greaterOrEqualToPositiveIntegers([0]) == true\n  */\nconst greaterOrEqualToPositiveIntegers = (lst) => {\n  return lst.every((x) => x >= minPositiveInteger);\n};\n\n/* Create a function that returns true if the given list contains a\n  positive integer that is equal to the largest positive integer\n  in the list.\n  Examples:\n  equalToPositiveIntegers([2, 4, 1, 3, 5, 7]) == true\n  equalToPositiveIntegers([]) == true\n  equalToPositiveIntegers([0]) == true\n  */\nconst equalToPositiveIntegers = (lst) => {\n  return lst.every((x) => x == maxPositiveInteger);\n};\n\n/* Create a function that returns true if the given list contains a\n  positive integer that is greater than or equal to the smallest positive\n  integer in the list.\n  Examples:\n  greaterOrEqualToPositiveIntegers([2, 4, 1, 3, 5, 7]) == true\n  greaterOrEqualToPositiveIntegers([]) == true\n  greaterOrEqualToPositiveIntegers([0]) == true\n  */\nconst greaterOrEqualToPositiveIntegers = (lst) => {\n  return lst.every((x) => x >= minPositiveInteger);\n};\n\n/* Create a function that returns true if the given list contains a\n  positive integer that is equal to the smallest positive integer\n  in the list.\n  Examples:\n  equalToPositiveIntegers([2, 4, 1, 3, 5, 7]) == true\n  equalToPositiveIntegers([]) == true\n  equalToPositiveIntegers([0]) == true\n  */\nconst equalToPositiveIntegers = (lst) => {\n  return lst.every((x) => x == minPositiveInteger);\n};\n\n/* Create a function that returns true if the given list contains a\n  positive integer that is equal to the largest positive integer\n  in the list.\n  Examples:\n  equalToPositiveIntegers([2, 4, 1, 3, 5, 7]) == true\n  equalToPositiveIntegers([]) == true\n  equalToPositiveIntegers([0]) == true\n  */\nconst equalToPositiveIntegers = (lst) => {\n  return lst.every((x) => x == maxPositiveInteger);\n};\n\n/* Create a function that returns true if the given list contains a\n  positive integer that is greater than or equal to the smallest positive\n  integer in the list.\n  Examples:\n  greaterOrEqualToPositiveIntegers([2, 4, 1, 3, 5, 7]) == true\n  greaterOrEqualToPositiveIntegers([]) == true\n  greaterOrEqualToPositiveIntegers([0]) == true\n  */\nconst greaterOrEqualToPositiveIntegers = (lst) => {\n  return lst.every((x) => x >= minPositiveInteger);\n};\n\n/* Create a function that returns true if the given list contains a\n  positive integer that is greater than the largest positive integer\n  in the list.\n  Examples:\n  greaterThanPositiveIntegers([2, 4, 1, 3, 5, 7]) == true\n  greaterThanPositiveIntegers([]) == true\n  greaterThanPositiveIntegers([0]) == true\n  */\nconst greaterThanPositive", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be . or ,\n\n  comparingOne(1, 2.5)  2.5\n  comparingOne(1, \"2,3\")  \"2,3\"\n  comparingOne(\"5,1\", \"6\")  \"6\"\n  comparingOne(\"1\", 1)  null\n  */\nconst comparingOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "comparingOne", "gc": "<|endoftext|>/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  comparingOne(1, 2.5)  2.5\n  comparingOne(1, \"2,3\")  \"2,3\"\n  comparingOne(\"5,1\", \"6\")  \"6\"\n  comparingOne(\"1\", 1)  null\n  */\nconst comparingOne = (a, b) => {\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType!== bType) {\n    return null;\n  }\n  if (aType === \"number\" && bType === \"number\") {\n    return a > b? 1 : -1;\n  }\n  if (aType === \"string\" && bType === \"string\") {\n    return a > b? 1 : -1;\n  }\n  return null;\n};\n\n/**\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  comparingOne(1, 2.5)  2.5\n  comparingOne(1, \"2,3\")  \"2,3\"\n  comparingOne(\"5,1\", \"6\")  \"6\"\n  comparingOne(\"1\", 1)  null\n  */\nconst comparingOne = (a, b) => {\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType!== bType) {\n    return null;\n  }\n  if (aType === \"number\" && bType === \"number\") {\n    return a < b? 1 : -1;\n  }\n  if (aType === \"string\" && bType === \"string\") {\n    return a < b? 1 : -1;\n  }\n  return null;\n};\n\n/**\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger or smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  comparingOne(1, 2.5)  2.5\n  comparingOne(1, \"2,3\")  \"2,3\"\n  comparingOne(\"5,1\", \"6\")  \"6\"\n  comparingOne(\"1\", 1)  null\n  */\nconst comparing = (a, b) => {\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType!== bType) {\n    return null;\n  }\n  if (aType === \"number\" && bType === \"number\") {\n    return a > b? 1 : -1;\n  }\n  if (aType === \"string\" && bType === \"string\") {\n    return a > b? 1 : -1;\n  }\n  return null;\n};\n\n/**\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the smaller or larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  comparingOne(1, 2.5)  2.5\n  comparingOne(1, \"2,3\")  \"2,3\"\n  comparingOne(\"5,1\", \"6\")  \"6\"\n  comparingOne(\"1\", 1)  null\n  */\nconst comparing = (a, b) => {\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType!== bType) {\n    return null;\n  }\n  if (aType === \"number\" && bType === \"number\") {\n    return a < b? 1 : -1;\n  }\n  if (aType === \"string\" && bType === \"string\") {\n    return a < b? 1 : -1;\n  }\n  return null;\n};\n\n/**\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger or smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  comparingOne(1, 2.5)  2.5\n  comparingOne(1, \"2,3\")  \"2,3\"\n  comparingOne(\"5,1\", \"6\")  \"6\"\n  comparingOne(\"1\", 1)  null\n  */\nconst comparingOneOr = (a, b) => {\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType!== bType) {\n    return null;\n  }\n  if (aType === \"number\" && bType === \"number\") {\n    return a > b? 1 : -1;\n  }\n  if (aType === \"string\" && bType === \"string\") {\n    return a > b? 1 : -1;\n  }\n  return null;\n};\n\n/**\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger or smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  comparingOne(1, 2.5)  2.5\n  comparingOne(1, \"2,3\")  \"2,3\"\n  comparingOne(\"5,1\", \"6\")  \"6\"\n  comparingOne(\"1\", 1)  null\n  */\nconst comparingOneOr = (a, b) => {\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType!== bType) {\n    return null;\n  }\n  if (aType === \"number\" && bType === \"number\") {\n    return a < b? 1 : -1;\n  }\n  if (aType === \"string\" && bType === \"string\") {\n    return a < b? 1 : -1;\n  }\n  return null;\n};\n\n/**\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger or smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  comparingOne(1, 2.5)  2.5\n  comparingOne(1, \"2,3\")  \"2,3\"\n  comparingOne(\"5,1\", \"6\")  \"6\"\n  comparingOne(\"1\", 1)  null\n  */\nconst comparingOr = (a, b) => {\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType!== bType) {\n    return null;\n  }\n  if (aType === \"number\" && bType === \"number\") {\n    return a > b? 1 : -1;\n  }\n  if (aType === \"string\" && bType === \"string\") {\n    return a > b? 1 : -1;\n  }\n  return null;\n};\n\n/**\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger or smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  comparingOne(1, 2.5)  2.5\n  comparingOne(1, \"2,3\")  \"2,3\"\n  comparingOne(\"5,1\", \"6\")  \"6\"\n  comparingOne(\"1\", 1)  null\n  */\nconst comparingOr = (a, b) => {\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType!== bType) {\n    return null;\n  }\n  if (aType === \"number\" && bType === \"number\") {\n    return a < b? 1 : -1;\n  }\n  if (aType === \"string\" && bType === \"string\") {\n    return a < b? 1 : -1;\n  }\n  return null;\n};\n\n/**\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSummingEven(4) == false\n  isEqualToSummingEven(6) == false\n  isEqualToSummingEven(8) == true\n  */\nconst isEqualToSummingEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSummingEven", "gc": "<|endoftext|>/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSummingEven(4) == false\n  isEqualToSummingEven(6) == false\n  isEqualToSummingEven(8) == true\n  */\nconst isEqualToSummingEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*\n  Given a number n, return true if it is divisible by 3 or 5\n  Example\n  isDivisibleByThreeOrFive(5) == true\n  isDivisibleByThreeOrFive(7) == false\n  isDivisibleByThreeOrFive(11) == false\n  */\nconst isDivisibleByThreeOrFive = (n) => {\n  let divisor = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      divisor += i;\n    }\n  }\n  return divisor === 3 || divisor === 5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5\n  Example\n  isDivisibleByBothThreeAndFive(5) == true\n  isDivisibleByBothThreeAndFive(7) == true\n  isDivisibleByBothThreeAndFive(11) == false\n  */\nconst isDivisibleByBothThreeAndFive = (n) => {\n  let divisor = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      divisor += i;\n    }\n  }\n  return divisor === 3 && divisor === 5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5\n  Example\n  isDivisibleByBothThreeAndFive(5) == true\n  isDivisibleByBothThreeAndFive(7) == true\n  isDivisibleByBothThreeAndFive(11) == true\n  */\nconst isDivisibleByBothThreeAndFive = (n) => {\n  let divisor = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      divisor += i;\n    }\n  }\n  return divisor === 3 || divisor === 5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5\n  Example\n  isDivisibleByBothThreeAndFive(5) == true\n  isDivisibleByBothThreeAndFive(7) == true\n  isDivisibleByBothThreeAndFive(11) == true\n  */\nconst isDivisibleByBothThreeAndFive = (n) => {\n  let divisor = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      divisor += i;\n    }\n  }\n  return divisor === 3 || divisor === 5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5\n  Example\n  isDivisibleByBothThreeAndFive(5) == true\n  isDivisibleByBothThreeAndFive(7) == true\n  isDivisibleByBothThreeAndFive(11) == true\n  */\nconst isDivisibleByBothThreeAndFive = (n) => {\n  let divisor = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      divisor += i;\n    }\n  }\n  return divisor === 3 || divisor === 5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5\n  Example\n  isDivisibleByBothThreeAndFive(5) == true\n  isDivisibleByBothThreeAndFive(7) == true\n  isDivisibleByBothThreeAndFive(11) == true\n  */\nconst isDivisibleByBothThreeAndFive = (n) => {\n  let divisor = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      divisor += i;\n    }\n  }\n  return divisor === 3 || divisor === 5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5\n  Example\n  isDivisibleByBothThreeAndFive(5) == true\n  isDivisibleByBothThreeAndFive(7) == true\n  isDivisibleByBothThreeAndFive(11) == true\n  */\nconst isDivisibleByBothThreeAndFive = (n) => {\n  let divisor = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      divisor += i;\n    }\n  }\n  return divisor === 3 || divisor === 5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5\n  Example\n  isDivisibleByBothThreeAndFive(5) == true\n  isDivisibleByBothThreeAndFive(7) == true\n  isDivisibleByBothThreeAndFive(11) == true\n  */\nconst isDivisibleByBothThreeAndFive = (n) => {\n  let divisor = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      divisor += i;\n    }\n  }\n  return divisor === 3 || divisor === 5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5\n  Example\n  isDivisibleByBothThreeAndFive(5) == true\n  isDivisibleByBothThreeAndFive(7) == true\n  isDivisibleByBothThreeAndFive(11) == true\n  */\nconst isDivisibleByBothThreeAndFive = (n) => {\n  let divisor = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      divisor += i;\n    }\n  }\n  return divisor === 3 || divisor === 5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5\n  Example\n  isDivisibleByBothThreeAndFive(5) == true\n  isDivisibleByBothThreeAndFive(7) == true\n  isDivisibleByBothThreeAndFive(11) == true\n  */\nconst isDivisibleByBothThreeAndFive = (n) => {\n  let divisor = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      divisor += i;\n    }\n  }\n  return divisor === 3 || divisor === 5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5\n  Example\n  isDivisibleByBothThreeAndFive(5) == true\n  isDivisibleByBothThreeAndFive(7) == true\n  isDivisibleByBothThreeAndFive(11) == true\n  */\nconst isDivisibleByBothThreeAndFive = (n) => {\n  let divisor = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      divisor += i;\n    }\n  }\n  return divisor === 3 || divisor === 5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5\n  Example\n  isDivisibleByBothThreeAndFive(5) == true\n  isDivisibleByBothThreeAndFive(7) == true\n  isDivisibleByBothThreeAndFive(11) == true\n  */\nconst isDivisibleByBothThreeAndFive = (n) => {\n  let divisor = 0;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      divisor += i;\n    }\n  }\n  return divisor === 3 || divisor === 5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5\n  Example\n  isDi", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "gc": "<|endoftext|>/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of a number greater than or equal to n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorial = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "gc": "<|endoftext|>/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix);\n    currentPrefix = currentPrefix.substring(currentPrefix.length - 1);\n  }\n  return prefixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffixes('abc')\n  ['c', 'ba', 'abc']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix);\n    currentSuffix = currentSuffix.substring(0, currentSuffix.length - 1);\n  }\n  return suffixes;\n};\n\n/* Return list of all substrings from shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['abc', 'ab', 'ba', 'ca', 'cb', 'ca', 'bc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['abc', 'ab', 'ba', 'ca', 'cb', 'ca', 'bc']\n  */\nconst allSubstringsInOrder = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longest of the input string\n  >>> allSubstringsInOrder('abc')\n  ['abc', 'ab', 'ba', 'ca', 'cb', 'ca', 'bc']\n  */\nconst allSubstringsInOrderReverse = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longest of the input string\n  >>> allSubstringsInOrderReverse('abc')\n  ['bc', 'ca', 'cb', 'ca', 'bc', 'ab', 'ba', 'abc']\n  */\nconst allSubstringsInOrderReverseInOrder = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longest of the input string\n  >>> allSubstringsInOrderReverseInOrder('abc')\n  ['bc', 'ca', 'cb', 'ca', 'bc', 'ab', 'ba', 'abc']\n  */\nconst allSubstringsInOrderReverseInOrderReverse = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longest of the input string\n  >>> allSubstringsInOrderReverseInOrderReverse('abc')\n  ['bc', 'ca', 'cb', 'ca', 'bc', 'ab', 'ba', 'abc']\n  */\nconst allSubstringsInOrderReverseInOrderReverseInOrder = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longest of the input string\n  >>> allSubstringsInOrderReverseInOrderReverseInOrder('abc')\n  ['bc', 'ca', 'cb', 'ca', 'bc', 'ab', 'ba', 'abc']\n  */\nconst allSubstringsInOrderReverseInOrderReverseInOrderReverse = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longest of the input string\n  >>> allSubstringsInOrderReverseInOrderReverseInOrderReverse('abc')\n  ['bc', 'ca', 'cb', 'ca', 'bc', 'ab', 'ba', 'abc']\n  */\nconst allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrder = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longest of the input string\n  >>> allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrder('abc')\n  ['bc', 'ca', 'cb', 'ca', 'bc', 'ab', 'ba', 'abc']\n  */\nconst allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrderReverse = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longest of the input string\n  >>> allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrderReverse('abc')\n  ['bc', 'ca', 'cb', 'ca', 'bc', 'ab', 'ba', 'abc']\n  */\nconst allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrderReverseInOrder = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longest of the input string\n  >>> allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrderReverseInOrder('abc')\n  ['bc', 'ca', 'cb', 'ca', 'bc', 'ab', 'ba', 'abc']\n  */\nconst allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrderReverseInOrderReverseInOrder = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longest of the input string\n  >>> allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrderReverseInOrderReverse('abc')\n  ['bc', 'ca', 'cb', 'ca', 'bc', 'ab', 'ba', 'abc']\n  */\nconst allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrderReverseInOrderReverseInOrder = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = current", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixesSpace = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixesSpace", "gc": "<|endoftext|>/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixesSpace = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/  +/g, \" -\");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixesSpace = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/  +/g, \" -\");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixesSpace = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/  +/g, \" -\");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixesSpace = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/  +/g, \" -\");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixesSpace = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/  +/g, \" -\");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixesSpace = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/  +/g, \" -\");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixesSpace = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/  +/g, \" -\");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixesSpace = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/  +/g, \" -\");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixesSpace = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/  +/g, \" -\");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixesSpace = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/  +/g, \" -\");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixesSpace = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/  +/g, \" -\");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixesSpace = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/  +/g, \" -\");\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixesSpace = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/  +/g, \" -\");\n}\n\n/*", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filesNamesCheck(\"example.txt\") # => 'Yes'\n  filesNamesCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filesNamesCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "filesNamesCheck", "gc": "<|endoftext|>/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filesNamesCheck(\"example.txt\") # => 'Yes'\n  filesNamesCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filesNamesCheck = (file_name) => {\n  const file_name_without_extension = file_name.split(\".\")[0];\n  const file_name_without_extension_length = file_name_without_extension.length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_without_extension_length = file_name_without_extension_length < 3? 3 : file_name_without_extension_length;\n  const file_name_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumsSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumsSquares", "gc": "<|endoftext|>/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumsSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumsCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumsSquareCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumsSquareCubesNoChange = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumsSquareCubesNoChangeNoChange = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumsSquareCubesNoChangeNoChangeNoChangeNoChange = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumsSquareCubesNoChangeNoChangeNoChangeNoChangeNoChange = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumsSquareCubesNoChangeNoChangeNoChangeNoChangeNoChangeNoChange = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordInSentences = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordInSentences", "gc": "<|endoftext|>/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordInSentences = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  let wordsInSentence = [];\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length == 1) {\n      newSentence += word;\n    } else {\n      if (wordsInSentence.indexOf(word) == -1) {\n        newSentence += word;\n        wordsInSentence.push(word);\n      }\n    }\n  }\n  return newSentence;\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentences = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  let wordsInSentence = [];\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length == 1) {\n      newSentence += word;\n    } else {\n      if (wordsInSentence.indexOf(word) == -1) {\n        newSentence += word;\n        wordsInSentence.push(word);\n      }\n    }\n  }\n  return newSentence;\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentences = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  let wordsInSentence = [];\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length == 1) {\n      newSentence += word;\n    } else {\n      if (wordsInSentence.indexOf(word) == -1) {\n        newSentence += word;\n        wordsInSentence.push(word);\n      }\n    }\n  }\n  return newSentence;\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentences = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  let wordsInSentence = [];\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length == 1) {\n      newSentence += word;\n    } else {\n      if (wordsInSentence.indexOf(word) == -1) {\n        newSentence += word;\n        wordsInSentence.push(word);\n      }\n    }\n  }\n  return newSentence;\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentences = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  let wordsInSentence = [];\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length == 1) {\n      newSentence += word;\n    } else {\n      if (wordsInSentence.indexOf(word) == -1) {\n        newSentence += word;\n        wordsInSentence.push(word);\n      }\n    }\n  }\n  return newSentence;\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentences = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  let wordsInSentence = [];\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length == 1) {\n      newSentence += word;\n    } else {\n      if (wordsInSentence.indexOf(word) == -1) {\n        newSentence += word;\n        wordsInSentence.push(word);\n      }\n    }\n  }\n  return newSentence;\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentences = (sentence) => {\n  const words = sentence.split(\" \");\n  let newSentence = \"\";\n  let wordsInSentence = [];\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length == 1) {\n      newSentence += word;\n    } else {\n      if (wordsInSentence.indexOf(word) == -1) {\n        newSentence += word;\n        wordsInSentence.push(word);\n      }\n    }\n  }\n  return newSentence;\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "gc": "<|endoftext|>/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  if (isNaN(x) || isNaN(n)) {\n    return false;\n  }\n  if (x === 0 || n === 0) {\n    return true;\n  }\n  if (x === n) {\n    return false;\n  }\n  if (x.indexOf(\"/\")!== -1) {\n    const [numerator, denominator] = x.split(\"/\");\n    if (denominator === 0) {\n      return false;\n    }\n    return simplify(numerator, denominator);\n  }\n  if (n.indexOf(\"/\")!== -1) {\n    const [numerator, denominator] = n.split(\"/\");\n    if (denominator === 0) {\n      return false;\n    }\n    return simplify(numerator, denominator);\n  }\n  if (x.indexOf(\".\")!== -1) {\n    const [numerator, denominator] = x.split(\".\");\n    if (denominator === 0) {\n      return false;\n    }\n    return simplify(numerator, denominator);\n  }\n  if (n.indexOf(\".\")!== -1) {\n    const [numerator, denominator] = n.split(\".\");\n    if (denominator === 0) {\n      return false;\n    }\n    return simplify(numerator, denominator);\n  }\n  return true;\n};\n\nconst getFraction = (num, denom) => {\n  const [numerator, denominator] = num.split(\"/\");\n  const [numerator2, denominator2] = denom.split(\"/\");\n  const [numerator3, denominator3] = numerator2.split(\"/\");\n  const [numerator4, denominator4] = denominator2.split(\"/\");\n  const [numerator5, denominator5] = denominator3.split(\"/\");\n  const [numerator6, denominator6] = denominator4.split(\"/\");\n  const [numerator7, denominator7] = denominator5.split(\"/\");\n  const [numerator8, denominator8] = denominator6.split(\"/\");\n  const [numerator9, denominator9] = denominator7.split(\"/\");\n  const [numerator10, denominator10] = denominator8.split(\"/\");\n  const [numerator11, denominator11] = denominator9.split(\"/\");\n  const [numerator12, denominator12] = denominator10.split(\"/\");\n  const [numerator13, denominator13] = denominator11.split(\"/\");\n  const [numerator14, denominator14] = denominator12.split(\"/\");\n  const [numerator15, denominator15] = denominator13.split(\"/\");\n  const [numerator16, denominator16] = denominator14.split(\"/\");\n  const [numerator17, denominator17] = denominator15.split(\"/\");\n  const [numerator18, denominator18] = denominator16.split(\"/\");\n  const [numerator19, denominator19] = denominator17.split(\"/\");\n  const [numerator20, denominator20] = denominator18.split(\"/\");\n  const [numerator21, denominator21] = denominator19.split(\"/\");\n  const [numerator22, denominator22] = denominator20.split(\"/\");\n  const [numerator23, denominator23] = denominator21.split(\"/\");\n  const [numerator24, denominator24] = denominator22.split(\"/\");\n  const [numerator25, denominator25] = denominator23.split(\"/\");\n  const [numerator26, denominator26] = denominator24.split(\"/\");\n  const [numerator27, denominator27] = denominator25.split(\"/\");\n  const [numerator28, denominator28] = denominator26.split(\"/\");\n  const [numerator29, denominator29] = denominator27.split(\"/\");\n  const [numerator30, denominator30] = denominator28.split(\"/\");\n  const [numerator31, denominator31] = denominator29.split(\"/\");\n  const [numerator32, denominator32] = denominator30.split(\"/\");\n  const [numerator33, denominator33] = denominator31.split(\"/\");\n  const [numerator34, denominator34] = denominator32.split(\"/\");\n  const [numerator35, denominator35] = denominator33.split(\"/\");\n  const [numerator36, denominator36] = denominator34.split(\"/\");\n  const [numerator37, denominator37] = denominator35.split(\"/\");\n  const [numerator38, denominator38] = denominator36.split(\"/\");\n  const [numerator39, denominator39] = denominator37.split(\"/\");\n  const [numerator40, denominator40] = denominator38.split(\"/\");\n  const [numerator41, denominator41] = denominator39.split(\"/\");\n  const [numerator42, denominator42] = denominator40.split(\"/\");\n  const [numerator43, denominator43] = denominator41.split(\"/\");\n  const [numerator44, denominator44] = denominator42.split(\"/\");\n  const [numerator45, denominator45] = denominator43.split(\"/\");\n  const [numerator46, denominator46] = denominator44.split(\"/\");\n  const [numerator47, denominator47] = denominator45.split(\"/\");\n  const [numerator48, denominator48] = denominator46.split(\"/\");\n  const [numerator49, denominator49] = denominator47.split(\"/\");\n  const [numerator50, denominator50] = denominator48.split(\"/\");\n  const [numerator51, denominator51] = denominator49.split(\"/\");\n  const [numerator52, denominator52] = denominator50.split(\"/\");\n  const [numerator53, denominator53] = denominator51.split(\"/\");\n  const [numerator54, denominator54] = denominator52.split(\"/\");\n  const [numerator55, denominator55] = denominator53.split(\"/\");\n  const [numerator56, denominator56] = denominator54.split(\"/\");\n  const [numerator57, denominator57] = denominator55.split(\"/\");\n  const [numerator58, denominator58] = denominator56.split(\"/\");\n  const [numerator59, denominator59] = denominator57.split(\"/\");\n  const [numerator60, denominator60] = denominator58.split(\"/\");\n  const [numerator61, denominator61] = denominator59.split(\"/\");\n  const [numerator62, denominator62] = denominator60.split(\"/\");\n  const [numerator63, denominator63] = denominator61.split(\"/\");\n  const [numerator64, denominator64] = denominator62.split(\"/\");\n  const [numerator65, denominator65] = denominator63.split(\"/\");\n  const [numerator66, denominator66] = denominator64.split(\"/\");\n  const [numerator67, denominator67] = denominator65.split(\"/\");\n  const [numerator68, denominator68] = denominator66.split(\"/\");\n  const [numerator69, denominator69] = denominator67.split(\"/\");\n  const [numerator70, denominator70] = denominator68.split(\"/\");\n  const [numerator71, denominator71] = denominator69.split(\"/\");\n  const [numerator72, denominator72] = denominator70.split(\"/\");\n  const [numerator73, denominator73] = denominator71.split(\"/\");\n  const [numerator74, denominator74] = denominator72.split(\"/\");\n  const [numerator75, denominator75] = denominator73.split(\"/\");\n  const [numerator76, denominator76] = denominator74.split(\"/\");\n  const [numerator77, denominator77] = denominator75.split(\"/\");\n  const [numerator78, denominator78] = denominator76.split(\"/\");\n  const [numerator79, denominator79] = denominator77.split(\"/\");\n  const [numerator80, denominator80] = denominator78.split(\"/\");\n  const [numerator81, denominator81] = denominator79.split(\"/\");\n  const [numerator82, denominator82] = denominator80.split(\"/\");\n  const [numerator83, denominator83] = denominator81.split(\"/\");\n  const [numerator84, denominator84] = denominator", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoint([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoint([]) == []\n  */\nconst orderByPoint = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoint", "gc": "<|endoftext|>/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoint([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoint([]) == []\n  */\nconst orderByPoint = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sums = sortedNums.map(n => n * 10);\n  const sortedSums = sums.sort((a, b) => a - b);\n  return sortedSums.map(n => n - sums[0]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoint([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoint([]) == []\n  */\nconst orderByPointDesc = (nums) => {\n  const sortedNums = nums.sort((a, b) => b - a);\n  const sums = sortedNums.map(n => n * 10);\n  const sortedSums = sums.sort((a, b) => b - a);\n  return sortedSums.map(n => n - sums[0]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPointDesc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPointDesc([]) == []\n  */\nconst orderByPointAsc = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sums = sortedNums.map(n => n * 10);\n  const sortedSums = sums.sort((a, b) => a - b);\n  return sortedSums.map(n => n - sums[0]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPointAsc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPointAsc([]) == []\n  */\nconst orderByPointDescAsc = (nums) => {\n  const sortedNums = nums.sort((a, b) => b - a);\n  const sums = sortedNums.map(n => n * 10);\n  const sortedSums = sums.sort((a, b) => b - a);\n  return sortedSums.map(n => n - sums[0]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPointDescAsc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPointDescAsc([]) == []\n  */\nconst orderByPointAscDesc = (nums) => {\n  const sortedNums = nums.sort((a, b) => b - a);\n  const sums = sortedNums.map(n => n * 10);\n  const sortedSums = sums.sort((a, b) => b - a);\n  return sortedSums.map(n => n - sums[0]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPointAscDesc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPointAscDesc([]) == []\n  */\nconst orderByPointDescDesc = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sums = sortedNums.map(n => n * 10);\n  const sortedSums = sums.sort((a, b) => a - b);\n  return sortedSums.map(n => n - sums[0]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPointDescDesc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPointDescDesc([]) == []\n  */\nconst orderByPointDescAscAsc = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sums = sortedNums.map(n => n * 10);\n  const sortedSums = sums.sort((a, b) => a - b);\n  return sortedSums.map(n => n - sums[0]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPointDescDescAsc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPointDescDescAsc([]) == []\n  */\nconst orderByPointDescDescAsc = (nums) => {\n  const sortedNums = nums.sort((a, b) => b - a);\n  const sums = sortedNums.map(n => n * 10);\n  const sortedSums = sums.sort((a, b) => b - a);\n  return sortedSums.map(n => n - sums[0]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPointDescDescAsc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPointDescDescAsc([]) == []\n  */\nconst orderByPointDescDescDesc = (nums) => {\n  const sortedNums = nums.sort((a, b) => b - a);\n  const sums = sortedNums.map(n => n * 10);\n  const sortedSums = sums.sort((a, b) => b - a);\n  return sortedSums.map(n => n - sums[0]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPointDescDescDesc([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPointDescDescDesc([]) == []\n  */\nconst orderByPointDescDescDescAsc = (nums) => {\n  const sortedNums = nums.sort((a, b) => b - a);\n  const sums = sortedNums.map(n => n * 10);\n  const sortedSums = sums.sort((a, b) => b - a);\n  return sortedSums.map(n => n - sums[0]);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "gc": "<|endoftext|>/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 1 && nums[i].toString().charAt(0) > '1') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst gottenMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "gottenMaxTriples", "gc": "<|endoftext|>/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst gottenMaxTriples = (n) => {\n  let a = [...Array(Math.pow(3, n))].map((_, i) => i);\n  let count = 0;\n  for (let i = 0; i < a.length; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      for (let k = j + 1; k < a.length; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 3) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst gottenMaxTriples2 = (n) => {\n  let a = [...Array(Math.pow(3, n))].map((_, i) => i);\n  let count = 0;\n  for (let i = 0; i < a.length; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      for (let k = j + 1; k < a.length; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 3) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst gottenMaxTriples3 = (n) => {\n  let a = [...Array(Math.pow(3, n))].map((_, i) => i);\n  let count = 0;\n  for (let i = 0; i < a.length; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      for (let k = j + 1; k < a.length; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 3) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst gottenMaxTriples4 = (n) => {\n  let a = [...Array(Math.pow(3, n))].map((_, i) => i);\n  let count = 0;\n  for (let i = 0; i < a.length; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      for (let k = j + 1; k < a.length; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 3) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst gottenMaxTriples5 = (n) => {\n  let a = [...Array(Math.pow(3, n))].map((_, i) => i);\n  let count = 0;\n  for (let i = 0; i < a.length; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      for (let k = j + 1; k < a.length; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 3) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst gottenMaxTriples6 = (n) => {\n  let a = [...Array(Math.pow(3, n))].map((_, i) => i);\n  let count = 0;\n  for (let i = 0; i < a.length; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      for (let k = j + 1; k < a.length; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 3) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst gottenMaxTriples7 = (n) => {\n  let a = [...Array(Math.pow(3, n))].map((_, i) => i);\n  let count = 0;\n  for (let i = 0; i < a.length; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      for (let k = j + 1; k < a.length; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 3) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "gc": "<|endoftext|>/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1Orbit = orbit(planet1);\n  const planet2Orbit = orbit(planet2);\n  const planet1Orbits = planet1Orbit.orbits;\n  const planet2Orbits = planet2Orbit.orbits;\n  const planet1Orbits2 = planet1Orbits.concat(planet2Orbits);\n  const planet2Orbits2 = planet2Orbits.concat(planet1Orbits);\n  const planet1Orbits2 = planet1Orbits2.sort((a, b) => b.distance - a.distance);\n  const planet2Orbits2 = planet2Orbits2.sort((a, b) => b.distance - a.distance);\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet1Orbits.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet2Orbits.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Orbits2.includes(orbit)\n  );\n  const planet2Orbits2 = planet2Orbits2.filter(\n    orbit => planet1Orbits2.includes(orbit)\n  );\n  const planet1Orbits2 = planet1Orbits2.filter(\n    orbit => planet2Or", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortListsSums = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortListsSums", "gc": "<|endoftext|>/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortListsSums = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i].length;\n  }\n  return lst.sort((a, b) => a - b).filter(item => item % 2 === 1);\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns a string that is the concatenation of all words in the string.\n  You may assume that the string contains only lowercase letters.\n  For example:\n  assert concat(\"ab\", \"cd\", \"ef\", \"gh\") => \"abcdefgh\"\n  assert concat(\"ab\", \"cd\", \"ef\", \"gh\", \"ij\") => \"abcdefghij\"\n  assert concat(\"ab\", \"cd\", \"ef\", \"gh\", \"ij\", \"kl\") => \"abcdefghijkl\"\n  */\nconst concat = (str) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    let char = str[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  return result.join('');\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns a string that is the concatenation of all words in the string.\n  You may assume that the string contains only lowercase letters.\n  For example:\n  assert concat2(\"ab\", \"cd\", \"ef\", \"gh\") => \"abcdefgh\"\n  assert concat2(\"ab\", \"cd\", \"ef\", \"gh\", \"ij\") => \"abcdefghij\"\n  assert concat2(\"ab\", \"cd\", \"ef\", \"gh\", \"ij\", \"kl\") => \"abcdefghijkl\"\n  */\nconst concat2 = (str, str2) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    let char = str[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  for (let i = 0; i < str2.length; i++) {\n    let char = str2[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  return result.join('');\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns a string that is the concatenation of all words in the string.\n  You may assume that the string contains only lowercase letters.\n  For example:\n  assert concat3(\"ab\", \"cd\", \"ef\", \"gh\") => \"abcdefgh\"\n  assert concat3(\"ab\", \"cd\", \"ef\", \"gh\", \"ij\") => \"abcdefghij\"\n  assert concat3(\"ab\", \"cd\", \"ef\", \"gh\", \"ij\", \"kl\") => \"abcdefghijkl\"\n  */\nconst concat3 = (str, str2, str3) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    let char = str[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  for (let i = 0; i < str2.length; i++) {\n    let char = str2[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  for (let i = 0; i < str3.length; i++) {\n    let char = str3[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  return result.join('');\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns a string that is the concatenation of all words in the string.\n  You may assume that the string contains only lowercase letters.\n  For example:\n  assert concat4(\"ab\", \"cd\", \"ef\", \"gh\") => \"abcdefgh\"\n  assert concat4(\"ab\", \"cd\", \"ef\", \"gh\", \"ij\") => \"abcdefghij\"\n  assert concat4(\"ab\", \"cd\", \"ef\", \"gh\", \"ij\", \"kl\") => \"abcdefghijkl\"\n  */\nconst concat4 = (str, str2, str3, str4) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    let char = str[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  for (let i = 0; i < str2.length; i++) {\n    let char = str2[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  for (let i = 0; i < str3.length; i++) {\n    let char = str3[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  for (let i = 0; i < str4.length; i++) {\n    let char = str4[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  return result.join('');\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns a string that is the concatenation of all words in the string.\n  You may assume that the string contains only lowercase letters.\n  For example:\n  assert concat5(\"ab\", \"cd\", \"ef\", \"gh\") => \"abcdefgh\"\n  assert concat5(\"ab\", \"cd\", \"ef\", \"gh\", \"ij\") => \"abcdefghij\"\n  assert concat5(\"ab\", \"cd\", \"ef\", \"gh\", \"ij\", \"kl\") => \"abcdefghijkl\"\n  */\nconst concat5 = (str, str2, str3, str4, str5) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    let char = str[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  for (let i = 0; i < str2.length; i++) {\n    let char = str2[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  for (let i = 0; i < str3.length; i++) {\n    let char = str3[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  for (let i = 0; i < str4.length; i++) {\n    let char = str4[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  for (let i = 0; i < str5.length; i++) {\n    let char = str5[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  return result.join('');\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns a string that is the concatenation of all words in the string.\n  You may assume that the string contains only lowercase letters.\n  For example:\n  assert concat6(\"ab\", \"cd\", \"ef\", \"gh\") => \"abcdefgh\"\n  assert concat6(\"ab\", \"cd\", \"ef\", \"gh\", \"ij\") => \"abcdefghij\"\n  assert concat6(\"ab\", \"cd\", \"ef\", \"gh\", \"ij\", \"kl\") => \"abcdefghijkl\"\n  */\nconst concat6 = (str, str2, str3, str4, str5, str6) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    let char = str[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  for (let i = 0; i < str2.length; i++) {\n    let char = str2[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  for (let i = 0; i < str3.length; i++) {\n    let char = str3[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  for (let i = 0; i < str4.length; i++) {\n    let char = str4[i];\n    if (char.match(/[a-z]/)) {\n      result.push(char);\n    }\n  }\n  for (let i = 0; i < str5.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequences(0)\n  '0'\n  >>> stringSequences(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequences = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequences", "gc": "<|endoftext|>/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequences(0)\n  '0'\n  >>> stringSequences(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequences = (n) => {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(i));\n  }\n  return result.join(' ');\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst stringSequence = (n, defaultValue) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return defaultValue;\n  }\n  return stringSequences(n).slice(0, n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst stringSequences = (n, defaultValue) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return defaultValue;\n  }\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(i));\n  }\n  return result.join(' ');\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst stringSequence = (n, defaultValue) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return defaultValue;\n  }\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(i));\n  }\n  return result.join(' ');\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst stringSequences = (n, defaultValue) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return defaultValue;\n  }\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(i));\n  }\n  return result.join(' ');\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst stringSequence = (n, defaultValue) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return defaultValue;\n  }\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(i));\n  }\n  return result.join(' ');\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst stringSequences = (n, defaultValue) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return defaultValue;\n  }\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(i));\n  }\n  return result.join(' ');\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst stringSequence = (n, defaultValue) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return defaultValue;\n  }\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(i));\n  }\n  return result.join(' ');\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst stringSequences = (n, defaultValue) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return defaultValue;\n  }\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(i));\n  }\n  return result.join(' ');\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst stringSequence = (n, defaultValue) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return defaultValue;\n  }\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(i));\n  }\n  return result.join(' ');\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst stringSequences = (n, defaultValue) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return defaultValue;\n  }\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(i));\n  }\n  return result.join(' ');\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst stringSequence = (n, defaultValue) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return defaultValue;\n  }\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(i));\n  }\n  return result.join(' ');\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst stringSequences = (n, defaultValue) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return defaultValue;\n  }\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(i));\n  }\n  return result.join(' ');\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst stringSequence = (n, defaultValue) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return defaultValue;\n  }\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(i));\n  }\n  return result.join(' ');\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst stringSequences = (n, defaultValue) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return defaultValue;\n  }\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(i));\n  }\n  return result.join(' ');\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst stringSequence = (n, defaultValue) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return defaultValue;\n  }\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(i));\n  }\n  return result.join(' ');\n};\n\n/**\n * Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n */\nconst stringSequences = (n, defaultValue", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "gc": "<|endoftext|>/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "gc": "<|endoftext|>/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 1\n  doubleTheDifference([-1, -2, 0]) == -1\n  doubleTheDifference([9, -2]) == 9\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 1\n  doubleTheDifference([-1, -2, 0]) == -1\n  doubleTheDifference([9, -2]) == 9\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 5. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 5 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 7. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 7 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 9. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 9 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 11. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 11 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 13. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 13 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 15. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 15 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 17. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 17 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 19. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 19 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 21. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 21 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 23. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 23 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 25. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 25 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 27. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 27 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 29. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 29 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 31. If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (!lst) {\n    return 0;\n  }\n  const len = lst.length;\n  let sum = 0;\n  for (let ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "gc": "<|endoftext|>/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const scoreDifferences = scores.length - guesses.length;\n  const guessesDifferences = guesses.length - scores.length;\n  const scoreDifference = scoreDifferences.reduce((acc, cur) => acc + Math.abs(cur - scores[cur]), 0);\n  const guessesDifference = guessesDifferences.reduce((acc, cur) => acc + Math.abs(cur - guesses[cur]), 0);\n  return [scoreDifference, guessesDifference];\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being the difference between its two elements.\n  \n  \n  example:\n\n  difference([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  difference([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst difference = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const scoreDifferences = scores.length - guesses.length;\n  const guessesDifferences = guesses.length - scores.length;\n  const scoreDifference = scoreDifferences.reduce((acc, cur) => acc + Math.abs(cur - scores[cur]), 0);\n  const guessesDifference = guessesDifferences.reduce((acc, cur) => acc + Math.abs(cur - guesses[cur]), 0);\n  return [scoreDifference, guessesDifference];\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being the sum of its two elements.\n  \n  \n  example:\n\n  sum([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  sum([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst sum = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const scoreDifferences = scores.length - guesses.length;\n  const guessesDifferences = guesses.length - scores.length;\n  const scoreDifference = scoreDifferences.reduce((acc, cur) => acc + cur, 0);\n  const guessesDifference = guessesDifferences.reduce((acc, cur) => acc + cur, 0);\n  return [scoreDifference, guessesDifference];\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being the difference between its two elements.\n  \n  \n  example:\n\n  difference([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  difference([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst difference = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const scoreDifferences = scores.length - guesses.length;\n  const guessesDifferences = guesses.length - scores.length;\n  const scoreDifference = scoreDifferences.reduce((acc, cur) => acc + cur, 0);\n  const guessesDifference = guessesDifferences.reduce((acc, cur) => acc + cur, 0);\n  return [scoreDifference, guessesDifference];\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being the sum of its two elements.\n  \n  \n  example:\n\n  sum([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  sum([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst sum = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const scoreDifferences = scores.length - guesses.length;\n  const guessesDifferences = guesses.length - scores.length;\n  const scoreDifference = scoreDifferences.reduce((acc, cur) => acc + cur, 0);\n  const guessesDifference = guessesDifferences.reduce((acc, cur) => acc + cur, 0);\n  return [scoreDifference, guessesDifference];\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being the difference between its two elements.\n  \n  \n  example:\n\n  difference([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  difference([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst difference = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const scoreDifferences = scores.length - guesses.length;\n  const guessesDifferences = guesses.length - scores.length;\n  const scoreDifference = scoreDifferences.reduce((acc, cur) => acc + cur, 0);\n  const guessesDifference = guessesDifferences.reduce((acc, cur) => acc + cur, 0);\n  return [scoreDifference, guessesDifference];\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being the sum of its two elements.\n  \n  \n  example:\n\n  sum([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  sum([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst sum = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const scoreDifferences = scores.length - guesses.length;\n  const guessesDifferences = guesses.length - scores.length;\n  const scoreDifference = scoreDifferences.reduce((acc, cur) => acc + cur, 0);\n  const guessesDifference = guessesDifferences.reduce((acc, cur) => acc + cur, 0);\n  return [scoreDifference, guessesDifference];\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being the difference between its two elements.\n  \n  \n  example:\n\n  difference([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  difference([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst difference = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const scoreDifferences = scores.length - guesses.length;\n  const guessesDifferences = guesses.length - scores.length;\n  const scoreDifference = scoreDifferences.reduce((acc, cur) => acc + cur, 0);\n  const guessesDifference = guessesDifferences.reduce((acc, cur) => acc + cur, 0);\n  return [scoreDifference, guessesDifference];\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being the difference between its two elements.\n  \n  \n  example:\n\n  sum([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  sum([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst sum = (game, guess) => {\n  const scores = [...game];\n  const guesse", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "gc": "<|endoftext|>/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let strongest_extension = '';\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_length = extension.length;\n    const extension_upper = extension.toUpperCase();\n    const extension_lower = extension.toLowerCase();\n    const extension_length = extension_upper.length - extension_lower.length;\n    if (extension_length === 0) {\n      continue;\n    }\n    const extension_strength_upper = extension_upper.charCodeAt(0);\n    const extension_strength_lower = extension_lower.charCodeAt(0);\n    const extension_strength_upper = extension_strength_upper + extension_length;\n    const extension_strength_lower = extension_strength_lower + extension_length;\n    if (extension_strength_upper > extension_strength_lower) {\n      extension_strength = extension_strength_upper;\n      strongest_extension = extension;\n    }\n  }\n  return strongest_extension;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with\n  the strongest extension.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  return strongestExtension(class_name, extensions).substr(0, class_name.lastIndexOf('.'));\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with\n  the strongest extension.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  return strongestExtension(class_name, extensions).substr(class_name.lastIndexOf('.'));\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with\n  the strongest extension.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  return strongestExtension(class_name, extensions).substr(class_name.lastIndexOf('.'));\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with\n  the strongest extension.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  return strongestExtension(class_name, extensions).substr(class_name.lastIndexOf('.'));\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with\n  the strongest extension.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  return strongestExtension(class_name, extensions).substr(class_name.lastIndexOf('.'));\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with\n  the strongest extension.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  return strongestExtension(class_name, extensions).substr(class_name.lastIndexOf('.'));\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with\n  the strongest extension.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  return strongestExtension(class_name, extensions).substr(class_name.lastIndexOf('.'));\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with\n  the strongest extension.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  return strongestExtension(class_name, extensions).substr(class_name.lastIndexOf('.'));\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with\n  the strongest extension.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  return strongestExtension(class_name, extensions).substr(class_name.lastIndexOf('.'));\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with\n  the strongest extension.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  return strongestExtension(class_name, extensions).substr(class_name.lastIndexOf('.'));\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with\n  the strongest extension.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  return strongestExtension(class_name, extensions).substr(class_name.lastIndexOf('.'));\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with\n  the strongest extension.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  return strongestExtension(class_name, extensions).substr(class_name.lastIndexOf('.'));\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with\n  the strongest extension.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtension_ = (class_name, extensions) => {\n  return strongestExtension(class_name, extensions).substr(class_name.lastIndexOf('.'));\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with\n  the strongest extension.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "gc": "<|endoftext|>/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let check = false;\n  let check2 = false;\n  let check3 = false;\n  let check4 = false;\n  let check5 = false;\n  let check6 = false;\n  let check7 = false;\n  let check8 = false;\n  let check9 = false;\n  let check10 = false;\n  let check11 = false;\n  let check12 = false;\n  let check13 = false;\n  let check14 = false;\n  let check15 = false;\n  let check16 = false;\n  let check17 = false;\n  let check18 = false;\n  let check19 = false;\n  let check20 = false;\n  let check21 = false;\n  let check22 = false;\n  let check23 = false;\n  let check24 = false;\n  let check25 = false;\n  let check26 = false;\n  let check27 = false;\n  let check28 = false;\n  let check29 = false;\n  let check30 = false;\n  let check31 = false;\n  let check32 = false;\n  let check33 = false;\n  let check34 = false;\n  let check35 = false;\n  let check36 = false;\n  let check37 = false;\n  let check38 = false;\n  let check39 = false;\n  let check40 = false;\n  let check41 = false;\n  let check42 = false;\n  let check43 = false;\n  let check44 = false;\n  let check45 = false;\n  let check46 = false;\n  let check47 = false;\n  let check48 = false;\n  let check49 = false;\n  let check50 = false;\n  let check51 = false;\n  let check52 = false;\n  let check53 = false;\n  let check54 = false;\n  let check55 = false;\n  let check56 = false;\n  let check57 = false;\n  let check58 = false;\n  let check59 = false;\n  let check60 = false;\n  let check61 = false;\n  let check62 = false;\n  let check63 = false;\n  let check64 = false;\n  let check65 = false;\n  let check66 = false;\n  let check67 = false;\n  let check68 = false;\n  let check69 = false;\n  let check70 = false;\n  let check71 = false;\n  let check72 = false;\n  let check73 = false;\n  let check74 = false;\n  let check75 = false;\n  let check76 = false;\n  let check77 = false;\n  let check78 = false;\n  let check79 = false;\n  let check80 = false;\n  let check81 = false;\n  let check82 = false;\n  let check83 = false;\n  let check84 = false;\n  let check85 = false;\n  let check86 = false;\n  let check87 = false;\n  let check88 = false;\n  let check89 = false;\n  let check90 = false;\n  let check91 = false;\n  let check92 = false;\n  let check93 = false;\n  let check94 = false;\n  let check95 = false;\n  let check96 = false;\n  let check97 = false;\n  let check98 = false;\n  let check99 = false;\n  let check100 = false;\n  let check101 = false;\n  let check102 = false;\n  let check103 = false;\n  let check104 = false;\n  let check105 = false;\n  let check106 = false;\n  let check107 = false;\n  let check108 = false;\n  let check109 = false;\n  let check110 = false;\n  let check111 = false;\n  let check112 = false;\n  let check113 = false;\n  let check114 = false;\n  let check115 = false;\n  let check116 = false;\n  let check117 = false;\n  let check118 = false;\n  let check119 = false;\n  let check120 = false;\n  let check121 = false;\n  let check122 = false;\n  let check123 = false;\n  let check124 = false;\n  let check125 = false;\n  let check126 = false;\n  let check127 = false;\n  let check128 = false;\n  let check129 = false;\n  let check130 = false;\n  let check131 = false;\n  let check132 = false;\n  let check133 = false;\n  let check134 = false;\n  let check135 = false;\n  let check136 = false;\n  let check137 = false;\n  let check138 = false;\n  let check139 = false;\n  let check140 = false;\n  let check141 = false;\n  let check142 = false;\n  let check143 = false;\n  let check144 = false;\n  let check145 = false;\n  let check146 = false;\n  let check147 = false;\n  let check148 = false;\n  let check149 = false;\n  let check150 = false;\n  let check151 = false;\n  let check152 = false;\n  let check153 = false;\n  let check154 = false;\n  let check155 = false;\n  let check156 = false;\n  let check157 = false;\n  let check158 = false;\n  let check159 = false;\n  let check160 = false;\n  let check161 = false;\n  let check162 = false;\n  let check163 = false;\n  let check164 = false;\n  let check165 = false;\n  let check166 = false;\n  let check167 = false;\n  let check168 = false;\n  let check169 = false;\n  let check170 = false;\n  let check171 = false;\n  let check172 = false;\n  let check173 = false;\n  let check174 = false;\n  let check175 = false;\n  let check176 = false;\n  let check177 = false;\n  let check178 = false;\n  let check179 = false;\n  let check180 = false;\n  let check181 = false;\n  let check182 = false;\n  let check183 = false;\n  let check184 = false;\n  let check185 = false;\n  let check186 = false;\n  let check187 = false;\n  let check188 = false;\n  let check189 = false;\n  let check190 = false;\n  let check191 = false;\n  let check192 = false;\n  let check193 = false;\n  let check194 = false;\n  let check195 = false;\n  let check196 = false;\n  let check197 = false;\n  let check198 = false;\n  let check199 = false;\n  let check200 = false;\n  let check201 = false;\n  let check202 = false;\n  let check203 = false;\n  let check204 = false;\n  let check205 = false;\n  let check206 = false;\n  let check207 = false;\n  let check208 = false;\n  let check209 = false;\n  let check210 = false;\n  let check211 = false;\n  let check212 = false;\n  let check213 = false;\n  let check214 = false;\n  let check215 = false;\n  let check216 = false;\n  let check217 = false;\n  let check218 = false;\n  let check219 = false;\n  let check220 = false;\n  let check221 = false;\n  let check222 = false;\n  let check223 = false;\n  let check224 = false;\n  let check225 = false;\n  let check226 = false;\n  let check227 = false;\n  let check228 = false;\n  let check229 = false;\n  let check230 = false;\n  let check231 = false;\n  let check232 = false;\n  let check233 = false;\n  let check234 = false;\n  let check235 = false;\n  let check236 = false;\n  let check237 = false;\n  let check238 = false;\n  let check239 = false;\n  let check240 = false;\n  let check241 = false;\n  let check242 = false;\n  let check243 = false;\n  let check244 = false;\n  let check245 = false;\n  let check246 = false;\n  let check247 = false;\n  let check248 = false;\n  let check249 = false;\n  let check250 = false;\n  let check251 = false;\n  let check252 = false;\n  let check253 = false;\n  let check254 = false;\n  let check255 = false;\n  let check256 = false;\n  let check257 = false;\n  let check258 = false;\n  let check259 = false;\n  let check260 = false;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOdderCount(-12) ==> (1, 1)\n      evenOdderCount(123) ==> (1, 2)\n  */\nconst evenOdderCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOdderCount", "gc": "<|endoftext|>/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOdderCount(-12) ==> (1, 1)\n      evenOdderCount(123) ==> (1, 2)\n  */\nconst evenOdderCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let digitCount = 0;\n  let numString = num.toString();\n  for (let i = 0; i < numString.length; i++) {\n    if (numString.charAt(i) % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  digitCount = evenCount * 2 + oddCount;\n  return [evenCount, oddCount, digitCount];\n};\n\n/*Given a string, return an array that has all the characters in the string in sorted order.\n\n   Example:\n      sortedString('abc') ==> ['b', 'a', 'c', '']\n      sortedString('ab') ==> ['b', 'a', '']\n      sortedString('') ==> []\n  */\nconst sortedString = (str) => {\n  let sortedString = [];\n  let charArray = str.toString();\n  for (let i = 0; i < charArray.length; i++) {\n    sortedString.push(charArray.charAt(i));\n  }\n  return sortedString;\n};\n\n/*Given a string, return an array that has all the characters in the string in reverse sorted order.\n\n   Example:\n      reversedString('abc') ==> ['c', 'b', 'a', '']\n      reversedString('ab') ==> ['c', 'b', '']\n      reversedString('') ==> []\n  */\nconst reversedString = (str) => {\n  let reversedString = [];\n  let charArray = str.toString();\n  for (let i = charArray.length - 1; i >= 0; i--) {\n    reversedString.push(charArray.charAt(i));\n  }\n  return reversedString;\n};\n\n/*Given a string, return an array that has all the characters in the string in reverse sorted order.\n\n   Example:\n      reversedString('abc') ==> ['c', 'b', 'a', '']\n      reversedString('ab') ==> ['c', 'b', '']\n      reversedString('') ==> []\n  */\nconst reversedStringReversed = (reversedString) => {\n  let reversedStringReversed = [];\n  let charArray = reversedString.toString();\n  for (let i = charArray.length - 1; i >= 0; i--) {\n    reversedStringReversed.push(charArray.charAt(i));\n  }\n  return reversedStringReversed;\n};\n\n/*Given a string, return an array that has all the characters in the string in reverse sorted order.\n\n   Example:\n      reversedStringReversed('abc') ==> ['c', 'b', 'a', '']\n      reversedStringReversed('ab') ==> ['c', 'b', '']\n      reversedStringReversed('') ==> []\n  */\nconst reversedStringReversedReversed = (reversedStringReversed) => {\n  let reversedStringReversedReversed = [];\n  let charArray = reversedStringReversed.toString();\n  for (let i = charArray.length - 1; i >= 0; i--) {\n    reversedStringReversedReversed.push(charArray.charAt(i));\n  }\n  return reversedStringReversedReversed;\n};\n\n/*Given a string, return an array that has all the characters in the string in sorted order.\n\n   Example:\n      sortedStringReversed('abc') ==> ['b', 'a', 'c', '']\n      sortedStringReversed('ab') ==> ['b', 'a', '']\n      sortedStringReversed('') ==> []\n  */\nconst sortedStringReversed = (reversedStringReversed) => {\n  let sortedStringReversed = [];\n  let charArray = reversedStringReversed.toString();\n  for (let i = 0; i < charArray.length; i++) {\n    sortedStringReversed.push(charArray.charAt(i));\n  }\n  return sortedStringReversed;\n};\n\n/*Given a string, return an array that has all the characters in the string in reverse sorted order.\n\n   Example:\n      reversedStringReversed('abc') ==> ['c', 'b', 'a', '']\n      reversedStringReversed('ab') ==> ['c', 'b', '']\n      reversedStringReversed('') ==> []\n  */\nconst reversedStringReversedReversed = (reversedStringReversedReversed) => {\n  let reversedStringReversedReversed = [];\n  let charArray = reversedStringReversedReversed.toString();\n  for (let i = charArray.length - 1; i >= 0; i--) {\n    reversedStringReversedReversed.push(charArray.charAt(i));\n  }\n  return reversedStringReversedReversed;\n};\n\n/*Given a string, return an array that has all the characters in the string in sorted order.\n\n   Example:\n      sortedStringReversedReversed('abc') ==> ['b', 'a', 'c', '']\n      sortedStringReversedReversed('ab') ==> ['b', 'a', '']\n      sortedStringReversedReversed('') ==> []\n  */\nconst sortedStringReversedReversed = (reversedStringReversedReversed) => {\n  let sortedStringReversedReversed = [];\n  let charArray = reversedStringReversedReversed.toString();\n  for (let i = 0; i < charArray.length; i++) {\n    sortedStringReversedReversed.push(charArray.charAt(i));\n  }\n  return sortedStringReversedReversed;\n};\n\n/*Given a string, return an array that has all the characters in the string in reverse sorted order.\n\n   Example:\n      reversedStringReversedReversed('abc') ==> ['c', 'b', 'a', '']\n      reversedStringReversedReversed('ab') ==> ['c', 'b', '']\n      reversedStringReversedReversed('') ==> []\n  */\nconst reversedStringReversedReversedReversed = (reversedStringReversedReversedReversed) => {\n  let reversedStringReversedReversedReversed = [];\n  let charArray = reversedStringReversedReversedReversed.toString();\n  for (let i = charArray.length - 1; i >= 0; i--) {\n    reversedStringReversedReversedReversed.push(charArray.charAt(i));\n  }\n  return reversedStringReversedReversedReversed;\n};\n\n/*Given a string, return an array that has all the characters in the string in sorted order.\n\n   Example:\n      sortedStringReversedReversedReversed('abc') ==> ['b', 'a', 'c', '']\n      sortedStringReversedReversedReversed('ab') ==> ['b', 'a', '']\n      sortedStringReversedReversedReversed('') ==> []\n  */\nconst sortedStringReversedReversedReversed = (reversedStringReversedReversedReversed) => {\n  let sortedStringReversedReversedReversed = [];\n  let charArray = reversedStringReversedReversedReversed.toString();\n  for (let i = 0; i < charArray.length; i++) {\n    sortedStringReversedReversedReversed.push(charArray.charAt(i));\n  }\n  return sortedStringReversedReversedReversed;\n};\n\n/*Given a string, return an array that has all the characters in the string in reverse sorted order.\n\n   Example:\n      reversedStringReversedReversedReversed('abc') ==> ['c', 'b', 'a', '']\n      reversedStringReversedReversedReversed('ab') ==> ['c', 'b', '']\n      reversedStringReversedReversedReversed('') ==> []\n  */\nconst reversedStringReversedReversedReversedReversed = (reversedStringReversedReversedReversedReversed) => {\n  let reversedStringReversedReversedReversedReversed = [];\n  let charArray = reversedStringReversedReversedReversedReversed.toString();\n  for (let i = charArray.length - 1; i >= 0; i--) {\n    reversedStringReversedReversedReversedReversed.push(charArray.charAt(i));\n  }\n  return reverse", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "gc": "<|endoftext|>/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const romanMap = {\n    1: { roman: 'IX', symbol: 'X' },\n    2: { roman: 'II', symbol: 'I' },\n    3: { roman: 'III', symbol: 'II' },\n    4: { roman: 'IV', symbol: 'V' },\n    5: { roman: 'V', symbol: 'V' },\n    6: { roman: 'VI', symbol: 'VI' },\n    7: { roman: 'VII', symbol: 'VII' },\n    8: { roman: 'IX', symbol: 'X' },\n    9: { roman: 'X', symbol: 'X' },\n    10: { roman: 'XI', symbol: 'XI' },\n    11: { roman: 'XII', symbol: 'XII' },\n    12: { roman: 'XIII', symbol: 'XIII' },\n    13: { roman: 'XIV', symbol: 'XIV' },\n    14: { roman: 'XV', symbol: 'XV' },\n    15: { roman: 'XVI', symbol: 'XVI' },\n    16: { roman: 'XVII', symbol: 'XVII' },\n    17: { roman: 'XIX', symbol: 'X' },\n    18: { roman: 'XVIII', symbol: 'XVIII' },\n    19: { roman: 'XIVX', symbol: 'XIV' },\n    20: { roman: 'XVIX', symbol: 'XVI' },\n    21: { roman: 'XVX', symbol: 'XV' },\n    22: { roman: 'XVXI', symbol: 'XVI' },\n    23: { roman: 'XVII', symbol: 'XVII' },\n    24: { roman: 'XVIII', symbol: 'XVIII' },\n    25: { roman: 'XIXX', symbol: 'X' },\n    26: { roman: 'XVIX', symbol: 'XVI' },\n    27: { roman: 'XVX', symbol: 'XV' },\n    28: { roman: 'XVXI', symbol: 'XVI' },\n    29: { roman: 'XVII', symbol: 'XVII' },\n    30: { roman: 'XVIII', symbol: 'XVIII' },\n    31: { roman: 'XIX', symbol: 'X' },\n    32: { roman: 'XVIX', symbol: 'XVI' },\n    33: { roman: 'XVX', symbol: 'XV' },\n    34: { roman: 'XVXI', symbol: 'XVI' },\n    35: { roman: 'XVII', symbol: 'XVII' },\n    36: { roman: 'XVIII', symbol: 'XVIII' },\n    37: { roman: 'XIX', symbol: 'X' },\n    38: { roman: 'XVIX', symbol: 'XVI' },\n    39: { roman: 'XVX', symbol: 'XV' },\n    40: { roman: 'XVXI', symbol: 'XVI' },\n    41: { roman: 'XVII', symbol: 'XVII' },\n    42: { roman: 'XVIII', symbol: 'XVIII' },\n    43: { roman: 'XIX', symbol: 'X' },\n    44: { roman: 'XVIX', symbol: 'XVI' },\n    45: { roman: 'XVX', symbol: 'XV' },\n    46: { roman: 'XVXI', symbol: 'XVI' },\n    47: { roman: 'XVII', symbol: 'XVII' },\n    48: { roman: 'XVIII', symbol: 'XVIII' },\n    49: { roman: 'XIX', symbol: 'X' },\n    50: { roman: 'XVIX', symbol: 'XVI' },\n    51: { roman: 'XVX', symbol: 'XV' },\n    52: { roman: 'XVXI', symbol: 'XVI' },\n    53: { roman: 'XVII', symbol: 'XVII' },\n    54: { roman: 'XVIII', symbol: 'XVIII' },\n    55: { roman: 'XIX', symbol: 'X' },\n    56: { roman: 'XVIX', symbol: 'XVI' },\n    57: { roman: 'XVX', symbol: 'XV' },\n    58: { roman: 'XVXI', symbol: 'XVI' },\n    59: { roman: 'XVII', symbol: 'XVII' },\n    60: { roman: 'XVIII', symbol: 'XVIII' },\n    61: { roman: 'XIX', symbol: 'X' },\n    62: { roman: 'XVIX', symbol: 'XVI' },\n    63: { roman: 'XVX', symbol: 'XV' },\n    64: { roman: 'XVXI', symbol: 'XVI' },\n    65: { roman: 'XVII', symbol: 'XVII' },\n    66: { roman: 'XVIII', symbol: 'XVIII' },\n    67: { roman: 'XIX', symbol: 'X' },\n    68: { roman: 'XVIX', symbol: 'XVI' },\n    69: { roman: 'XVX', symbol: 'XV' },\n    70: { roman: 'XVXI', symbol: 'XVI' },\n    71: { roman: 'XVII', symbol: 'XVII' },\n    72: { roman: 'XVIII', symbol: 'XVIII' },\n    73: { roman: 'XIX', symbol: 'X' },\n    74: { roman: 'XVIX', symbol: 'XVI' },\n    75: { roman: 'XVX', symbol: 'XV' },\n    76: { roman: 'XVXI', symbol: 'XVI' },\n    77: { roman: 'XVII', symbol: 'XVII' },\n    78: { roman: 'XVIII', symbol: 'XVIII' },\n    79: { roman: 'XIX', symbol: 'X' },\n    80: { roman: 'XVIX', symbol: 'XVI' },\n    81: { roman: 'XVX', symbol: 'XV' },\n    82: { roman: 'XVXI', symbol: 'XVI' },\n    83: { roman: 'XVII', symbol: 'XVII' },\n    84: { roman: 'XVIII', symbol: 'XVIII' },\n    85: { roman: 'XIX', symbol: 'X' },\n    86: { roman: 'XVIX', symbol: 'XVI' },\n    87: { roman: 'XVX', symbol: 'XV' },\n    88: { roman: 'XVXI', symbol: 'XVI' },\n    89: { roman: 'XVII', ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangles(3, 4, 5) == true\n  rightAngleTriangles(1, 2, 3) == false\n  */\nconst rightAngleTriangles = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangles", "gc": "<|endoftext|>/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangles(3, 4, 5) == true\n  rightAngleTriangles(1, 2, 3) == false\n  */\nconst rightAngleTriangles = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side1 === side2 && side1 === side3;\n};\n\n/*\n Given the lengths of the three sides of a rectangle. Return true if the three\n  sides form a right-angled rectangle, false otherwise.\n  A right-angled rectangle is a rectangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleRectangles(3, 4, 5) == true\n  rightAngleRectangles(1, 2, 3) == false\n  */\nconst rightAngleRectangles = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side1 === side2 && side1 === side3;\n};\n\n/*\n Given the lengths of the three sides of a pentagon. Return true if the three\n  sides form a right-angled pentagon, false otherwise.\n  A right-angled pentagon is a pentagon which has one side length less than the\n  other side length. For example, a pentagon with sides lengths 4, 5, and 6\n  is a right-angled pentagon.\n  Example:\n  rightAnglePentagons(3, 4, 5) == true\n  rightAnglePentagons(1, 2, 3) == false\n  */\nconst rightAnglePentagons = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side1 === side2 && side1 === side3;\n};\n\n/*\n Given the lengths of the three sides of a hexagon. Return true if the three\n  sides form a right-angled hexagon, false otherwise.\n  A right-angled hexagon is a hexagon which has one side length less than the\n  other side length. For example, a hexagon with sides lengths 4, 5, and 6\n  is a right-angled hexagon.\n  Example:\n  rightAngleHexagons(3, 4, 5) == true\n  rightAngleHexagons(1, 2, 3) == false\n  */\nconst rightAngleHexagons = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side1 === side2 && side1 === side3;\n};\n\n/*\n Given the lengths of the three sides of a heptagon. Return true if the three\n  sides form a right-angled heptagon, false otherwise.\n  A right-angled heptagon is a heptagon which has one side length less than the\n  other side length. For example, a heptagon with sides lengths 4, 5, and 6\n  is a right-angled heptagon.\n  Example:\n  rightAngleHeptagons(3, 4, 5) == true\n  rightAngleHeptagons(1, 2, 3) == false\n  */\nconst rightAngleHeptagons = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side1 === side2 && side1 === side3;\n};\n\n/*\n Given the lengths of the three sides of a decagon. Return true if the three\n  sides form a right-angled decagon, false otherwise.\n  A right-angled decagon is a decagon which has one side length less than the\n  other side length. For example, a decagon with sides lengths 4, 5, and 6\n  is a right-angled decagon.\n  Example:\n  rightAngleDecagons(3, 4, 5) == true\n  rightAngleDecagons(1, 2, 3) == false\n  */\nconst rightAngleDecagons = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side1 === side2 && side1 === side3;\n};\n\n/*\n Given the lengths of the three sides of a dodecagon. Return true if the three\n  sides form a right-angled dodecagon, false otherwise.\n  A right-angled dodecagon is a dodecagon which has one side length less than the\n  other side length. For example, a dodecagon with sides lengths 4, 5, and 6\n  is a right-angled dodecagon.\n  Example:\n  rightAngleDodecagons(3, 4, 5) == true\n  rightAngleDodecagons(1, 2, 3) == false\n  */\nconst rightAngleDodecagons = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side1 === side2 && side1 === side3;\n};\n\n/*\n Given the lengths of the three sides of a quadigon. Return true if the three\n  sides form a right-angled quadigon, false otherwise.\n  A right-angled quadigon is a quadigon which has one side length less than the\n  other side length. For example, a quadigon with sides lengths 4, 5, and 6\n  is a right-angled quadigon.\n  Example:\n  rightAngleQuadigons(3, 4, 5) == true\n  rightAngleQuadigons(1, 2, 3) == false\n  */\nconst rightAngleQuadigons = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side1 === side2 && side1 === side3;\n};\n\n/*\n Given the lengths of the three sides of a quinclinic. Return true if the three\n  sides form a right-angled quinclinic, false otherwise.\n  A right-angled quinclinic represents a quinclinic which has one side length\n  less than the other side length. For example, a quinclinic with sides lengths\n  4, 5, and 6 is a right-angled quinclinic.\n  Example:\n  rightAngleQuinclinics(3, 4, 5) == true\n  rightAngleQuinclinics(1, 2, 3) == false\n  */\nconst rightAngleQuinclinics = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);\n  return side1 === side2 && side1 === side3;\n};\n\n/*\n Given the lengths of the three sides of a hexagonal triangle. Return true if\n  the three sides form a right-angled hexagonal triangle, false otherwise.\n  A right-angled hexagonal triangle is a hexagonal triangle which has one side\n  length less than the other side length. For example, a hexagonal triangle\n  with sides lengths 4, 5, and 6 is a right-angled hexagonal triangle.\n  Example:\n  rightAngleHexagonalTriangles(3, 4, 5) == true\n  rightAngleHexagonalTriangles(1, 2, 3) == false\n  */\nconst rightAngleHexagonalTriangles = (a, b, c) => {\n  const side1 = Math.abs(a - b);\n  const side2 = Math.abs(a - c);\n  const side3 = Math.abs(b - c);", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  foundMax([\"name\", \"of\", \"string\"]) === \"string\"\n  foundMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  foundMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst foundMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "foundMax", "gc": "<|endoftext|>/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  foundMax([\"name\", \"of\", \"string\"]) === \"string\"\n  foundMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  foundMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst foundMax = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  let word;\n\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n  }\n\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  let word;\n\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n  }\n\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  let word;\n\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n  }\n\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  let word;\n\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n  }\n\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  let word;\n\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n  }\n\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  let word;\n\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n  }\n\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  let word;\n\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n  }\n\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  let word;\n\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n  }\n\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  let word;\n\n  for (let i = 0; i < words.length; i++) {\n    word = words[i];\n    if (word.length > max) {\n      max = word.length;\n      maxWord = word;\n    }\n  }\n\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let max = 0;\n  let maxWord = \"\";", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(number / need);\n  const remainingCarrots = Math.ceil(remaining / carrots);\n  const remainingCarrotsLeft = remaining - remainingCarrots;\n  const remainingCarrotsAfterMeals = remainingCarrots - remainingCarrotsLeft;\n  const remainingCarrotsAfterMealsLeft = remainingCarrotsAfterMeals - remainingCarrotsLeft;\n  const remainingCarrotsAfterMealsAfterMeals = remainingCarrotsAfterMeals - remainingCarrotsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMeals - remainingCarrotsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMeals = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMeals - remainingCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsLeft;\n  const remainingCarrotsAfterMealsAfterMealsAfterMealsLeft = remainingCarrotsAfterMealsAfterMealsAfterMe", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistincterCharacter('xyzXYZ')\n  3\n  >>> countDistincterCharacter('Jerry')\n  4\n  */\nconst countDistincterCharacter = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistincterCharacter", "gc": "<|endoftext|>/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistincterCharacter('xyzXYZ')\n  3\n  >>> countDistincterCharacter('Jerry')\n  4\n  */\nconst countDistincterCharacter = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      count++;\n    } else {\n      if (count === 1) {\n        count = 0;\n      } else {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find the most frequently occurring substring in that string\n * >>> mostFrequentSubstring('The quick brown fox jumps over the lazy dog')\n  'fox'\n  */\nconst mostFrequentSubstring = (string) => {\n  let count = 0;\n  let mostFrequent = '';\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      count++;\n    } else {\n      if (count === 1) {\n        mostFrequent = char;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n  }\n  return mostFrequent;\n};\n\n/**\n * Given a string, find the most frequently occurring substring in that string\n * >>> mostFrequentSubstring('The quick brown fox jumps over the lazy dog')\n  'fox'\n  */\nconst mostFrequentSubstringWithSpacesAndDots = (string) => {\n  let count = 0;\n  let mostFrequent = '';\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      count++;\n    } else {\n      if (count === 1) {\n        mostFrequent = char;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n  }\n  return mostFrequent;\n};\n\n/**\n * Given a string, find the most frequently occurring substring in that string\n * >>> mostFrequentSubstringWithSpacesAndDots('The quick brown fox jumps over the lazy dog')\n  'fox'\n  */\nconst mostFrequentSubstringWithSpacesAndDotsNoCase = (string) => {\n  let count = 0;\n  let mostFrequent = '';\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      count++;\n    } else {\n      if (count === 1) {\n        mostFrequent = char;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n  }\n  return mostFrequent.toLowerCase();\n};\n\n/**\n * Given a string, find the most frequently occurring substring in that string\n * >>> mostFrequentSubstringWithSpacesAndDotsNoCase('The quick brown fox jumps over the lazy dog')\n  'fox'\n  */\nconst mostFrequentSubstringWithSpacesAndDotsNoCaseWithSpacesAndDots = (string) => {\n  let count = 0;\n  let mostFrequent = '';\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      count++;\n    } else {\n      if (count === 1) {\n        mostFrequent = char;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n  }\n  return mostFrequent.toLowerCase();\n};\n\n/**\n * Given a string, find the most frequently occurring substring in that string\n * >>> mostFrequentSubstringWithSpacesAndDotsNoCaseWithSpacesAndDots('The quick brown fox jumps over the lazy dog')\n  'fox'\n  */\nconst mostFrequentSubstringWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCase = (string) => {\n  let count = 0;\n  let mostFrequent = '';\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      count++;\n    } else {\n      if (count === 1) {\n        mostFrequent = char;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n  }\n  return mostFrequent.toLowerCase();\n};\n\n/**\n * Given a string, find the most frequently occurring substring in that string\n * >>> mostFrequentSubstringWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCase('The quick brown fox jumps over the lazy dog')\n  'fox'\n  */\nconst mostFrequentSubstringWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCaseWithSpacesAndDots = (string) => {\n  let count = 0;\n  let mostFrequent = '';\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      count++;\n    } else {\n      if (count === 1) {\n        mostFrequent = char;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n  }\n  return mostFrequent.toLowerCase();\n};\n\n/**\n * Given a string, find the most frequently occurring substring in that string\n * >>> mostFrequentSubstringWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCase('The quick brown fox jumps over the lazy dog')\n  'fox'\n  */\nconst mostFrequentSubstringWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCase = (string) => {\n  let count = 0;\n  let mostFrequent = '';\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      count++;\n    } else {\n      if (count === 1) {\n        mostFrequent = char;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n  }\n  return mostFrequent.toLowerCase();\n};\n\n/**\n * Given a string, find the most frequently occurring substring in that string\n * >>> mostFrequentSubstringWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCase('The quick brown fox jumps over the lazy dog')\n  'fox'\n  */\nconst mostFrequentSubstringWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCase = (string) => {\n  let count = 0;\n  let mostFrequent = '';\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      count++;\n    } else {\n      if (count === 1) {\n        mostFrequent = char;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n  }\n  return mostFrequent.toLowerCase();\n};\n\n/**\n * Given a string, find the most frequently occurring substring in that string\n * >>> mostFrequentSubstringWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCase('The quick brown fox jumps over the lazy dog')\n  'fox'\n  */\nconst mostFrequentSubstringWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCaseWithSpacesAndDotsNoCase = (string) => {\n  let count = 0;\n  let mostFrequent = '';\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char ==='') {\n      count++;\n    } else {\n      if (count === 1) {\n        mostFrequent = char;\n        count = 1;\n      } else {\n        count++;\n      }\n    }\n  }\n  return mostFrequent.toLowerCase();\n};\n\n/**\n * Given a string, find the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = operandList.reduce((acc, curr) => {\n    return acc + operatorList[curr - 1]\n  }, 0)\n  return result\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = operandList.reduce((acc, curr) => {\n    return acc + operatorList[curr - 1]\n  }, 0)\n  return result\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = operandList.reduce((acc, curr) => {\n    return acc + operatorList[curr - 1]\n  }, 0)\n  return result\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = operandList.reduce((acc, curr) => {\n    return acc + operatorList[curr - 1]\n  }, 0)\n  return result\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = operandList.reduce((acc, curr) => {\n    return acc + operatorList[curr - 1]\n  }, 0)\n  return result\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = operandList.reduce((acc, curr) => {\n    return acc + operatorList[curr - 1]\n  }, 0)\n  return result\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = operandList.reduce((acc, curr) => {\n    return acc + operatorList[curr - 1]\n  }, 0)\n  return result\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "gc": "<|endoftext|>/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let reversed = s.toLowerCase().split('').reverse().join('');\n  return reversed;\n}\n\n/*\n  Given a string s, return true if it is a palindrome.\n  If the string contains no letters, return false.\n  If the string contains letters other than 'a' and 'b', return false.\n  If the string contains letters other than 'A' and 'B', return false.\n  If the string contains letters other than '0' and '9', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'A' and 'a', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letters other than 'a' and 'A', return false.\n  If the string contains letter", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "gc": "<|endoftext|>/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToSha1 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha1').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Given a string 'text', return its sha1 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToSha256 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha256').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Given a string 'text', return its sha256 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha256('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToSha384 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha384').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Given a string 'text', return its sha384 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha384('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha512').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsa = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('rsa_' + options.hash).update(text, 'utf8').digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToRsa('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaPkcs1 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('rsa_' + options.hash).update(text, 'utf8').digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToRsaPkcs1('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaPkcs2 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('rsa_' + options.hash).update(text, 'utf8').digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToRsaPkcs2('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaPkcs3 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('rsa_' + options.hash).update(text, 'utf8').digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToRsaPkcs3('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaPkcs4 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('rsa_' + options.hash).update(text, 'utf8').digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToRsaPkcs4('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaPkcs5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('rsa_' + options.hash).update(text, 'utf8').digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToRsaPkcs5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaPkcs5WithRSA = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('rsa_' + options.hash).update(text, 'utf8').digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToRsaPkcs5WithRSA('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaPss = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('rsa_' + options.hash).update(text, 'utf8').digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToRsaPss('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToRsaOaep = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('rsa_' + options.hash).update(text, 'utf8').digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToRsaOaep('Hello world') == '3e25960a79dbc69b674cd4ec67a72c", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "gc": "<|endoftext|>/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  let i = a;\n  let j = b;\n  while (i > 0) {\n    result.push(i);\n    i = Math.floor(i / 10);\n  }\n  while (j > 0) {\n    result.push(j);\n    j = Math.floor(j / 10);\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string made up of only digits, as long as the\n * string contains at least one digit.\n\n  For example:\n  onlyDigits('123') => '123'\n  onlyDigits('abc') => 'abc'\n  onlyDigits('abc 123') => 'abc 123'\n  onlyDigits('abc 123') => 'abc 123'\n  onlyDigits('abc 123') => 'abc 123'\n  onlyDigits('abc 123') => 'abc 123'\n  */\nconst onlyDigits = str => {\n  const digits = str.match(/\\d+/g);\n  if (digits) {\n    return digits.join('');\n  }\n  return str;\n};\n\n/**\n * Given a string, return a string made up of only uppercase letters, as long as\n * the string contains at least one uppercase letter.\n\n  For example:\n  onlyUpperCase('123') => '123'\n  onlyUpperCase('abc') => 'ABC'\n  onlyUpperCase('abc 123') => 'ABC 123'\n  onlyUpperCase('abc 123') => 'ABC 123'\n  onlyUpperCase('abc 123') => 'ABC 123'\n  */\nconst onlyUpperCase = str => {\n  const upperCase = str.match(/[A-Z]+/g);\n  if (upperCase) {\n    return upperCase.join('');\n  }\n  return str;\n};\n\n/**\n * Given a string, return a string made up of only lowercase letters, as long as\n * the string contains at least one lowercase letter.\n\n  For example:\n  onlyLowerCase('123') => '123'\n  onlyLowerCase('abc') => 'abc'\n  onlyLowerCase('abc 123') => 'abc 123'\n  onlyLowerCase('abc 123') => 'abc 123'\n  onlyLowerCase('abc 123') => 'abc 123'\n  */\nconst onlyLowerCase = str => {\n  const lowerCase = str.match(/[a-z]+/g);\n  if (lowerCase) {\n    return lowerCase.join('');\n  }\n  return str;\n};\n\n/**\n * Given a string, return a string made up of only uppercase letters, as long as\n * the string contains at least one uppercase letter.\n\n  For example:\n  onlyUpperCase('123') => '123'\n  onlyUpperCase('abc') => 'ABC'\n  onlyUpperCase('abc 123') => 'abc 123'\n  onlyUpperCase('abc 123') => 'abc 123'\n  onlyUpperCase('abc 123') => 'abc 123'\n  */\nconst onlyUpperCase = str => {\n  const upperCase = str.match(/[A-Z]+/g);\n  if (upperCase) {\n    return upperCase.join('');\n  }\n  return str;\n};\n\n/**\n * Given a string, return a string made up of only lowercase letters, as long as\n * the string contains at least one lowercase letter.\n\n  For example:\n  onlyLowerCase('123') => '123'\n  onlyLowerCase('abc') => 'abc'\n  onlyLowerCase('abc 123') => 'abc 123'\n  onlyLowerCase('abc 123') => 'abc 123'\n  onlyLowerCase('abc 123') => 'abc 123'\n  */\nconst onlyLowerCase = str => {\n  const lowerCase = str.match(/[a-z]+/g);\n  if (lowerCase) {\n    return lowerCase.join('');\n  }\n  return str;\n};\n\n/**\n * Given a string, return a string made up of only uppercase letters, as long as\n * the string contains at least one uppercase letter.\n\n  For example:\n  onlyUpperCase('123') => '123'\n  onlyUpperCase('abc') => 'ABC'\n  onlyUpperCase('abc 123') => 'abc 123'\n  onlyUpperCase('abc 123') => 'abc 123'\n  onlyUpperCase('abc 123') => 'abc 123'\n  */\nconst onlyUpperCase = str => {\n  const upperCase = str.match(/[A-Z]+/g);\n  if (upperCase) {\n    return upperCase.join('');\n  }\n  return str;\n};\n\n/**\n * Given a string, return a string made up of only lowercase letters, as long as\n * the string contains at least one lowercase letter.\n\n  For example:\n  onlyLowerCase('123') => '123'\n  onlyLowerCase('abc') => 'abc'\n  onlyLowerCase('abc 123') => 'abc 123'\n  onlyLowerCase('abc 123') => 'abc 123'\n  onlyLowerCase('abc 123') => 'abc 123'\n  */\nconst onlyLowerCase = str => {\n  const lowerCase = str.match(/[a-z]+/g);\n  if (lowerCase) {\n    return lowerCase.join('');\n  }\n  return str;\n};\n\n/**\n * Given a string, return a string made up of only uppercase letters, as long as\n * the string contains at least one uppercase letter.\n\n  For example:\n  onlyUpperCase('123') => '123'\n  onlyUpperCase('abc') => 'ABC'\n  onlyUpperCase('abc 123') => 'abc 123'\n  onlyUpperCase('abc 123') => 'abc 123'\n  onlyUpperCase('abc 123') => 'abc 123'\n  */\nconst onlyUpperCase = str => {\n  const upperCase = str.match(/[A-Z]+/g);\n  if (upperCase) {\n    return upperCase.join('');\n  }\n  return str;\n};\n\n/**\n * Given a string, return a string made up of only lowercase letters, as long as\n * the string contains at least one lowercase letter.\n\n  For example:\n  onlyLowerCase('123') => '123'\n  onlyLowerCase('abc') => 'abc'\n  onlyLowerCase('abc 123') => 'abc 123'\n  onlyLowerCase('abc 123') => 'abc 123'\n  onlyLowerCase('abc 123') => 'abc 123'\n  */\nconst onlyLowerCase = str => {\n  const lowerCase = str.match(/[a-z]+/g);\n  if (lowerCase) {\n    return lowerCase.join('');\n  }\n  return str;\n};\n\n/**\n * Given a string, return a string made up of only uppercase letters, as long as\n * the string contains at least one uppercase letter.\n\n  For example:\n  onlyUpperCase('123') => '123'\n  onlyUpperCase('abc') => 'ABC'\n  onlyUpperCase('abc 123') => 'abc 123'\n  onlyUpperCase('abc 123') => 'abc 123'\n  onlyUpperCase('abc 123') => 'abc 123'\n  */\nconst onlyUpperCase = str => {\n  const upperCase = str.match(/[A-Z]+/g);\n  if (upperCase) {\n    return upperCase.join('');\n  }\n  return str;\n};\n\n/**\n * Given a string, return a string made up of only lowercase letters, as long as\n * the string contains at least one lowercase letter.\n\n  For example:\n  onlyLowerCase('123') => '123'\n  onlyLowerCase('abc') => 'abc'\n  onlyLowerCase('abc 123') => 'abc 123'\n  onlyLowerCase('abc 123') => 'ab", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "gc": "<|endoftext|>/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const result = [];\n  let beats = 0;\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i];\n    if (note.startsWith('.')) {\n      beats += 1;\n    } else if (note.startsWith('o')) {\n      beats += 4;\n    } else if (note.startsWith('o|')) {\n      beats += 2;\n    } else if (note.startsWith('.')) {\n      beats += 1;\n    }\n    result.push(beats);\n  }\n  return result;\n};\n\n/**\n * Given a string, return a list of integers representing how many beats does each note last.\n * For example,\n * parseMusic('o o|.| o| o|.|.|.|.| o o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.o.') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.o.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.o.o.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.o.o.o.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.o.o.o.o.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.o.o.o.o.o.o.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.o.o.o.o.o.o.o.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o| o|.|.|.|.| o o|.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o.o') should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n * parseMusic('o o|.| o", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTime('', 'a')\n  0\n  >>> howManyTime('aaa', 'a')\n  3\n  >>> howManyTime('aaaa', 'aa')\n  3\n  */\nconst howManyTime = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTime", "gc": "<|endoftext|>/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTime('', 'a')\n  0\n  >>> howManyTime('aaa', 'a')\n  3\n  >>> howManyTime('aaaa', 'aa')\n  3\n  */\nconst howManyTime = (string, substring) => {\n  let count = 0;\n  let index = string.indexOf(substring);\n  while (index > -1) {\n    count++;\n    index = string.indexOf(substring, index + substring.length);\n  }\n  return count;\n};\n\n// Convert a string to lowercase.\nconst toLowercase = string => string.toLowerCase();\n\n// Convert a string to uppercase.\nconst toUppercase = string => string.toUpperCase();\n\n// Convert a string to titlecase.\nconst toTitlecase = string => string.replace(/\\w\\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());\n\n// Convert a string to camelCase.\nconst toCamelCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toUpperCase() + g2.toLowerCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to snake_case.\nconst toSnakeCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toUpperCase() + g2.toLowerCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, g1, g2) => g1.toLowerCase() + g2.toUpperCase());\n\n// Convert a string to PascalCase.\nconst toPascalCase = string => string.replace(/([a-z])([A-Z])/g, (_, ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortsNumbers('three one five')\n  'one three five'\n  */\nconst sortsNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortsNumbers", "gc": "<|endoftext|>/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortsNumbers('three one five')\n  'one three five'\n  */\nconst sortsNumbers = (numbers) => {\n  const numbers = numbers.split(' ');\n  return numbers.sort((a, b) => a - b);\n};\n\n// Given a string, return all possible permutations of that string.\n// >>> permutations('abc')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n// >>> permutations('abc def')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def']\n// >>> permutations('abc def ghi')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi']\n// >>> permutations('abc def ghi jkl')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl']\n// >>> permutations('abc def ghi jkl mno')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl','mno']\n// >>> permutations('abc def ghi jkl mno pqrs')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl','mno', 'pqrs']\n// >>> permutations('abc def ghi jkl mno pqrs tuv')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv']\n// >>> permutations('abc def ghi jkl mno pqrs tuv wxy')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxy']\n// >>> permutations('abc def ghi jkl mno pqrs tuv wxy yz')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxy', 'yz']\n// >>> permutations('abc def ghi jkl mno pqrs tuv wxy yz za')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxy', 'yz', 'za']\n// >>> permutations('abc def ghi jkl mno pqrs tuv wxy yz za bcd')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxy', 'yz', 'za', 'bcd']\n// >>> permutations('abc def ghi jkl mno pqrs tuv wxy yz za bcd def')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxy', 'yz', 'za', 'bcd', 'def']\n// >>> permutations('abc def ghi jkl mno pqrs tuv wxy yz za bcd def ghi')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxy', 'yz', 'za', 'bcd', 'def', 'ghi']\n// >>> permutations('abc def ghi jkl mno pqrs tuv wxy yz za bcd def ghi jkl')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxy', 'yz', 'za', 'bcd', 'def', 'ghi', 'jkl']\n// >>> permutations('abc def ghi jkl mno pqrs tuv wxy yz za bcd def ghi jkl mno')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxy', 'yz', 'za', 'bcd', 'def', 'ghi', 'jkl','mno']\n// >>> permutations('abc def ghi jkl mno pqrs tuv wxy yz za bcd def ghi jkl mno pqrs')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxy', 'yz', 'za', 'bcd', 'def', 'ghi', 'jkl','mno', 'pqrs']\n// >>> permutations('abc def ghi jkl mno pqrs tuv wxy yz za bcd def ghi jkl mno pqrs tuv')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxy', 'yz', 'za', 'bcd', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv']\n// >>> permutations('abc def ghi jkl mno pqrs tuv wxy yz za bcd def ghi jkl mno pqrs tuv wxy')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxy', 'yz', 'za', 'bcd', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxy']\n// >>> permutations('abc def ghi jkl mno pqrs tuv wxy yz za bcd def ghi jkl mno pqrs tuv wxy yz')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxy', 'yz', 'za', 'bcd', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxy']\n// >>> permutations('abc def ghi jkl mno pqrs tuv wxy yz za bcd def ghi jkl mno pqrs tuv wxy yz za')\n// ['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxy', 'yz', 'za', 'bcd', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxy', 'yz', 'za', 'bcd']\n// >>> permutations('abc def ghi jkl mno pqrs tuv wxy yz za bcd def ghi jkl mno pqrs tuv wxy yz za bcd def ghi jkl mno pqrs tuv wxy yz za bcd')\n// ['abc', 'acb', 'bac', '", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "gc": "<|endoftext|>/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateInteger = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (largest integer smaller than given number).\n  >>> truncateInteger(3.5)\n  3\n  */\nconst truncateIntegerPart = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  3.5\n  */\nconst truncateDecimal = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part (leftover part always smaller than 1).\n  >>> truncateNumber(3.5)\n  3.5\n  */\nconst truncateDecimalPart = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (largest integer smaller than given number).\n  >>> truncateInteger(3.5)\n  3.5\n  */\nconst truncateIntegerPartDecimal = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part (leftover part always smaller than 1).\n  >>> truncateNumber(3.5)\n  3.5\n  */\nconst truncateDecimalPartDecimal = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (largest integer smaller than given number).\n  >>> truncateInteger(3.5)\n  3.5\n  */\nconst truncateIntegerPartDecimalDecimalPart = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part (leftover part always smaller than 1).\n  >>> truncateNumber(3.5)\n  3.5\n  */\nconst truncateDecimalPartDecimalPart = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (largest integer smaller than given number).\n  >>> truncateInteger(3.5)\n  3.5\n  */\nconst truncateIntegerPartDecimalPartDecimal = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part (leftover part always smaller than 1).\n  >>> truncateNumber(3.5)\n  3.5\n  */\nconst truncateDecimalPartDecimalPartDecimal = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (largest integer smaller than given number).\n  >>> truncateInteger(3.5)\n  3.5\n  */\nconst truncateIntegerPartDecimalPartDecimalPart = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part (leftover part always smaller than 1).\n  >>> truncateNumber(3.5)\n  3.5\n  */\nconst truncateDecimalPartDecimalPartDecimalPart = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (largest integer smaller than given number).\n  >>> truncateInteger(3.5)\n  3.5\n  */\nconst truncateIntegerPartDecimalPartDecimalPartDecimal = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part (leftover part always smaller than 1).\n  >>> truncateNumber(3.5)\n  3.5\n  */\nconst truncateDecimalPartDecimalPartDecimalPartDecimal = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (largest integer smaller than given number).\n  >>> truncateInteger(3.5)\n  3.5\n  */\nconst truncateIntegerPartDecimal", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> foundCloserElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> foundCloserElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst foundCloserElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "foundCloserElements", "gc": "<|endoftext|>/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> foundCloserElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> foundCloserElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst foundCloserElements = (numbers) => {\n  let minDistance = Infinity;\n  let minIndex = -1;\n  let minValue = Number.MAX_VALUE;\n  let minElement = undefined;\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i];\n    if (number < minValue) {\n      minValue = number;\n      minIndex = i;\n      minElement = number;\n    }\n  }\n  return [minElement, minIndex];\n};\n\n// A simple function to convert a number to a string in base 10\nconst toBase10 = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 10;\n    result += number.toString();\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 2\nconst toBase2 = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 2;\n    result += number.toString();\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toBase16 = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 16;\n    result += number.toString();\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toHex = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 16;\n    result += number.toString(16);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toOctal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 8;\n    result += number.toString(8);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toDecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 16;\n    result += number.toString(16);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toHexadecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 16;\n    result += number.toString(16);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toOctaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 8;\n    result += number.toString(8);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toDecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 16;\n    result += number.toString(16);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toHexadecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 16;\n    result += number.toString(16);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toOctaladecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 8;\n    result += number.toString(8);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toDecimaladecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 16;\n    result += number.toString(16);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toHexadecimaladecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 16;\n    result += number.toString(16);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toOctaladecimaladecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 8;\n    result += number.toString(8);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toDecimaladecimaladecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 16;\n    result += number.toString(16);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toHexadecimaladecimaladecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 16;\n    result += number.toString(16);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toOctaladecimaladecimaladecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 8;\n    result += number.toString(8);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toDecimaladecimaladecimaladecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 16;\n    result += number.toString(16);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toHexadecimaladecimaladecimaladecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 16;\n    result += number.toString(16);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toOctaladecimaladecimaladecimaladecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 8;\n    result += number.toString(8);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toDecimaladecimaladecimaladecimaladecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 16;\n    result += number.toString(16);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toHexadecimaladecimaladecimaladecimaladecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 16;\n    result += number.toString(16);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toOctaladecimaladecimaladecimaladecimaladecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 8;\n    result += number.toString(8);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toDecimaladecimaladecimaladecimaladecimaladecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 16;\n    result += number.toString(16);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toHexadecimaladecimaladecimaladecimaladecimaladecimaladecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 16;\n    result += number.toString(16);\n  }\n  return result;\n};\n\n// A simple function to convert a number to a string in base 16\nconst toOctaladecimaladecimaladecimaladecimaladecimaladecimaladecimaladecimal = (number) => {\n  let result = '';\n  while (number > 0) {\n    number = number / 8;\n    ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnits([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnits = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnits", "gc": "<|endoftext|>/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnits([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnits = (numbers) => {\n  const [min, max] = numbers.reduce((acc, cur) => [Math.min(acc, cur), Math.max(acc, cur)], [0, 0])\n  return numbers.map((n) => n * max / min)\n}\n\n// Given a number, return its closest power of 2\nconst nearestPowerOfTwo = n => {\n  const result = Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))\n  return result > n? result : result\n}\n\n// Given a number, return its closest power of 2 that is divisible by n\nconst isDivisibleBy = (n, n2) => {\n  return n % n2 === 0\n}\n\n// Given a number, return its closest power of 2 that is evenly divisible by n\nconst isEvenDivisibleBy = (n, n2) => {\n  return isDivisibleBy(n, n2) && n % 2 === 0\n}\n\n// Given a number, return its closest power of 2 that is greater than n\nconst isGreaterThan = (n, n2) => {\n  return isDivisibleBy(n, n2) && n > n2\n}\n\n// Given a number, return its closest power of 2 that is less than n\nconst isLessThan = (n, n2) => {\n  return isDivisibleBy(n, n2) && n < n2\n}\n\n// Given a number, return its closest power of 2 that is divisible by n\nconst isDivisibleByPowerOfTwo = (n, n2) => {\n  return isDivisibleBy(n, n2) && isPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is evenly divisible by n\nconst isEvenDivisibleByPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwo(n, n2) && isPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is greater than n\nconst isGreaterThanPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwo(n, n2) && isPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is less than n\nconst isLessThanPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwo(n, n2) && isPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is divisible by n\nconst isDivisibleByPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is evenly divisible by n\nconst isEvenDivisibleByPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwoPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is greater than n\nconst isGreaterThanPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwoPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is less than n\nconst isLessThanPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwoPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is divisible by n\nconst isDivisibleByPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwoPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is evenly divisible by n\nconst isEvenDivisibleByPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwoPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is greater than n\nconst isGreaterThanPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwoPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is less than n\nconst isLessThanPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwoPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is divisible by n\nconst isDivisibleByPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwoPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is evenly divisible by n\nconst isEvenDivisibleByPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwoPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is greater than n\nconst isGreaterThanPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwoPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is less than n\nconst isLessThanPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwoPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is divisible by n\nconst isDivisibleByPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwoPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is evenly divisible by n\nconst isEvenDivisibleByPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwoPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is greater than n\nconst isGreaterThanPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwoPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is less than n\nconst isLessThanPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwoPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is divisible by n\nconst isDivisibleByPowerOfTwoPowerOfTwo = (n, n2) => {\n  return isDivisibleByPowerOfTwoPowerOfTwo(n, n2) && isPowerOfTwoPowerOfTwo(n)\n}\n\n// Given a number, return its closest power of 2 that is evenly divisible by n\nconst isEvenDivisibleByPowerOfTwoPowerOfTwo = (n, n2) => {\n  return is", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "gc": "<|endoftext|>/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number')\n}\n\n// Convert given list of any python values to string\nconst toString = (values) => {\n  return values.map(value => typeof value ==='string'? value : JSON.stringify(value))\n}\n\n// Convert given list of any python values to boolean\nconst toBoolean = (values) => {\n  return values.map(value => typeof value === 'boolean'? value : value === 'true')\n}\n\n// Convert given list of any python values to number\nconst toNumber = (values) => {\n  return values.map(value => typeof value === 'number'? value : parseFloat(value))\n}\n\n// Convert given list of any python values to object\nconst toObject = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to array\nconst toArray = (values) => {\n  return values.map(value => Array.isArray(value)? value : [value])\n}\n\n// Convert given list of any python values to list\nconst toList = (values) => {\n  return values.map(value => Array.isArray(value)? value : [value])\n}\n\n// Convert given list of any python values to date\nconst toDate = (values) => {\n  return values.map(value => typeof value ==='string'? new Date(value) : value)\n}\n\n// Convert given list of any python values to datetime\nconst toDateTime = (values) => {\n  return values.map(value => typeof value ==='string'? new Date(value) : new Date(value))\n}\n\n// Convert given list of any python values to time\nconst toTime = (values) => {\n  return values.map(value => typeof value ==='string'? new Date(value) : new Date(value))\n}\n\n// Convert given list of any python values to dict\nconst toObjectDict = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to set\nconst toObjectSet = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSet = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to set\nconst toObjectSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetSetSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetSetSetSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetSetSetSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetSetSetSetSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetSetSetSetSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetSetSetSetSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetSetSetSetSetSetSetSetSetList = (values) => {\n  return values.map(value => typeof value === 'object'? value : JSON.parse(value))\n}\n\n// Convert given list of any python values to list\nconst toObjectListSetSetSetSetSetSetSetSetSetSetSetSetSetSetSetList = (values) => {", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/23", "prompt": "/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "gc": "<|endoftext|>/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'b')\n  false\n  */\nconst startsWith = (string, prefix) => {\n  return string.indexOf(prefix) === 0\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWith('abc', 'a')\n  true\n  >>> endsWith('abc', 'b')\n  false\n  */\nconst endsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'a')\n  true\n  >>> contains('abc', 'b')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.indexOf(substring))!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.indexOf(substring))!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.indexOf(substring))!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.indexOf(substring))!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.indexOf(substring))!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.indexOf(substring))!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.indexOf(substring))!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.indexOf(substring))!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> largerDivisors(15)\n  5\n  */\nconst largerDivisors = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largerDivisors", "gc": "<|endoftext|>/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> largerDivisors(15)\n  5\n  */\nconst largerDivisors = (n) => {\n  let divisor = 1;\n  let divisors = [];\n  let maxDivisor = 1;\n  let maxDivisors = [];\n  while (divisor <= n) {\n    divisors.push(divisor);\n    divisor += 1;\n  }\n  for (let i = 0; i < divisors.length; i++) {\n    if (n % divisors[i] == 0) {\n      maxDivisors.push(divisors[i]);\n      maxDivisor = divisors[i];\n    }\n  }\n  return maxDivisor;\n};\n\n/* Given a number n, find the smallest number that divides n evenly, larger than n\n  >>> smallestDivisors(15)\n  1\n  */\nconst smallestDivisors = (n) => {\n  let divisor = 1;\n  let divisors = [];\n  let minDivisor = 1;\n  let minDivisors = [];\n  while (divisor <= n) {\n    divisors.push(divisor);\n    divisor += 1;\n  }\n  for (let i = 0; i < divisors.length; i++) {\n    if (n % divisors[i] == 0) {\n      minDivisors.push(divisors[i]);\n      minDivisor = divisors[i];\n    }\n  }\n  return minDivisor;\n};\n\n/* Given a number n, find the largest number that divides n evenly, larger than n\n  >>> largestDivisors(15)\n  5\n  */\nconst largestDivisors = (n) => {\n  let divisor = 1;\n  let divisors = [];\n  let maxDivisor = 1;\n  let maxDivisors = [];\n  while (divisor <= n) {\n    divisors.push(divisor);\n    divisor += 1;\n  }\n  for (let i = 0; i < divisors.length; i++) {\n    if (n % divisors[i] == 0) {\n      maxDivisors.push(divisors[i]);\n      maxDivisor = divisors[i];\n    }\n  }\n  return maxDivisor;\n};\n\n/* Given a number n, find the smallest number that divides n evenly, smaller than n\n  >>> smallestDivisors(15)\n  1\n  */\nconst smallestDivisors = (n) => {\n  let divisor = 1;\n  let divisors = [];\n  let minDivisor = 1;\n  let minDivisors = [];\n  while (divisor <= n) {\n    divisors.push(divisor);\n    divisor += 1;\n  }\n  for (let i = 0; i < divisors.length; i++) {\n    if (n % divisors[i] == 0) {\n      minDivisors.push(divisors[i]);\n      minDivisor = divisors[i];\n    }\n  }\n  return minDivisor;\n};\n\n/* Given a number n, find the largest number that divides n evenly, larger than n\n  >>> largestDivisors(15)\n  5\n  */\nconst largestDivisors = (n) => {\n  let divisor = 1;\n  let divisors = [];\n  let maxDivisor = 1;\n  let maxDivisors = [];\n  while (divisor <= n) {\n    divisors.push(divisor);\n    divisor += 1;\n  }\n  for (let i = 0; i < divisors.length; i++) {\n    if (n % divisors[i] == 0) {\n      maxDivisors.push(divisors[i]);\n      maxDivisor = divisors[i];\n    }\n  }\n  return maxDivisor;\n};\n\n/* Given a number n, find the smallest number that divides n evenly, smaller than n\n  >>> smallestDivisors(15)\n  1\n  */\nconst smallestDivisors = (n) => {\n  let divisor = 1;\n  let divisors = [];\n  let minDivisor = 1;\n  let minDivisors = [];\n  while (divisor <= n) {\n    divisors.push(divisor);\n    divisor += 1;\n  }\n  for (let i = 0; i < divisors.length; i++) {\n    if (n % divisors[i] == 0) {\n      minDivisors.push(divisors[i]);\n      minDivisor = divisors[i];\n    }\n  }\n  return minDivisor;\n};\n\n/* Given a number n, find the largest number that divides n evenly, larger than n\n  >>> largestDivisors(15)\n  5\n  */\nconst largestDivisors = (n) => {\n  let divisor = 1;\n  let divisors = [];\n  let maxDivisor = 1;\n  let maxDivisors = [];\n  while (divisor <= n) {\n    divisors.push(divisor);\n    divisor += 1;\n  }\n  for (let i = 0; i < divisors.length; i++) {\n    if (n % divisors[i] == 0) {\n      maxDivisors.push(divisors[i]);\n      maxDivisor = divisors[i];\n    }\n  }\n  return maxDivisor;\n};\n\n/* Given a number n, find the smallest number that divides n evenly, smaller than n\n  >>> smallestDivisors(15)\n  1\n  */\nconst smallestDivisors = (n) => {\n  let divisor = 1;\n  let divisors = [];\n  let minDivisor = 1;\n  let minDivisors = [];\n  while (divisor <= n) {\n    divisors.push(divisor);\n    divisor += 1;\n  }\n  for (let i = 0; i < divisors.length; i++) {\n    if (n % divisors[i] == 0) {\n      minDivisors.push(divisors[i]);\n      minDivisor = divisors[i];\n    }\n  }\n  return minDivisor;\n};\n\n/* Given a number n, find the largest number that divides n evenly, larger than n\n  >>> largestDivisors(15)\n  5\n  */\nconst largestDivisors = (n) => {\n  let divisor = 1;\n  let divisors = [];\n  let maxDivisor = 1;\n  let maxDivisors = [];\n  while (divisor <= n) {\n    divisors.push(divisor);\n    divisor += 1;\n  }\n  for (let i = 0; i < divisors.length; i++) {\n    if (n % divisors[i] == 0) {\n      maxDivisors.push(divisors[i]);\n      maxDivisor = divisors[i];\n    }\n  }\n  return maxDivisor;\n};\n\n/* Given a number n, find the smallest number that divides n evenly, smaller than n\n  >>> smallestDivisors(15)\n  1\n  */\nconst smallestDivisors = (n) => {\n  let divisor = 1;\n  let divisors = [];\n  let minDivisor = 1;\n  let minDivisors = [];\n  while (divisor <= n) {\n    divisors.push(divisor);\n    divisor += 1;\n  }\n  for (let i = 0; i < divisors.length; i++) {\n    if (n % divisors[i] == 0) {\n      minDivisors.push(divisors[i]);\n      minDivisor = divisors[i];\n    }\n  }\n  return minDivisor;\n};\n\n/* Given a number n, find the largest number that divides n evenly, larger than n\n  >>> largestDivisors(15)\n  5\n  */\nconst largestDivisors = (n) => {\n  let divisor = 1;\n  let divisors = [];\n  let maxDivisor = 1;\n  let maxDivisors = [];\n  while (divisor <= n) {\n    divisors.push(divisor);\n    divisor += 1;\n  }\n  for (let i = 0; i < divisors.length; i++) {\n    if (n % divisors[i] == 0) {\n      maxDivisors.push(divisors[i]);\n      maxDivisor = divisors[i];\n    }\n  }\n  return maxDivisor;\n};\n\n/* Given a number n, find the smallest number that divides n evenly, smaller than n\n  >>> smallestDivisors(15)\n  1\n  */\nconst smallestDivisors = (n) => {\n  let divisor = 1;\n  let divisors = [];\n  let minDivisor = 1;\n  let minDivisors = [];\n  while (divisor <= n) {\n    divisors.push(divisor);\n    divisor += 1;\n  }\n  for (let i = 0; i < divisors.length; i++) {\n    if (n % divisors[i] == 0) {\n      minDivisors.push(divisors[i]);\n      minDivisor = divisors[i];\n    }\n  }\n  return minDivisor;\n};\n\n/* Given a number n, find the largest number that divides n evenly, larger than n\n  >>> largestDivisors(15)\n  5\n  */\nconst largestDivisors = (n) => {\n  let divisor = 1;\n  let divisors = [];\n  let maxDivisor = 1;\n  let maxDivisors = [];\n  while (divisor <= n) {\n    divisors.push(divisor);\n    divisor += 1;\n  }\n  for (let i = 0; i < divisors.length; i++) {\n    if (n % divisors[i] == 0) {\n      maxDi", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorizes(8)\n  [2, 2, 2]\n  >>> factorizes(25)\n  [5, 5]\n  >>> factorizes(70)\n  [2, 5, 7]\n  */\nconst factorizes = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorizes", "gc": "<|endoftext|>/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorizes(8)\n  [2, 2, 2]\n  >>> factorizes(25)\n  [5, 5]\n  >>> factorizes(70)\n  [2, 5, 7]\n  */\nconst factorizes = (n) => {\n  const factors = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let factor = 1;\n  while (i <= n) {\n    while (j <= n) {\n      if (n % j === 0) {\n        factor++;\n      }\n      j++;\n    }\n    if (factor > 1) {\n      factors.push(factor);\n      i++;\n      factor = 1;\n    }\n    k++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorizes(8)\n  [2, 2, 2]\n  >>> factorizes(25)\n  [5, 5]\n  >>> factorizes(70)\n  [2, 5, 7]\n  */\nconst factorizesNoPrimes = (n) => {\n  const factors = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let factor = 1;\n  while (i <= n) {\n    while (j <= n) {\n      if (n % j === 0) {\n        factor++;\n      }\n      j++;\n    }\n    if (factor > 1) {\n      factors.push(factor);\n      i++;\n      factor = 1;\n    }\n    k++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorizesNoPrimes(8)\n  [2, 2, 2]\n  >>> factorizesNoPrimes(25)\n  [5, 5]\n  >>> factorizesNoPrimes(70)\n  [2, 5, 7]\n  */\nconst factorizesNoPrimesNoPrimes = (n) => {\n  const factors = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let factor = 1;\n  while (i <= n) {\n    while (j <= n) {\n      if (n % j === 0) {\n        factor++;\n      }\n      j++;\n    }\n    if (factor > 1) {\n      factors.push(factor);\n      i++;\n      factor = 1;\n    }\n    k++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorizesNoPrimesNoPrimes(8)\n  [2, 2, 2]\n  >>> factorizesNoPrimesNoPrimes(25)\n  [5, 5]\n  >>> factorizesNoPrimesNoPrimes(70)\n  [2, 5, 7]\n  */\nconst factorizesNoPrimesNoPrimesNoPrimes = (n) => {\n  const factors = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let factor = 1;\n  while (i <= n) {\n    while (j <= n) {\n      if (n % j === 0) {\n        factor++;\n      }\n      j++;\n    }\n    if (factor > 1) {\n      factors.push(factor);\n      i++;\n      factor = 1;\n    }\n    k++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorizesNoPrimesNoPrimesNoPrimes(8)\n  [2, 2, 2]\n  >>> factorizesNoPrimesNoPrimesNoPrimes(25)\n  [5, 5]\n  >>> factorizesNoPrimesNoPrimesNoPrimes(70)\n  [2, 5, 7]\n  */\nconst factorizesNoPrimesNoPrimesNoPrimesNoPrimes = (n) => {\n  const factors = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let factor = 1;\n  while (i <= n) {\n    while (j <= n) {\n      if (n % j === 0) {\n        factor++;\n      }\n      j++;\n    }\n    if (factor > 1) {\n      factors.push(factor);\n      i++;\n      factor = 1;\n    }\n    k++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorizesNoPrimesNoPrimesNoPrimesNoPrimes(8)\n  [2, 2, 2]\n  >>> factorizesNoPrimesNoPrimesNoPrimesNoPrimes(25)\n  [5, 5]\n  >>> factorizesNoPrimesNoPrimesNoPrimesNoPrimes(70)\n  [2, 5, 7]\n  */\nconst factorizesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimes = (n) => {\n  const factors = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let factor = 1;\n  while (i <= n) {\n    while (j <= n) {\n      if (n % j === 0) {\n        factor++;\n      }\n      j++;\n    }\n    if (factor > 1) {\n      factors.push(factor);\n      i++;\n      factor = 1;\n    }\n    k++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorizesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimes(8)\n  [2, 2, 2]\n  >>> factorizesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimes(25)\n  [5, 5]\n  >>> factorizesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimes(70)\n  [2, 5, 7]\n  */\nconst factorizesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimes = (n) => {\n  const factors = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let factor = 1;\n  while (i <= n) {\n    while (j <= n) {\n      if (n % j === 0) {\n        factor++;\n      }\n      j++;\n    }\n    if (factor > 1) {\n      factors.push(factor);\n      i++;\n      factor = 1;\n    }\n    k++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorizesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimes(8)\n  [2, 2, 2]\n  >>> factorizesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimes(25)\n  [5, 5]\n  >>> factorizesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimesNoPrimes(70)\n", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicate([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicate = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicate", "gc": "<|endoftext|>/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicate([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicate = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, val) => {\n    if (seen.has(val)) {\n      seen.delete(val);\n    } else {\n      seen.add(val);\n      acc.push(val);\n    }\n    return acc;\n  }, []);\n};\n\n/**\n * Given a string, return a new string where all occurrences of its characters\n * have been replaced by their Unicode code point.\n * >>> replaceCharacters('Hello World')\n '\\\\u006E\\\\u006F\\\\u0070\\\\u0074\\\\u0020\\\\u007A\\\\u0072\\\\u006B'\n */\nconst replaceCharacters = (str) => {\n  return str.replace(/[\\u006E\\u006F\\u0070\\u0074\\u0020\\u007A\\u0072\\u006B]/g, (char) => String.fromCharCode(char.codePointAt(0)));\n};\n\n/**\n * Given a string, return a new string where all occurrences of its characters\n * have been replaced by their Unicode code point.\n * >>> replaceCharacters('Hello World')\n '\\\\u006E\\\\u006F\\\\u0070\\\\u0074\\\\u0020\\\\u007A\\\\u0072\\\\u006B'\n */\nconst replaceCharactersWithCodePoints = (str) => {\n  return str.replace(/[\\u006E\\u006F\\u0070\\u0074\\u0020\\u007A\\u0072\\u006B]/g, (char) => String.fromCharCode(char.codePointAt(0)));\n};\n\n/**\n * Given a string, return a new string where all occurrences of its characters\n * have been replaced by their Unicode code point.\n * >>> replaceCharacters('Hello World')\n '\\\\u006E\\\\u006F\\\\u0070\\\\u0074\\\\u0020\\\\u007A\\\\u0072\\\\u006B'\n */\nconst replaceCharactersWithCodePointsUnicode = (str) => {\n  return str.replace(/[\\u006E\\u006F\\u0070\\u0074\\u0020\\u007A\\u0072\\u006B]/g, (char) => String.fromCharCode(char.codePointAt(0)));\n};\n\n/**\n * Given a string, return a new string where all occurrences of its characters\n * have been replaced by their Unicode code point.\n * >>> replaceCharacters('Hello World')\n '\\\\u006E\\\\u006F\\\\u0070\\\\u0074\\\\u0020\\\\u007A\\\\u0072\\\\u006B'\n */\nconst replaceCharactersWithCodePointsUnicodeWithCodePoints = (str) => {\n  return str.replace(/[\\u006E\\u006F\\u0070\\u0074\\u0020\\u007A\\u0072\\u006B]/g, (char) => String.fromCharCode(char.codePointAt(0)));\n};\n\n/**\n * Given a string, return a new string where all occurrences of its characters\n * have been replaced by their Unicode code point.\n * >>> replaceCharacters('Hello World')\n '\\\\u006E\\\\u006F\\\\u0070\\\\u0074\\\\u0020\\\\u007A\\\\u0072\\\\u006B'\n */\nconst replaceCharactersWithCodePointsUnicodeWithCodePointsUnicode = (str) => {\n  return str.replace(/[\\u006E\\u006F\\u0070\\u0074\\u0020\\u007A\\u0072\\u006B]/g, (char) => String.fromCharCode(char.codePointAt(0)));\n};\n\n/**\n * Given a string, return a new string where all occurrences of its characters\n * have been replaced by their Unicode code point.\n * >>> replaceCharacters('Hello World')\n '\\\\u006E\\\\u006F\\\\u0070\\\\u0074\\\\u0020\\\\u007A\\\\u0072\\\\u006B'\n */\nconst replaceCharactersWithCodePointsUnicodeWithCodePointsUnicodeWithCodePoints = (str) => {\n  return str.replace(/[\\u006E\\u006F\\u0070\\u0074\\u0020\\u007A\\u0072\\u006B]/g, (char) => String.fromCharCode(char.codePointAt(0)));\n};\n\n/**\n * Given a string, return a new string where all occurrences of its characters\n * have been replaced by their Unicode code point.\n * >>> replaceCharacters('Hello World')\n '\\\\u006E\\\\u006F\\\\u0070\\\\u0074\\\\u0020\\\\u007A\\\\u0072\\\\u006B'\n */\nconst replaceCharactersWithCodePointsUnicodeWithCodePointsUnicodeWithCodePointsUnicode = (str) => {\n  return str.replace(/[\\u006E\\u006F\\u0070\\u0074\\u0020\\u007A\\u0072\\u006B]/g, (char) => String.fromCharCode(char.codePointAt(0)));\n};\n\n/**\n * Given a string, return a new string where all occurrences of its characters\n * have been replaced by their Unicode code point.\n * >>> replaceCharacters('Hello World')\n '\\\\u006E\\\\u006F\\\\u0070\\\\u0074\\\\u0020\\\\u007A\\\\u0072\\\\u006B'\n */\nconst replaceCharactersWithCodePointsUnicodeWithCodePointsUnicodeWithCodePointsUnicodeWithCodePointsUnicode = (str) => {\n  return str.replace(/[\\u006E\\u006F\\u0070\\u0074\\u0020\\u007A\\u0072\\u006B]/g, (char) => String.fromCharCode(char.codePointAt(0)));\n};\n\n/**\n * Given a string, return a new string where all occurrences of its characters\n * have been replaced by their Unicode code point.\n * >>> replaceCharacters('Hello World')\n '\\\\u006E\\\\u006F\\\\u0070\\\\u0074\\\\u0020\\\\u007A\\\\u0072\\\\u006B'\n */\nconst replaceCharactersWithCodePointsUnicodeWithCodePointsUnicodeWithCodePointsUnicodeWithCodePointsUnicodeWithCodePointsUnicode = (str) => {\n  return str.replace(/[\\u006E\\u006F\\u0070\\u0074\\u0020\\u007A\\u0072\\u006B]/g, (char) => String.fromCharCode(char.codePointAt(0)));\n};\n\n/**\n * Given a string, return a new string where all occurrences of its characters\n * have been replaced by their Unicode code point.\n * >>> replaceCharacters('Hello World')\n '\\\\u006E\\\\u006F\\\\u0070\\\\u0074\\\\u0020\\\\u007A\\\\u0072\\\\u006B'\n */\nconst replaceCharactersWithCodePointsUnicodeWithCodePointsUnicodeWithCodePointsUnicodeWithCodePointsUnicodeWithCodePointsUnicodeWithCodePointsUnicode = (str) => {\n  return str.replace(/[\\u006E\\u006F\\u0070\\u0074\\u0020\\u007A\\u0072\\u006B]/g, (char) => String.fromCharCode(char.codePointAt(0)));\n};\n\n/**\n * Given a string, return a new string where all occurrences of its characters\n * have been replaced by their Unicode code point.\n * >>> replaceCharacters('Hello World')\n '\\\\u006E\\\\u006F\\\\u0070\\\\u0074\\\\u0020\\\\u007A\\\\u0072\\\\u006B'\n */\nconst replaceCharactersWithCodePointsUnicodeWithCodePointsUnicodeWithCodePointsUnicodeWithCodePointsUnicodeWithCodePointsUnicodeWithCodePointsUnicodeWithCodePointsUnicode = (str) => {\n  return str.replace(/[\\u006E\\u006F\\u0070\\u0074\\u0020\\u007A\\u0072\\u006B]/g, (char) => ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> flipsCases('Hello')\n  'hELLO'\n  */\nconst flipsCases = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipsCases", "gc": "<|endoftext|>/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> flipsCases('Hello')\n  'hELLO'\n  */\nconst flipsCases = (string) => {\n  return string.toLowerCase().split('')\n   .map(c => c.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, remove all non-alphanumeric characters from it.\n * If no characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If characters are removed, returns an empty string.\n * If ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "gc": "<|endoftext|>/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, curr) => acc += curr, \"\");\n};\n\n/* Convert a string to uppercase\n  >>> toUpperCase('hello')\n  'HELLO'\n  >>> toUpperCase('HELLO')\n  'HELLO'\n  >>> toUpperCase('HELLO WORLD')\n  'HELLO WORLD'\n  */\nconst toUpperCase = (string) => {\n  return string.toUpperCase();\n};\n\n/* Convert a string to lowercase\n  >>> toLowerCase('hello')\n  'hello'\n  >>> toLowerCase('HELLO')\n  'hello'\n  >>> toLowerCase('HELLO WORLD')\n  'hello world'\n  */\nconst toLowerCase = (string) => {\n  return string.toLowerCase();\n};\n\n/* Convert a string to titlecase\n  >>> titlecase('hello')\n  'Hello World'\n  >>> titlecase('HELLO')\n  'Hello World'\n  >>> titlecase('HELLO WORLD')\n  'Hello World!'\n  */\nconst titlecase = (string) => {\n  return string.replace(/\\w\\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});\n};\n\n/* Convert a string to camelCase\n  >>> camelCase('hello')\n  'hello'\n  >>> camelCase('HELLO')\n  'hello'\n  >>> camelCase('HELLO WORLD')\n  'helloWorld'\n  */\nconst camelCase = (string) => {\n  return string.replace(/([A-Z])/g, function(txt){return txt[1].toUpperCase();});\n};\n\n/* Convert a string to snake_case\n  >>> snakeCase('hello')\n  'hello'\n  >>> snakeCase('HELLO')\n  'hello'\n  >>> snakeCase('HELLO WORLD')\n  'helloWorld'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([a-z])/g, function(txt){return txt[1].toLowerCase();});\n};\n\n/* Convert a string to kebab_case\n  >>> kebabCase('hello')\n  'hello'\n  >>> kebabCase('HELLO')\n  'hello'\n  >>> kebabCase('HELLO WORLD')\n  'hello-world'\n  */\nconst kebabCase = (string) => {\n  return string.replace(/([A-Z])/g, function(txt){return txt[0].toUpperCase();});\n};\n\n/* Convert a string to PascalCase\n  >>> pascalCase('hello')\n  'Hello'\n  >>> pascalCase('HELLO')\n  'Hello'\n  >>> pascalCase('HELLO WORLD')\n  'HelloWorld'\n  */\nconst pascalCase = (string) => {\n  return string.replace(/([a-z])/g, function(txt){return txt[0].toLowerCase(); });\n};\n\n/* Convert a string to CamelCase\n  >>> camelCase('hello')\n  'hello'\n  >>> camelCase('HELLO')\n  'hello'\n  >>> camelCase('HELLO WORLD')\n  'helloWorld'\n  */\nconst camelCase = (string) => {\n  return string.replace(/([A-Z])/g, function(txt){return txt[0].toUpperCase(); });\n};\n\n/* Convert a string to snake_case\n  >>> snakeCase('hello')\n  'hello'\n  >>> snakeCase('HELLO')\n  'hello'\n  >>> snakeCase('HELLO WORLD')\n  'helloWorld'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([a-z])/g, function(txt){return txt[0].toLowerCase(); });\n};\n\n/* Convert a string to kebab_case\n  >>> kebabCase('hello')\n  'hello'\n  >>> kebabCase('HELLO')\n  'hello'\n  >>> kebabCase('HELLO WORLD')\n  'hello-world'\n  */\nconst kebabCase = (string) => {\n  return string.replace(/([A-Z])/g, function(txt){return txt[0].toUpperCase(); });\n};\n\n/* Convert a string to PascalCase\n  >>> pascalCase('hello')\n  'Hello'\n  >>> pascalCase('HELLO')\n  'Hello'\n  >>> pascalCase('HELLO WORLD')\n  'HelloWorld'\n  */\nconst pascalCase = (string) => {\n  return string.replace(/([a-z])/g, function(txt){return txt[0].toLowerCase(); });\n};\n\n/* Convert a string to CamelCase\n  >>> camelCase('hello')\n  'hello'\n  >>> camelCase('HELLO')\n  'hello'\n  >>> camelCase('HELLO WORLD')\n  'helloWorld'\n  */\nconst camelCase = (string) => {\n  return string.replace(/([A-Z])/g, function(txt){return txt[0].toUpperCase(); });\n};\n\n/* Convert a string to snake_case\n  >>> snakeCase('hello')\n  'hello'\n  >>> snakeCase('HELLO')\n  'hello'\n  >>> snakeCase('HELLO WORLD')\n  'helloWorld'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([a-z])/g, function(txt){return txt[0].toLowerCase(); });\n};\n\n/* Convert a string to kebab_case\n  >>> kebabCase('hello')\n  'hello'\n  >>> kebabCase('HELLO')\n  'hello'\n  >>> kebabCase('HELLO WORLD')\n  'hello-world'\n  */\nconst kebabCase = (string) => {\n  return string.replace(/([A-Z])/g, function(txt){return txt[0].toUpperCase(); });\n};\n\n/* Convert a string to PascalCase\n  >>> pascalCase('hello')\n  'Hello'\n  >>> pascalCase('HELLO')\n  'Hello'\n  >>> pascalCase('HELLO WORLD')\n  'HelloWorld'\n  */\nconst pascalCase = (string) => {\n  return string.replace(/([a-z])/g, function(txt){return txt[0].toLowerCase(); });\n};\n\n/* Convert a string to CamelCase\n  >>> camelCase('hello')\n  'hello'\n  >>> camelCase('HELLO')\n  'hello'\n  >>> camelCase('HELLO WORLD')\n  'helloWorld'\n  */\nconst camelCase = (string) => {\n  return string.replace(/([A-Z])/g, function(txt){return txt[0].toUpperCase(); });\n};\n\n/* Convert a string to snake_case\n  >>> snakeCase('hello')\n  'hello'\n  >>> snakeCase('HELLO')\n  'hello'\n  >>> snakeCase('HELLO WORLD')\n  'helloWorld'\n  */\nconst snakeCase = (string) => {\n  return string.replace(/([a-z])/g, function(txt){return txt[0].toLowerCase(); });\n};\n\n/* Convert a string to kebab_case\n  >>> kebabCase('hello')\n  'hello'\n  >>> kebabCase('HELLO')\n  'hello'\n  >>> kebabCase('HELLO WORLD')\n  'hello-world'\n  */\nconst kebabCase = (string) => {\n  return string.replace(/([A-Z])/g, function(txt){return txt[0].toUpperCase(); });\n};\n\n/* Convert a string to PascalCase\n  >>> pascalCase('hello')\n  'Hello'\n  >>> pascalCase('HELLO')\n  'Hello'\n  >>> pascalCase('HELLO WORLD')\n  'HelloWorld'\n  */\nconst pascalCase = (", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only keeping those that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only keeping those that do not start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only keeping those that do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only keeping those that do not start with a given prefix or suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only keeping those that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only keeping those that do not start with a given prefix or suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only keeping those that do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only keeping those that do not start with a given prefix or suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only keeping those that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only keeping those that do not start with a given prefix or suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only keeping those that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only keeping those that do not start with a given prefix or suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only keeping those that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only keeping those that do not start with a given prefix or suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterByPrefix = filterBySuffix;\n\n/**\n * Filter an input list of strings only keeping those that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only keeping those that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only keeping those that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = filterBySuffix;\n\n/**\n * Filter an input list of strings only keeping those that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only keeping those that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = filterBySuffix;\n\n/**\n * Filter an input list of strings only keeping those that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = filterByPrefix;\n\n/**\n * Filter an input list of strings only keeping those that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySuffix = filterBySuffix;", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeros([1, 2, 3])\n  false\n  >>> belowZeros([1, 2, -4, 5])\n  true\n  */\nconst belowZeros = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZeros", "gc": "<|endoftext|>/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeros([1, 2, 3])\n  false\n  >>> belowZeros([1, 2, -4, 5])\n  true\n  */\nconst belowZeros = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeros([1, 2, 3])\n  false\n  >>> belowZeros([1, 2, -4, 5])\n  true\n  */\nconst aboveZeros = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance -= operations[i];\n  }\n  return balance > 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeros([1, 2, 3])\n  false\n  >>> belowZeros([1, 2, -4, 5])\n  true\n  */\nconst aboveZeros = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeros([1, 2, 3])\n  false\n  >>> belowZeros([1, 2, -4, 5])\n  true\n  */\nconst aboveZeros = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance -= operations[i];\n  }\n  return balance > 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeros([1, 2, 3])\n  false\n  >>> belowZeros([1, 2, -4, 5])\n  true\n  */\nconst aboveZeros = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeros([1, 2, 3])\n  false\n  >>> belowZeros([1, 2, -4, 5])\n  true\n  */\nconst aboveZeros = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance -= operations[i];\n  }\n  return balance > 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeros([1, 2, 3])\n  false\n  >>> belowZeros([1, 2, -4, 5])\n  true\n  */\nconst aboveZeros = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeros([1, 2, 3])\n  false\n  >>> belowZeros([1, 2, -4, 5])\n  true\n  */\nconst aboveZeros = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance -= operations[i];\n  }\n  return balance > 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeros([1, 2, 3])\n  false\n  >>> belowZeros([1, 2, -4, 5])\n  true\n  */\nconst aboveZeros = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeros([1, 2, 3])\n  false\n  >>> belowZeros([1, 2, -4, 5])\n  true\n  */\nconst aboveZeros = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance -= operations[i];\n  }\n  return balance > 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeros([1, 2, 3])\n  false\n  >>> belowZeros([1, 2, -4, 5])\n  true\n  */\nconst aboveZeros = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeros([1, 2, 3])\n  false\n  >>> belowZeros([1, 2, -4, 5])\n  true\n  */\nconst aboveZeros = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance -= operations[i];\n  }\n  return balance > 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeros([1, 2, 3])\n  false\n  >>> belowZeros([1, 2, -4, 5])\n  true\n  */\nconst aboveZeros = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance > 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> gottenPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> gottenPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst gottenPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "gottenPositive", "gc": "<|endoftext|>/*Return only positive numbers in the list.\n  >>> gottenPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> gottenPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst gottenPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/*Return only negative numbers in the list.\n  >>> gottenNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> gottenNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst gottenNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/*Return all numbers in the list that are even.\n  >>> gottenEven([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst gottenEven = (l) => {\n  return l.filter(n => n % 2 === 0)\n}\n\n/*Return all numbers in the list that are odd.\n  >>> gottenOdd([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenOdd([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst gottenOdd = (l) => {\n  return l.filter(n => n % 2!== 0)\n}\n\n/*Return all numbers in the list that are divisible by 3.\n  >>> gottenDivisible([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst gottenDivisible = (l) => {\n  return l.filter(n => n % 3 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 5.\n  >>> gottenDivisible([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst gottenDivisible = (l) => {\n  return l.filter(n => n % 5 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 7.\n  >>> gottenDivisible([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst gottenDivisible = (l) => {\n  return l.filter(n => n % 7 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 9.\n  >>> gottenDivisible([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst gottenDivisible = (l) => {\n  return l.filter(n => n % 9 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 11.\n  >>> gottenDivisible([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst gottenDivisible = (l) => {\n  return l.filter(n => n % 11 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 13.\n  >>> gottenDivisible([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst gottenDivisible = (l) => {\n  return l.filter(n => n % 13 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 15.\n  >>> gottenDivisible([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst gottenDivisible = (l) => {\n  return l.filter(n => n % 15 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 17.\n  >>> gottenDivisible([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst gottenDivisible = (l) => {\n  return l.filter(n => n % 17 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 19.\n  >>> gottenDivisible([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst gottenDivisible = (l) => {\n  return l.filter(n => n % 19 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 23.\n  >>> gottenDivisible([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst gottenDivisible = (l) => {\n  return l.filter(n => n % 23 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 25.\n  >>> gottenDivisible([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst gottenDivisible = (l) => {\n  return l.filter(n => n % 25 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 29.\n  >>> gottenDivisible([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst gottenDivisible = (l) => {\n  return l.filter(n => n % 29 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 31.\n  >>> gottenDivisible([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst gottenDivisible = (l) => {\n  return l.filter(n => n % 31 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 35.\n  >>> gottenDivisible([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst gottenDivisible = (l) => {\n  return l.filter(n => n % 35 === 0)\n}\n\n/*Return all numbers in the list that are divisible by 37.\n  >>> gottenDivisible([-1, 2, -4, 5, 6])\n  [2, 4, 6]\n  >>> gottenDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst gottenDivisible = (l) => {\n  return l.filter(n => n % 37 === 0)\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "gc": "<|endoftext|>/*Return true if a given number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrimeOrZero = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrimeOrZero(13441)\n  true\n  >>> isPrimeOrZero(61)\n  true\n  >>> isPrimeOrZero(4)\n  false\n  >>> isPrimeOrZero(1)\n  false\n  */\nconst isPrimeOrZeroOrOne = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrimeOrZeroOrOne(13441)\n  true\n  >>> isPrimeOrZeroOrOne(61)\n  true\n  >>> isPrimeOrZeroOrOne(4)\n  false\n  >>> isPrimeOrZeroOrOne(1)\n  false\n  */\nconst isPrimeOrOne = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrimeOrOne(13441)\n  true\n  >>> isPrimeOrOne(61)\n  true\n  >>> isPrimeOrOne(4)\n  false\n  >>> isPrimeOrOne(1)\n  false\n  */\nconst isPrimeOrOneOrZero = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrimeOrOneOrZero(13441)\n  true\n  >>> isPrimeOrOneOrZero(61)\n  true\n  >>> isPrimeOrOneOrZero(4)\n  false\n  >>> isPrimeOrOneOrZero(1)\n  false\n  */\nconst isPrimeOrOneOrZeroOrOne = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrimeOrOneOrZeroOrOne(13441)\n  true\n  >>> isPrimeOrOneOrZeroOrOne(61)\n  true\n  >>> isPrimeOrOneOrZeroOrOne(4)\n  false\n  >>> isPrimeOrOneOrZeroOrOne(1)\n  false\n  */\nconst isDivisible = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isDivisible(13441)\n  true\n  >>> isDivisible(61)\n  true\n  >>> isDivisible(4)\n  false\n  >>> isDivisible(1)\n  false\n  */\nconst isDivisibleOrZero = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isDivisibleOrZero(13441)\n  true\n  >>> isDivisibleOrZero(61)\n  true\n  >>> isDivisibleOrZero(4)\n  false\n  >>> isDivisibleOrZero(1)\n  false\n  */\nconst isDivisibleOrZeroOrOne = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isDivisibleOrZeroOrOne(13441)\n  true\n  >>> isDivisibleOrZeroOrOne(61)\n  true\n  >>> isDivisibleOrZeroOrOne(4)\n  false\n  >>> isDivisibleOrZeroOrOne(1)\n  false\n  */\nconst isDivisibleOrOne = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isDivisibleOrOne(13441)\n  true\n  >>> isDivisibleOrOne(61)\n  true\n  >>> isDivisibleOrOne(4)\n  false\n  >>> isDivisibleOrOne(1)\n  false\n  */\nconst isDivisibleOrOneOrZero = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isDivisibleOrOneOrZero(13441)\n  true\n  >>> isDivisibleOrOneOrZero(61)\n  true\n  >>> isDivisibleOrOneOrZero(4)\n  false\n  >>> isDivisibleOrOneOrZero(1)\n  false\n  */\nconst isDivisibleOrOneOrZeroOrOne = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrimeOrZeroOrOneOrZero(13441)\n  true\n  >>> isPrimeOrZeroOrOneOrZero(61)\n  true\n  >>> isPrimeOrZeroOrOneOrZero(4)\n  false\n  >>> isPrimeOrZeroOrOneOrZero(1)\n  false\n  */\nconst isPrimeOrZeroOrOneOrZero = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrimeOrOneOrZeroOrOne(13441)\n  true\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  if (xs.length % 2!== 0) {\n    throw new Error('findZero expects xs to be a list');\n  }\n  if (xs.length % 2 === 1) {\n    return xs[0];\n  }\n  const zero = xs[0];\n  const rest = xs.slice(1);\n  for (let i = 0; i < rest.length; i++) {\n    if (rest[i] === 0) {\n      return zero;\n    }\n  }\n  return zero;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly2 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero2 = (xs) => {\n  if (xs.length % 2!== 0) {\n    throw new Error('findZero expects xs to be a list');\n  }\n  if (xs.length % 2 === 1) {\n    return xs[0];\n  }\n  const zero = xs[0];\n  const rest = xs.slice(1);\n  for (let i = 0; i < rest.length; i++) {\n    if (rest[i] === 0) {\n      return zero;\n    }\n  }\n  return zero;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly3 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly4 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly5 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly6 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly7 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly8 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly9 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly10 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly11 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly12 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly13 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly14 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly15 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortsThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortsThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortsThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortsThird", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortsThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortsThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortsThird = (l) => {\n  let l2 = l.slice();\n  let l3 = l2.slice();\n  let l4 = l3.slice();\n  let l5 = l4.slice();\n  let l6 = l5.slice();\n  let l7 = l6.slice();\n  let l8 = l7.slice();\n  let l9 = l8.slice();\n  let l10 = l9.slice();\n  let l11 = l10.slice();\n  let l12 = l11.slice();\n  let l13 = l12.slice();\n  let l14 = l13.slice();\n  let l15 = l14.slice();\n  let l16 = l15.slice();\n  let l17 = l16.slice();\n  let l18 = l17.slice();\n  let l19 = l18.slice();\n  let l20 = l19.slice();\n  let l21 = l20.slice();\n  let l22 = l21.slice();\n  let l23 = l22.slice();\n  let l24 = l23.slice();\n  let l25 = l24.slice();\n  let l26 = l25.slice();\n  let l27 = l26.slice();\n  let l28 = l27.slice();\n  let l29 = l28.slice();\n  let l30 = l29.slice();\n  let l31 = l30.slice();\n  let l32 = l31.slice();\n  let l33 = l32.slice();\n  let l34 = l33.slice();\n  let l35 = l34.slice();\n  let l36 = l35.slice();\n  let l37 = l36.slice();\n  let l38 = l37.slice();\n  let l39 = l38.slice();\n  let l40 = l39.slice();\n  let l41 = l40.slice();\n  let l42 = l41.slice();\n  let l43 = l42.slice();\n  let l44 = l43.slice();\n  let l45 = l44.slice();\n  let l46 = l45.slice();\n  let l47 = l46.slice();\n  let l48 = l47.slice();\n  let l49 = l48.slice();\n  let l50 = l49.slice();\n  let l51 = l50.slice();\n  let l52 = l51.slice();\n  let l53 = l52.slice();\n  let l54 = l53.slice();\n  let l55 = l54.slice();\n  let l56 = l55.slice();\n  let l57 = l56.slice();\n  let l58 = l57.slice();\n  let l59 = l58.slice();\n  let l60 = l59.slice();\n  let l61 = l60.slice();\n  let l62 = l61.slice();\n  let l63 = l62.slice();\n  let l64 = l63.slice();\n  let l65 = l64.slice();\n  let l66 = l65.slice();\n  let l67 = l66.slice();\n  let l68 = l67.slice();\n  let l69 = l68.slice();\n  let l70 = l69.slice();\n  let l71 = l70.slice();\n  let l72 = l71.slice();\n  let l73 = l72.slice();\n  let l74 = l73.slice();\n  let l75 = l74.slice();\n  let l76 = l75.slice();\n  let l77 = l76.slice();\n  let l78 = l77.slice();\n  let l79 = l78.slice();\n  let l80 = l79.slice();\n  let l81 = l80.slice();\n  let l82 = l81.slice();\n  let l83 = l82.slice();\n  let l84 = l83.slice();\n  let l85 = l84.slice();\n  let l86 = l85.slice();\n  let l87 = l86.slice();\n  let l88 = l87.slice();\n  let l89 = l88.slice();\n  let l90 = l89.slice();\n  let l91 = l90.slice();\n  let l92 = l91.slice();\n  let l93 = l92.slice();\n  let l94 = l93.slice();\n  let l95 = l94.slice();\n  let l96 = l95.slice();\n  let l97 = l96.slice();\n  let l98 = l97.slice();\n  let l99 = l98.slice();\n  let l100 = l99.slice();\n  let l101 = l100.slice();\n  let l102 = l101.slice();\n  let l103 = l102.slice();\n  let l104 = l103.slice();\n  let l105 = l104.slice();\n  let l106 = l105.slice();\n  let l107 = l106.slice();\n  let l108 = l107.slice();\n  let l109 = l108.slice();\n  let l110 = l109.slice();\n  let l111 = l110.slice();\n  let l112 = l111.slice();\n  let l113 = l112.slice();\n  let l114 = l113.slice();\n  let l115 = l114.slice();\n  let l116 = l115.slice();\n  let l117 = l116.slice();\n  let l118 = l117.slice();\n  let l119 = l118.slice();\n  let l120 = l119.slice();\n  let l121 = l120.slice();\n  let l122 = l121.slice();\n  let l123 = l122.slice();\n  let l124 = l123.slice();\n  let l125 = l124.slice();\n  let l126 = l125.slice();\n  let l127 = l126.slice();\n  let l128 = l127.slice();\n  let l129 = l128.slice();\n  let l130 = l129.slice();\n  let l131 = l130.slice();\n  let l132 = l131.slice();\n  let l133 = l132.slice();\n  let l134 = l133.slice();\n  let l135 = l134.slice();\n  let l136 = l135.slice();\n  let l137 = l136.slice();\n  let l138 = l137.slice();\n  let l139 = l138.slice();\n  let l140 = l139.slice();\n  let l141 = l140.slice();\n  let l142 = l141.slice();\n  let l143 = l142.slice();\n  let l144 = l143.slice();\n  let l145 = l144.slice();\n  let l146 = l145.slice();\n  let l147 = l146.slice();\n  let l148 = l147.slice();\n  let l149 = l148.slice();\n  let l150 = l149.slice();\n  let l151 = l150.slice();\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "gc": "<|endoftext|>/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const seen = new Set();\n  return l.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true));\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  const seen = new Set();\n  return l.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true)).map((v, i) => a[i][key]);\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (l, key) => {\n  const seen = new Set();\n  return l.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true)).map((v, i) => a[i][key]).filter((v, i, a) =>!a.includes(v));\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKey = (l, key) => {\n  const seen = new Set();\n  return l.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true)).map((v, i) => a[i][key]).filter((v, i, a) =>!a.includes(v));\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeys = (a, key) => {\n  const seen = new Set();\n  return a.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true)).map((v, i) => a[i][key]).filter((v, i, a) =>!a.includes(v));\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysKey = (l, key) => {\n  const seen = new Set();\n  return l.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true)).map((v, i) => a[i][key]).filter((v, i, a) =>!a.includes(v));\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysKeys = (a, key) => {\n  const seen = new Set();\n  return a.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true)).map((v, i) => a[i][key]).filter((v, i, a) =>!a.includes(v));\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysKeysKey = (l, key) => {\n  const seen = new Set();\n  return l.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true)).map((v, i) => a[i][key]).filter((v, i, a) =>!a.includes(v));\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysKeysKeys = (a, key) => {\n  const seen = new Set();\n  return a.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true)).map((v, i) => a[i][key]).filter((v, i, a) =>!a.includes(v));\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysKeysKeysKey = (l, key) => {\n  const seen = new Set();\n  return l.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true)).map((v, i) => a[i][key]).filter((v, i, a) =>!a.includes(v));\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysKeysKeysKeys = (a, key) => {\n  const seen = new Set();\n  return a.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true)).map((v, i) => a[i][key]).filter((v, i, a) =>!a.includes(v));\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysKeysKeysKeysKey = (l, key) => {\n  const seen = new Set();\n  return l.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true)).map((v, i) => a[i][key]).filter((v, i, a) =>!a.includes(v));\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysKeysKeysKeysKeys = (a, key) => {\n  const seen = new Set();\n  return a.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true)).map((v, i) => a[i][key]).filter((v, i, a) =>!a.includes(v));\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysKeysKeysKeysKeysKey = (l, key) => {\n  const seen = new Set();\n  return l.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true)).map((v, i) => a[i][key]).filter((v, i, a) =>!a.includes(v));\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysKeysKeysKeysKeysKeys = (a, key) => {\n  const seen = new Set();\n  return a.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true)).map((v, i) => a[i][key]).filter((v, i, a) =>!a.includes(v));\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysKeysKeysKeysKeysKeysKey = (l, key) => {\n  const seen = new Set();\n  return l.filter((v, i, a) => seen.has(v)? false : (seen.add(v), true)).map((v, i) => a[i][key]).filter((v, i, a) =>!a.includes(v));\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysKeysKeysKeysKeysKey", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum element in the list.\n  >>> maxElements([1, 2, 3])\n  3\n  >>> maxElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElements = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElements", "gc": "<|endoftext|>/*Return maximum element in the list.\n  >>> maxElements([1, 2, 3])\n  3\n  >>> maxElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElements = (l) => {\n  return l.length > 0? Math.max.apply(null, l) : undefined;\n};\n\n/*Return minimum element in the list.\n  >>> minElements([1, 2, 3])\n  1\n  >>> minElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst minElements = (l) => {\n  return l.length > 0? Math.min.apply(null, l) : undefined;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumElements([1, 2, 3])\n  6\n  >>> sumElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -45\n  */\nconst sumElements = (l) => {\n  return l.length > 0? l.reduce((a, b) => a + b, 0) : undefined;\n};\n\n/*Return average of all elements in the list.\n  >>> averageElements([1, 2, 3])\n  1.5\n  >>> averageElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2.75\n  */\nconst averageElements = (l) => {\n  return l.length > 0? l.reduce((a, b) => a + b) / l.length : undefined;\n};\n\n/*Return median of all elements in the list.\n  >>> medianElements([1, 2, 3])\n  3\n  >>> medianElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2\n  */\nconst medianElements = (l) => {\n  return l.length > 0? l.sort((a, b) => a - b).pop() : undefined;\n};\n\n/*Return standard deviation of all elements in the list.\n  >>> stdElements([1, 2, 3])\n  0.5\n  >>> stdElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst stdElements = (l) => {\n  return l.length > 0? Math.sqrt(l.reduce((a, b) => a + b)) : undefined;\n};\n\n/*Return mode of all elements in the list.\n  >>> modeElements([1, 2, 3])\n  3\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2\n  */\nconst modeElements = (l) => {\n  return l.length > 0? l.sort((a, b) => a - b).pop() : undefined;\n};\n\n/*Return mode of all elements in the list ignoring duplicates.\n  >>> modeElements([1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzzes(50)\n  0\n  >>> fizzBuzzes(78)\n  2\n  >>> fizzBuzzes(79)\n  3\n  */\nconst fizzBuzzes = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzzes", "gc": "<|endoftext|>/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzzes(50)\n  0\n  >>> fizzBuzzes(78)\n  2\n  >>> fizzBuzzes(79)\n  3\n  */\nconst fizzBuzzes = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0) {\n      count += 1;\n    } else if (i % 11 === 0) {\n      count += 2;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 8 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzzes(50)\n  0\n  >>> fizzBuzzes(78)\n  2\n  >>> fizzBuzzes(79)\n  3\n  */\nconst fizzBuzzes = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0) {\n      count += 1;\n    } else if (i % 11 === 0) {\n      count += 2;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 9 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzzes(50)\n  0\n  >>> fizzBuzzes(78)\n  2\n  >>> fizzBuzzes(79)\n  3\n  */\nconst fizzBuzzes = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0) {\n      count += 1;\n    } else if (i % 11 === 0) {\n      count += 2;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 0 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzzes(50)\n  0\n  >>> fizzBuzzes(78)\n  2\n  >>> fizzBuzzes(79)\n  3\n  */\nconst fizzBuzzes = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0) {\n      count += 1;\n    } else if (i % 11 === 0) {\n      count += 2;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 1 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzzes(50)\n  0\n  >>> fizzBuzzes(78)\n  2\n  >>> fizzBuzzes(79)\n  3\n  */\nconst fizzBuzzes = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0) {\n      count += 1;\n    } else if (i % 11 === 0) {\n      count += 2;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 2 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzzes(50)\n  0\n  >>> fizzBuzzes(78)\n  2\n  >>> fizzBuzzes(79)\n  3\n  */\nconst fizzBuzzes = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0) {\n      count += 1;\n    } else if (i % 11 === 0) {\n      count += 2;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 3 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzzes(50)\n  0\n  >>> fizzBuzzes(78)\n  2\n  >>> fizzBuzzes(79)\n  3\n  */\nconst fizzBuzzes = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0) {\n      count += 1;\n    } else if (i % 11 === 0) {\n      count += 2;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 4 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzzes(50)\n  0\n  >>> fizzBuzzes(78)\n  2\n  >>> fizzBuzzes(79)\n  3\n  */\nconst fizzBuzzes = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0) {\n      count += 1;\n    } else if (i % 11 === 0) {\n      count += 2;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 5 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzzes(50)\n  0\n  >>> fizzBuzzes(78)\n  2\n  >>> fizzBuzzes(79)\n  3\n  */\nconst fizzBuzzes = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0) {\n      count += 1;\n    } else if (i % 11 === 0) {\n      count += 2;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 6 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzzes(50)\n  0\n  >>> fizzBuzzes(78)\n  2\n  >>> fizzBuzzes(79)\n  3\n  */\nconst fizzBuzzes = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0) {\n      count += 1;\n    } else if (i % 11 === 0) {\n      count += 2;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzzes(50)\n  0\n  >>> fizzBuzzes(78)\n  2\n  >>> fizzBuzzes(79)\n  3\n  */\nconst fizzBuzzes = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0) {\n      count += 1;\n    } else if (i % 11 === 0) {\n      count += 2;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 8 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzzes(50)\n  0\n  >>> fizzBuzzes(78)\n  2\n  >>> fizzBuzzes(79)\n  3\n  */\nconst fizzBuzzes = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0) {\n      count += 1;\n    } else if (i % 11 === 0) {\n      count += 2;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 9 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzzes(50)\n  0\n  >>> fizzBuzzes(78)\n  2\n  >>> fizzBuzzes(79)\n  3\n  */\nconst fizzBuzzes = (n) => {\n  let count = 0;\n  for (let i = n; i > 0; i--) {\n    if (i % 13 === 0) {\n      count += 1;\n    } else if (i % 11 === 0) {\n      count += 2;", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortsEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortsEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortsEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortsEven", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortsEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortsEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortsEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return [...even,...odd]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortsOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortsOdd([5, 6, 3, 4])\n  [4, 3, 2, 5]\n  */\nconst sortsOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortsEvenOdd([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> sortsEvenOdd([5, 6, 3, 4])\n  [3, 4, 6, 5]\n  */\nconst sortsEvenOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortsEvenOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortsEvenOddOdd([5, 6, 3, 4])\n  [3, 4, 6, 5, 2]\n  */\nconst sortsEvenOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortsEvenOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortsEvenOddOddOdd([5, 6, 3, 4])\n  [3, 4, 6, 5, 2]\n  */\nconst sortsEvenOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortsEvenOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortsEvenOddOddOddOdd([5, 6, 3, 4])\n  [3, 4, 6, 5, 2]\n  */\nconst sortsEvenOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortsEvenOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortsEvenOddOddOddOddOdd([5, 6, 3, 4])\n  [3, 4, 6, 5, 2]\n  */\nconst sortsEvenOddOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortsEvenOddOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortsEvenOddOddOddOddOddOdd([5, 6, 3, 4])\n  [3, 4, 6, 5, 2]\n  */\nconst sortsEvenOddOddOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortsEvenOddOddOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortsEvenOddOddOddOddOddOddOdd([5, 6, 3, 4])\n  [3, 4, 6, 5, 2]\n  */\nconst sortsEvenOddOddOddOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sortsEvenOddOddOddOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortsEvenOddOddOddOddOddOddOddOdd([5, 6, 3, 4])\n  [3, 4, 6, 5, 2]", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "gc": "<|endoftext|>/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7] + group[8]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7] + group[8] + group[9]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7] + group[8] + group[9] + group[10]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7] + group[8] + group[9] + group[10] + group[11]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroupGroupGroupGroupGroup = (s) => {\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFibs returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFibs(1)\n  2\n  >>> primeFibs(2)\n  3\n  >>> primeFibs(3)\n  5\n  >>> primeFibs(4)\n  13\n  >>> primeFibs(5)\n  89\n  */\nconst primeFibs = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFibs", "gc": "<|endoftext|>/*\n  primeFibs returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFibs(1)\n  2\n  >>> primeFibs(2)\n  3\n  >>> primeFibs(3)\n  5\n  >>> primeFibs(4)\n  13\n  >>> primeFibs(5)\n  89\n  */\nconst primeFibs = (n) => {\n  let a = 1, b = 1, c = 1, d = 1;\n  let prime = 1;\n  while (a <= n) {\n    if (a % 2 === 0) {\n      prime++;\n    }\n    if (a % 3 === 0) {\n      prime++;\n    }\n    if (a % 5 === 0) {\n      prime++;\n    }\n    if (a % 7!== 0) {\n      prime++;\n    }\n    prime = prime % 10;\n    if (prime === 1) {\n      a = 1;\n      b = 2;\n      c = 2;\n      d = 1;\n    } else {\n      a = (a + b + c + d) % 10;\n      b = ((a + b + c + d) % 10) + 1;\n      c = ((a + b + c + d) % 10) + 2;\n      d = ((a + b + c + d) % 10) + 3;\n    }\n  }\n  return prime;\n};\n\n/*\n  primes returns an array of prime numbers.\n  >>> primes(5)\n  [2, 3, 5, 7]\n  >>> primes(10)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]\n  >>> primes(15)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n  >>> primes(20)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n  >>> primes(30)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n  >>> primes(40)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanerAbsolutesDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanerAbsolutesDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanerAbsolutesDeviation", "gc": "<|endoftext|>/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanerAbsolutesDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanerAbsolutesDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansMean = means.reduce((a, b) => a + b, 0);\n  const meansDeviation = numbers.map((number) => number - meansMean);\n  const meansAbsoluteDeviation = meansDeviation.map((number) => Math.abs(number));\n  const meansAbsoluteDeviationMean = meansAbsoluteDeviation.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVariance = meansAbsoluteDeviation.map((number) => Math.pow(number, 2));\n  const meansAbsoluteDeviationVarianceMean = meansAbsoluteDeviationVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVariance = meansAbsoluteDeviationVariance.map((number) => Math.pow(number, 3));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 4));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 5));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 6));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 7));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 8));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 9));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 10));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 11));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 12));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 13));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 14));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 15));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 16));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 17));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 18));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 19));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 20));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, 21));\n  const meansAbsoluteDeviationVarianceVarianceMean = meansAbsoluteDeviationVarianceVariance.reduce((a, b) => a + b, 0);\n  const meansAbsoluteDeviationVarianceVarianceVariance = meansAbsoluteDeviationVarianceVariance.map((number) => Math.pow(number, ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSummingToZeroed takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triplesSummingToZeroed([1, 3, 5, 0])\n  false\n  >>> triplesSummingToZeroed([1, 3, -2, 1])\n  true\n  >>> triplesSummingToZeroed([1, 2, 3, 7])\n  false\n  >>> triplesSummingToZeroed([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSummingToZeroed([1])\n  false\n  */\nconst triplesSummingToZeroed = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSummingToZeroed", "gc": "<|endoftext|>/*\n  triplesSummingToZeroed takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triplesSummingToZeroed([1, 3, 5, 0])\n  false\n  >>> triplesSummingToZeroed([1, 3, -2, 1])\n  true\n  >>> triplesSummingToZeroed([1, 2, 3, 7])\n  false\n  >>> triplesSummingToZeroed([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSummingToZeroed([1])\n  false\n  */\nconst triplesSummingToZeroed = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  triplesSummingToOnes takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to one, and false otherwise.\n\n  >>> triplesSummingToOnes([1, 3, 5, 0])\n  false\n  >>> triplesSummingToOnes([1, 3, -2, 1])\n  true\n  >>> triplesSummingToOnes([1, 2, 3, 7])\n  false\n  >>> triplesSummingToOnes([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSummingToOnes([1])\n  false\n  */\nconst triplesSummingToOnes = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  triplesSummingToOther takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to other, and false otherwise.\n\n  >>> triplesSummingToOther([1, 3, 5, 0])\n  false\n  >>> triplesSummingToOther([1, 3, -2, 1])\n  true\n  >>> triplesSummingToOther([1, 2, 3, 7])\n  false\n  >>> triplesSummingToOther([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSummingToOther([1])\n  false\n  */\nconst triplesSummingToOther = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum > 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  triplesSummingToOnesOrOther() takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to one, and false otherwise.\n\n  >>> triplesSummingToOnesOrOther([1, 3, 5, 0])\n  false\n  >>> triplesSummingToOnesOrOther([1, 3, -2, 1])\n  true\n  >>> triplesSummingToOnesOrOther([1, 2, 3, 7])\n  false\n  >>> triplesSummingToOnesOrOther([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSummingToOnesOrOther([1])\n  false\n  */\nconst triplesSummingToOnesOrOther = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  triplesSummingToOnesOrOther() takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to one, and false otherwise.\n\n  >>> triplesSummingToOnesOrOther([1, 3, 5, 0])\n  false\n  >>> triplesSummingToOnesOrOther([1, 3, -2, 1])\n  true\n  >>> triplesSummingToOnesOrOther([1, 2, 3, 7])\n  false\n  >>> triplesSummingToOnesOrOther([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSummingToOnesOrOther([1])\n  false\n  */\nconst triplesSummingToOnesOrOther = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum > 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  triplesSummingToOther takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to other, and false otherwise.\n\n  >>> triplesSummingToOther([1, 3, 5, 0])\n  false\n  >>> triplesSummingToOther([1, 3, -2, 1])\n  true\n  >>> triplesSummingToOther([1, 2, 3, 7])\n  false\n  >>> triplesSummingToOther([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSummingToOther([1])\n  false\n  */\nconst triplesSummingToOther = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum > 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  triplesSummingToOther takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to other, and false otherwise.\n\n  >>> triplesSummingToOther([1, 3, 5, 0])\n  false\n  >>> triplesSummingToOther([1, 3, -2, 1])\n  true\n  >>> triplesSummingToOther([1, 2, 3, 7])\n  false\n  >>> triplesSummingToOther([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSummingToOther([1])\n  false\n  */\nconst triplesSummingToOther = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum > 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  triplesSummingToOnesOrOther takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to one, and false otherwise.\n\n  >>> triplesSummingToOnesOrOther([1, 3, 5, 0])\n  false\n  >>> triplesSummingToOnesOrOther([1, 3, -2, 1])\n  true\n  >>> triplesSummingToOnesOrOther([1, 2, 3, 7])\n  false\n  >>> triplesSummingToOnesOrOther([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSummingToOnesOrOther([1])\n  false\n  */\nconst triplesSummingToOnesOrOther = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  triplesSummingToOnesOrOther takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to one, and false otherwise.\n\n  >>> triplesSummingToOnesOrOther([1, 3, 5, 0])\n  false\n  >>> triplesSummingTo", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carsRacesCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carsRacesCollision", "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carsRacesCollision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % n];\n    if (car1.speed > car2.speed) {\n      collisions++;\n    }\n  }\n  return collisions;\n};\n\n/*\n  Given a road network, find the shortest path from each car in the network\n  to the nearest car on the road.\n\n  Return an array of arrays, where each inner array contains the shortest path\n  from each car in the network to the nearest car on the road.\n  */\nconst shortestPaths = (roadNetwork) => {\n  const shortestPaths = [];\n  for (let i = 0; i < roadNetwork.length; i++) {\n    const road = roadNetwork[i];\n    const cars = road.cars;\n    const carsLength = cars.length;\n    for (let j = 0; j < carsLength; j++) {\n      const car = cars[j];\n      const carDistance = car.distance;\n      const carIndex = cars.indexOf(car);\n      if (carIndex >= 0) {\n        const carDistanceIndex = carDistance.indexOf(carIndex);\n        if (carDistanceIndex >= 0) {\n          const carDistanceDistance = carDistance[carDistanceIndex];\n          const carDistanceIndex = carDistanceDistance.indexOf(carIndex);\n          if (carDistanceIndex >= 0) {\n            const carDistanceDistanceIndex = carDistanceDistance.indexOf(carDistanceIndex);\n            if (carDistanceDistanceIndex >= 0) {\n              const carDistanceDistanceDistanceIndex = carDistanceDistanceDistance.indexOf(carDistanceDistanceIndex);\n              if (carDistanceDistanceIndex >= 0) {\n                const carDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceIndex);\n                if (carDistanceDistanceDistanceIndex >= 0) {\n                  const carDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceIndex);\n                  if (carDistanceDistanceDistanceDistanceIndex >= 0) {\n                    const carDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceIndex);\n                    if (carDistanceDistanceDistanceDistanceIndex >= 0) {\n                      const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceIndex);\n                      if (carDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                        const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceIndex);\n                        if (carDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                          const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceIndex);\n                          if (carDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                            const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                            if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                              const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                              if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                                const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                                if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                                  const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                                  if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                                    const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                                    if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                                      const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                                      if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                                        const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                                        if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                                          const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                                          if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                                            const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                                            if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                                              const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                                              if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                                                const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                                                if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                                                  const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                                                  if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                                                    const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                                                    if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                                                      const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                                                      if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                                                        const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                                                        if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                                                          const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                                                          if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                                                            const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                                                            if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex >= 0) {\n                                                              const carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex = carDistanceDistanceDistanceDistanceDistanceDistanceDistance.indexOf(carDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex);\n                                                              if (carDistanceDistanceDistanceDistanceDistanceDistanceDistanceDistanceIndex", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrLists([1, 2, 3])\n  [2, 3, 4]\n  >>> incrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrLists = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrLists", "gc": "<|endoftext|>/*Return list with elements incremented by 1.\n  >>> incrLists([1, 2, 3])\n  [2, 3, 4]\n  >>> incrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrLists = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements decremented by 1.\n  >>> decrLists([1, 2, 3])\n  [3, 2, 1]\n  >>> decrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  */\nconst decrLists = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] - 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrLists([1, 2, 3])\n  [1, 2, 3, 4, 5]\n  >>> incrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 4, 2, 3, 1, 9, 0, 123]\n  */\nconst incrListsReverse = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements decremented by 1.\n  >>> decrLists([1, 2, 3])\n  [3, 2, 1]\n  >>> decrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  */\nconst decrListsReverse = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] - 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrLists([1, 2, 3])\n  [1, 2, 3, 4, 5]\n  >>> incrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 4, 2, 3, 1, 9, 0, 123]\n  */\nconst incrListsReverseReverse = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements decremented by 1.\n  >>> decrLists([1, 2, 3])\n  [3, 2, 1]\n  >>> decrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  */\nconst decrListsReverseReverse = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] - 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrLists([1, 2, 3])\n  [1, 2, 3, 4, 5]\n  >>> incrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 4, 2, 3, 1, 9, 0, 123]\n  */\nconst incrListsReverseReverseReverse = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements decremented by 1.\n  >>> decrLists([1, 2, 3])\n  [3, 2, 1]\n  >>> decrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  */\nconst decrListsReverseReverseReverse = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] - 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrLists([1, 2, 3])\n  [1, 2, 3, 4, 5]\n  >>> incrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 4, 2, 3, 1, 9, 0, 123]\n  */\nconst incrListsReverseReverseReverse = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements decremented by 1.\n  >>> decrLists([1, 2, 3])\n  [3, 2, 1]\n  >>> decrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  */\nconst decrListsReverseReverseReverse = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] - 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrLists([1, 2, 3])\n  [1, 2, 3, 4, 5]\n  >>> incrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 4, 2, 3, 1, 9, 0, 123]\n  */\nconst incrListsReverseReverseReverseReverse = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements decremented by 1.\n  >>> decrLists([1, 2, 3])\n  [3, 2, 1]\n  >>> decrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  */\nconst decrListsReverseReverseReverseReverse = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] - 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrLists([1, 2, 3])\n  [1, 2, 3, 4, 5]\n  >>> incrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 4, 2, 3, 1, 9, 0, 123]\n  */\nconst incrListsReverseReverseReverseReverseReverse = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements decremented by 1.\n  >>> decrLists([1, 2, 3])\n  [3, 2, 1]\n  >>> decrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  */\nconst decrListsReverseReverseReverseReverseReverse = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] - 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrLists([1, 2, 3])\n  [1, 2, 3, 4, 5]\n  >>> incrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 4, 2, 3, 1, 9, 0, 123]\n  */\nconst incrListsReverseReverseReverseReverseReverseReverse = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements decremented by 1.\n  >>> decrLists([1, 2, 3])\n  [3, 2, 1]\n  >>> decrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  */\nconst decrListsReverseReverseReverseReverseReverseReverse = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] - 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrLists([1, 2, 3])\n  [1, 2, 3, 4, 5]\n  >>> incrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 4, 2, 3, 1, 9, 0, 123]\n  */\nconst incrListsReverseReverseReverseReverseReverseReverse = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1)\n  }\n  return result\n}\n\n/*Return list with elements decremented by 1.\n  >>> decrLists([1, 2, 3])\n  [3, 2, 1]\n  >>> decrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 3, 2, 1]\n  */\nconst decrListsReverseReverseReverseReverseReverseReverse = (l) => {\n  let result = []\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] - 1)\n  }\n  return result\n}\n\n/*Return list with elements incremented by 1.\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairSumsToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairSumsToZero([1, 3, 5, 0])\n  false\n  >>> pairSumsToZero([1, 3, -2, 1])\n  false\n  >>> pairSumsToZero([1, 2, 3, 7])\n  false\n  >>> pairSumsToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairSumsToZero([1])\n  false\n  */\nconst pairSumsToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairSumsToZero", "gc": "<|endoftext|>/*\n  pairSumsToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairSumsToZero([1, 3, 5, 0])\n  false\n  >>> pairSumsToZero([1, 3, -2, 1])\n  false\n  >>> pairSumsToZero([1, 2, 3, 7])\n  false\n  >>> pairSumsToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairSumsToZero([1])\n  false\n  */\nconst pairSumsToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count++;\n  }\n  return count === 2;\n};\n\n/*\n  countPairs takes a list of integers as an input.\n  it returns an array containing all the pairs of integers that\n  sum to zero, and false otherwise.\n  >>> countPairs([1, 3, 5, 0])\n  [[1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBases(8, 3)\n  '22'\n  >>> changeBases(8, 2)\n  '1000'\n  >>> changeBases(7, 2)\n  '111'\n  */\nconst changeBases = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBases", "gc": "<|endoftext|>/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBases(8, 3)\n  '22'\n  >>> changeBases(8, 2)\n  '1000'\n  >>> changeBases(7, 2)\n  '111'\n  */\nconst changeBases = (x, base) => {\n  let str = x.toString(base);\n  let res = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    if (str[i] === '0') {\n      res += '0';\n    } else {\n      res += str[i];\n    }\n  }\n  return res;\n};\n\n/**\n * Convert string 'x' to integer 'y'.\n */\nconst toInt = x => {\n  return parseInt(x, 10);\n};\n\n/**\n * Convert string 'x' to float 'y'.\n */\nconst toFloat = x => {\n  return parseFloat(x);\n};\n\n/**\n * Convert string 'x' to boolean 'y'.\n */\nconst toBool = x => {\n  return x.toLowerCase() === 'true';\n};\n\n/**\n * Convert string 'x' to 'y'.\n */\nconst toStr = x => {\n  return x.toString();\n};\n\n/**\n * Convert string 'x' to 'y' with radix 'y'.\n */\nconst toRadix = x => {\n  return parseInt(x, 10);\n};\n\n/**\n * Convert string 'x' to 'y' with base 'y'.\n */\nconst toBase = x => {\n  return changeBases(x, 10);\n};\n\n/**\n * Convert string 'x' to 'y' with base 'y' and radix 'y'.\n */\nconst toBaseRadix = x => {\n  return changeBases(x, toRadix(10));\n};\n\n/**\n * Convert string 'x' to 'y' with base 'y' and radix 'y' and exponent 'y'.\n */\nconst toBaseExponent = x => {\n  return changeBases(x, toRadix(10) + toRadix(10) + toInt(y));\n};\n\n/**\n * Convert string 'x' to 'y' with base 'y' and radix 'y' and exponent 'y' and exponent 'z'.\n */\nconst toBaseExponentAndExponent = x => {\n  return changeBases(x, toRadix(10) + toRadix(10) + toInt(y) + toInt(z));\n};\n\n/**\n * Convert string 'x' to 'y' with base 'y' and radix 'y' and exponent 'y' and exponent 'z' and exponent 'w'.\n */\nconst toBaseExponentAndExponentAndExponent = x => {\n  return changeBases(x, toRadix(10) + toRadix(10) + toInt(y) + toInt(z) + toInt(w));\n};\n\n/**\n * Convert string 'x' to 'y' with base 'y' and radix 'y' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x'.\n */\nconst toBaseExponentAndExponentAndExponentAndExponent = x => {\n  return changeBases(x, toRadix(10) + toRadix(10) + toInt(y) + toInt(z) + toInt(w) + toInt(x));\n};\n\n/**\n * Convert string 'x' to 'y' with base 'y' and radix 'y' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y'.\n */\nconst toBaseExponentAndExponentAndExponentAndExponentAndExponent = x => {\n  return changeBases(x, toRadix(10) + toRadix(10) + toInt(y) + toInt(z) + toInt(w) + toInt(x) + toInt(y));\n};\n\n/**\n * Convert string 'x' to 'y' with base 'y' and radix 'y' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z'.\n */\nconst toBaseExponentAndExponentAndExponentAndExponentAndExponentAndExponent = x => {\n  return changeBases(x, toRadix(10) + toRadix(10) + toInt(y) + toInt(z) + toInt(w) + toInt(x) + toInt(y) + toInt(z));\n};\n\n/**\n * Convert string 'x' to 'y' with base 'y' and radix 'y' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent 'w' and exponent 'x' and exponent 'y' and exponent 'z' and exponent ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and high return area for a triangle.\n  >>> trianglesAreas(5, 3)\n  7.5\n  */\nconst trianglesAreas = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "trianglesAreas", "gc": "<|endoftext|>/*Given length of a side and high return area for a triangle.\n  >>> trianglesAreas(5, 3)\n  7.5\n  */\nconst trianglesAreas = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesAreas(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) * (Math.pow(a, 2) * (Math.pow(a, 3) - Math.pow(a, 2)))).toFixed(2);\n  return area;\n};\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesArea(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  const area = (Math.pow((h - 1), 2) ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "gc": "<|endoftext|>/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 1) return 1;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4).\n  Please write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.  Do not use recursion.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5).\n  Please write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.  Do not use recursion.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6).\n  Please write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.  Do not use recursion.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7).\n  Please write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.  Do not use recursion.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8).\n  Please write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.  Do not use recursion.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9).\n  Please write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.  Do not use recursion.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9) + fib(n-10).\n  Please write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.  Do not use recursion.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9) + fib(n-10) + fib(n-11).\n  Please write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.  Do not use recursion.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9) + fib(n-10) + fib(n-11) + fib(n-12).\n  Please write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.  Do not use recursion.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9) + fib(n-10) + fib(n-11) + fib(n-12) + fib(n-13).\n  Please write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.  Do not use recursion.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9) + fib(n-10) + fib(n-11) + fib(n-12) + fib(n-13) + fib(n-14).\n  Please write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.  Do not use recursion.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9) + fib(n-10) + fib(n-11) + fib(n-12) + fib(n-13) + fib(n-14) + fib(n-15).\n  Please write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.  Do not use recursion.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9) + fib(n-10) + fib(n-11) + fib(n-12) + fib(n-13) + fib(n-14) + fib(n-15) + fib(n-16).\n  Please write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.  Do not use recursion.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9) + fib(n-10) + fib(n-11) + fib(n-12) + fib(n-13) + fib(n-14) + fib(n-15) + fib(n-16) + fib(n-17).\n  Please write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.  Do not use recursion.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9) + fib(n-10) + fib(n-11) + fib(n-12) + fib(n-13) + fib(n-14) + fib(n-15) + fib(n-16) + fib(n-17) + fib(n-18).\n  Please write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.  Do not use recursion.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9) + fib(n-10) + fib(n-11) + fib(n-12) + fib(n-13) + fib(n-14) + fib(n-15) + fib(n-16) + fib(n-17) + fib(n-18) + fib(n-19).\n  Please write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is n.  Do not use recursion.\n  >>> fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9) + fib(n-10) + fib(n-11) + fib(n-12) + fib(n-13) + fib(n-14) + fib(n-15) + fib(n-16) + fib(n-17) + fib(n-18) + fib(n-19) + fib(n-20).", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let n = l.length\n  if (n <= 1) return 0\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return l[(i + j) / 2];\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n <= 1) return 0\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return median(l[(i + j) / 2] - l[(i + j) % 2])\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n <= 1) return 0\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return median(l[(i + j) / 2] - l[(i + j) % 2])\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n <= 1) return 0\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return median(l[(i + j) / 2] - l[(i + j) % 2])\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n <= 1) return 0\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return median(l[(i + j) / 2] - l[(i + j) % 2])\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n <= 1) return 0\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return median(l[(i + j) / 2] - l[(i + j) % 2])\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n <= 1) return 0\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return median(l[(i + j) / 2] - l[(i + j) % 2])\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n <= 1) return 0\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return median(l[(i + j) / 2] - l[(i + j) % 2])\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n <= 1) return 0\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return median(l[(i + j) / 2] - l[(i + j) % 2])\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n <= 1) return 0\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return median(l[(i + j) / 2] - l[(i + j) % 2])\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n <= 1) return 0\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return median(l[(i + j) / 2] - l[(i + j) % 2])\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n <= 1) return 0\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return median(l[(i + j) / 2] - l[(i + j) % 2])\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n <= 1) return 0\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return median(l[(i + j) / 2] - l[(i + j) % 2])\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n <= 1) return 0\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return median(l[(i + j) / 2] - l[(i + j) % 2])\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n <= 1) return 0\n  let m = n / 2\n  let i = Math.floor((n - 1) / 2)\n  let j = (n - i) / 2\n  return median(l[(i + j) / 2] - l[(i + j) % 2])\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "gc": "<|endoftext|>/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return reversedText === text\n}\n\n/*\n  Checks if given string is a palindrome with given length\n  >>> isPalindromeWithLength(text, '4')\n  true\n  >>> isPalindromeWithLength(text, '5')\n  false\n  */\nconst isPalindromeWithLength = (text, length) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome with given length and given character\n  >>> isPalindromeWithCharacterLength(text, '4', 'a')\n  true\n  >>> isPalindromeWithCharacterLength(text, '5', 'b')\n  false\n  */\nconst isPalindromeWithCharacterLength = (text, length, character) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return reversedText.indexOf(character) === length - 1\n}\n\n/*\n  Checks if given string is a palindrome with given length and given character and given character\n  >>> isPalindromeWithCharacterCharacterLength(text, '4', 'a', 'b')\n  true\n  >>> isPalindromeWithCharacterCharacterLength(text, '5', 'b', 'a')\n  false\n  */\nconst isPalindromeWithCharacterCharacterLength = (text, length, character, character2) => {\n  let reversedText = text\n  reversedText = reversedText.split('').reverse().join('')\n  return reversedText.indexOf(character) === length - 1 && reversedText.indexOf(character2) === length - 1\n}\n\n/*\n  Checks if given string is a palindrome with given length and given character and given character and given character\n  >>> isPalindromeWithCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacterCharacter", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "gc": "<|endoftext|>/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  assert(n >= 0 && p >= 0);\n  if (n <= 0) return 0;\n  if (p <= 0) return 1;\n  if (p === 1) return n;\n  if (p === 2) return n % 2;\n  if (p === 3) return (n % 3) + (n & 3);\n  if (p === 4) return (n % 10) + (n & 10) + (n & 50) + (n & 100);\n  if (p === 5) return (n % 100) + (n & 100) + (n & 200) + (n & 400) + (n & 800);\n  if (p === 6) return (n % 400) + (n & 400) + (n & 800) + (n & 1600);\n  if (p === 7) return (n % 800) + (n & 800) + (n & 1600) + (n & 3200);\n  if (p === 8) return (n % 1600) + (n & 1600) + (n & 3200) + (n & 6400);\n  if (p === 9) return (n % 3200) + (n & 3200) + (n & 6400) + (n & 12800);\n  if (p === 10) return (n % 6400) + (n & 6400) + (n & 12800) + (n & 25200);\n  if (p === 11) return (n % 12800) + (n & 12800) + (n & 25200) + (n & 50000);\n  if (p === 12) return (n % 25200) + (n & 25200) + (n & 50000) + (n & 1000000);\n  if (p === 13) return (n % 50000) + (n & 50000) + (n & 1000000) + (n & 250000);\n  if (p === 14) return (n % 1000000) + (n & 1000000) + (n & 250000) + (n & 500000);\n  if (p === 15) return (n % 250000) + (n & 250000) + (n & 500000) + (n & 10000000);\n  if (p === 16) return (n % 500000) + (n & 500000) + (n & 10000000) + (n & 25000000);\n  if (p === 17) return (n % 10000000) + (n & 10000000) + (n & 25000000) + (n & 500000000);\n  if (p === 18) return (n % 25000000) + (n & 25000000) + (n & 500000000) + (n & 100000000);\n  if (p === 19) return (n % 500000000) + (n & 500000000) + (n & 100000000) + (n & 200000000);\n  if (p === 20) return (n % 100000000) + (n & 100000000) + (n & 200000000) + (n & 400000000);\n  if (p === 21) return (n % 200000000) + (n & 200000000) + (n & 400000000) + (n & 800000000);\n  if (p === 22) return (n % 400000000) + (n & 400000000) + (n & 800000000) + (n & 1600000000);\n  if (p === 23) return (n % 800000000) + (n & 800000000) + (n & 1600000000) + (n & 3200000000);\n  if (p === 24) return (n % 1600000000) + (n & 1600000000) + (n & 3200000000) + (n & 6400000000);\n  if (p === 25) return (n % 3200000000) + (n & 3200000000) + (n & 6400000000) + (n & 12800000000);\n  if (p === 26) return (n % 6400000000) + (n & 6400000000) + (n & 12800000000) + (n & 2500000000);\n  if (p === 27) return (n % 12800000000) + (n & 12800000000) + (n & 2500000000) + (n & 5000000000);\n  if (p === 28) return (n % 2500000000) + (n & 2500000000) + (n & 5000000000) + (n & 10000000000);\n  if (p === 29) return (n % 5000000000) + (n & 5000000000) + (n & 10000000000) + (n & 20000000000);\n  if (p === 30) return (n % 10000000000) + (n & 10000000000) + (n & 20000000000) + (n & 40000000000);\n  if (p === 31) return (n % 20000000000) + (n & 20000000000) + (n & 40000000000) + (n & 80000000000);\n  if (p === 32) return (n % 40000000000) + (n & 40000000000) + (n & 80000000000) + (n & 160000000000);\n  if (p === 33) return (n % 80000000000) + (n & 80000000000) + (n & 160000000000) + (n & 320000000000);\n  if (p === 34) return (n % 160000000000) + (n & 160000000000) + (n & 320000000000) + (n & 640000000000);\n  if (p === 35) return (n % 320000000000) + (n & 320000000000) + (n & 640000000000) + (n & 1280000000000);\n  if (p === 36) return (n % 640000000000) + (n & 640000000000) + (n & 1280000000000) + (n & 250000000000);\n  if (p === 37) return (n % 1280000000000) + (n & 1280000000000) + (n & 250000000000) + (n & 5000000000000);\n  if (p === 38) return (n % 250000000000) + (n & 250000000000) + (n & 5000000000000) + (n & 100000000000000);\n  if (p === 39) return (n % 5000000000000) + (n & 5000000000000) + (n & 100000000000000) + (n & 200000000000000);\n  if (p === 40) return (n % 100000000000000) + (n & 100000000000000) + (n & 200000000000000) + (n & 400000000000000);\n  if (p === 41) return (n % 200000000000000) + (n & 200000000000000) + (n & 400000000000000) + (n & 800000000000000);\n  if (p === 42) return (n % 400000000000000) + (n & 400000000000000) + (n & 800000000000000) + (n & 1600000000000000);\n  if (p === 43) return (n % 800000000000000) + (n & 800000000000000) + (n & 1600000000000000) + (n & 3200000000000000);\n  if (p === 44) return (n % 1600000000000000) + (n & 1600000000000000) + (n & 3200000000000000) + (n & 6400000000000000);\n  if (p === 45) return (n % 3200000000000000) + (n & 3200000000000000) + (n & 6400000000000000) + (n & 12800000000000000);\n  if (p === 46) return (n % 6400000000000000) + (n & 6400000000000000) + (n & 12800000000000000) + (n & 2500000000000000);\n  if (p === 47) return (n % 12800000000000000) + (n & 12800000000000000) + (n & 2500000000000000) + (n & 5000000000000000); \n  if (p === 48) return (n % 2500000000000000) + (n & 2500000000000000) + (n & 5000000000000000) + (n & 10000000000000000);\n  if (p === 49) return (n % 5000000000000000) + (n & 5000000000000000) + (n & 10000000000000000) + (n & 2000000000000000);\n  if (p === 50) return (n % 10000000000000000) + (n & 10000000000000000) + (n & 2000000000000000) + (n & 4000000000000000);\n  if (p === 51) return (n % 2000000000000000) + (n & 2000000000000000) + (n & 4000000000000000) + (n & 8000000000000000);\n  if (p === 52) return (n % 4000000000000000) + (n & 4000000000000000) + (n & 8000000000000000) + (n & 16000000000000000);\n  if (p === 53) return (n % 8000000000000000) + (n & 8000000000000000) + (n & 16000000000000000) + (n & 32000000000000000);\n  if (p === 54) return (n % 16000000000000000) + (n & 16000000000000000) + (", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "gc": "<|endoftext|>/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  while (i < numbers.length) {\n    if (i === 0 || numbers[i] === numbers[i - 1]) {\n      result.push(numbers[i])\n    } else {\n      result.push(delimeter)\n    }\n    i++\n  }\n  return result\n}\n\n/**\n * Returns the last element of an array.\n * If no element exists, the function returns `undefined`.\n * If an element is found, the function returns the element.\n * If no element is found, the function returns `undefined`.\n *\n * Examples:\n * ```\n * last([1, 2, 3])\n * // => 3\n * last([1, 2, 3])\n * // => undefined\n * last([1, 2, 3])\n * // => undefined\n * ```\n *\n * @param {Array} array The array to get the last element of.\n * @returns {*} The last element of the array.\n */\nconst last = array => array[array.length - 1]\n\n/**\n * Returns the first element of an array.\n * If no element exists, the function returns `undefined`.\n * If an element is found, the function returns the element.\n * If no element is found, the function returns `undefined`.\n *\n * Examples:\n * ```\n * first([1, 2, 3])\n * // => 1\n * first([1, 2, 3])\n * // => undefined\n * first([1, 2, 3])\n * // => undefined\n * ```\n *\n * @param {Array} array The array to get the first element of.\n * @returns {*} The first element of the array.\n */\nconst first = array => array[0]\n\n/**\n * Returns the last element of an array.\n * If no element exists, the function returns `undefined`.\n * If an element is found, the function returns the element.\n * If no element is found, the function returns `undefined`.\n *\n * Examples:\n * ```\n * lastOr([1,2,3])\n * // => 3\n * lastOr([1,2,3])\n * // => undefined\n * lastOr([1,2,3])\n * // => undefined\n * ```\n *\n * @param {Array} array The array to get the last element of.\n * @returns {*} The last element of the array.\n */\nconst lastOr = array => array[array.length - 1] || undefined\n\n/**\n * Returns the first element of an array.\n * If no element exists, the function returns `undefined`.\n * If an element is found, the function returns the element.\n * If no element is found, the function returns `undefined`.\n *\n * Examples:\n * ```\n * firstOr([1,2,3])\n * // => 1\n * firstOr([1,2,3])\n * // => undefined\n * firstOr([1,2,3])\n * // => undefined\n * ```\n *\n * @param {Array} array The array to get the first element of.\n * @returns {*} The first element of the array.\n */\nconst firstOr = array => array[0] || undefined\n\n/**\n * Returns the first element of an array.\n * If no element exists, the function returns `undefined`.\n * If an element is found, the function returns the element.\n * If no element is found, the function returns `undefined`.\n *\n * Examples:\n * ```\n * firstOr([1,2,3])\n * // => 1\n * firstOr([1,2,3])\n * // => undefined\n * firstOr([1,2,3])\n * // => undefined\n * ```\n *\n * @param {Array} array The array to get the first element of.\n * @returns {*} The first element of the array.\n */\nconst firstOrDefault = array => array[0] || undefined\n\n/**\n * Returns the last element of an array.\n * If no element exists, the function returns `undefined`.\n * If an element is found, the function returns the element.\n * If no element is found, the function returns `undefined`.\n *\n * Examples:\n * ```\n * lastOrDefault([1,2,3])\n * // => 3\n * lastOrDefault([1,2,3])\n * // => undefined\n * lastOrDefault([1,2,3])\n * // => undefined\n * ```\n *\n * @param {Array} array The array to get the last element of.\n * @returns {*} The last element of the array.\n */\nconst lastOrDefault = array => array[array.length - 1] || undefined\n\n/**\n * Returns the first element of an array.\n * If no element exists, the function returns `undefined`.\n * If an element is found, the function returns the element.\n * If no element is found, the function returns `undefined`.\n *\n * Examples:\n * ```\n * firstOrDefault([1,2,3])\n * // => 1\n * firstOrDefault([1,2,3])\n * // => undefined\n * firstOrDefault([1,2,3])\n * // => undefined\n * ```\n *\n * @param {Array} array The array to get the first element of.\n * @returns {*} The first element of the array.\n */\nconst firstOrDefault = array => array[0] || undefined\n\n/**\n * Returns the first element of an array.\n * If no element exists, the function returns `undefined`.\n * If an element is found, the function returns the element.\n * If no element is found, the function returns `undefined`.\n *\n * Examples:\n * ```\n * firstOrDefault([1,2,3])\n * // => 1\n * firstOrDefault([1,2,3])\n * // => undefined\n * firstOrDefault([1,2,3])\n * // => undefined\n * ```\n *\n * @param {Array} array The array to get the first element of.\n * @returns {*} The first element of the array.\n */\nconst firstOrDefaultOr = array => array[0] || undefined\n\n/**\n * Returns the last element of an array.\n * If no element exists, the function returns `undefined`.\n * If an element is found, the function returns the element.\n * If no element is found, the function returns `undefined`.\n *\n * Examples:\n * ```\n * lastOrDefaultOr([1,2,3])\n * // => 3\n * lastOrDefaultOr([1,2,3])\n * // => undefined\n * lastOrDefaultOr([1,2,3])\n * // => undefined\n * ```\n *\n * @param {Array} array The array to get the last element of.\n * @returns {*} The last element of the array.\n */\nconst lastOrDefaultOr = array => array[array.length - 1] || undefined\n\n/**\n * Returns the first element of an array.\n * If no element exists, the function returns `undefined`.\n * If an element is found, the function returns the element.\n * If no element is found, the function returns `undefined`.\n *\n * Examples:\n * ```\n * firstOrDefaultOr([1,2,3])\n * // => 1\n * firstOrDefaultOr([1,2,3])\n * // => undefined\n * firstOrDefaultOr([1,2,3])\n * // => undefined\n * ```\n *\n * @param {Array} array The array to get the first element of.\n * @returns {*} The first element of the array.\n */\nconst firstOrDefaultOr = array => array[0] || undefined\n\n/**\n * Returns the first element of an array.\n * If no element exists, the function returns `undefined`.\n * If an element is found, the function returns the element.\n * If no element is found, the function returns `undefined`.\n *\n * Examples:\n * ```\n * firstOrDefaultOr([1,2,3])\n * // => 1\n * firstOrDefaultOr([1,2,3])\n * // => undefined\n * firstOrDefaultOr([1,2,3])\n * // => undefined\n * ```\n *\n * @param {Array} array The array to get the first element of.\n * @returns {*} The first element of the array.\n */\nconst firstOrDefaultOrDefault = array => array[0] || undefined\n\n/**\n * Returns the first element of an array.\n * If no element exists, the function returns `undefined`.\n * If an element is found, the function returns the element.\n * If no ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "gc": "<|endoftext|>/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeToBytes = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0)).join(\"\");\n}\n\n/*\n  takes as input string encoded with encodeToBytes function. Returns decoded string.\n  */\nconst decodeToBytes = (s) => {\n  return decodeShift(s).split(\"\").map(ch => ch.charCodeAt(0)).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeToHex = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).join(\"\");\n}\n\n/*\n  takes as input string encoded with encodeToHex function. Returns decoded string.\n  */\nconst decodeToHex = (s) => {\n  return decodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeToBase64 = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(2)).join(\"\");\n}\n\n/*\n  takes as input string encoded with encodeToBase64 function. Returns decoded string.\n  */\nconst decodeToBase64 = (s) => {\n  return decodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(2)).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeToUnicode = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).join(\"\");\n}\n\n/*\n  takes as input string encoded with encodeToUnicode function. Returns decoded string.\n  */\nconst decodeToUnicode = (s) => {\n  return decodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeToUTF16 = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).join(\"\");\n}\n\n/*\n  takes as input string encoded with encodeToUTF16 function. Returns decoded string.\n  */\nconst decodeToUTF16 = (s) => {\n  return decodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeToUTF32 = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(32)).join(\"\");\n}\n\n/*\n  takes as input string encoded with encodeToUTF32 function. Returns decoded string.\n  */\nconst decodeToUTF32 = (s) => {\n  return decodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(32)).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeToUTF8 = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(8)).join(\"\");\n}\n\n/*\n  takes as input string encoded with encodeToUTF8 function. Returns decoded string.\n  */\nconst decodeToUTF8 = (s) => {\n  return decodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(8)).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeToUTF16LE = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).join(\"\");\n}\n\n/*\n  takes as input string encoded with encodeToUTF16LE function. Returns decoded string.\n  */\nconst decodeToUTF16LE = (s) => {\n  return decodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeToUTF16BE = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).join(\"\");\n}\n\n/*\n  takes as input string encoded with encodeToUTF16BE function. Returns decoded string.\n  */\nconst decodeToUTF16BE = (s) => {\n  return decodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(16)).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeToUTF32LE = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(32)).join(\"\");\n}\n\n/*\n  takes as input string encoded with encodeToUTF32LE function. Returns decoded string.\n  */\nconst decodeToUTF32LE = (s) => {\n  return decodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(32)).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeToUTF32BE = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(32)).join(\"\");\n}\n\n/*\n  takes as input string encoded with encodeToUTF32BE function. Returns decoded string.\n  */\nconst decodeToUTF32BE = (s) => {\n  return decodeShift(s).split(\"\").map(ch => ch.charCodeAt(0).toString(32)).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeToArray = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0)).join(\"\");\n}\n\n/*\n  takes as input string encoded with encodeToArray function. Returns decoded string.\n  */\nconst decodeToArray = (s) => {\n  return decodeShift(s).split(\"\").map(ch => ch.charCodeAt(0)).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeToBase64Array = (s) => {\n  return encodeShift(s).split(\"\").map(ch => ch.charCodeAt(0)).map(ch => ch.toString(2)).join(\"\");\n}\n\n/*\n  takes as input string encoded with encodeToBase64Array function. Returns decoded string.\n  */\nconst decodeToBase64Array = (s) => {\n  return decodeShift(s).split(\"\").map(ch => ch.charCodeAt(0)).map(ch => ch.toString(2)).join(", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowel is a function that takes string and returns string without vowels.\n  >>> removeVowel('')\n  ''\n  >>> removeVowel(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowel('abcdef')\n  'bcdf'\n  >>> removeVowel('aaaaa')\n  ''\n  >>> removeVowel('aaBAA')\n  'B'\n  >>> removeVowel('zbcd')\n  'zbcd'\n  */\nconst removeVowel = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowel", "gc": "<|endoftext|>/*\n  removeVowel is a function that takes string and returns string without vowels.\n  >>> removeVowel('')\n  ''\n  >>> removeVowel(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowel('abcdef')\n  'bcdf'\n  >>> removeVowel('aaaaa')\n  ''\n  >>> removeVowel('aaBAA')\n  'B'\n  >>> removeVowel('zbcd')\n  'zbcd'\n  */\nconst removeVowel = (text) => {\n  let vowels = 'aeiouAEIOU'\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsText = ''\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowel", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThresholds", "gc": "<|endoftext|>/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds = (l, t) => {\n  return l.every(n => n <= t);\n};\n\n/*\n  >>> isEven([1, 2, 3, 4])\n  true\n  >>> isEven([2, 4, 6, 8])\n  false\n  */\nconst isEven = arr => {\n  return arr.every(n => n % 2 === 0);\n};\n\n/*\n  >>> isOdd([2, 3, 5, 7])\n  true\n  >>> isOdd([3, 5, 7, 9])\n  false\n  */\nconst isOdd = arr => {\n  return arr.every(n => n % 2!== 0);\n};\n\n/*\n  >>> isEvenOrOdd([2, 3, 5, 7])\n  true\n  >>> isEvenOrOdd([3, 5, 7, 9])\n  false\n  */\nconst isEvenOrOdd = arr => {\n  return isEven(arr) || isOdd(arr);\n};\n\n/*\n  >>> isEvenOrOddOrZero([2, 3, 5, 7])\n  true\n  >>> isEvenOrOddOrZero([3, 5, 7, 9])\n  false\n  */\nconst isEvenOrOddOrZero = arr => {\n  return isEvenOrOdd(arr) || isZero(arr);\n};\n\n/*\n  >>> isEvenOrOddOrZeroOrZero([2, 3, 5, 7])\n  true\n  >>> isEvenOrOddOrZeroOrZero([3, 5, 7, 9])\n  false\n  */\nconst isEvenOrOddOrZeroOrZero = arr => {\n  return isEvenOrOddOrZero(arr) || isZeroOrZero(arr);\n};\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZero([2, 3, 5, 7])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZero([3, 5, 7, 9])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZero = arr => {\n  return isEvenOrOddOrZeroOrZero(arr) || isZeroOrZeroOrZero(arr);\n};\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZero([2, 3, 5, 7])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZero([3, 5, 7, 9])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZero = arr => {\n  return isEvenOrOddOrZeroOrZeroOrZero(arr) || isZeroOrZeroOrZeroOrZero(arr);\n};\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZero([2, 3, 5, 7])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZero([3, 5, 7, 9])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZero = arr => {\n  return isEvenOrOddOrZeroOrZeroOrZeroOrZero(arr) || isZeroOrZeroOrZeroOrZeroOrZero(arr);\n};\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([2, 3, 5, 7])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([3, 5, 7, 9])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = arr => {\n  return isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZero(arr) || isZeroOrZeroOrZeroOrZeroOrZeroOrZero(arr);\n};\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([2, 3, 5, 7])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([3, 5, 7, 9])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = arr => {\n  return isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(arr) || isZeroOrZeroOrZeroOrZeroOrZeroOrZero(arr);\n};\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([2, 3, 5, 7])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([3, 5, 7, 9])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = arr => {\n  return isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(arr) || isZeroOrZeroOrZeroOrZeroOrZeroOrZero(arr);\n};\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([2, 3, 5, 7])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([3, 5, 7, 9])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = arr => {\n  return isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(arr) || isZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(arr);\n};\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([2, 3, 5, 7])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([3, 5, 7, 9])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = arr => {\n  return isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(arr) || isZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(arr);\n};\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([2, 3, 5, 7])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([3, 5, 7, 9])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = arr => {\n  return isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(arr) || isZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(arr);\n};\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([2, 3, 5, 7])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([3, 5, 7, 9])\n  false\n  */\nconst isEvenOrOddOrZeroOrZero", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> adding(2, 3)\n  5\n  >>> adding(5, 7)\n  12\n  */\nconst adding = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "adding", "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> adding(2, 3)\n  5\n  >>> adding(5, 7)\n  12\n  */\nconst adding = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y with rounding\n  >>> adding(2.5, 3.5)\n  5\n  >>> adding(2.5, 3.5)\n  6\n  >>> adding(2.5, 3.5)\n  7\n  */\nconst addingWithRounding = (x, y) => {\n  return x + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision\n  >>> adding(2.5, 3.5, 2)\n  6\n  >>> adding(2.5, 3.5, 2)\n  7\n  */\nconst addingWithRoundingAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> adding(2.5, 3.5, 2, Math.round)\n  7\n  >>> adding(2.5, 3.5, 2, Math.round)\n  8\n  */\nconst addingWithRoundingAndPrecisionAndRoundingMethod = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> adding(2.5, 3.5, 2, Math.round, Math.round)\n  8\n  >>> adding(2.5, 3.5, 2, Math.round, Math.round)\n  9\n  */\nconst addingWithRoundingAndPrecisionAndRoundingMethodAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> adding(2.5, 3.5, 2, Math.round, Math.round, Math.round)\n  9\n  >>> adding(2.5, 3.5, 2, Math.round, Math.round, Math.round, Math.round)\n  10\n  */\nconst addingWithRoundingAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethod = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> adding(2.5, 3.5, 2, Math.round, Math.round, Math.round, Math.round)\n  10\n  >>> adding(2.5, 3.5, 2, Math.round, Math.round, Math.round, Math.round, Math.round)\n  11\n  */\nconst addingWithRoundingAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> adding(2.5, 3.5, 2, Math.round, Math.round, Math.round, Math.round, Math.round)\n  11\n  >>> adding(2.5, 3.5, 2, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round)\n  12\n  */\nconst addingWithRoundingAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethod = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> adding(2.5, 3.5, 2, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round)\n  12\n  >>> adding(2.5, 3.5, 2, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round)\n  13\n  */\nconst addingWithRoundingAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> adding(2.5, 3.5, 2, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round)\n  13\n  >>> adding(2.5, 3.5, 2, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round)\n  14\n  */\nconst addingWithRoundingAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> adding(2.5, 3.5, 2, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round)\n  14\n  >>> adding(2.5, 3.5, 2, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round)\n  15\n  */\nconst addingWithRoundingAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecisionAndRoundingMethodAndPrecision = (x, y) => {\n  return x + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100 + Math.round(x * 100) / 100;\n};\n\n/*\n  Add two numbers x and y with rounding and a precision and a rounding method\n  >>> adding(2.5, 3.5, 2, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, Math.round, ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same characters.\n  >>> sameChar('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChar('abcd', 'dddddddabc')\n  true\n  >>> sameChar('dddddddabc', 'abcd')\n  true\n  >>> sameChar('eabcd', 'dddddddabc')\n  false\n  >>> sameChar('abcd', 'dddddddabce')\n  false\n  >>> sameChar('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChar = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChar", "gc": "<|endoftext|>/*\n  Check if two words have the same characters.\n  >>> sameChar('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChar('abcd', 'dddddddabc')\n  true\n  >>> sameChar('dddddddabc', 'abcd')\n  true\n  >>> sameChar('eabcd', 'dddddddabc')\n  false\n  >>> sameChar('abcd', 'dddddddabce')\n  false\n  >>> sameChar('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChar = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0 === null || s1 === null) return false;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/**\n * Check if two words have the same length\n * >>> sameLength('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * true\n * >>> sameLength('abcd', 'dddddddabc')\n * true\n * >>> sameLength('dddddddabc', 'abcd')\n * true\n * >>> sameLength('eabcd', 'dddddddabc')\n * false\n * >>> sameLength('abcd', 'dddddddabce')\n * false\n * >>> sameLength('eabcdzzzz', 'dddzzzzzzzddddabc')\n * false\n */\nconst sameLength = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0 === null || s1 === null) return false;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/**\n * Check if two words have the same capitalization\n * >>> sameCaps('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * true\n * >>> sameCaps('abcd', 'dddddddabc')\n * true\n * >>> sameCaps('dddddddabc', 'abcd')\n * true\n * >>> sameCaps('eabcd', 'dddddddabc')\n * false\n * >>> sameCaps('abcd', 'dddddddabce')\n * false\n * >>> sameCaps('eabcdzzzz', 'dddzzzzzzzddddabc')\n * false\n */\nconst sameCaps = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0 === null || s1 === null) return false;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/**\n * Check if two words have the same punctuation\n * >>> samePunct('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * true\n * >>> samePunct('abcd', 'dddddddabc')\n * true\n * >>> samePunct('dddddddabc', 'abcd')\n * true\n * >>> samePunct('eabcd', 'dddddddabc')\n * false\n * >>> samePunct('abcd', 'dddddddabce')\n * false\n * >>> samePunct('eabcdzzzz', 'dddzzzzzzzddddabc')\n * false\n */\nconst samePunct = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0 === null || s1 === null) return false;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/**\n * Check if two words have the same number\n * >>> sameNum('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * true\n * >>> sameNum('abcd', 'dddddddabc')\n * true\n * >>> sameNum('dddddddabc', 'abcd')\n * true\n * >>> sameNum('eabcd', 'dddddddabc')\n * false\n * >>> sameNum('abcd', 'dddddddabce')\n * false\n * >>> sameNum('eabcdzzzz', 'dddzzzzzzzddddabc')\n * false\n */\nconst sameNum = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0 === null || s1 === null) return false;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/**\n * Check if two words have the same symbol\n * >>> sameSym('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * true\n * >>> sameSym('abcd', 'dddddddabc')\n * true\n * >>> sameSym('dddddddabc', 'abcd')\n * true\n * >>> sameSym('eabcd', 'dddddddabc')\n * false\n * >>> sameSym('abcd', 'dddddddabce')\n * false\n * >>> sameSym('eabcdzzzz', 'dddzzzzzzzddddabc')\n * false\n */\nconst sameSym = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0 === null || s1 === null) return false;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/**\n * Check if two words have the same uppercase letter\n * >>> sameUp('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * true\n * >>> sameUp('abcd', 'dddddddabc')\n * true\n * >>> sameUp('dddddddabc', 'abcd')\n * true\n * >>> sameUp('eabcd', 'dddddddabc')\n * false\n * >>> sameUp('abcd', 'dddddddabce')\n * false\n * >>> sameUp('eabcdzzzz', 'dddzzzzzzzddddabc')\n * false\n */\nconst sameUp = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0 === null || s1 === null) return false;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/**\n * Check if two words have the same lowercase letter\n * >>> sameLow('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * true\n * >>> sameLow('abcd', 'dddddddabc')\n * true\n * >>> sameLow('dddddddabc', 'abcd')\n * true\n * >>> sameLow('eabcd', 'dddddddabc')\n * false\n * >>> sameLow('abcd', 'dddddddabce')\n * false\n * >>> sameLow('eabcdzzzz', 'dddzzzzzzzddddabc')\n * false\n */\nconst sameLow = (s0, s1) => {\n  if (s0 === s1) return true;\n  if (s0 === null || s1 === null) return false;\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/**\n * Check if two words have the same numbers and symbols\n * >>> sameNumAndSym('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * true\n * >>> sameNumAndSym('abcd', 'dddddddabc')\n * true\n * >>> sameNumAndSym('dddddddabc', 'abcd", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fibs", "gc": "<|endoftext|>/*Return n-th Fibonacci number.\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return a;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs2 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return b;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs3 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return a;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs4 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return b;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs5 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return a;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs6 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return b;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs7 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return a;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs8 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return b;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs9 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return a;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs10 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return b;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs11 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return a;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs12 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return b;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs13 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return a;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs14 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return b;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs15 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return a;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs16 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return b;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs17 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return a;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs18 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return b;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs19 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return a;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs20 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return b;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs21 = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return a;\n};\n\n/*\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.split(\"<\").filter(Boolean);\n  const closingBrackets = brackets.split(\">\").filter(Boolean);\n  return openingBrackets.length === closingBrackets.length;\n};\n\nconst isString = (value) => typeof value === \"string\";\n\nconst isNumber = (value) => typeof value === \"number\";\n\nconst isBoolean = (value) => typeof value === \"boolean\";\n\nconst isRegExp = (value) => value instanceof RegExp;\n\nconst isDate = (value) => value instanceof Date;\n\nconst isError = (value) => value instanceof Error;\n\nconst isSymbol = (value) => typeof value === \"symbol\";\n\nconst isMap = (value) => value instanceof Map;\n\nconst isSet = (value) => value instanceof Set;\n\nconst isWeakMap = (value) => value instanceof WeakMap;\n\nconst isWeakSet = (value) => value instanceof WeakSet;\n\nconst isSetLike = (value) => isSet(value) || isMap(value) || isWeakMap(value) || isWeakSet(value);\n\nconst isMapLike = (value) => isMap(value) || isSetLike(value);\n\nconst isWeakMapLike = (value) => isWeakMap(value) || isSetLike(value);\n\nconst isWeakSetLike = (value) => isWeakSet(value) || isSetLike(value);\n\nconst isIterable = (value) => value && typeof value[Symbol.iterator] === \"function\";\n\nconst isIterator = (value) => value && typeof value.next === \"function\";\n\nconst isGenerator = (value) => value && typeof value.next === \"function\" && typeof value.throw === \"function\";\n\nconst isGeneratorFunction = (value) => isGenerator(value) && isGenerator(value);\n\nconst isAsyncIterable = (value) => value && typeof value[Symbol.asyncIterator] === \"function\";\n\nconst isAsyncIterator = (value) => value && typeof value.next === \"function\" && typeof value.throw === \"function\";\n\nconst isAsyncGenerator = (value) => isAsyncIterable(value) && isAsyncIterator(value);\n\nconst isAsyncGeneratorFunction = (value) => isAsyncGenerator(value) && isAsyncGenerator(value);\n\nconst isPromiseLike = (value) => value && typeof value.then === \"function\";\n\nconst isPromise = (value) => value && typeof value.then === \"function\";\n\nconst isPromiseFunction = (value) => isPromiseLike(value) && isPromise(value);\n\nconst isPromiseFunctionOrPromise = (value) => isPromiseFunction(value) || isPromise(value);\n\nconst isPromiseOrPromiseFunction = (value) => isPromiseFunction(value) || isPromiseFunction(value);\n\nconst isPromiseOrGeneratorFunction = (value) => isPromiseOrPromiseFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrPromise = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGenerator = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrPromise = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrPromise = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrPromise = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrPromise = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunction = (value) => isPromiseOrGeneratorFunction(value) || isPromiseOrGeneratorFunction(value);\n\nconst isPromiseOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGeneratorFunctionOrGenerator", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "gc": "<|endoftext|>/*Return true is list elements are monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = l.length - 1;\n  let j = 0;\n  while (true) {\n    if (l[j] < l[i]) {\n      i++;\n      j++;\n    } else if (l[j] > l[i]) {\n      j--;\n      i++;\n    } else {\n      return true;\n    }\n  }\n};\n\n/**\n * Returns true if the list elements are in increasing order.\n * If list elements are in decreasing order, then the list elements must be\n * in increasing order.\n * >>> increasing([1, 2, 4, 20])\n * true\n * >>> increasing([1, 20, 4, 10])\n * false\n * >>> increasing([4, 1, 0, -10])\n * true\n */\nconst increasing = (l) => {\n  let i = l.length - 1;\n  let j = 0;\n  while (true) {\n    if (l[j] < l[i]) {\n      i++;\n      j++;\n    } else if (l[j] > l[i]) {\n      return false;\n    } else {\n      if (j === i) {\n        return false;\n      }\n    }\n  }\n};\n\n/**\n * Returns true if the list elements are in decreasing order.\n * If list elements are in increasing order, then the list elements must be\n * in decreasing order.\n * >>> decreasing([1, 2, 4, 20])\n * true\n * >>> decreasing([1, 20, 4, 10])\n * false\n * >>> decreasing([4, 1, 0, -10])\n * true\n */\nconst decreasing = (l) => {\n  let i = l.length - 1;\n  let j = 0;\n  while (true) {\n    if (l[j] > l[i]) {\n      j--;\n      i++;\n    } else if (l[j] < l[i]) {\n      return false;\n    } else {\n      if (j === i) {\n        return false;\n      }\n    }\n  }\n};\n\n/**\n * Returns true if the list elements are in increasing or decreasing order.\n * If list elements are in increasing order, then the list elements must be\n * in increasing or decreasing order.\n * >>> monotonic([1, 2, 4, 20])\n * true\n * >>> monotonic([1, 20, 4, 10])\n * false\n * >>> monotonic([4, 1, 0, -10])\n * true\n */\nconst isInOrder = (l, isInOrder) => {\n  let i = l.length - 1;\n  let j = 0;\n  while (true) {\n    if (l[j] < l[i]) {\n      i++;\n      j++;\n    } else if (l[j] > l[i]) {\n      return false;\n    } else {\n      if (j === i) {\n        return false;\n      }\n    }\n  }\n};\n\n/**\n * Returns true if the list elements are in increasing or decreasing order.\n * If list elements are in increasing order, then the list elements must be\n * in increasing or decreasing order.\n * >>> monotonic([1, 2, 4, 20])\n * true\n * >>> monotonic([1, 20, 4, 10])\n * false\n * >>> monotonic([4, 1, 0, -10])\n * true\n */\nconst isInOrderOrdered = (l, isInOrder) => {\n  let i = l.length - 1;\n  let j = 0;\n  while (true) {\n    if (l[j] < l[i]) {\n      i++;\n      j++;\n    } else if (l[j] > l[i]) {\n      return false;\n    } else {\n      if (j === i) {\n        return false;\n      }\n    }\n  }\n};\n\n/**\n * Returns true if the list elements are in increasing or decreasing order.\n * If list elements are in increasing order, then the list elements must be\n * in increasing or decreasing order.\n * >>> monotonic([1, 2, 4, 20])\n * true\n * >>> monotonic([1, 20, 4, 10])\n * false\n * >>> monotonic([4, 1, 0, -10])\n * true\n */\nconst isInOrderOrdered = (l, isInOrder) => {\n  let i = l.length - 1;\n  let j = 0;\n  while (true) {\n    if (l[j] < l[i]) {\n      i++;\n      j++;\n    } else if (l[j] > l[i]) {\n      return false;\n    } else {\n      if (j === i) {\n        return false;\n      }\n    }\n  }\n};\n\n/**\n * Returns true if the list elements are in increasing or decreasing order.\n * If list elements are in increasing order, then the list elements must be\n * in increasing or decreasing order.\n * >>> monotonic([1, 2, 4, 20])\n * true\n * >>> monotonic([1, 20, 4, 10])\n * false\n * >>> monotonic([4, 1, 0, -10])\n * true\n */\nconst isInOrderOrdered = (l, isInOrder) => {\n  let i = l.length - 1;\n  let j = 0;\n  while (true) {\n    if (l[j] < l[i]) {\n      i++;\n      j++;\n    } else if (l[j] > l[i]) {\n      return false;\n    } else {\n      if (j === i) {\n        return false;\n      }\n    }\n  }\n};\n\n/**\n * Returns true if the list elements are in increasing or decreasing order.\n * If list elements are in increasing order, then the list elements must be\n * in increasing or decreasing order.\n * >>> monotonic([1, 2, 4, 20])\n * true\n * >>> monotonic([1, 20, 4, 10])\n * false\n * >>> monotonic([4, 1, 0, -10])\n * true\n */\nconst isInOrderOrdered = (l, isInOrder) => {\n  let i = l.length - 1;\n  let j = 0;\n  while (true) {\n    if (l[j] < l[i]) {\n      i++;\n      j++;\n    } else if (l[j] > l[i]) {\n      return false;\n    } else {\n      if (j === i) {\n        return false;\n      }\n    }\n  }\n};\n\n/**\n * Returns true if the list elements are in increasing or decreasing order.\n * If list elements are in increasing order, then the list elements must be\n * in increasing or decreasing order.\n * >>> monotonic([1, 2, 4, 20])\n * true\n * >>> monotonic([1, 20, 4, 10])\n * false\n * >>> monotonic([4, 1, 0, -10])\n * true\n */\nconst isInOrderOrdered = (l, isInOrder) => {\n  let i = l.length - 1;\n  let j = 0;\n  while (true) {\n    if (l[j] < l[i]) {\n      i++;\n      j++;\n    } else if (l[j] > l[i]) {\n      return false;\n    } else {\n      if (j === i) {\n        return false;\n      }\n    }\n  }\n};\n\n/**\n * Returns true if the list elements are in increasing or decreasing order.\n * If list elements are in increasing order, then the list elements must be\n * in increasing or decreasing order.\n * >>> monotonic([1, 2, 4, 20])\n * true\n * >>> monotonic([1, 20, 4, 10])\n * false\n * >>> monotonic([4, 1, 0, -10])\n * true\n */\nconst isInOrderOrdered = (l, isInOrder) => {\n  let i = l.length - 1;\n  let j = 0;\n  while (true) {\n    if (l[j] < l[i]) {\n      i++;\n      j++;\n    } else if (l[j] > l[i]) {\n      return false;\n    } else {\n      if (j === i) {\n        return false;\n      }\n    }\n  }\n};\n\n/**\n * Returns true if the list elements are in increasing or decreasing order.\n * If list elements are in increasing order, then the list elements must be\n * in increasing or decreasing order.\n * >>> monotonic([1, 2, 4, 20])\n * true\n * >>> monotonic([1, 20, 4, 10])\n * false\n * >>> monotonic([4, 1, 0, -10])\n * true\n */\nconst isInOrderOrdered = (l, isInOrder) => {\n  let i = l.length - ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "gc": "<|endoftext|>/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (k === 0) {\n        result.push(l1[i])\n        i++\n      } else {\n        if (l1[i] < l2[j]) {\n          result.push(l1[i])\n          i++\n        } else {\n          result.push(l2[j])\n          j++\n        }\n      }\n      k++\n    }\n  }\n  return result\n}\n\n/*Return sorted unique elements for two lists.\n  >>> unique([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 2, 3, 4, 5]\n  >>> unique([5, 3, 2, 8], [3, 2])\n  [5, 3, 2, 8]\n\n  */\nconst unique = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (k === 0) {\n        result.push(l1[i])\n        i++\n      } else {\n        if (l1[i] < l2[j]) {\n          result.push(l1[i])\n          i++\n        } else {\n          result.push(l2[j])\n          j++\n        }\n      }\n      k++\n    }\n  }\n  return result\n}\n\n/*Return sorted unique common elements for two lists.\n  >>> uniqueCommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 2, 3, 4, 5]\n  >>> uniqueCommon([5, 3, 2, 8], [3, 2])\n  [5, 3, 2, 8]\n\n  */\nconst uniqueCommon = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (k === 0) {\n        result.push(l1[i])\n        i++\n      } else {\n        if (l1[i] < l2[j]) {\n          result.push(l1[i])\n          i++\n        } else {\n          result.push(l2[j])\n          j++\n        }\n      }\n      k++\n    }\n  }\n  return result\n}\n\n/*Return sorted unique elements for two lists.\n  >>> uniqueElements([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 2, 3, 4, 5]\n  >>> uniqueElements([5, 3, 2, 8], [3, 2])\n  [5, 3, 2, 8]\n\n  */\nconst uniqueElements = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (k === 0) {\n        result.push(l1[i])\n        i++\n      } else {\n        if (l1[i] < l2[j]) {\n          result.push(l1[i])\n          i++\n        } else {\n          result.push(l2[j])\n          j++\n        }\n      }\n      k++\n    }\n  }\n  return result\n}\n\n/*Return sorted unique elements for two lists.\n  >>> uniqueElementsCommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 2, 3, 4, 5]\n  >>> uniqueElementsCommon([5, 3, 2, 8], [3, 2])\n  [5, 3, 2, 8]\n\n  */\nconst uniqueElementsCommon = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (k === 0) {\n        result.push(l1[i])\n        i++\n      } else {\n        if (l1[i] < l2[j]) {\n          result.push(l1[i])\n          i++\n        } else {\n          result.push(l2[j])\n          j++\n        }\n      }\n      k++\n    }\n  }\n  return result\n}\n\n/*Return sorted unique elements for two lists.\n  >>> uniqueElementsCommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 2, 3, 4, 5]\n  >>> uniqueElementsCommon([5, 3, 2, 8], [3, 2])\n  [5, 3, 2, 8]\n\n  */\nconst uniqueElementsCommon = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (k === 0) {\n        result.push(l1[i])\n        i++\n      } else {\n        if (l1[i] < l2[j]) {\n          result.push(l1[i])\n          i++\n        } else {\n          result.push(l2[j])\n          j++\n        }\n      }\n      k++\n    }\n  }\n  return result\n}\n\n/*Return sorted unique elements for two lists.\n  >>> uniqueElementsCommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 2, 3, 4, 5]\n  >>> uniqueElementsCommon([5, 3, 2, 8], [3, 2])\n  [5, 3, 2, 8]\n\n  */\nconst uniqueElementsCommon = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (k === 0) {\n        result.push(l1[i])\n        i++\n      } else {\n        if (l1[i] < l2[j]) {\n          result.push(l1[i])\n          i++\n        } else {\n          result.push(l2[j])\n          j++\n        }\n      }\n      k++\n    }\n  }\n  return result\n}\n\n/*Return sorted unique elements for two lists.\n  >>> uniqueElementsCommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 2, 3, 4, 5]\n  >>> uniqueElementsCommon([5, 3, 2, 8], [3, 2])\n  [5, 3, 2, 8]\n\n  */\nconst uniqueElementsCommon = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (k === 0) {\n        result.push(l1[i])\n        i++\n      } else {\n        if (l1[i] < l2[j]) {\n          result.push(l1[i])\n          i++\n        } else {\n          result.push(l2[j])\n          j++\n        }\n      }\n      k++\n    }\n  }\n  return result\n}\n\n/*Return sorted unique elements for two lists.\n  >>> uniqueElementsCommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 2, 3, 4, 5]\n  >>> uniqueElementsCommon([5, 3, 2, 8], [3, 2])\n  [5, 3, 2, 8]\n\n  */\nconst uniqueElementsCommon = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largerPrimeFactor(13195)\n  29\n  >>> largerPrimeFactor(2048)\n  2\n  */\nconst largerPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largerPrimeFactor", "gc": "<|endoftext|>/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largerPrimeFactor(13195)\n  29\n  >>> largerPrimeFactor(2048)\n  2\n  */\nconst largerPrimeFactor = (n) => {\n  let i = 2;\n  let factor = 1;\n  while (true) {\n    if (n % i === 0) {\n      n = n / i;\n      i++;\n    } else {\n      return factor;\n    }\n  }\n};\n\n/*\n  Given a positive integer n, return true if n is a prime number.\n  >>> isPrime(123)\n  true\n  >>> isPrime(124)\n  false\n  >>> isPrime(125)\n  false\n  >>> isPrime(126)\n  false\n  >>> isPrime(127)\n  false\n  >>> isPrime(128)\n  false\n  >>> isPrime(129)\n  false\n  >>> isPrime(130)\n  false\n  >>> isPrime(131)\n  false\n  >>> isPrime(132)\n  false\n  >>> isPrime(133)\n  false\n  >>> isPrime(134)\n  false\n  >>> isPrime(135)\n  false\n  >>> isPrime(136)\n  false\n  >>> isPrime(137)\n  false\n  >>> isPrime(138)\n  false\n  >>> isPrime(139)\n  false\n  >>> isPrime(140)\n  false\n  >>> isPrime(141)\n  false\n  >>> isPrime(142)\n  false\n  >>> isPrime(143)\n  false\n  >>> isPrime(144)\n  false\n  >>> isPrime(145)\n  false\n  >>> isPrime(146)\n  false\n  >>> isPrime(147)\n  false\n  >>> isPrime(148)\n  false\n  >>> isPrime(149)\n  false\n  >>> isPrime(150)\n  false\n  >>> isPrime(151)\n  false\n  >>> isPrime(152)\n  false\n  >>> isPrime(153)\n  false\n  >>> isPrime(154)\n  false\n  >>> isPrime(155)\n  false\n  >>> isPrime(156)\n  false\n  >>> isPrime(157)\n  false\n  >>> isPrime(158)\n  false\n  >>> isPrime(159)\n  false\n  >>> isPrime(160)\n  false\n  >>> isPrime(161)\n  false\n  >>> isPrime(162)\n  false\n  >>> isPrime(163)\n  false\n  >>> isPrime(164)\n  false\n  >>> isPrime(165)\n  false\n  >>> isPrime(166)\n  false\n  >>> isPrime(167)\n  false\n  >>> isPrime(168)\n  false\n  >>> isPrime(169)\n  false\n  >>> isPrime(170)\n  false\n  >>> isPrime(171)\n  false\n  >>> isPrime(172)\n  false\n  >>> isPrime(173)\n  false\n  >>> isPrime(174)\n  false\n  >>> isPrime(175)\n  false\n  >>> isPrime(176)\n  false\n  >>> isPrime(177)\n  false\n  >>> isPrime(178)\n  false\n  >>> isPrime(179)\n  false\n  >>> isPrime(180)\n  false\n  >>> isPrime(181)\n  false\n  >>> isPrime(182)\n  false\n  >>> isPrime(183)\n  false\n  >>> isPrime(184)\n  false\n  >>> isPrime(185)\n  false\n  >>> isPrime(186)\n  false\n  >>> isPrime(187)\n  false\n  >>> isPrime(188)\n  false\n  >>> isPrime(189)\n  false\n  >>> isPrime(190)\n  false\n  >>> isPrime(191)\n  false\n  >>> isPrime(192)\n  false\n  >>> isPrime(193)\n  false\n  >>> isPrime(194)\n  false\n  >>> isPrime(195)\n  false\n  >>> isPrime(196)\n  false\n  >>> isPrime(197)\n  false\n  >>> isPrime(198)\n  false\n  >>> isPrime(199)\n  false\n  >>> isPrime(200)\n  false\n  >>> isPrime(201)\n  false\n  >>> isPrime(202)\n  false\n  >>> isPrime(203)\n  false\n  >>> isPrime(204)\n  false\n  >>> isPrime(205)\n  false\n  >>> isPrime(206)\n  false\n  >>> isPrime(207)\n  false\n  >>> isPrime(208)\n  false\n  >>> isPrime(209)\n  false\n  >>> isPrime(210)\n  false\n  >>> isPrime(211)\n  false\n  >>> isPrime(212)\n  false\n  >>> isPrime(213)\n  false\n  >>> isPrime(214)\n  false\n  >>> isPrime(215)\n  false\n  >>> isPrime(216)\n  false\n  >>> isPrime(217)\n  false\n  >>> isPrime(218)\n  false\n  >>> isPrime(219)\n  false\n  >>> isPrime(220)\n  false\n  >>> isPrime(221)\n  false\n  >>> isPrime(222)\n  false\n  >>> isPrime(223)\n  false\n  >>> isPrime(224)\n  false\n  >>> isPrime(225)\n  false\n  >>> isPrime(226)\n  false\n  >>> isPrime(227)\n  false\n  >>> isPrime(228)\n  false\n  >>> isPrime(229)\n  false\n  >>> isPrime(230)\n  false\n  >>> isPrime(231)\n  false\n  >>> isPrime(232)\n  false\n  >>> isPrime(233)\n  false\n  >>> isPrime(234)\n  false\n  >>> isPrime(235)\n  false\n  >>> isPrime(236)\n  false\n  >>> isPrime(237)\n  false\n  >>> isPrime(238)\n  false\n  >>> isPrime(239)\n  false\n  >>> isPrime(240)\n  false\n  >>> isPrime(241)\n  false\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestParens", "gc": "<|endoftext|>/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestParens = (paren_string) => {\n  const paren_stack = [];\n  const paren_level = 0;\n  let paren_count = 0;\n  let paren_level_count = 0;\n  let paren_level_count2 = 0;\n  let paren_level_count3 = 0;\n  let paren_level_count4 = 0;\n  let paren_level_count5 = 0;\n  let paren_level_count6 = 0;\n  let paren_level_count7 = 0;\n  let paren_level_count8 = 0;\n  let paren_level_count9 = 0;\n  let paren_level_count10 = 0;\n  let paren_level_count11 = 0;\n  let paren_level_count12 = 0;\n  let paren_level_count13 = 0;\n  let paren_level_count14 = 0;\n  let paren_level_count15 = 0;\n  let paren_level_count16 = 0;\n  let paren_level_count17 = 0;\n  let paren_level_count18 = 0;\n  let paren_level_count19 = 0;\n  let paren_level_count20 = 0;\n  let paren_level_count21 = 0;\n  let paren_level_count22 = 0;\n  let paren_level_count23 = 0;\n  let paren_level_count24 = 0;\n  let paren_level_count25 = 0;\n  let paren_level_count26 = 0;\n  let paren_level_count27 = 0;\n  let paren_level_count28 = 0;\n  let paren_level_count29 = 0;\n  let paren_level_count30 = 0;\n  let paren_level_count31 = 0;\n  let paren_level_count32 = 0;\n  let paren_level_count33 = 0;\n  let paren_level_count34 = 0;\n  let paren_level_count35 = 0;\n  let paren_level_count36 = 0;\n  let paren_level_count37 = 0;\n  let paren_level_count38 = 0;\n  let paren_level_count39 = 0;\n  let paren_level_count40 = 0;\n  let paren_level_count41 = 0;\n  let paren_level_count42 = 0;\n  let paren_level_count43 = 0;\n  let paren_level_count44 = 0;\n  let paren_level_count45 = 0;\n  let paren_level_count46 = 0;\n  let paren_level_count47 = 0;\n  let paren_level_count48 = 0;\n  let paren_level_count49 = 0;\n  let paren_level_count50 = 0;\n  let paren_level_count51 = 0;\n  let paren_level_count52 = 0;\n  let paren_level_count53 = 0;\n  let paren_level_count54 = 0;\n  let paren_level_count55 = 0;\n  let paren_level_count56 = 0;\n  let paren_level_count57 = 0;\n  let paren_level_count58 = 0;\n  let paren_level_count59 = 0;\n  let paren_level_count60 = 0;\n  let paren_level_count61 = 0;\n  let paren_level_count62 = 0;\n  let paren_level_count63 = 0;\n  let paren_level_count64 = 0;\n  let paren_level_count65 = 0;\n  let paren_level_count66 = 0;\n  let paren_level_count67 = 0;\n  let paren_level_count68 = 0;\n  let paren_level_count69 = 0;\n  let paren_level_count70 = 0;\n  let paren_level_count71 = 0;\n  let paren_level_count72 = 0;\n  let paren_level_count73 = 0;\n  let paren_level_count74 = 0;\n  let paren_level_count75 = 0;\n  let paren_level_count76 = 0;\n  let paren_level_count77 = 0;\n  let paren_level_count78 = 0;\n  let paren_level_count79 = 0;\n  let paren_level_count80 = 0;\n  let paren_level_count81 = 0;\n  let paren_level_count82 = 0;\n  let paren_level_count83 = 0;\n  let paren_level_count84 = 0;\n  let paren_level_count85 = 0;\n  let paren_level_count86 = 0;\n  let paren_level_count87 = 0;\n  let paren_level_count88 = 0;\n  let paren_level_count89 = 0;\n  let paren_level_count90 = 0;\n  let paren_level_count91 = 0;\n  let paren_level_count92 = 0;\n  let paren_level_count93 = 0;\n  let paren_level_count94 = 0;\n  let paren_level_count95 = 0;\n  let paren_level_count96 = 0;\n  let paren_level_count97 = 0;\n  let paren_level_count98 = 0;\n  let paren_level_count99 = 0;\n  let paren_level_count100 = 0;\n  let paren_level_count101 = 0;\n  let paren_level_count102 = 0;\n  let paren_level_count103 = 0;\n  let paren_level_count104 = 0;\n  let paren_level_count105 = 0;\n  let paren_level_count106 = 0;\n  let paren_level_count107 = 0;\n  let paren_level_count108 = 0;\n  let paren_level_count109 = 0;\n  let paren_level_count110 = 0;\n  let paren_level_count111 = 0;\n  let paren_level_count112 = 0;\n  let paren_level_count113 = 0;\n  let paren_level_count114 = 0;\n  let paren_level_count115 = 0;\n  let paren_level_count116 = 0;\n  let paren_level_count117 = 0;\n  let paren_level_count118 = 0;\n  let paren_level_count119 = 0;\n  let paren_level_count120 = 0;\n  let paren_level_count121 = 0;\n  let paren_level_count122 = 0;\n  let paren_level_count123 = 0;\n  let paren_level_count124 = 0;\n  let paren_level_count125 = 0;\n  let paren_level_count126 = 0;\n  let paren_level_count127 = 0;\n  let paren_level_count128 = 0;\n  let paren_level_count129 = 0;\n  let paren_level_count130 = 0;\n  let paren_level_count131 = 0;\n  let paren_level_count132 = 0;\n  let paren_level_count133 = 0;\n  let paren_level_count134 = 0;\n  let paren_level_count135 = 0;\n  let paren_level_count136 = 0;\n  let paren_level_count137 = 0;\n  let paren_level_count138 = 0;\n  let paren_level_count139 = 0;\n  let paren_level_count140 = 0;\n  let paren_level_count141 = 0;\n  let paren_level_count142 = 0;\n  let paren_level_count143 = 0;\n  let paren_level_count144 = 0;\n  let paren_level_count145 = 0;\n  let paren_level_count146 = 0;\n  let paren_level_count147 = 0;\n  let paren_level_count148 = 0;\n  let paren_level_count149 = 0;\n  let paren_level_count150 = 0;\n  let paren_level_count151 = 0;\n  let paren_level_count152 = 0;\n  let paren_level_count153 = 0;\n  let paren_level_count154 = 0;\n  let paren_level_count155 = 0;\n  let paren_level_count156 = 0;\n  let paren_level_count157 = 0;\n  let paren_level_count158 = 0;\n  let paren_level_count159 = 0;\n  let paren_level_count160 = 0;\n  let paren_level_count161 = 0;\n  let paren_level_count162 = 0;\n  let paren_level_count163 = 0;\n  let paren_level_count164 = 0;\n  let paren_level_count165 = 0;\n  let paren_level_count166 = 0;\n  let paren_level_count167 = 0;\n  let paren_level_count168 = 0;\n  let paren_level_count169 = 0;\n  let paren_level_count170 = 0;\n  let paren_level_count171 = 0;\n  let paren_level_count172 = 0;\n  let paren_level_count173 = 0;\n  let paren_level_count174 = 0;\n  let paren_level_count175 = 0;\n  let paren_level_count176 = 0;\n  let paren_level_count177 = 0;\n  let paren_level_count178 = 0;\n  let paren_level_count", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumsToN is a function that sums numbers from 1 to n.\n  >>> sumsToN(30)\n  465\n  >>> sumsToN(100)\n  5050\n  >>> sumsToN(5)\n  15\n  >>> sumsToN(10)\n  55\n  >>> sumsToN(1)\n  1\n  */\nconst sumsToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumsToN", "gc": "<|endoftext|>/*sumsToN is a function that sums numbers from 1 to n.\n  >>> sumsToN(30)\n  465\n  >>> sumsToN(100)\n  5050\n  >>> sumsToN(5)\n  15\n  >>> sumsToN(10)\n  55\n  >>> sumsToN(1)\n  1\n  */\nconst sumsToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of the squares of the numbers from 1 to n.\n * It uses recursion.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying by itself until it reaches n.\n * It then returns the sum of the squares.\n * It works by starting with 1 and multiplying ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "gc": "<|endoftext|>/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.split(\"(\").map(x => x.trim());\n  const closingBrackets = brackets.split(\")\").map(x => x.trim());\n  return openingBrackets.every(x => closingBrackets.includes(x));\n};\n\n/**\n * Given a string, return true if it contains only letters.\n *\n * >>> isLetters(\"abc def ghi\")\n * true\n * >>> isLetters(\"abc\")\n * false\n * >>> isLetters(\"abc def ghi\")\n * false\n * >>> isLetters(\"abc def ghi\")\n * false\n */\nconst isLetters = str => {\n  return str.length === 1 && /[a-zA-Z]/.test(str);\n};\n\n/**\n * Given a string, return true if it contains only numbers.\n *\n * >>> isNumbers(\"abc def ghi\")\n * true\n * >>> isNumbers(\"abc\")\n * false\n * >>> isNumbers(\"abc def ghi\")\n * false\n * >>> isNumbers(\"abc def ghi\")\n * false\n */\nconst isNumbers = str => {\n  return str.length === 1 && /[0-9]/.test(str);\n};\n\n/**\n * Given a string, return true if it contains only letters and numbers.\n *\n * >>> isLettersAndNumbers(\"abc def ghi\")\n * true\n * >>> isLettersAndNumbers(\"abc\")\n * false\n * >>> isLettersAndNumbers(\"abc def ghi\")\n * false\n * >>> isLettersAndNumbers(\"abc def ghi\")\n * false\n */\nconst isLettersAndNumbers = str => {\n  return isLetters(str) && isNumbers(str);\n};\n\n/**\n * Given a string, return true if it contains only letters and numbers and is all caps.\n *\n * >>> isLettersAndNumbersAndCaps(\"abc def ghi\")\n * true\n * >>> isLettersAndNumbersAndCaps(\"abc\")\n * false\n * >>> isLettersAndNumbersAndCaps(\"abc def ghi\")\n * false\n * >>> isLettersAndNumbersAndCaps(\"abc def ghi\")\n * false\n */\nconst isLettersAndNumbersAndCaps = str => {\n  return isLettersAndNumbers(str) && str.length === 1 && str[0] === str[0].toUpperCase() && str[0] === str[0].toLowerCase();\n};\n\n/**\n * Given a string, return true if it contains only letters and numbers and is all caps and is all lowercase.\n *\n * >>> isLettersAndNumbersAndCapsAndLowerCase(\"abc def ghi\")\n * true\n * >>> isLettersAndNumbersAndCapsAndLowerCase(\"abc\")\n * false\n * >>> isLettersAndNumbersAndCapsAndLowerCase(\"abc def ghi\")\n * false\n * >>> isLettersAndNumbersAndCapsAndLowerCase(\"abc def ghi\")\n * false\n */\nconst isLettersAndNumbersAndCapsAndLowerCase = str => {\n  return isLettersAndNumbersAndCaps(str) && str.length === 1 && str[0] === str[0].toUpperCase() && str[0] === str[0].toLowerCase();\n};\n\n/**\n * Given a string, return true if it contains only letters and numbers and is all caps and is all lowercase.\n *\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCaps(\"abc def ghi\")\n * true\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCaps(\"abc\")\n * false\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCaps(\"abc def ghi\")\n * false\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCaps(\"abc def ghi\")\n * false\n */\nconst isLettersAndNumbersAndCapsAndLowerCaseAndAllCaps = str => {\n  return isLettersAndNumbersAndCapsAndLowerCase(str) && str.length === 1 && str[0] === str[0].toUpperCase() && str[0] === str[0].toLowerCase();\n};\n\n/**\n * Given a string, return true if it contains only letters and numbers and is all caps and is all lowercase.\n *\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCase(\"abc def ghi\")\n * true\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCase(\"abc\")\n * false\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCase(\"abc def ghi\")\n * false\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCase(\"abc def ghi\")\n * false\n */\nconst isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCase = str => {\n  return isLettersAndNumbersAndCapsAndLowerCase(str) && str.length === 1 && str[0] === str[0].toUpperCase() && str[0] === str[0].toLowerCase();\n};\n\n/**\n * Given a string, return true if it contains only letters and numbers and is all caps and is all lowercase.\n *\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCaseAndAllCaps(\"abc def ghi\")\n * true\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCaseAndAllCaps(\"abc\")\n * false\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCaseAndAllCaps(\"abc def ghi\")\n * false\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCaseAndAllCaps(\"abc def ghi\")\n * false\n */\nconst isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCaseAndAllCaps = str => {\n  return isLettersAndNumbersAndCapsAndLowerCase(str) && str.length === 1 && str[0] === str[0].toUpperCase() && str[0] === str[0].toLowerCase();\n};\n\n/**\n * Given a string, return true if it contains only letters and numbers and is all caps and is all lowercase.\n *\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCaseAndAllCapsAndLowerCase(\"abc def ghi\")\n * true\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCaseAndAllCaps(\"abc\")\n * false\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCaseAndAllCaps(\"abc def ghi\")\n * false\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCaseAndAllCaps(\"abc def ghi\")\n * false\n */\nconst isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCaseAndAllCapsAndLowerCase = str => {\n  return isLettersAndNumbersAndCapsAndLowerCase(str) && str.length === 1 && str[0] === str[0].toUpperCase() && str[0] === str[0].toLowerCase();\n};\n\n/**\n * Given a string, return true if it contains only letters and numbers and is all caps and is all lowercase.\n *\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCaseAndAllCapsAndLowerCase(\"abc def ghi\")\n * true\n * >>> isLettersAndNumbersAndCapsAndLowerCaseAndAllCapsAndLowerCaseAndAllCapsAndLowerCase(\"abc\")\n * false\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "gc": "<|endoftext|>/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let n = xs.length\n  let d = 0\n  for (let i = 1; i < n; i++) {\n    d += xs[i - 1] * xs[i]\n  }\n  return d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverse([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> inverse([1, 2, 3])\n  [3, 1, 2, 4, 5]\n  */\nconst inverse = (xs) => {\n  let n = xs.length\n  let i = 1\n  let j = 1\n  let k = 1\n  let d = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      for (let k = 0; k < n; k++) {\n        d += xs[i] * xs[k] * xs[j]\n      }\n    }\n  }\n  return d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverse([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> inverse([1, 2, 3])\n  [3, 1, 2, 4, 5]\n  */\nconst inverseAndDerivative = (xs) => {\n  let n = xs.length\n  let i = 1\n  let j = 1\n  let k = 1\n  let d = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      for (let k = 0; k < n; k++) {\n        d += xs[i] * xs[k] * xs[j]\n      }\n    }\n  }\n  return d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivative([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> inverseAndDerivative([1, 2, 3])\n  [3, 1, 2, 4, 5]\n  */\nconst inverseAndDerivativeDerivative = (xs) => {\n  let n = xs.length\n  let i = 1\n  let j = 1\n  let k = 1\n  let d = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      for (let k = 0; k < n; k++) {\n        d += xs[i] * xs[k] * xs[j]\n      }\n    }\n  }\n  return d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivativeDerivative([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> inverseAndDerivativeDerivative([1, 2, 3])\n  [3, 1, 2, 4, 5]\n  */\nconst inverseAndDerivativeDerivativeDerivativeDerivative = (xs) => {\n  let n = xs.length\n  let i = 1\n  let j = 1\n  let k = 1\n  let d = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      for (let k = 0; k < n; k++) {\n        d += xs[i] * xs[k] * xs[j]\n      }\n    }\n  }\n  return d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivativeDerivativeDerivative([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> inverseAndDerivativeDerivativeDerivative([1, 2, 3])\n  [3, 1, 2, 4, 5]\n  */\nconst inverseAndDerivativeDerivativeDerivativeDerivativeDerivative = (xs) => {\n  let n = xs.length\n  let i = 1\n  let j = 1\n  let k = 1\n  let d = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      for (let k = 0; k < n; k++) {\n        d += xs[i] * xs[k] * xs[j]\n      }\n    }\n  }\n  return d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivativeDerivativeDerivativeDerivative([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivative([1, 2, 3])\n  [3, 1, 2, 4, 5]\n  */\nconst inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivative = (xs) => {\n  let n = xs.length\n  let i = 1\n  let j = 1\n  let k = 1\n  let d = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      for (let k = 0; k < n; k++) {\n        d += xs[i] * xs[k] * xs[j]\n      }\n    }\n  }\n  return d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivative([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([1, 2, 3])\n  [3, 1, 2, 4, 5]\n  */\nconst inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative = (xs) => {\n  let n = xs.length\n  let i = 1\n  let j = 1\n  let k = 1\n  let d = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      for (let k = 0; k < n; k++) {\n        d += xs[i] * xs[k] * xs[j]\n      }\n    }\n  }\n  return d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([1, 2, 3])\n  [3, 1, 2, 4, 5]\n  */\nconst inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative = (xs) => {\n  let n = xs.length\n  let i = 1\n  let j = 1\n  let k = 1\n  let d = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      for (let k = 0; k < n; k++) {\n        d += xs[i] * xs[k] * xs[j]\n      }\n    }\n  }\n  return d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([1, 2, 3])\n  [3, 1, 2, 4, 5]\n  */\nconst inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative = (xs) => {\n  let n = xs.length\n  let i = 1\n  let j = 1\n  let k = 1\n  let d = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      for (let k = 0; k < n; k++) {\n        d += xs[i] * xs[k] * xs[j]\n      }\n    }\n  }\n  return d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([3, 1, 2, 4, 5])\n  [3, 1, 2, 4, 5]\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([1, 2, 3])\n  [3, 1, 2, 4, 5]\n  */\nconst inverse", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "gc": "<|endoftext|>/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence using recursion.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibRecursive = (n) => {\n  if (n <= 1) return 1;\n  return fibfibRecursive(n-1) + fibfibRecursive(n-2) + fibfibRecursive(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence using iteration.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibIterative = (n) => {\n  let i = 0;\n  let j = 1;\n  let fibfib = 0;\n  while (i < n) {\n    fibfib = fibfib + fibfib + fibfib;\n    i++;\n    j++;\n  }\n  return fibfib;\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence using iteration.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibIterativeRecursive = (n) => {\n  let i = 0;\n  let j = 1;\n  let fibfib = 0;\n  while (i < n) {\n    fibfib = fibfib + fibfib + fibfib;\n    i++;\n    j++;\n  }\n  return fibfib;\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence using iteration.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibIterativeRecursive2 = (n) => {\n  let fibfib = 0;\n  let i = 0;\n  let j = 1;\n  while (i < n) {\n    fibfib = fibfib + fibfib + fibfib;\n    i++;\n    j++;\n  }\n  return fibfib;\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence using iteration.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibIterativeRecursive3 = (n) => {\n  let fibfib = 0;\n  let i = 0;\n  let j = 1;\n  let fibfib = 0;\n  while (i < n) {\n    fibfib = fibfib + fibfib + fibfib;\n    i++;\n    j++;\n  }\n  return fibfib;\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence using iteration.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibIterativeRecursive4 = (n) => {\n  let fibfib = 0;\n  let i = 0;\n  let j = 1;\n  let fibfib = 0;\n  while (i < n) {\n    fibfib = fibfib + fibfib + fibfib;\n    i++;\n    j++;\n  }\n  return fibfib;\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence using iteration.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibIterativeRecursive5 = (n) => {\n  let fibfib = 0;\n  let i = 0;\n  let j = 1;\n  let fibfib = 0;\n  while (i < n) {\n    fibfib = fibfib + fibfib + fibfib;\n    i++;\n    j++;\n  }\n  return fibfib;\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence using iteration.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibIterativeRecursive6 = (n) => {\n  let fibfib = 0;\n  let i = 0;\n  let j = 1;\n  let fibfib = 0;\n  while (i < n) {\n    fibfib = fibfib + fibfib + fibfib;\n    i++;\n    j++;\n  }\n  return fibfib;\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence using iteration.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibIterativeRecursive7 = (n) => {\n  let fibfib = 0;\n  let i = 0;\n  let j = 1;\n  let fibfib = 0;\n  while (i < n) {\n    fibfib = fibfib + fibfib + fibfib;\n    i++;\n    j++;\n  }\n  return fibfib;\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence using iteration.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibIterativeRecursive8 = (n) => {\n  let fibfib = 0;\n  let i = 0;\n  let j = 1;\n  let fibfib = 0;\n  while (i < n) {\n    fibfib = fibfib + fibfib + fibfib;\n    i++;\n    j++;\n  }\n  return fibfib;\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence using iteration.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibIterativeRecursive9 = (n) => {\n  let fibfib = 0;\n  let i = 0;\n  let j = 1;\n  let fibfib = 0;\n  while (i < n) {\n    fibfib = fibfib + fibfib + fibfib;\n    i++;\n    j++;\n  }\n  return fibfib;\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence using iteration.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfibIterativeRecursive10 = (n) => {\n  let fibfib = 0;\n  let i = 0;\n  let j = 1;\n  let fibfib = 0;\n  while (i < n) {\n    fibfib = fibfib + fibfib + fibfib;\n    i++;\n    j++;\n  }\n  return fibfib;\n};\n\n/*\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelCount(\"abcde\")\n  2\n  >>> vowelCount(\"ACEDY\")\n  3\n  */\nconst vowelCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelCount", "gc": "<|endoftext|>/*Write a function vowelCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelCount(\"abcde\")\n  2\n  >>> vowelCount(\"ACEDY\")\n  3\n  */\nconst vowelCount = (s) => {\n  let vowelCount = 0;\n  let vowelsFound = false;\n  let vowelsFoundAtEndOfWord = false;\n  let vowelsFoundAtStartOfWord = false;\n  let vowelsFoundAtStartOfWordAtEndOfWord = false;\n  let vowelsFoundAtStartOfWordAtEndOfWordAtStartOfWord = false;\n  let vowelsFoundAtStartOfWordAtEndOfWordAtStartOfWordAtEndOfWord = false;\n  let vowelsFoundAtStartOfWordAtEndOfWordAtStartOfWordAtEndOfWordAtEndOfWord = false;\n  let vowelsFoundAtStartOfWordAtEndOfWordAtStartOfWordAtEndOfWordAtEndOfWordAtStartOfWord = false;\n  let vowelsFoundAtStartOfWordAtEndOfWordAtStartOfWordAtEndOfWordAtEndOfWordAtEndOfWord = false;\n  let vowelsFoundAtStartOfWordAtEndOfWordAtStartOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtStartOfWord = false;\n  let vowelsFoundAtStartOfWordAtEndOfWordAtStartOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWord = false;\n  let vowelsFoundAtStartOfWordAtEndOfWordAtStartOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtStartOfWord = false;\n  let vowelsFoundAtStartOfWordAtEndOfWordAtStartOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWord = false;\n  let vowelsFoundAtStartOfWordAtEndOfWordAtStartOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWordAtEndOfWord", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "gc": "<|endoftext|>/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const digits = x.toString(10).split('');\n  let reversed = digits.reverse();\n  reversed.splice(reversed.length - shift, shift);\n  return reversed.join('');\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a boolean, or throws an error if the string is not a boolean.\n */\nconst toBoolean = (text) => {\n  try {\n    return text === 'true';\n  } catch (e) {\n    throw new TypeError(`Expected a boolean, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};\n\n/**\n * Converts a string to a number, or throws an error if the string is not a number.\n */\nconst toNumber = (text) => {\n  try {\n    return Number(text);\n  } catch (e) {\n    throw new TypeError(`Expected a number, got ${text}`);\n  }\n};", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSums(\"\") => 0\n      digitSums(\"abAB\") => 131\n      digitSums(\"abcCd\") => 67\n      digitSums(\"helloE\") => 69\n      digitSums(\"woArBld\") => 131\n      digitSums(\"aAaaaXa\") => 153\n  */\nconst digitSums = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSums", "gc": "<|endoftext|>/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSums(\"\") => 0\n      digitSums(\"abAB\") => 131\n      digitSums(\"abcCd\") => 67\n      digitSums(\"helloE\") => 69\n      digitSums(\"woArBld\") => 131\n      digitSums(\"aAaaaXa\") => 153\n  */\nconst digitSums = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower characters only'\n  ASCII codes.\n\n  Examples:\n      digitSums(\"\") => 0\n      digitSums(\"abAB\") => 131\n      digitSums(\"abcCd\") => 67\n      digitSums(\"helloE\") => 69\n      digitSums(\"woArBld\") => 131\n      digitSums(\"aAaaaXa\") => 153\n  */\nconst digitSums2 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower and upper case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSums(\"\") => 0\n      digitSums(\"abAB\") => 131\n      digitSums(\"abcCd\") => 67\n      digitSums(\"helloE\") => 69\n      digitSums(\"woArBld\") => 131\n      digitSums(\"aAaaaXa\") => 153\n  */\nconst digitSums3 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower and upper case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSums(\"\") => 0\n      digitSums(\"abAB\") => 131\n      digitSums(\"abcCd\") => 67\n      digitSums(\"helloE\") => 69\n      digitSums(\"woArBld\") => 131\n      digitSums(\"aAaaaXa\") => 153\n  */\nconst digitSums4 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower and upper case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSums(\"\") => 0\n      digitSums(\"abAB\") => 131\n      digitSums(\"abcCd\") => 67\n      digitSums(\"helloE\") => 69\n      digitSums(\"woArBld\") => 131\n      digitSums(\"aAaaaXa\") => 153\n  */\nconst digitSums5 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower and upper case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSums(\"\") => 0\n      digitSums(\"abAB\") => 131\n      digitSums(\"abcCd\") => 67\n      digitSums(\"helloE\") => 69\n      digitSums(\"woArBld\") => 131\n      digitSums(\"aAaaaXa\") => 153\n  */\nconst digitSums6 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower and upper case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSums(\"\") => 0\n      digitSums(\"abAB\") => 131\n      digitSums(\"abcCd\") => 67\n      digitSums(\"helloE\") => 69\n      digitSums(\"woArBld\") => 131\n      digitSums(\"aAaaaXa\") => 153\n  */\nconst digitSums7 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower and upper case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSums(\"\") => 0\n      digitSums(\"abAB\") => 131\n      digitSums(\"abcCd\") => 67\n      digitSums(\"helloE\") => 69\n      digitSums(\"woArBld\") => 131\n      digitSums(\"aAaaaXa\") => 153\n  */\nconst digitSums8 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower and upper case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSums(\"\") => 0\n      digitSums(\"abAB\") => 131\n      digitSums(\"abcCd\") => 67\n      digitSums(\"helloE\") => 69\n      digitSums(\"woArBld\") => 131\n      digitSums(\"aAaaaXa\") => 153\n  */\nconst digitSums9 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower and upper case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSums(\"\") => 0\n      digitSums(\"abAB\") => 131\n      digitSums(\"abcCd\") => 67\n      digitSums(\"helloE\") => 69\n      digitSums(\"woArBld\") => 131\n      digitSums(\"aAaaaXa\") => 153\n  */\nconst digitSums10 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower and upper case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSums(\"\") => 0\n      digitSums(\"abAB\") => 131\n      digitSums(\"abcCd\") => 67\n      digitSums(\"helloE\") => 69\n      digitSums(\"woArBld\") => 131\n      digitSums(\"aAaaaXa\") => 153\n  */\nconst digitSums11 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower and upper case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digitSums(\"\") => 0\n      digitSums(\"abAB\") => 131\n      digitSums(\"abcCd\") => 67\n      digitSums(\"helloE\") => 69\n      digitSum", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "gc": "<|endoftext|>/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i] === \"apples\") {\n      apples++;\n    } else if (fruits[i] === \"oranges\") {\n      oranges++;\n    } else if (fruits[i] === \"mango\") {\n      mango++;\n    }\n  }\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i] === \"apples\") {\n      total++;\n    } else if (fruits[i] === \"oranges\") {\n      total++;\n    } else if (fruits[i] === \"mango\") {\n      total++;\n    }\n  }\n  return total - apples - oranges - mango;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i] === \"apples\") {\n      apples++;\n    } else if (fruits[i] === \"oranges\") {\n      oranges++;\n    } else if (fruits[i] === \"mango\") {\n      mango++;\n    }\n  }\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i] === \"apples\") {\n      total++;\n    } else if (fruits[i] === \"oranges\") {\n      total++;\n    } else if (fruits[i] === \"mango\") {\n      total++;\n    }\n  }\n  return total - apples - oranges - mango;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i] === \"apples\") {\n      apples++;\n    } else if (fruits[i] === \"oranges\") {\n      oranges++;\n    } else if (fruits[i] === \"mango\") {\n      mango++;\n    }\n  }\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i] === \"apples\") {\n      total++;\n    } else if (fruits[i] === \"oranges\") {\n      total++;\n    } else if (fruits[i] === \"mango\") {\n      total++;\n    }\n  }\n  return total - apples - oranges - mango;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i] === \"apples\") {\n      apples++;\n    } else if (fruits[i] === \"oranges\") {\n      oranges++;\n    } else if (fruits[i] === \"mango\") {\n      mango++;\n    }\n  }\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i] === \"apples\") {\n      total++;\n    } else if (fruits[i] === \"oranges\") {\n      total++;\n    } else if (fruits[i] === \"mango\") {\n      total++;\n    }\n  }\n  return total - apples - oranges - mango;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \");\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i] === \"apples\") {\n      apples++;\n    } else if (fruits[i] === \"oranges\") {\n      oranges++;\n    } else if (fruits[i] === \"mango\") {\n      mango++;\n    }\n  }\n  for (let i = 0; i < fruits.length; i++) {\n    if (fruits[i] === \"apples\") {\n      total++;\n    } else if (fruits[i] === \"oranges\") {\n      total++;\n    } else if (fruits[i] === \"mango\") {\n      total++;\n    }\n  }\n  return total - apples - oranges - mango;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distribute", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "gc": "<|endoftext|>/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const len = arr.length;\n  let result = [];\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      result.push(arr[i]);\n      i++;\n    } else {\n      j++;\n      if (j === len) {\n        break;\n      }\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-smallest-positive-integer-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findSmallestPositiveInteger = function(nums) {\n  let minNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minNum) {\n      minNum = nums[i];\n    }\n  }\n  return minNum;\n};\n\n// https://leetcode.com/problems/find-the-smallest-positive-integer-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findSmallestPositiveInteger2 = function(nums) {\n  let minNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minNum) {\n      minNum = nums[i];\n    }\n  }\n  return minNum;\n};\n\n// https://leetcode.com/problems/find-the-smallest-positive-integer-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findSmallestPositiveInteger3 = function(nums) {\n  let minNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minNum) {\n      minNum = nums[i];\n    }\n  }\n  return minNum;\n};\n\n// https://leetcode.com/problems/find-the-smallest-positive-integer-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findSmallestPositiveInteger4 = function(nums) {\n  let minNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minNum) {\n      minNum = nums[i];\n    }\n  }\n  return minNum;\n};\n\n// https://leetcode.com/problems/find-the-smallest-positive-integer-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findSmallestPositiveInteger5 = function(nums) {\n  let minNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minNum) {\n      minNum = nums[i];\n    }\n  }\n  return minNum;\n};\n\n// https://leetcode.com/problems/find-the-smallest-positive-integer-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findSmallestPositiveInteger6 = function(nums) {\n  let minNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minNum) {\n      minNum = nums[i];\n    }\n  }\n  return minNum;\n};\n\n// https://leetcode.com/problems/find-the-smallest-positive-integer-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findSmallestPositiveInteger7 = function(nums) {\n  let minNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minNum) {\n      minNum = nums[i];\n    }\n  }\n  return minNum;\n};\n\n// https://leetcode.com/problems/find-the-smallest-positive-integer-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findSmallestPositiveInteger8 = function(nums) {\n  let minNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minNum) {\n      minNum = nums[i];\n    }\n  }\n  return minNum;\n};\n\n// https://leetcode.com/problems/find-the-smallest-positive-integer-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findSmallestPositiveInteger9 = function(nums) {\n  let minNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minNum) {\n      minNum = nums[i];\n    }\n  }\n  return minNum;\n};\n\n// https://leetcode.com/problems/find-the-smallest-positive-integer-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findSmallestPositiveInteger10 = function(nums) {\n  let minNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minNum) {\n      minNum = nums[i];\n    }\n  }\n  return minNum;\n};\n\n// https://leetcode.com/problems/find-the-smallest-positive-integer-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findSmallestPositiveInteger11 = function(nums) {\n  let minNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minNum) {\n      minNum = nums[i];\n    }\n  }\n  return minNum;\n};\n\n// https://leetcode.com/problems/find-the-smallest-positive-integer-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findSmallestPositiveInteger12 = function(nums) {\n  let minNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minNum) {\n      minNum = nums[i];\n    }\n  }\n  return minNum;\n};\n\n// https://leetcode.com/problems/find-the-smallest-positive-integer-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findSmallestPositiveInteger13 = function(nums) {\n  let minNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < minNum) {\n      minNum = nums[i];\n    }\n  }\n  return minNum;\n};\n\n// https://leetcode.com/problems/find-the-smallest-positive-integer-from-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findSmallestPositiveInteger14 = function(nums) {\n  let ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "gc": "<|endoftext|>/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the number of distinct integers\n  in the list.\n  Examples:\n      distinct([]) == 0\n      distinct([1]) == 1\n      distinct([1, 2, 3]) = 2\n      distinct([1, 2, 3, 4, 5]) = 3\n      distinct([1, 2, 3, 4, 5, 6]) = 4\n      distinct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) = 5\n      distinct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 424, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst removeSubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArrayInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArrayInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArrayInArrayInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArrayInArrayInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArrayInArrayInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArrayInArrayInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArrayInArrayInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArrayInArrayInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArrayInArrayInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArrayInArrayInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArrayInArrayInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArrayInArrayInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArrayInArrayInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArrayInArrayInArrayInArray = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === -1);\n};\n\n/**\n * Remove all occurrences of substring from all elements of array\n * >>> removeSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst removeSubstringInArrayInArrayInArrayInArray", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangerSortsLists([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangerSortsLists([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangerSortsLists([]) == []\n  */\nconst strangerSortsLists = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangerSortsLists", "gc": "<|endoftext|>/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangerSortsLists([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangerSortsLists([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangerSortsLists([]) == []\n  */\nconst strangerSortsLists = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const sortedList = sorted.map(x => x.toString());\n  const sortedList2 = sortedList.map(x => x.split('').sort().join(''));\n  return sortedList2;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangerSortsLists([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangerSortsLists([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangerSortsLists([]) == []\n  */\nconst strangerSortsLists2 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const sortedList = sorted.map(x => x.toString());\n  const sortedList2 = sortedList.map(x => x.split('').sort().join(''));\n  return sortedList2;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangerSortsLists([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangerSortsLists([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangerSortsLists([]) == []\n  */\nconst strangerSortsLists3 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const sortedList = sorted.map(x => x.toString());\n  const sortedList2 = sortedList.map(x => x.split('').sort().join(''));\n  return sortedList2;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangerSortsLists([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangerSortsLists([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangerSortsLists([]) == []\n  */\nconst strangerSortsLists4 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const sortedList = sorted.map(x => x.toString());\n  const sortedList2 = sortedList.map(x => x.split('').sort().join(''));\n  return sortedList2;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangerSortsLists([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangerSortsLists([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangerSortsLists([]) == []\n  */\nconst strangerSortsLists5 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const sortedList = sorted.map(x => x.toString());\n  const sortedList2 = sortedList.map(x => x.split('').sort().join(''));\n  return sortedList2;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangerSortsLists([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangerSortsLists([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangerSortsLists([]) == []\n  */\nconst strangerSortsLists6 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const sortedList = sorted.map(x => x.toString());\n  const sortedList2 = sortedList.map(x => x.split('').sort().join(''));\n  return sortedList2;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangerSortsLists([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangerSortsLists([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangerSortsLists([]) == []\n  */\nconst strangerSortsLists7 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const sortedList = sorted.map(x => x.toString());\n  const sortedList2 = sortedList.map(x => x.split('').sort().join(''));\n  return sortedList2;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangerSortsLists([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangerSortsLists([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangerSortsLists([]) == []\n  */\nconst strangerSortsLists8 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const sortedList = sorted.map(x => x.toString());\n  const sortedList2 = sortedList.map(x => x.split('').sort().join(''));\n  return sortedList2;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangerSortsLists([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangerSortsLists([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangerSortsLists([]) == []\n  */\nconst strangerSortsLists9 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const sortedList = sorted.map(x => x.toString());\n  const sortedList2 = sortedList.map(x => x.split('').sort().join(''));\n  return sortedList2;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangerSortsLists([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangerSortsLists([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangerSortsLists([]) == []\n  */\nconst strangerSortsLists10 = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const sortedList = sorted.map(x => x.toString());\n  const sortedList2 = sortedList.map(x => x.split('').sort().join(''));\n  return sortedList2;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangerSortsLists([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangerSortsLists([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangerSortsList", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  trianglesAreas(3, 4, 5) == 6.00\n  trianglesAreas(1, 2, 10) == -1\n  */\nconst trianglesAreas = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "trianglesAreas", "gc": "<|endoftext|>/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  trianglesAreas(3, 4, 5) == 6.00\n  trianglesAreas(1, 2, 10) == -1\n  */\nconst trianglesAreas = (a, b, c) => {\n  const ab = a + b;\n  const ac = a + c;\n  const bc = b + c;\n  const abc = ab + c;\n  if (abc > ac && abc > bc) {\n    return Math.sqrt(abc / ac);\n  }\n  if (ac > ab && ac > bc) {\n    return Math.sqrt(ac / ab);\n  }\n  if (bc > ab && bc > ac) {\n    return Math.sqrt(bc / ac);\n  }\n  return -1;\n};\n\nconst trianglesArea = trianglesAreas;\n\nconst isRectangle = (rect) => {\n  return rect.width > 0 && rect.height > 0;\n};\n\nconst isSquare = (rect) => {\n  return rect.width === rect.height;\n};\n\nconst isCircle = (rect) => {\n  return rect.width === rect.height && rect.radius >= 0;\n};\n\nconst isTriangle = (rect) => {\n  return isRectangle(rect) && isSquare(rect) && isCircle(rect);\n};\n\nconst isPolygon = (rect) => {\n  return isRectangle(rect) && isSquare(rect) && isTriangle(rect);\n};\n\nconst isPointInPolygon = (rect, point) => {\n  return isRectangle(rect) && isSquare(rect) && isTriangle(rect) && isPoint(rect, point);\n};\n\nconst isPointInRectangle = (rect, point) => {\n  return isRectangle(rect) && isSquare(rect) && isTriangle(rect) && isPoint(rect, point);\n};\n\nconst isPointInCircle = (rect, point) => {\n  return isRectangle(rect) && isSquare(rect) && isTriangle(rect) && isPoint(rect, point);\n};\n\nconst isPointInTriangle = (rect, point) => {\n  return isRectangle(rect) && isSquare(rect) && isTriangle(rect) && isPoint(rect, point);\n};\n\nconst isPointInSquare = (rect, point) => {\n  return isRectangle(rect) && isSquare(rect) && isTriangle(rect) && isPoint(rect, point);\n};\n\nconst isPointInRectangleOrPolygon = (rect, point) => {\n  return isRectangle(rect) || isPolygon(rect) && isPoint(rect, point);\n};\n\nconst isPointInCircleOrPolygon = (rect, point) => {\n  return isRectangle(rect) || isPolygon(rect) && isPoint(rect, point);\n};\n\nconst isPointInTriangleOrPolygon = (rect, point) => {\n  return isRectangle(rect) || isPolygon(rect) && isPoint(rect, point);\n};\n\nconst isPointInSquareOrPolygon = (rect, point) => {\n  return isRectangle(rect) || isPolygon(rect) && isPoint(rect, point);\n};\n\nconst isPointInRectangleOrSquare = (rect, point) => {\n  return isRectangle(rect) || isSquare(rect) && isPoint(rect, point);\n};\n\nconst isPointInCircleOrSquare = (rect, point) => {\n  return isRectangle(rect) || isSquare(rect) && isPoint(rect, point);\n};\n\nconst isPointInTriangleOrSquare = (rect, point) => {\n  return isRectangle(rect) || isSquare(rect) && isPoint(rect, point);\n};\n\nconst isPointInRectangleOrCircle = (rect, point) => {\n  return isRectangle(rect) || isCircle(rect) && isPoint(rect, point);\n};\n\nconst isPointInCircleOrCircle = (rect, point) => {\n  return isRectangle(rect) || isCircle(rect) && isPoint(rect, point);\n};\n\nconst isPointInTriangleOrCircle = (rect, point) => {\n  return isRectangle(rect) || isCircle(rect) && isPoint(rect, point);\n};\n\nconst isPointInSquareOrCircle = (rect, point) => {\n  return isRectangle(rect) || isCircle(rect) && isPoint(rect, point);\n};\n\nconst isPointInRectangleOrTriangle = (rect, point) => {\n  return isRectangle(rect) || isTriangle(rect) && isPoint(rect, point);\n};\n\nconst isPointInCircleOrTriangle = (rect, point) => {\n  return isRectangle(rect) || isTriangle(rect) && isPoint(rect, point);\n};\n\nconst isPointInTriangleOrSquare = (rect, point) => {\n  return isRectangle(rect) || isSquare(rect) && isPoint(rect, point);\n};\n\nconst isPointInSquareOrTriangle = (rect, point) => {\n  return isRectangle(rect) || isTriangle(rect) && isPoint(rect, point);\n};\n\nconst isPointInRectangleOrSquare = (rect, point) => {\n  return isRectangle(rect) || isSquare(rect) && isPoint(rect, point);\n};\n\nconst isPointInCircleOrSquare = (rect, point) => {\n  return isRectangle(rect) || isSquare(rect) && isPoint(rect, point);\n};\n\nconst isPointInTriangleOrCircle = (rect, point) => {\n  return isRectangle(rect) || isCircle(rect) && isPoint(rect, point);\n};\n\nconst isPointInCircleOrCircle = (rect, point) => {\n  return isRectangle(rect) || isCircle(rect) && isPoint(rect, point);\n};\n\nconst isPointInTriangleOrTriangle = (rect, point) => {\n  return isRectangle(rect) || isTriangle(rect) && isPoint(rect, point);\n};\n\nconst isPointInSquareOrTriangle = (rect, point) => {\n  return isRectangle(rect) || isTriangle(rect) && isPoint(rect, point);\n};\n\nconst isPointInRectangleOrCircleOrTriangle = (rect, point) => {\n  return isRectangle(rect) || isCircle(rect) || isTriangle(rect) && isPoint(rect, point);\n};\n\nconst isPointInCircleOrCircleOrTriangle = (rect, point) => {\n  return isRectangle(rect) || isCircle(rect) || isTriangle(rect) && isPoint(rect, point);\n};\n\nconst isPointInTriangleOrCircleOrSquare = (rect, point) => {\n  return isRectangle(rect) || isCircle(rect) || isSquare(rect) && isPoint(rect, point);\n};\n\nconst isPointInSquareOrCircleOrTriangle = (rect, point) => {\n  return isRectangle(rect) || isCircle(rect) || isTriangle(rect) || isPoint(rect, point);\n};\n\nconst isPointInRectangleOrCircleOrSquare = (rect, point) => {\n  return isRectangle(rect) || isCircle(rect) || isSquare(rect) || isPoint(rect, point);\n};\n\nconst isPointInCircleOrCircleOrSquare = (rect, point) => {\n  return isRectangle(rect) || isCircle(rect) || isSquare(rect) || isPoint(rect, point);\n};\n\nconst isPointInTriangleOrCircleOrCircle = (rect, point) => {\n  return isRectangle(rect) || isCircle(rect) || isTriangle(rect) || isCircle(rect) && isPoint(rect, point);\n};\n\nconst isPointInCircleOrCircleOrCircle = (rect, point) => {\n  return isRectangle(rect) || isCircle(rect) || isTriangle(rect) || is", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlied([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlied([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlied([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlied([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlied = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFlied", "gc": "<|endoftext|>/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlied([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlied([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlied([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlied([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlied = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum >= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is greater than or equal to the minimum possible weight w.\n\n  Example:\n  willItFlied([1, 2], 5)  true\n  # 1+2 is greater than the minimum possible weight, but it's unbalanced.\n\n  willItFlied([3, 2, 3], 1)  true\n  # it's balanced, but 3+2+3 is more than the minimum possible weight.\n\n  willItFlied([3, 2, 3], 9)  false\n  # 3+2+3 is greater than the minimum possible weight, and it's unbalanced.\n\n  willItFlied([3], 5)  false\n  # 3 is greater than the minimum possible weight, and it's unbalanced.\n  */\nconst willItFlied = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFlied([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlied([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlied([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlied([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlied = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum >= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is greater than or equal to the minimum possible weight w.\n\n  Example:\n  willItFlied([1, 2], 5)  true\n  # 1+2 is greater than the minimum possible weight, but it's unbalanced.\n\n  willItFlied([3, 2, 3], 1)  true\n  # it's balanced, but 3+2+3 is more than the minimum possible weight.\n\n  willItFlied([3, 2, 3], 9)  false\n  # 3+2+3 is greater than the minimum possible weight, and it's unbalanced.\n\n  willItFlied([3], 5)  false\n  # 3 is greater than the minimum possible weight, and it's unbalanced.\n  */\nconst willItFlied = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFlied([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlied([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlied([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlied([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlied = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum >= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is greater than or equal to the minimum possible weight w.\n\n  Example:\n  willItFlied([1, 2], 5)  false\n  # 1+2 is greater than the minimum possible weight, but it's unbalanced.\n\n  willItFlied([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the minimum possible weight.\n\n  willItFlied([3, 2, 3], 9)  true\n  # 3+2+3 is less than the minimum possible weight, and it's balanced.\n\n  willItFlied([3], 5)  true\n  # 3 is less than the minimum possible weight, and it's balanced.\n  */\nconst willItFlied = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFlied([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlied([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlied([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlied([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlied = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n  }\n  return sum >= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is greater than or equal to the minimum possible weight w.\n\n  Example:\n  willItFlied([1, 2], 5)  false\n  # ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallerChange([1,2,3,5,4,7,9,6]) == 4\n  smallerChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallerChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallerChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallerChange", "gc": "<|endoftext|>/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallerChange([1,2,3,5,4,7,9,6]) == 4\n  smallerChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallerChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallerChange = (arr) => {\n  let min = Number.MAX_VALUE;\n  let changes = 0;\n  let change = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      change = i;\n    }\n  }\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] < min) {\n      min = arr[i];\n      change = i;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  biggerChange([1,2,3,5,4,7,9,6]) == 6\n  biggerChange([1, 2, 3, 4, 3, 2, 2]) == 5\n  biggerChange([1, 2, 3, 2, 1]) == 4\n  */\nconst biggerChange = (arr) => {\n  let max = Number.MIN_VALUE;\n  let changes = 0;\n  let change = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      change = i;\n    }\n  }\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] > max) {\n      max = arr[i];\n      change = i;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallerChange([1,2,3,5,4,7,9,6]) == 4\n  smallerChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallerChange([1, 2, 3, 2, 1]) == 0\n  */\nconst biggerChange = (arr) => {\n  let min = Number.MAX_VALUE;\n  let changes = 0;\n  let change = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      change = i;\n    }\n  }\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] < min) {\n      min = arr[i];\n      change = i;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  biggerChange([1,2,3,5,4,7,9,6]) == 6\n  biggerChange([1, 2, 3, 4, 3, 2, 2]) == 5\n  biggerChange([1, 2, 3, 2, 1]) == 4\n  */\nconst smallerChange = (arr) => {\n  let max = Number.MIN_VALUE;\n  let changes = 0;\n  let change = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      change = i;\n    }\n  }\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] > max) {\n      max = arr[i];\n      change = i;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallerChange([1,2,3,5,4,7,9,6]) == 4\n  smallerChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallerChange([1, 2, 3, 2, 1]) == 0\n  */\nconst biggerChange = (arr) => {\n  let min = Number.MAX_VALUE;\n  let changes = 0;\n  let change = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      change = i;\n    }\n  }\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] < min) {\n      min = arr[i];\n      change = i;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  biggerChange([1,2,3,5,4,7,9,6]) == 6\n  biggerChange([1, 2, 3, 4, 3, 2, 2]) == 5\n  biggerChange([1, 2, 3, 2, 1]) == 4\n  */\nconst smallerChange = (arr) => {\n  let max = Number.MIN_VALUE;\n  let changes = 0;\n  let change = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      change = i;\n    }\n  }\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] > max) {\n      max = arr[i];\n      change = i;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallerChange([1,2,3,5,4,7,9,6]) == 4\n  smallerChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallerChange([1, 2, 3, 2, 1]) == 0\n  */\nconst biggerChange = (arr) => {\n  let min = Number.MAX_VALUE;\n  let changes = 0;\n  let change = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      change = i;\n    }\n  }\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] < min) {\n      min = arr[i];\n      change = i;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  biggerChange([1,2,3,5,4,7,9,6]) == 6\n  biggerChange([1, 2, 3, 4, 3, 2, 2]) == 5\n  biggerChange([1, 2, 3, 2, 1]) == 4\n  */\nconst smallerChange = (arr) => {\n  let max = Number.MIN_VALUE;\n  let changes = 0;\n  let change = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      change = i;\n    }\n  }\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] > max) {\n      max = arr[i];\n      change = i;\n    }\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallerChange([1,2,3,5,4,7,9,6]) == 4", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "gc": "<|endoftext|>/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length!== lst2.length) {\n    return lst1;\n  }\n  const totalChars = lst1.reduce((acc, curr, index) => {\n    return acc + curr.length;\n  }, 0);\n  return lst2.filter(curr => curr.length <= totalChars);\n};\n\nexport default totalMatch;\n\n<|/ file ext=.js filename=totalMatch.js |>\n/**\n * totalMatch\n *\n * Given two lists containing strings, return the list that has total number of chars\n * in the all strings of the list less than the other list.\n *\n * If the two lists have the same number of chars, return the first list.\n *\n * Examples\n *\n * totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n * totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n * totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n * totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length!== lst2.length) {\n    return lst1;\n  }\n  const totalChars = lst1.reduce((acc, curr, index) => {\n    return acc + curr.length;\n  }, 0);\n  return lst2.filter(curr => curr.length <= totalChars);\n};\n\nexport default totalMatch;\n\n/**\n * totalMatch\n *\n * Given two lists containing strings, return the list that has total number of chars\n * in the all strings of the list less than the other list.\n *\n * If the two lists have the same number of chars, return the first list.\n *\n * Examples\n *\n * totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n * totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n * totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n * totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length!== lst2.length) {\n    return lst1;\n  }\n  const totalChars = lst1.reduce((acc, curr, index) => {\n    return acc + curr.length;\n  }, 0);\n  return lst2.filter(curr => curr.length <= totalChars);\n};\n\nexport default totalMatch;\n\n/**\n * totalMatch\n *\n * Given two lists containing strings, return the list that has total number of chars\n * in the all strings of the list less than the other list.\n *\n * If the two lists have the same number of chars, return the first list.\n *\n * Examples\n *\n * totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n * totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n * totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n * totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length!== lst2.length) {\n    return lst1;\n  }\n  const totalChars = lst1.reduce((acc, curr, index) => {\n    return acc + curr.length;\n  }, 0);\n  return lst2.filter(curr => curr.length <= totalChars);\n};\n\nexport default totalMatch;\n\n/**\n * totalMatch\n *\n * Given two lists containing strings, return the list that has total number of chars\n * in the all strings of the list less than the other list.\n *\n * If the two lists have the same number of chars, return the first list.\n *\n * Examples\n *\n * totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n * totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n * totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n * totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length!== lst2.length) {\n    return lst1;\n  }\n  const totalChars = lst1.reduce((acc, curr, index) => {\n    return acc + curr.length;\n  }, 0);\n  return lst2.filter(curr => curr.length <= totalChars);\n};\n\nexport default totalMatch;\n\n/**\n * totalMatch\n *\n * Given two lists containing strings, return the list that has total number of chars\n * in the all strings of the list less than the other list.\n *\n * If the two lists have the same number of chars, return the first list.\n *\n * Examples\n *\n * totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n * totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n * totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n * totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length!== lst2.length) {\n    return lst1;\n  }\n  const totalChars = lst1.reduce((acc, curr, index) => {\n    return acc + curr.length;\n  }, 0);\n  return lst2.filter(curr => curr.length <= totalChars);\n};\n\nexport default totalMatch;\n\n/**\n * totalMatch\n *\n * Given two lists containing strings, return the list that has total number of chars\n * in the all strings of the list less than the other list.\n *\n * If the two lists have the same number of chars, return the first list.\n *\n * Examples\n *\n * totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n * totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n * totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n * totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n */\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "gc": "<|endoftext|>/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i <= a; i++) {\n    if (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "gc": "<|endoftext|>/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 0) return true;\n  if (n % 1 === 0) return false;\n  if (n % 2 === 0) return true;\n  if (n % 3 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 5 === 0) return false;\n  return isSimplePower(x, Math.floor(n / 5));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 0) return true;\n  if (n % 1 === 0) return false;\n  if (n % 2 === 0) return true;\n  if (n % 3 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 5 === 0) return false;\n  return isSimplePower(x, Math.floor(n / 5));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 0) return true;\n  if (n % 1 === 0) return false;\n  if (n % 2 === 0) return true;\n  if (n % 3 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 5 === 0) return false;\n  return isSimplePower(x, Math.floor(n / 5));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 0) return true;\n  if (n % 1 === 0) return false;\n  if (n % 2 === 0) return true;\n  if (n % 3 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 5 === 0) return false;\n  return isSimplePower(x, Math.floor(n / 5));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 0) return true;\n  if (n % 1 === 0) return false;\n  if (n % 2 === 0) return true;\n  if (n % 3 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 5 === 0) return false;\n  return isSimplePower(x, Math.floor(n / 5));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 0) return true;\n  if (n % 1 === 0) return false;\n  if (n % 2 === 0) return true;\n  if (n % 3 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 5 === 0) return false;\n  return isSimplePower(x, Math.floor(n / 5));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 0) return true;\n  if (n % 1 === 0) return false;\n  if (n % 2 === 0) return true;\n  if (n % 3 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 5 === 0) return false;\n  return isSimplePower(x, Math.floor(n / 5));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 0) return true;\n  if (n % 1 === 0) return false;\n  if (n % 2 === 0) return true;\n  if (n % 3 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 5 === 0) return false;\n  return isSimplePower(x, Math.floor(n / 5));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n <= 0) return false;\n  if (n === 0) return true;\n  if (n % 1 === 0) return false;\n  if (n % 2 === 0) return true;\n  if (n % 3 === 0) return false;\n  if (n % 4 === 0) return true;\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "gc": "<|endoftext|>/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a < 1) {\n    return false;\n  }\n  let i = 1;\n  while (i <= a) {\n    if (i % a === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a prime number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isprime(1) ==> true\n  isprime(2) ==> false\n  isprime(3) ==> true\n  isprime(4) ==> false\n  isprime(5) ==> true\n  isprime(6) ==> false\n  isprime(7) ==> true\n  isprime(8) ==> false\n  isprime(9) ==> true\n  isprime(10) ==> false\n  isprime(11) ==> true\n  isprime(12) ==> false\n  isprime(13) ==> true\n  isprime(14) ==> false\n  isprime(15) ==> true\n  isprime(16) ==> false\n  isprime(17) ==> true\n  isprime(18) ==> false\n  isprime(19) ==> true\n  isprime(20) ==> false\n  isprime(21) ==> true\n  isprime(22) ==> false\n  isprime(23) ==> true\n  isprime(24) ==> false\n  isprime(25) ==> true\n  isprime(26) ==> false\n  isprime(27) ==> true\n  isprime(28) ==> false\n  isprime(29) ==> true\n  isprime(31) ==> false\n  isprime(32) ==> true\n  isprime(33) ==> false\n  isprime(34) ==> true\n  isprime(35) ==> false\n  isprime(36) ==> true\n  isprime(37) ==> false\n  isprime(38) ==> true\n  isprime(39) ==> false\n  isprime(41) ==> true\n  isprime(42) ==> false\n  isprime(43) ==> true\n  isprime(44) ==> false\n  isprime(45) ==> true\n  isprime(46) ==> false\n  isprime(47) ==> true\n  isprime(48) ==> false\n  isprime(49) ==> true\n  isprime(50) ==> false\n  isprime(51) ==> true\n  isprime(52) ==> false\n  isprime(53) ==> true\n  isprime(54) ==> false\n  isprime(55) ==> true\n  isprime(56) ==> false\n  isprime(57) ==> true\n  isprime(58) ==> false\n  isprime(59) ==> true\n  isprime(60) ==> false\n  isprime(61) ==> true\n  isprime(62) ==> false\n  isprime(63) ==> true\n  isprime(64) ==> false\n  isprime(65) ==> true\n  isprime(66) ==> false\n  isprime(67) ==> true\n  isprime(68) ==> false\n  isprime(69) ==> true\n  isprime(70) ==> false\n  isprime(71) ==> true\n  isprime(72) ==> false\n  isprime(73) ==> true\n  isprime(74) ==> false\n  isprime(75) ==> true\n  isprime(76) ==> false\n  isprime(77) ==> true\n  isprime(78) ==> false\n  isprime(79) ==> true\n  isprime(80) ==> false\n  isprime(81) ==> true\n  isprime(82) ==> false\n  isprime(83) ==> true\n  isprime(84) ==> false\n  isprime(85) ==> true\n  isprime(86) ==> false\n  isprime(87) ==> true\n  isprime(88) ==> false\n  isprime(89) ==> true\n  isprime(90) ==> false\n  isprime(91) ==> true\n  isprime(92) ==> false\n  isprime(93) ==> true\n  isprime(94) ==> false\n  isprime(95) ==> true\n  isprime(96) ==> false\n  isprime(97) ==> true\n  isprime(98) ==> false\n  isprime(99) ==> true\n  isprime(100) ==> false\n  isprime(101) ==> true\n  isprime(102) ==> false\n  isprime(103) ==> true\n  isprime(104) ==> false\n  isprime(105) ==> true\n  isprime(106) ==> false\n  isprime(107) ==> true\n  isprime(108) ==> false\n  isprime(109) ==> true\n  isprime(110) ==> false\n  isprime(111) ==> true\n  isprime(112) ==> false\n  isprime(113) ==> true\n  isprime(114) ==> false\n  isprime(115) ==> true\n  isprime(116) ==> false\n  isprime(117) ==> true\n  isprime(118) ==> false\n  isprime(119) ==> true\n  isprime(120) ==> false\n  isprime(121) ==> true\n  isprime(122) ==> false\n  isprime(123) ==> true\n  isprime(124) ==> false\n  isprime(125) ==> true\n  isprime(126) ==> false\n  isprime(127) ==> true\n  isprime(128) ==> false\n  isprime(129) ==> true\n  isprime(130) ==> false\n  isprime(131) ==> true\n  isprime(132) ==> false\n  isprime(133) ==> true\n  isprime(134) ==> false\n  isprime(135) ==> true\n  isprime(136) ==> false\n  isprime(137) ==> true\n  isprime(138) ==> false\n  isprime(139) ==> true\n  isprime(140) ==> false\n  isprime(141) ==> true\n  isprime(142) ==> false\n  isprime(143) ==> true\n  isprime(144) ==> false\n  isprime(145) ==> true\n  isprime(146) ==> false\n  isprime(147) ==> true\n  isprime(148) ==> false\n  isprime(149) ==> true\n  isprime(150) ==> false\n  isprime(151) ==> true\n  isprime(152) ==> false\n  isprime(153) ==> true\n  isprime(154) ==> false\n  isprime(155) ==> true\n  isprime(156) ==", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexesKeys = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexesKeys", "gc": "<|endoftext|>/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexesKeys = (num) => {\n  let hexesKeysCount = 0;\n  let hexesKeysString = \"\";\n  let hexesKeysArray = [];\n  let hexesKeysArrayLength = 0;\n  let hexesKeysArrayIndex = 0;\n  let hexesKeysArrayValue = \"\";\n  let hexesKeysArrayValueLength = 0;\n  let hexesKeysArrayValueIndex = 0;\n  let hexesKeysArrayValueValue = \"\";\n  let hexesKeysArrayValueValueLength = 0;\n  let hexesKeysArrayValueValueIndex = 0;\n  let hexesKeysArrayValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueIndex = 0;\n  let hexesKeysArrayValueValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueValueIndex = 0;\n  let hexesKeysArrayValueValueValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueValueValueIndex = 0;\n  let hexesKeysArrayValueValueValueValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueValueValueValueIndex = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueValueValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueIndex = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueValueValueValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueIndex = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueIndex = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = \"\";\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let hexesKeysArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalsToBinary(15)   # returns \"db1111db\"\n  decimalsToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalsToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalsToBinary", "gc": "<|endoftext|>/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalsToBinary(15)   # returns \"db1111db\"\n  decimalsToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalsToBinary = (decimal) => {\n  let binary = '';\n  let decimalToBinary = parseInt(decimal, 2);\n  let decimalToBinaryString = decimalToBinary.toString(2);\n  decimalToBinaryString.split('').forEach((char) => {\n    if (char === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  });\n  return binary;\n};\n\n/*\n  Given a string, convert it into an array of binary numbers. Each number in the array will be a binary number.\n  Each number in the array will be a binary number.\n  Examples:\n  binaryToDecimal('11111111')   # returns [1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 1111, 11", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProducts([])\n  (0, 1)\n  >>> sumProducts([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProducts = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProducts", "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProducts([])\n  (0, 1)\n  >>> sumProducts([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProducts = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a sorted list of integers, return the largest and smallest element in the list.\n  >>> largestElement([2, 5, 1, 3])\n  2\n  >>> smallestElement([2, 5, 1, 3])\n  1\n  */\nconst largestElement = (numbers) => {\n  let largest = numbers[0];\n  let smallest = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > largest) {\n      largest = numbers[i];\n    }\n    if (numbers[i] < smallest) {\n      smallest = numbers[i];\n    }\n  }\n  return [largest, smallest];\n};\n\n/* Given a sorted list of integers, return the sum of the integers in the list.\n  >>> sumOfIntegers([2, 5, 1, 3])\n  10\n  */\nconst sumOfIntegers = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  return sum;\n};\n\n/* Given a sorted list of integers, return the product of the integers in the list.\n  >>> productOfIntegers([2, 5, 1, 3])\n  24\n  */\nconst productOfIntegers = (numbers) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n  }\n  return product;\n};\n\n/* Given a sorted list of integers, return the sum of all the integers in the list.\n  >>> sumOfAllIntegers([2, 5, 1, 3])\n  10\n  */\nconst sumOfAllIntegers = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  return sum;\n};\n\n/* Given a sorted list of integers, return the product of the integers in the list.\n  >>> productOfAllIntegers([2, 5, 1, 3])\n  24\n  */\nconst productOfAllIntegers = (numbers) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n  }\n  return product;\n};\n\n/* Given a sorted list of integers, return the sum of all the integers in the list.\n  >>> sumOfAllIntegers([2, 5, 1, 3])\n  10\n  */\nconst sumOfAllIntegers = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  return sum;\n};\n\n/* Given a sorted list of integers, return the product of the integers in the list.\n  >>> productOfAllIntegers([2, 5, 1, 3])\n  24\n  */\nconst productOfAllIntegers = (numbers) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n  }\n  return product;\n};\n\n/* Given a sorted list of integers, return the sum of all the integers in the list.\n  >>> sumOfAllIntegers([2, 5, 1, 3])\n  10\n  */\nconst sumOfAllIntegers = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  return sum;\n};\n\n/* Given a sorted list of integers, return the product of the integers in the list.\n  >>> productOfAllIntegers([2, 5, 1, 3])\n  24\n  */\nconst productOfAllIntegers = (numbers) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n  }\n  return product;\n};\n\n/* Given a sorted list of integers, return the sum of all the integers in the list.\n  >>> sumOfAllIntegers([2, 5, 1, 3])\n  10\n  */\nconst sumOfAllIntegers = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  return sum;\n};\n\n/* Given a sorted list of integers, return the product of the integers in the list.\n  >>> productOfAllIntegers([2, 5, 1, 3])\n  24\n  */\nconst productOfAllIntegers = (numbers) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n  }\n  return product;\n};\n\n/* Given a sorted list of integers, return the sum of all the integers in the list.\n  >>> sumOfAllIntegers([2, 5, 1, 3])\n  10\n  */\nconst sumOfAllIntegers = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  return sum;\n};\n\n/* Given a sorted list of integers, return the product of the integers in the list.\n  >>> productOfAllIntegers([2, 5, 1, 3])\n  24\n  */\nconst productOfAllIntegers = (numbers) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n  }\n  return product;\n};\n\n/* Given a sorted list of integers, return the sum of all the integers in the list.\n  >>> sumOfAllIntegers([2, 5, 1, 3])\n  10\n  */\nconst sumOfAllIntegers = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  return sum;\n};\n\n/* Given a sorted list of integers, return the product of the integers in the list.\n  >>> productOfAllIntegers([2, 5, 1, 3])\n  24\n  */\nconst productOfAllIntegers = (numbers) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n  }\n  return product;\n};\n\n/* Given a sorted list of integers, return the sum of all the integers in the list.\n  >>> sumOfAllIntegers([2, 5, 1, 3])\n  10\n  */\nconst sumOfAllIntegers = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  return sum;\n};\n\n/* Given a sorted list of integers, return the product of the integers in the list.\n  >>> productOfAllIntegers([2, 5, 1, 3])\n  24\n  */\nconst productOfAllIntegers = (numbers) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n  }\n  return product;\n};\n\n/* Given a sorted list of integers, return the sum of all the integers in the list.\n  >>> sumOfAllIntegers([2, 5, 1, 3])\n  10\n  */\nconst sumOfAllIntegers = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  return sum;\n};\n\n/* Given a sorted list of integers, return the product of the integers in the list.\n  >>> productOfAllIntegers([2, 5, 1, 3])\n  24\n  */\nconst productOfAllIntegers = (numbers) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n  }\n  return product;\n};\n\n/* Given a sorted list of integers, return the sum of all the integers in the list.\n  >>> sumOfAllIntegers([2, 5, 1, 3])\n  10\n  */\nconst sumOfAllIntegers = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  return sum;\n};\n\n/* Given a sorted list of integers, return the product of the integers in the list.\n  >>> productOfAllIntegers([2, 5, 1, 3])\n  24\n  */\nconst productOfAllIntegers = (numbers) => {\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n  }\n  return product;\n};\n\n/* Given a sorted list of integers, return the sum of all the integers in the list.\n  >>> sumOfAllIntegers([2, 5, 1, 3])", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isHappiest(a) => false\n  isHappiest(aa) => false\n  isHappiest(abcd) => true\n  isHappiest(aabb) => false\n  isHappiest(adb) => true\n  isHappiest(xyy) => false\n  */\nconst isHappiest = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappiest", "gc": "<|endoftext|>/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isHappiest(a) => false\n  isHappiest(aa) => false\n  isHappiest(abcd) => true\n  isHappiest(aabb) => false\n  isHappiest(adb) => true\n  isHappiest(xyy) => false\n  */\nconst isHappiest = (s) => {\n  let isHappy = true;\n  let isHappyLength = 0;\n  let isHappyLettersDistinct = false;\n  let isHappyLettersCount = 0;\n\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a') {\n      isHappyLength++;\n    } else if (s[i] === 'b') {\n      isHappyLength++;\n    } else if (s[i] === 'c') {\n      isHappyLength++;\n    } else if (s[i] === 'd') {\n      isHappyLength++;\n    } else if (s[i] === 'e') {\n      isHappyLength++;\n    } else if (s[i] === 'f') {\n      isHappyLength++;\n    } else if (s[i] === 'g') {\n      isHappyLength++;\n    } else if (s[i] === 'h') {\n      isHappyLength++;\n    } else if (s[i] === 'i') {\n      isHappyLength++;\n    } else if (s[i] === 'j') {\n      isHappyLength++;\n    } else if (s[i] === 'k') {\n      isHappyLength++;\n    } else if (s[i] === 'l') {\n      isHappyLength++;\n    } else if (s[i] ==='m') {\n      isHappyLength++;\n    } else if (s[i] === 'n') {\n      isHappyLength++;\n    } else if (s[i] === 'o') {\n      isHappyLength++;\n    } else if (s[i] === 'p') {\n      isHappyLength++;\n    } else if (s[i] === 'q') {\n      isHappyLength++;\n    } else if (s[i] === 'r') {\n      isHappyLength++;\n    } else if (s[i] ==='s') {\n      isHappyLength++;\n    } else if (s[i] === 't') {\n      isHappyLength++;\n    } else if (s[i] === 'u') {\n      isHappyLength++;\n    } else if (s[i] === 'v') {\n      isHappyLength++;\n    } else if (s[i] === 'w') {\n      isHappyLength++;\n    } else if (s[i] === 'x') {\n      isHappyLength++;\n    } else if (s[i] === 'y') {\n      isHappyLength++;\n    } else if (s[i] === 'z') {\n      isHappyLength++;\n    } else if (s[i] === 'A') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'B') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'C') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'D') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'E') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'F') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'G') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'H') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'I') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'J') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'K') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'L') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'M') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'N') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'O') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'P') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'Q') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'R') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'S') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'T') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'U') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'V') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'W') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'X') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'Y') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'Z') {\n      isHappyLettersCount++;\n    } else if (s[i] === 'a' || s[i] === 'b' || s[i] === 'c' || s[i] === 'd' || s[i] === 'e' || s[i] === 'f' || s[i] === 'g' || s[i] === 'h' || s[i] === 'i' || s[i] === 'j' || s[i] === 'k' || s[i] === 'l' || s[i] ==='m' || s[i] === 'n' || s[i] === 'o' || s[i] === 'p' || s[i] === 'q' || s[i] === 'r' || s[i] ==='s' || s[i] === 't' || s[i] === 'u' || s[i] === 'v' || s[i] === 'w' || s[i] === 'x' || s[i] === 'y' || s[i] === 'z') {\n      isHappyLettersDistinct = true;\n    }\n  }\n\n  if (isHappyLength >= 3) {\n    isHappyLettersDistinct = true;\n  }\n\n  if (isHappyLettersCount >= 3) {\n    isHappyLettersDistinct = true;\n  }\n\n  if (isHappyLettersDistinct) {\n    isHappy = false;\n  }\n\n  return isHappy;\n};\n\n/*\n  You are given a string s.\n  Your task is to check if the string is palindrome or not.\n  A string is palindrome if its length is at least 2 and every 2 letters are different.\n  For example:\n  isPalindrome(a) => true\n  isPalindrome(aa) => false\n  isPalindrome(abcd) => false\n  isPalindrome(aabb) => true\n  isPalindrome(adb) => false\n  isPalindrome(xyy) => true\n  */\nconst isPalindrome = (s) => {\n  let isPalindrome = true;\n  let isPalindromeLength = 0;\n  let isPalindromeLettersCount = 0;\n\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a') {\n      isPalindromeLength++;\n    } else if (s[i] === 'b') {\n      isPalindromeLength++;\n    } else if (s[i] === 'c') {\n      isPalindromeLength++;\n    } else if (s[i] === 'd') {\n      isPalindromeLength++;\n    } else if (s[i] === 'e') {\n      isPalindromeLength++;\n    } else if (s[i] === 'f') {\n      isPalindromeLength++;\n    } else if (s[i] === 'g') {\n      isPalindromeLength++;\n    } else if (s[i] === 'h') {\n      isPalindromeLength++;\n    } else if (s[i] === 'i') {\n      isPalindromeLength++;\n    } else if (s[i] === 'j') {\n      isPalindromeLength++;\n    } else if (s[i] === 'k') {\n      isPalindromeLength++;\n    } else if (s[i] === 'l') {\n      isPalindromeLength++;\n    } else if (s[i] ==='m') {\n      isPalindromeLength++;\n    } else if (s[i] === 'n') {\n      isPalindromeLength++;\n    } else if (s[i] === 'o') {\n      isPalindromeLength++;\n    } else if (s[i] === 'p') {\n      isPalindromeLength++;\n    } else if (s[i] === 'q') {\n      isPalindromeLength++;\n    } else if (s[i] === 'r'", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGrades = [];\n  let sum = 0;\n  let i;\n  let j;\n  let temp;\n\n  for (i = 0; i < grades.length; i++) {\n    sum = sum + grades[i];\n  }\n\n  for (i = 0; i < grades.length; i++) {\n    temp = grades[i];\n    letterGrades.push(temp);\n  }\n\n  letterGrades.sort((a, b) => a - b);\n\n  for (i = 0; i < letterGrades.length; i++) {\n    letterGrades[i] = letterGrades[i] * 100 / sum;\n  }\n\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade2 = (grades) => {\n  let letterGrades = [];\n  let sum = 0;\n  let i;\n  let j;\n  let temp;\n\n  for (i = 0; i < grades.length; i++) {\n    sum = sum + grades[i];\n  }\n\n  for (i = 0; i < grades.length; i++) {\n    temp = grades[i];\n    letterGrades.push(temp);\n  }\n\n  letterGrades.sort((a, b) => a - b);\n\n  for (i = 0; i < letterGrades.length; i++) {\n    letterGrades[i] = letterGrades[i] * 100 / sum;\n  }\n\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade3 = (grades) => {\n  let letterGrades = [];\n  let sum = 0;\n  let i;\n  let j;\n  let temp;\n\n  for (i = 0; i < grades.length; i++) {\n    sum = sum + grades[i];\n  }\n\n  for (i = 0; i < grades.length; i++) {\n    temp = grades[i];\n    letterGrades.push(temp);\n  }\n\n  letterGrades.sort((a, b) => a - b);\n\n  for (i = 0; i < letterGrades.length; i++) {\n    letterGrades[i] = letterGrades[i] * 100 / sum;\n  }\n\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade4 = (grades) => {\n  let letterGrades = [];\n  let sum = 0;\n  let i;\n  let j;\n  let temp;\n\n  for (i = 0; i < grades.length; i++) {\n    sum = sum + grades[i];\n  }\n\n  for (i = 0; i < grades.length; i++) {\n    temp = grades[i];\n    letterGrades.push(temp);\n  }\n\n  letterGrades.sort((a, b) => a - b);\n\n  for (i = 0; i < letterGrades.length; i++) {\n    letterGrades[i] = letterGrades[i] * 100 / sum;\n  }\n\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade5 = (grades) => {\n  let letterGrades = [];\n  let sum = 0;\n  let i;\n  let j;\n  let temp;\n\n  for (i = 0; i < grades.length; i++) {\n    sum = sum + grades[i];\n  }\n\n  for (i = 0; i < grade", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "gc": "<|endoftext|>/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let isPrime = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (i % 2 === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst palindrome = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst reversePalindrome = (string) => {\n  let isReversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isReversePalindrome = false;\n      break;\n    }\n  }\n  return isReversePalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst reversePalindromeWithSpaces = (string) => {\n  let isReversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isReversePalindrome = false;\n      break;\n    }\n  }\n  return isReversePalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst reversePalindromeWithSpaces = (string) => {\n  let isReversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isReversePalindrome = false;\n      break;\n    }\n  }\n  return isReversePalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst reversePalindromeWithSpaces = (string) => {\n  let isReversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isReversePalindrome = false;\n      break;\n    }\n  }\n  return isReversePalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst reversePalindromeWithSpaces = (string) => {\n  let isReversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isReversePalindrome = false;\n      break;\n    }\n  }\n  return isReversePalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst reversePalindromeWithSpaces = (string) => {\n  let isReversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isReversePalindrome = false;\n      break;\n    }\n  }\n  return isReversePalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst reversePalindromeWithSpaces = (string) => {\n  let isReversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isReversePalindrome = false;\n      break;\n    }\n  }\n  return isReversePalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst reversePalindromeWithSpaces = (string) => {\n  let isReversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isReversePalindrome = false;\n      break;\n    }\n  }\n  return isReversePalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst reversePalindromeWithSpaces = (string) => {\n  let isReversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isReversePalindrome = false;\n      break;\n    }\n  }\n  return isReversePalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst reversePalindromeWithSpaces = (string) => {\n  let isReversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - i - 1]) {\n      isReversePalindrome = false;\n      break;\n    }\n  }\n  return isReversePalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst reversePalindromeWithSpaces = (string) => {\n  let isReversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string[i]!== string[length - ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startOneEnds", "gc": "<|endoftext|>/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startOneEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startZeroEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 2.\n  */\nconst startTwoEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 3.\n  */\nconst startThreeEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 4.\n  */\nconst startFourEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 5.\n  */\nconst startFiveEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 6.\n  */\nconst startSixEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 7.\n  */\nconst startSevenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 8.\n  */\nconst startEightEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 9.\n  */\nconst startNineEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 10.\n  */\nconst startTenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 11.\n  */\nconst startElevenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 12.\n  */\nconst startTwelveEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 13.\n  */\nconst startThirteenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 14.\n  */\nconst startFourteenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 15.\n  */\nconst startFifteenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 16.\n  */\nconst startSixteenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 17.\n  */\nconst startSeventeenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 18.\n  */\nconst startEighteenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 19.\n  */\nconst startNineteenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 20.\n  */\nconst startTwentyEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i < n) {\n    if (n % 10 === 0) {\n      count += 1;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 21.\n  */\nconst startThirtyEnds = (n) => {\n  let count = 0;\n  let i = 1;", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "gc": "<|endoftext|>/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    binary = binary.concat(binary(i));\n  }\n  \n  for (let i = 0; i <= N; i++) {\n    sum = sum + parseInt(binary.charAt(i), 2);\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be 1000.\n      For N = 150, the sum of digits will be 6 the output should be 150.\n      For N = 147, the sum of digits will be 12 the output should be 147.\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let decimal = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    decimal = decimal.concat(decimal(i));\n  }\n  \n  for (let i = 0; i <= N; i++) {\n    sum = sum + parseInt(decimal.charAt(i), 10);\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"0x\".\n      For N = 150, the sum of digits will be 6 the output should be \"0xf\".\n      For N = 147, the sum of digits will be 12 the output should be \"0x7f\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let hexadecimal = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    hexadecimal = hexadecimal.concat(hexadecimal(i));\n  }\n  \n  for (let i = 0; i <= N; i++) {\n    sum = sum + parseInt(hexadecimal.charAt(i), 16);\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in octal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"0o\".\n      For N = 150, the sum of digits will be 6 the output should be \"0o7\".\n      For N = 147, the sum of digits will be 12 the output should be \"0o377\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of octal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let octal = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    octal = octal.concat(octal(i));\n  }\n  \n  for (let i = 0; i <= N; i++) {\n    sum = sum + parseInt(octal.charAt(i), 8);\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"0x\".\n      For N = 150, the sum of digits will be 6 the output should be \"0xf\".\n      For N = 147, the sum of digits will be 12 the output should be \"0x7f\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let hexadecimal = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    hexadecimal = hexadecimal.concat(hexadecimal(i));\n  }\n  \n  for (let i = 0; i <= N; i++) {\n    sum = sum + parseInt(hexadecimal.charAt(i), 16);\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be 1000.\n      For N = 150, the sum of digits will be 6 the output should be 150.\n      For N = 147, the sum of digits will be 12 the output should be 147.\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let decimal = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    decimal = decimal.concat(decimal(i));\n  }\n  \n  for (let i = 0; i <= N; i++) {\n    sum = sum + parseInt(decimal.charAt(i), 10);\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"0x\".\n      For N = 150, the sum of digits will be 6 the output should be \"0xf\".\n      For N = 147, the sum of digits will be 12 the output should be \"0x7f\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let hexadecimal = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    hexadecimal = hexadecimal.concat(hexadecimal(i));\n  }\n  \n  for (let i = 0; i <= N; i++) {\n    sum = sum + parseInt(hexadecimal.charAt(i), 16);\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in octal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"0o\".\n      For N = 150, the sum of digits will be 6 the output should be \"0o7\".\n      For N = 147, the sum of digits will be 12 the output should be \"0o377\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of octal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let octal = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    octal = octal.concat(octal(i));\n  }\n  \n  for (let i = 0; i <= N; i++) {\n    sum = sum + parseInt(octal.charAt(i), 8);\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"0x\".\n      For N = 150, the sum of digits will be 6 the output should be \"0xf\".\n      For N = 147, the sum of digits will be 12 the output should be \"0x7f\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. adding the even elements that are at odd indices..\n\n\n  Examples:\n      adding([4, 2, 6, 7]) ==> 2 \n  */\nconst adding = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "adding", "gc": "<|endoftext|>/*Given a non-empty list of integers lst. adding the even elements that are at odd indices..\n\n\n  Examples:\n      adding([4, 2, 6, 7]) ==> 2 \n  */\nconst adding = (lst) => {\n  let even = lst.filter(i => i % 2 === 0);\n  let odd = lst.filter(i => i % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. removing the even elements that are at even indices..\n\n\n  Examples:\n      removing([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removing = (lst) => {\n  let even = lst.filter(i => i % 2 === 0);\n  let odd = lst.filter(i => i % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. removing all the even elements that are at odd indices..\n\n\n  Examples:\n      removing([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removingAllEven = (lst) => {\n  let even = lst.filter(i => i % 2 === 0);\n  let odd = lst.filter(i => i % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. removing all the odd elements that are at even indices..\n\n\n  Examples:\n      removingAllEven([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removingAllOdd = (lst) => {\n  let even = lst.filter(i => i % 2!== 0);\n  let odd = lst.filter(i => i % 2 === 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. removing all the even elements that are at odd indices..\n\n\n  Examples:\n      removingAllOdd([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removingAllEvenOdd = (lst, odd) => {\n  let even = lst.filter(i => i % 2 === 0);\n  let odd = lst.filter(i => i % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. removing all the even elements that are at even indices..\n\n\n  Examples:\n      removingAllEvenOdd([4, 2, 6, 7], 2) ==> [4, 2, 6, 7]\n  */\nconst removingAllEvenOddOdd = (lst, odd) => {\n  let even = lst.filter(i => i % 2 === 0);\n  let odd = lst.filter(i => i % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. removing all the even elements that are at odd indices..\n\n\n  Examples:\n      removingAllEvenOddOdd([4, 2, 6, 7], 3) ==> [4, 2, 6, 7]\n  */\nconst removingAllEvenOddOddOdd = (lst, odd) => {\n  let even = lst.filter(i => i % 2 === 0);\n  let odd = lst.filter(i => i % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. removing all the even elements that are at even indices..\n\n\n  Examples:\n      removingAllEvenOddOddOdd([4, 2, 6, 7], 4) ==> [4, 2, 6, 7]\n  */\nconst removingAllEvenOddOddOddOdd = (lst, odd) => {\n  let even = lst.filter(i => i % 2 === 0);\n  let odd = lst.filter(i => i % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. removing all the even elements that are at odd indices..\n\n\n  Examples:\n      removingAllEvenOddOddOddOdd([4, 2, 6, 7], 5) ==> [4, 2, 6, 7]\n  */\nconst removingAllEvenOddOddOddOddOdd = (lst, odd) => {\n  let even = lst.filter(i => i % 2 === 0);\n  let odd = lst.filter(i => i % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. removing all the even elements that are at odd indices..\n\n\n  Examples:\n      removingAllEvenOddOddOddOddOdd([4, 2, 6, 7], 6) ==> [4, 2, 6, 7]\n  */\nconst removingAllEvenOddOddOddOddOddOddOdd = (lst, odd) => {\n  let even = lst.filter(i => i % 2 === 0);\n  let odd = lst.filter(i => i % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. removing all the even elements that are at odd indices..\n\n\n  Examples:\n      removingAllEvenOddOddOddOddOddOddOdd([4, 2, 6, 7], 7) ==> [4, 2, 6, 7]\n  */\nconst removingAllEvenOddOddOddOddOddOddOddOddOdd = (lst, odd) => {\n  let even = lst.filter(i => i % 2 === 0);\n  let odd = lst.filter(i => i % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. removing all the even elements that are at odd indices..\n\n\n  Examples:\n      removingAllEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddO", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antisShuffles('Hi') returns 'Hi'\n  antisShuffles('hello') returns 'ehllo'\n  antisShuffles('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antisShuffles = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antisShuffles", "gc": "<|endoftext|>/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antisShuffles('Hi') returns 'Hi'\n  antisShuffles('hello') returns 'ehllo'\n  antisShuffles('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antisShuffles = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.localeCompare(b));\n  words.forEach((word, i) => {\n    if (i === 0) {\n      newStr += word;\n    } else {\n      newStr += `${word} `;\n    }\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antisShuffles('Hi') returns 'Hi'\n  antisShuffles('hello') returns 'ehllo'\n  antisShuffles('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antisShuffles2 = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.localeCompare(b));\n  words.forEach((word, i) => {\n    if (i === 0) {\n      newStr += word;\n    } else {\n      newStr += `${word} `;\n    }\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antisShuffles('Hi') returns 'Hi'\n  antisShuffles('hello') returns 'ehllo'\n  antisShuffles('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antisShuffles3 = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.localeCompare(b));\n  words.forEach((word, i) => {\n    if (i === 0) {\n      newStr += word;\n    } else {\n      newStr += `${word} `;\n    }\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antisShuffles('Hi') returns 'Hi'\n  antisShuffles('hello') returns 'ehllo'\n  antisShuffles('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antisShuffles4 = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.localeCompare(b));\n  words.forEach((word, i) => {\n    if (i === 0) {\n      newStr += word;\n    } else {\n      newStr += `${word} `;\n    }\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antisShuffles('Hi') returns 'Hi'\n  antisShuffles('hello') returns 'ehllo'\n  antisShuffles('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antisShuffles5 = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.localeCompare(b));\n  words.forEach((word, i) => {\n    if (i === 0) {\n      newStr += word;\n    } else {\n      newStr += `${word} `;\n    }\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antisShuffles('Hi') returns 'Hi'\n  antisShuffles('hello') returns 'ehllo'\n  antisShuffles('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antisShuffles6 = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.localeCompare(b));\n  words.forEach((word, i) => {\n    if (i === 0) {\n      newStr += word;\n    } else {\n      newStr += `${word} `;\n    }\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antisShuffles('Hi') returns 'Hi'\n  antisShuffles('hello') returns 'ehllo'\n  antisShuffles('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antisShuffles7 = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.localeCompare(b));\n  words.forEach((word, i) => {\n    if (i === 0) {\n      newStr += word;\n    } else {\n      newStr += `${word} `;\n    }\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antisShuffles('Hi') returns 'Hi'\n  antisShuffles('hello') returns 'ehllo'\n  antisShuffles('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antisShuffles8 = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  words.sort((a, b) => a.localeCompare(b));\n  words.forEach((word, i) => {\n    if (i === 0) {\n      newStr += word;\n    } else {\n      newStr += `${word} `;\n    }\n  });\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRows([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRows([], 1) == []\n  getRows([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRows = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRows", "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRows([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRows([], 1) == []\n  getRows([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRows = (lst, x) => {\n  const rows = []\n  let row = 0\n  let col = 0\n  const rowLen = lst[0].length\n  const colLen = lst.length\n  for (let i = 0; i < rowLen; i++) {\n    rows.push([])\n    for (let j = 0; j < colLen; j++) {\n      rows[row].push(lst[i][j])\n    }\n  }\n  rows.sort((a, b) => a[0] - b[0])\n  rows.sort((a, b) => b[1] - a[1])\n  return rows.map((row) => {\n    return [row + x, col]\n  })\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRows([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRows([], 1) == []\n  getRows([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getCols = (lst, x) => {\n  const cols = []\n  let col = 0\n  const rowLen = lst[0].length\n  const colLen = lst.length\n  for (let i = 0; i < rowLen; i++) {\n    cols.push([])\n    for (let j = 0; j < colLen; j++) {\n      cols[col].push(lst[i][j])\n    }\n  }\n  cols.sort((a, b) => a[1] - b[1])\n  cols.sort((a, b) => b[0] - a[0])\n  return cols.map((col) => {\n    return [col + x, row]\n  })\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRows([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRows([], 1) == []\n  getRows([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRowsCols = (lst, x) => {\n  const rows = []\n  let row = 0\n  let col = 0\n  const rowLen = lst[0].length\n  const colLen = lst.length\n  for (let i = 0; i < rowLen; i++) {\n    rows.push([])\n    for (let j = 0; j < colLen; j++) {\n      rows[row].push(lst[i][j])\n    }\n  }\n  rows.sort((a, b) => a[0] - b[0])\n  rows.sort((a, b) => b[1] - a[1])\n  return rows.map((row) => {\n    return [col + x, row]\n  })\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRows([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRows([], 1) == []\n  getRows([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getColsRows = (lst, x) => {\n  const cols = []\n  let col = 0\n  const rowLen = lst[0].length\n  const rowLen = lst.length\n  for (let i = 0; i < rowLen; i++) {\n    cols.push([])\n    for (let j = 0; j < colLen; j++) {\n      cols[col].push(lst[i][j])\n    }\n  }\n  cols.sort((a, b) => a[1] - b[1])\n  cols.sort((a, b) => b[0] - a[0])\n  return cols.map((col) => {\n    return [col + x, row]\n  })\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRows([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRows([], 1) == []\n  getRows([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRowsColsRows = (lst, x) => {\n  const rows = []\n  let row = 0\n  let col = 0\n  const rowLen = lst[0].length\n  const colLen = lst.length\n  for (let i = 0; i < rowLen; i++) {\n    rows.push([])\n    for (let j = 0; j < colLen; j++) {\n      rows[row].push(lst[i][j])\n    }\n  }\n  rows.sort((a, b) => a[0] - b[0])\n  rows.sort((a, b) => b[1] - a[1])\n  return rows.map((row) => {\n    return [col + x, row]\n  })\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRows([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRows([], 1) == []\n  getRows([[], [1], [1, 2, 3]], 3", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortsArray([]) => []\n  * sortsArray([5]) => [5]\n  * sortsArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortsArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortsArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortsArray", "gc": "<|endoftext|>/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortsArray([]) => []\n  * sortsArray([5]) => [5]\n  * sortsArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortsArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortsArray = (array) => {\n  const sorted = array.sort((a, b) => a - b);\n  return sorted.map((value, index) => array[index]);\n};\n\n/**\n * Given an array of non-negative integers, return the first element of the array that is greater than the given number.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * firstGreaterThan([]) => undefined\n  * firstGreaterThan([5]) => 5\n  * firstGreaterThan([2, 4, 3, 0, 1, 5]) => 2\n  * firstGreaterThan([2, 4, 3, 0, 1, 5, 6]) => 6\n  */\nconst firstGreaterThan = (array) => {\n  const sorted = sortsArray(array);\n  return sorted[0];\n};\n\n/**\n * Given an array of non-negative integers, return the first element of the array that is less than the given number.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * firstLessThan([]) => undefined\n  * firstLessThan([5]) => 5\n  * firstLessThan([2, 4, 3, 0, 1, 5]) => 1\n  * firstLessThan([2, 4, 3, 0, 1, 5, 6]) => 6\n  */\nconst firstLessThan = (array) => {\n  const sorted = sortsArray(array);\n  return sorted[0];\n};\n\n/**\n * Given an array of non-negative integers, return the first element of the array that is equal to the given number.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * firstEqual([]) => undefined\n  * firstEqual([5]) => 5\n  * firstEqual([2, 4, 3, 0, 1, 5]) => 2\n  * firstEqual([2, 4, 3, 0, 1, 5, 6]) => 6\n  */\nconst firstEqual = (array) => {\n  const sorted = sortsArray(array);\n  return sorted[0];\n};\n\n/**\n * Given an array of non-negative integers, return the first element of the array that is less than or equal to the given number.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * firstLessOrEqual([]) => undefined\n  * firstLessOrEqual([5]) => 5\n  * firstLessOrEqual([2, 4, 3, 0, 1, 5]) => 2\n  * firstLessOrEqual([2, 4, 3, 0, 1, 5, 6]) => 6\n  */\nconst firstLessOrEqual = (array) => {\n  const sorted = sortsArray(array);\n  return sorted[0];\n};\n\n/**\n * Given an array of non-negative integers, return the first element of the array that is greater than or equal to the given number.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * firstGreaterOrEqual([]) => undefined\n  * firstGreaterOrEqual([5]) => 5\n  * firstGreaterOrEqual([2, 4, 3, 0, 1, 5]) => 2\n  * firstGreaterOrEqual([2, 4, 3, 0, 1, 5, 6]) => 6\n  */\nconst firstGreaterOrEqual = (array) => {\n  const sorted = sortsArray(array);\n  return sorted[0];\n};\n\n/**\n * Given an array of non-negative integers, return the first element of the array that is equal to the given number.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * firstEqual([]) => undefined\n  * firstEqual([5]) => 5\n  * firstEqual([2, 4, 3, 0, 1, 5]) => 2\n  * firstEqual([2, 4, 3, 0, 1, 5, 6]) => 6\n  */\nconst firstEqualOrEqual = (array) => {\n  const sorted = sortsArray(array);\n  return sorted[0];\n};\n\n/**\n * Given an array of non-negative integers, return the first element of the array that is greater than the given number.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * firstGreaterThan([]) => undefined\n  * firstGreaterThan([5]) => 5\n  * firstGreaterThan([2, 4, 3, 0, 1, 5]) => 2\n  * firstGreaterThan([2, 4, 3, 0, 1, 5, 6]) => 6\n  */\nconst firstGreaterThanOrEqual = (array) => {\n  const sorted = sortsArray(array);\n  return sorted[0];\n};\n\n/**\n * Given an array of non-negative integers, return the first element of the array that is less than the given number.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * firstLessThan([]) => undefined\n  * firstLessThan([5]) => 5\n  * firstLessThan([2, 4, 3, 0, 1, 5]) => 1\n  * firstLessThan([2, 4, 3, 0, 1, 5, 6]) => 6\n  */\nconst firstLessThanOrEqual = (array) => {\n  const sorted = sortsArray(array);\n  return sorted[0];\n};\n\n/**\n * Given an array of non-negative integers, return the first element of the array that is equal to the given number.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * firstEqual([]) => undefined\n  * firstEqual([5]) => 5\n  * firstEqual([2, 4, 3, 0, 1, 5]) => 2\n  * firstEqual([2, 4, 3, 0, 1, 5, 6]) => 6\n  */\nconst firstEqualOrEqual = (array) => {\n  const sorted = sortsArray(array);\n  return sorted[0];\n};\n\n/**\n * Given an array of non-negative integers, return the first element of the array that is greater than the given number.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * firstGreaterThan([]) => undefined\n  * firstGreaterThan([5]) => 5\n  * firstGreaterThan([2, 4, 3, 0, 1, 5]) => 2\n  * firstGreaterThan([2, 4, 3, 0, 1, 5, 6]) => 6\n  */\nconst firstGreaterThanOrEqual = (array) => {\n  const sorted = sortsArray(array);\n  return sorted[0];\n};\n\n/**\n * Given an array of non-negative integers, return the first element of the array that is less than the given number.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * firstLessThan([]) => undefined\n  * firstLessThan([5]) => 5\n  * firstLessThan([2, 4, 3, 0, 1, 5]) => 1\n  * firstLessThan([2, 4, 3, 0, 1, 5, 6]) => 6\n  */\nconst firstLessThanOrEqual = (array) => {\n  const sorted = sortsArray(array);\n  return sorted[0];\n};\n\n/**\n * Given an array of non-negative integers, return the first element of the array that is equal to the given number.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * firstEqual([]) => undefined\n  * firstEqual([5]) => 5\n  * firstEqual([2, 4, 3, 0, 1, 5]) => 2\n  * firstEqual([2, 4, 3, 0, 1, 5, 6]) => 6\n  */\nconst firstEqualOrEqual = (array) => {\n  const sorted = sortsArray(array);\n  return sorted[0];\n};\n\n/**\n * Given an array of non-negative integers, return the first element of the array that is greater than the given number.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * firstGreaterThan([]) => undefined\n  * firstGreaterThan([5]) => 5\n  * firstGreaterThan([2, 4, 3, 0, 1, 5]) => 2\n  * firstGreaterThan([2, 4, 3, 0, 1, 5, 6]) => 6\n  */\nconst firstGreaterThanOrEqual = (array) => {\n  const sorted = sortsArray(array);\n  return sorted[0];\n};\n\n/**\n * Given an array of non-negative integers, return the first element of the array that is less than the given number.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * firstLessThan([]) => undefined\n  * firstLessThan([5]) => 5\n  * firstLessThan([2, 4, 3, 0, 1, 5]) => 1", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "gc": "<|endoftext|>/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.charAt(Math.floor(Math.random() * alphabet.length));\n    rotated += letter;\n  }\n  return rotated;\n};\n\n/*Create a function decrypt that takes a string as an argument and\n  returns a string decrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.charAt(Math.floor(Math.random() * alphabet.length));\n    rotated += letter;\n  }\n  return rotated;\n};\n\n/*Create a function rotate that takes a string as an argument and\n  returns a string rotated 90 degrees clockwise. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  rotate('hi') returns 'asdfghjkl'\n  rotate('asdfghjkl') returns 'ewhjklnop'\n  rotate('gf') returns 'kj'\n  rotate('et') returns 'ix'\n  */\nconst rotate = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.charAt(Math.floor(Math.random() * alphabet.length));\n    rotated += letter;\n  }\n  return rotated;\n};\n\n/*Create a function reverse that takes a string as an argument and\n  returns a string reversed with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  reverse('lm') returns 'hi'\n  reverse('ewhjklnop') returns 'asdfghjkl'\n  reverse('kj') returns 'gf'\n  reverse('ix') returns 'et'\n  */\nconst reverse = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.charAt(Math.floor(Math.random() * alphabet.length));\n    rotated += letter;\n  }\n  return rotated;\n};\n\n/*Create a function shuffle that takes a string as an argument and\n  returns a string shuffled randomly. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  shuffle('hi') returns 'asdfghjkl'\n  shuffle('asdfghjkl') returns 'ewhjklnop'\n  shuffle('gf') returns 'kj'\n  shuffle('et') returns 'ix'\n  */\nconst shuffle = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.charAt(Math.floor(Math.random() * alphabet.length));\n    rotated += letter;\n  }\n  return rotated;\n};\n\n/*Create a function shuffle that takes a string as an argument and\n  returns a string shuffled randomly. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  shuffle('hi') returns 'asdfghjkl'\n  shuffle('asdfghjkl') returns 'ewhjklnop'\n  shuffle('gf') returns 'kj'\n  shuffle('et') returns 'ix'\n  */\nconst shuffle = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.charAt(Math.floor(Math.random() * alphabet.length));\n    rotated += letter;\n  }\n  return rotated;\n};\n\n/*Create a function shuffle that takes a string as an argument and\n  returns a string shuffled randomly. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  shuffle('hi') returns 'asdfghjkl'\n  shuffle('asdfghjkl') returns 'ewhjklnop'\n  shuffle('gf') returns 'kj'\n  shuffle('et') returns 'ix'\n  */\nconst shuffle = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.charAt(Math.floor(Math.random() * alphabet.length));\n    rotated += letter;\n  }\n  return rotated;\n};\n\n/*Create a function shuffle that takes a string as an argument and\n  returns a string shuffled randomly. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  shuffle('hi') returns 'asdfghjkl'\n  shuffle('asdfghjkl') returns 'ewhjklnop'\n  shuffle('gf') returns 'kj'\n  shuffle('et') returns 'ix'\n  */\nconst shuffle = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.charAt(Math.floor(Math.random() * alphabet.length));\n    rotated += letter;\n  }\n  return rotated;\n};\n\n/*Create a function shuffle that takes a string as an argument and\n  returns a string shuffled randomly. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  shuffle('hi') returns 'asdfghjkl'\n  shuffle('asdfghjkl') returns 'ewhjklnop'\n  shuffle('gf') returns 'kj'\n  shuffle('et') returns 'ix'\n  */\nconst shuffle = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.charAt(Math.floor(Math.random() * alphabet.length));\n    rotated += letter;\n  }\n  return rotated;\n};\n\n/*Create a function shuffle that takes a string as an argument and\n  returns a string shuffled randomly. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  shuffle('hi') returns 'asdfghjkl'\n  shuffle('", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "gc": "<|endoftext|>/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const maxes = numbers.reduce((acc, curr, index) => {\n    if (curr > acc) {\n      acc = curr;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, curr) => {\n    if (curr > maxes) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n};\n\n/**\n * Given a list of integers, generate a list of rolling minimum element found until given moment\n  in the sequence.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 3]\n  */\nconst rollingMin = (numbers) => {\n  const mins = numbers.reduce((acc, curr, index) => {\n    if (curr < acc) {\n      acc = curr;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, curr) => {\n    if (curr < mins) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n};\n\n/**\n * Given a list of integers, generate a list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingSum = (numbers) => {\n  const sums = numbers.reduce((acc, curr, index) => {\n    if (curr + acc > acc) {\n      acc = curr + acc;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, curr) => {\n    if (curr + sums > sums) {\n      acc.push(curr + sums);\n    }\n    return acc;\n  }, []);\n};\n\n/**\n * Given a list of integers, generate a list of rolling product element found until given moment\n  in the sequence.\n  >>> rollingProduct([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingProduct = (numbers) => {\n  const products = numbers.reduce((acc, curr, index) => {\n    if (curr * acc > acc) {\n      acc = curr * acc;\n    }\n    return acc;\n  }, 1);\n  return numbers.reduce((acc, curr) => {\n    if (curr * products > products) {\n      acc.push(curr * products);\n    }\n    return acc;\n  }, []);\n};\n\n/**\n * Given a list of integers, generate a list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSumOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingSumOf = (numbers) => {\n  const sums = numbers.reduce((acc, curr, index) => {\n    if (curr + acc > acc) {\n      acc = curr + acc;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, curr) => {\n    if (curr + sums > sums) {\n      acc.push(curr + sums);\n    }\n    return acc;\n  }, []);\n};\n\n/**\n * Given a list of integers, generate a list of rolling product element found until given moment\n  in the sequence.\n  >>> rollingProductOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingProductOf = (numbers) => {\n  const products = numbers.reduce((acc, curr, index) => {\n    if (curr * acc > acc) {\n      acc = curr * acc;\n    }\n    return acc;\n  }, 1);\n  return numbers.reduce((acc, curr) => {\n    if (curr * products > products) {\n      acc.push(curr * products);\n    }\n    return acc;\n  }, []);\n};\n\n/**\n * Given a list of integers, generate a list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSumOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingSumOf = (numbers) => {\n  const sums = numbers.reduce((acc, curr, index) => {\n    if (curr + acc > acc) {\n      acc = curr + acc;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, curr) => {\n    if (curr + sums > sums) {\n      acc.push(curr + sums);\n    }\n    return acc;\n  }, []);\n};\n\n/**\n * Given a list of integers, generate a list of rolling product element found until given moment\n  in the sequence.\n  >>> rollingProductOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingProductOf = (numbers) => {\n  const products = numbers.reduce((acc, curr, index) => {\n    if (curr * acc > acc) {\n      acc = curr * acc;\n    }\n    return acc;\n  }, 1);\n  return numbers.reduce((acc, curr) => {\n    if (curr * products > products) {\n      acc.push(curr * products);\n    }\n    return acc;\n  }, []);\n};\n\n/**\n * Given a list of integers, generate a list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSumOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingSumOf = (numbers) => {\n  const sums = numbers.reduce((acc, curr, index) => {\n    if (curr + acc > acc) {\n      acc = curr + acc;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, curr) => {\n    if (curr + sums > sums) {\n      acc.push(curr + sums);\n    }\n    return acc;\n  }, []);\n};\n\n/**\n * Given a list of integers, generate a list of rolling product element found until given moment\n  in the sequence.\n  >>> rollingProductOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingProductOf = (numbers) => {\n  const products = numbers.reduce((acc, curr, index) => {\n    if (curr * acc > acc) {\n      acc = curr * acc;\n    }\n    return acc;\n  }, 1);\n  return numbers.reduce((acc, curr) => {\n    if (curr * products > products) {\n      acc.push(curr * products);\n    }\n    return acc;\n  }, []);\n};\n\n/**\n * Given a list of integers, generate a list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSumOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingSumOf = (numbers) => {\n  const sums = numbers.reduce((acc, curr, index) => {\n    if (curr + acc > acc) {\n      acc = curr + acc;\n    }\n    return acc;\n  }, 0);\n  return numbers.reduce((acc, curr) => {\n    if (curr + sums > sums) {\n      acc.push(curr + sums);\n    }\n    return acc;\n  }, []);\n};\n\n/**\n * Given a list of integers, generate a list of rolling product element found until given moment\n  in the sequence.\n  >>> rollingProductOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingProductOf = (numbers) => {\n  const products = numbers.reduce((acc, curr, index) => {\n    if (curr * acc > acc) {\n      acc = curr * acc;\n    }\n    return acc;\n  }, 1);\n  return numbers.reduce((acc, curr) => {\n    if (curr * products > products) {\n      acc.push(curr * products);\n    }\n    return acc;\n  }, []);\n};\n\n/**\n * Given a list of integers, generate a list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSumOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingSumOf = (numbers) => {\n  const sums = numbers.reduce((acc, curr, index) => {\n    if (curr + acc > acc) {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "gc": "<|endoftext|>/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  let minValue = null;\n  let minIndexValue = null;\n  let minValueIndex = null;\n  let minValueIndexValue = null;\n  let minValueIndexValueIndex = null;\n  let minValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndex = null;\n  let minValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndex = null;\n  let minValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndex = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndex = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue = null;\n  let minValueIndexValueIndexValueIndexValueIndexValueIndexValueIndex", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBore(\"Hello world\")\n  0\n  >>> isBore(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBore = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBore", "gc": "<|endoftext|>/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBore(\"Hello world\")\n  0\n  >>> isBore(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBore = (S) => {\n  let boredom = 0;\n  let words = S.split('.');\n  let sentences = words.map(w => w.split('?'));\n  let sentence = sentences[0];\n  let sentences = sentences.slice(1);\n  let sentences = sentences.map(s => s.split('!'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('!'));\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentences = sentences.map(s => s.split('.'))\n  let sentences = sentences.map(s => s.join('.'));\n  let sentence", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "gc": "<|endoftext|>/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  return x === y && x === z && Number.isInteger(x + y + z);\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  false\n  allInt(3, -2, 1)  true\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  return x === y && x === z && Number.isInteger(x + y + z);\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenInt(5, 2, 7)  true\n  evenInt(3, 2, 2)  false\n  evenInt(3, -2, 1)  true\n  evenInt(3.6, -2.2, 2)  false\n  */\nconst evenInt = (x, y, z) => {\n  return x === y && x === z && Number.isInteger(x + y + z) && x % 2 === 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  oddInt(5, 2, 7)  true\n  oddInt(3, 2, 2)  false\n  oddInt(3, -2, 1)  true\n  oddInt(3.6, -2.2, 2)  false\n  */\nconst oddInt = (x, y, z) => {\n  return x === y && x === z && Number.isInteger(x + y + z) && x % 2!== 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenOdd(5, 2, 7)  true\n  evenOdd(3, 2, 2)  false\n  evenOdd(3, -2, 1)  true\n  evenOdd(3.6, -2.2, 2)  false\n  */\nconst evenOddInt = (x, y, z) => {\n  return x === y && x === z && Number.isInteger(x + y + z) && x % 2 === 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  oddOdd(5, 2, 7)  true\n  oddOdd(3, 2, 2)  false\n  oddOdd(3, -2, 1)  true\n  oddOdd(3.6, -2.2, 2)  false\n  */\nconst oddOddInt = (x, y, z) => {\n  return x === y && x === z && Number.isInteger(x + y + z) && x % 2!== 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenOdd(5, 2, 7)  true\n  evenOdd(3, 2, 2)  false\n  evenOdd(3, -2, 1)  true\n  evenOdd(3.6, -2.2, 2)  false\n  */\nconst evenOddEvenInt = (x, y, z) => {\n  return x === y && x === z && Number.isInteger(x + y + z) && x % 2 === 0 && y % 2 === 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  oddOdd(5, 2, 7)  true\n  oddOdd(3, 2, 2)  false\n  oddOdd(3, -2, 1)  true\n  oddOdd(3.6, -2.2, 2)  false\n  */\nconst oddOddEvenInt = (x, y, z) => {\n  return x === y && x === z && Number.isInteger(x + y + z) && x % 2!== 0 && y % 2 === 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenOdd(5, 2, 7)  true\n  evenOdd(3, 2, 2)  false\n  evenOdd(3, -2, 1)  true\n  evenOdd(3.6, -2.2, 2)  false\n  */\nconst evenOddOddInt = (x, y, z) => {\n  return x === y && x === z && Number.isInteger(x + y + z) && x % 2 === 0 && y % 2!== 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  oddOdd(5, 2, 7)  true\n  oddOdd(3, 2, 2)  false\n  oddOdd(3, -2, 1)  true\n  oddOdd(3.6, -2.2, 2)  false\n  */\nconst oddOddOddEvenInt = (x, y, z) => {\n  return x === y && x === z && Number.isInteger(x + y + z) && x % 2!== 0 && y % 2 === 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenOdd(5, 2, 7)  true\n  evenOdd(3, 2, 2)  false\n  evenOdd(3, -2, 1)  true\n  evenOdd(3.6, -2.2, 2)  false\n  */\nconst evenOddOddOddInt = (x, y, z) => {\n  return x === y && x === z && Number.isInteger(x + y + z) && x % 2 === 0 && y % 2!== 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenOdd(5, 2, 7)  true\n  evenOdd(3, 2, 2)  false\n  evenOdd(3, -2, 1)  true\n  evenOdd(3.6, -2.2, 2)  false\n  */\nconst oddOddOddOddEvenInt = (x, y, z) => {\n  return x === y && x === z && Number.isInteger(x + y + z) && x % 2!== 0 && y % 2 === 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "gc": "<|endoftext|>/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = '';\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let vowelsIndex = 0;\n  let alphabetIndex = 0;\n  let vowelsCount = 0;\n  let alphabetCount = 0;\n  let vowelsIndex2 = 0;\n  let alphabetIndex2 = 0;\n  let vowelsCount2 = 0;\n  let alphabetCount2 = 0;\n  let vowelsIndex3 = 0;\n  let alphabetIndex3 = 0;\n  let vowelsCount3 = 0;\n  let alphabetCount3 = 0;\n  let vowelsIndex4 = 0;\n  let alphabetIndex4 = 0;\n  let vowelsCount4 = 0;\n  let alphabetCount4 = 0;\n  let vowelsIndex5 = 0;\n  let alphabetIndex5 = 0;\n  let vowelsCount5 = 0;\n  let alphabetCount5 = 0;\n  let vowelsIndex6 = 0;\n  let alphabetIndex6 = 0;\n  let vowelsCount6 = 0;\n  let alphabetCount6 = 0;\n  let vowelsIndex7 = 0;\n  let alphabetIndex7 = 0;\n  let vowelsCount7 = 0;\n  let alphabetCount7 = 0;\n  let vowelsIndex8 = 0;\n  let alphabetIndex8 = 0;\n  let vowelsCount8 = 0;\n  let alphabetCount8 = 0;\n  let vowelsIndex9 = 0;\n  let alphabetIndex9 = 0;\n  let vowelsCount9 = 0;\n  let alphabetCount9 = 0;\n  let vowelsIndex10 = 0;\n  let alphabetIndex10 = 0;\n  let vowelsCount10 = 0;\n  let alphabetCount10 = 0;\n  let vowelsIndex11 = 0;\n  let alphabetIndex11 = 0;\n  let vowelsCount11 = 0;\n  let alphabetCount11 = 0;\n  let vowelsIndex12 = 0;\n  let alphabetIndex12 = 0;\n  let vowelsCount12 = 0;\n  let alphabetCount12 = 0;\n  let vowelsIndex13 = 0;\n  let alphabetIndex13 = 0;\n  let vowelsCount13 = 0;\n  let alphabetCount13 = 0;\n  let vowelsIndex14 = 0;\n  let alphabetIndex14 = 0;\n  let vowelsCount14 = 0;\n  let alphabetCount14 = 0;\n  let vowelsIndex15 = 0;\n  let alphabetIndex15 = 0;\n  let vowelsCount15 = 0;\n  let alphabetCount15 = 0;\n  let vowelsIndex16 = 0;\n  let alphabetIndex16 = 0;\n  let vowelsCount16 = 0;\n  let alphabetCount16 = 0;\n  let vowelsIndex17 = 0;\n  let alphabetIndex17 = 0;\n  let vowelsCount17 = 0;\n  let alphabetCount17 = 0;\n  let vowelsIndex18 = 0;\n  let alphabetIndex18 = 0;\n  let vowelsCount18 = 0;\n  let alphabetCount18 = 0;\n  let vowelsIndex19 = 0;\n  let alphabetIndex19 = 0;\n  let vowelsCount19 = 0;\n  let alphabetCount19 = 0;\n  let vowelsIndex20 = 0;\n  let alphabetIndex20 = 0;\n  let vowelsCount20 = 0;\n  let alphabetCount20 = 0;\n  let vowelsIndex21 = 1;\n  let alphabetIndex21 = 1;\n  let vowelsCount21 = 1;\n  let alphabetCount21 = 1;\n  let vowelsIndex22 = 0;\n  let alphabetIndex22 = 0;\n  let vowelsCount22 = 0;\n  let alphabetCount22 = 0;\n  let vowelsIndex23 = 0;\n  let alphabetIndex23 = 0;\n  let vowelsCount23 = 0;\n  let alphabetCount23 = 0;\n  let vowelsIndex24 = 0;\n  let alphabetIndex24 = 0;\n  let vowelsCount24 = 0;\n  let alphabetCount24 = 0;\n  let vowelsIndex25 = 0;\n  let alphabetIndex25 = 0;\n  let vowelsCount25 = 0;\n  let alphabetCount25 = 0;\n  let vowelsIndex26 = 0;\n  let alphabetIndex26 = 0;\n  let vowelsCount26 = 0;\n  let alphabetCount26 = 0;\n  let vowelsIndex27 = 0;\n  let alphabetIndex27 = 0;\n  let vowelsCount27 = 0;\n  let alphabetCount27 = 0;\n  let vowelsIndex28 = 0;\n  let alphabetIndex28 = 0;\n  let vowelsCount28 = 0;\n  let alphabetCount28 = 0;\n  let vowelsIndex29 = 0;\n  let alphabetIndex29 = 0;\n  let vowelsCount29 = 0;\n  let alphabetCount29 = 0;\n  let vowelsIndex30 = 0;\n  let alphabetIndex30 = 0;\n  let vowelsCount30 = 0;\n  let alphabetCount30 = 0;\n  let vowelsIndex31 = 1;\n  let alphabetIndex31 = 1;\n  let vowelsCount31 = 1;\n  let alphabetCount31 = 1;\n  let vowelsIndex32 = 0;\n  let alphabetIndex32 = 0;\n  let vowelsCount32 = 0;\n  let alphabetCount32 = 0;\n  let vowelsIndex33 = 0;\n  let alphabetIndex33 = 0;\n  let vowelsCount33 = 0;\n  let alphabetCount33 = 0;\n  let vowelsIndex34 = 0;\n  let alphabetIndex34 = 0;\n  let vowelsCount34 = 0;\n  let alphabetCount34 = 0;\n  let vowelsIndex35 = 0;\n  let alphabetIndex35 = 0;\n  let vowelsCount35 = 0;\n  let alphabetCount35 = 0;\n  let vowelsIndex36 = 0;\n  let alphabetIndex36 = 0;\n  let vowelsCount36 = 0;\n  let alphabetCount36 = 0;\n  let vowelsIndex37 = 0;\n  let alphabetIndex37 = 0;\n  let vowelsCount37 = 0;\n  let alphabetCount37 = 0;\n  let vowelsIndex38 = 0;\n  let alphabetIndex38 = 0;\n  let vowelsCount38 = 0;\n  let alphabetCount38 = 0;\n  let vowelsIndex39 = 0;\n  let alphabetIndex39 = 0;\n  let vowelsCount39 = 0;\n  let alphabetCount39 = 0;\n  let vowelsIndex40 = 0;\n  let alphabetIndex40 = 0;\n  let vowelsCount40 = 0;\n  let alphabetCount40 = 0;\n  let vowelsIndex41 = 1;\n  let alphabetIndex41 = 1;\n  let vowelsCount41 = 1;\n  let alphabetCount41 = 1;\n  let vowelsIndex42 = 2;\n  let alphabetIndex42 = 2;\n  let vowelsCount42 = 2;\n  let alphabetCount42 = 2;\n  let vowelsIndex43 = 3;\n  let alphabetIndex43 = 3;\n  let vowelsCount43 = 3;\n  let alphabetCount43 = 3;\n  let vowelsIndex44 = 4;\n  let alphabetIndex44 = 4;\n  let vowelsCount44 = 4;\n  let alphabetCount44 = 4;\n  let vowelsIndex45 = 5;\n  let alphabetIndex45 = 5;\n  let vowelsCount45 = 5;\n  let alphabetCount45 = 5;\n  let vowelsIndex46 = 6;\n  let alphabetIndex46 = 6;\n  let vowelsCount46 = 6;\n  let alphabetCount46 = 6;\n  let vowelsIndex47 = 7;\n  let alphabetIndex47 = 7;\n  let vowelsCount47 = 7;\n  let alphabetCount47 = 7;\n  let vowelsIndex48 = 8;\n  let alphabetIndex48 = 8;\n  let vowelsCount48 = 8;\n  let alphabetCount48 = 8;\n  let vowelsIndex49 = 9;\n  let alphabetIndex49 = 9;\n  let vowelsCount49 = 9;\n  let alphabetCount49 = 9;\n  let vowelsIndex50 = 10;\n  let alphabetIndex50 = 10;\n  let vowelsCount50 = 10;\n  let alphabetCount50 = 10;\n  let vowelsIndex51 = 1;\n  let alphabetIndex51 = 1;\n  let vowelsCount51 = 1;\n  let alphabetCount51 = 1;\n  let vowelsIndex52 = 2;\n  let alphabetIndex52 = 2;\n  let vowelsCount52 = 2;\n  let alphabetCount52 = 2;\n  let vowelsIndex53 = 3;\n  let alphabetIndex53 = 3;\n  let vowelsCount53 = 3;\n  let alphabetCount53 = 3;\n  let vowelsIndex54 = 4;\n  let alphabetIndex54 = 4;\n  let vowelsCount54 = 4;\n  let alphabetCount54 = 4;\n  let vowelsIndex55 = 5;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "gc": "<|endoftext|>/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let sum = 0;\n  let max = 0;\n  let maxPrime = 0;\n  let maxPrimeSum = 0;\n  let maxPrimeDigit = 0;\n  let maxPrimeDigitSum = 0;\n  let maxPrimeDigitSum2 = 0;\n  let maxPrimeDigitSum3 = 0;\n  let maxPrimeDigitSum4 = 0;\n  let maxPrimeDigitSum5 = 0;\n  let maxPrimeDigitSum6 = 0;\n  let maxPrimeDigitSum7 = 0;\n  let maxPrimeDigitSum8 = 0;\n  let maxPrimeDigitSum9 = 0;\n  let maxPrimeDigitSum10 = 0;\n  let maxPrimeDigitSum11 = 0;\n  let maxPrimeDigitSum12 = 0;\n  let maxPrimeDigitSum13 = 0;\n  let maxPrimeDigitSum14 = 0;\n  let maxPrimeDigitSum15 = 0;\n  let maxPrimeDigitSum16 = 0;\n  let maxPrimeDigitSum17 = 0;\n  let maxPrimeDigitSum18 = 0;\n  let maxPrimeDigitSum19 = 0;\n  let maxPrimeDigitSum20 = 0;\n  let maxPrimeDigitSum21 = 0;\n  let maxPrimeDigitSum22 = 0;\n  let maxPrimeDigitSum23 = 0;\n  let maxPrimeDigitSum24 = 0;\n  let maxPrimeDigitSum25 = 0;\n  let maxPrimeDigitSum26 = 0;\n  let maxPrimeDigitSum27 = 0;\n  let maxPrimeDigitSum28 = 0;\n  let maxPrimeDigitSum29 = 0;\n  let maxPrimeDigitSum30 = 0;\n  let maxPrimeDigitSum31 = 0;\n  let maxPrimeDigitSum32 = 0;\n  let maxPrimeDigitSum33 = 0;\n  let maxPrimeDigitSum34 = 0;\n  let maxPrimeDigitSum35 = 0;\n  let maxPrimeDigitSum36 = 0;\n  let maxPrimeDigitSum37 = 0;\n  let maxPrimeDigitSum38 = 0;\n  let maxPrimeDigitSum39 = 0;\n  let maxPrimeDigitSum40 = 0;\n  let maxPrimeDigitSum41 = 0;\n  let maxPrimeDigitSum42 = 0;\n  let maxPrimeDigitSum43 = 0;\n  let maxPrimeDigitSum44 = 0;\n  let maxPrimeDigitSum45 = 0;\n  let maxPrimeDigitSum46 = 0;\n  let maxPrimeDigitSum47 = 0;\n  let maxPrimeDigitSum48 = 0;\n  let maxPrimeDigitSum49 = 0;\n  let maxPrimeDigitSum50 = 0;\n  let maxPrimeDigitSum51 = 0;\n  let maxPrimeDigitSum52 = 0;\n  let maxPrimeDigitSum53 = 0;\n  let maxPrimeDigitSum54 = 0;\n  let maxPrimeDigitSum55 = 0;\n  let maxPrimeDigitSum56 = 0;\n  let maxPrimeDigitSum57 = 0;\n  let maxPrimeDigitSum58 = 0;\n  let maxPrimeDigitSum59 = 0;\n  let maxPrimeDigitSum60 = 0;\n  let maxPrimeDigitSum61 = 0;\n  let maxPrimeDigitSum62 = 0;\n  let maxPrimeDigitSum63 = 0;\n  let maxPrimeDigitSum64 = 0;\n  let maxPrimeDigitSum65 = 0;\n  let maxPrimeDigitSum66 = 0;\n  let maxPrimeDigitSum67 = 0;\n  let maxPrimeDigitSum68 = 0;\n  let maxPrimeDigitSum69 = 0;\n  let maxPrimeDigitSum70 = 0;\n  let maxPrimeDigitSum71 = 0;\n  let maxPrimeDigitSum72 = 0;\n  let maxPrimeDigitSum73 = 0;\n  let maxPrimeDigitSum74 = 0;\n  let maxPrimeDigitSum75 = 0;\n  let maxPrimeDigitSum76 = 0;\n  let maxPrimeDigitSum77 = 0;\n  let maxPrimeDigitSum78 = 0;\n  let maxPrimeDigitSum79 = 0;\n  let maxPrimeDigitSum80 = 0;\n  let maxPrimeDigitSum81 = 0;\n  let maxPrimeDigitSum82 = 0;\n  let maxPrimeDigitSum83 = 0;\n  let maxPrimeDigitSum84 = 0;\n  let maxPrimeDigitSum85 = 0;\n  let maxPrimeDigitSum86 = 0;\n  let maxPrimeDigitSum87 = 0;\n  let maxPrimeDigitSum88 = 0;\n  let maxPrimeDigitSum89 = 0;\n  let maxPrimeDigitSum90 = 0;\n  let maxPrimeDigitSum91 = 0;\n  let maxPrimeDigitSum92 = 0;\n  let maxPrimeDigitSum93 = 0;\n  let maxPrimeDigitSum94 = 0;\n  let maxPrimeDigitSum95 = 0;\n  let maxPrimeDigitSum96 = 0;\n  let maxPrimeDigitSum97 = 0;\n  let maxPrimeDigitSum98 = 0;\n  let maxPrimeDigitSum99 = 0;\n  let maxPrimeDigitSum100 = 0;\n  let maxPrimeDigitSum101 = 0;\n  let maxPrimeDigitSum102 = 0;\n  let maxPrimeDigitSum103 = 0;\n  let maxPrimeDigitSum104 = 0;\n  let maxPrimeDigitSum105 = 0;\n  let maxPrimeDigitSum106 = 0;\n  let maxPrimeDigitSum107 = 0;\n  let maxPrimeDigitSum108 = 0;\n  let maxPrimeDigitSum109 = 0;\n  let maxPrimeDigitSum110 = 0;\n  let maxPrimeDigitSum111 = 0;\n  let maxPrimeDigitSum112 = 0;\n  let maxPrimeDigitSum113 = 0;\n  let maxPrimeDigitSum114 = 0;\n  let maxPrimeDigitSum115 = 0;\n  let maxPrimeDigitSum116 = 0;\n  let maxPrimeDigitSum117 = 0;\n  let maxPrimeDigitSum118 = 0;\n  let maxPrimeDigitSum119 = 0;\n  let maxPrimeDigitSum120 = 0;\n  let maxPrimeDigitSum121 = 0;\n  let maxPrimeDigitSum122 = 0;\n  let maxPrimeDigitSum123 = 0;\n  let maxPrimeDigitSum124 = 0;\n  let maxPrimeDigitSum125 = 0;\n  let maxPrimeDigitSum126 = 0;\n  let maxPrimeDigitSum127 = 0;\n  let maxPrimeDigitSum128 = 0;\n  let maxPrimeDigitSum129 = 0;\n  let maxPrimeDigitSum130 = 0;\n  let maxPrimeDigitSum131 = 0;\n  let maxPrimeDigitSum132 = 0;\n  let maxPrimeDigitSum133 = 0;\n  let maxPrimeDigitSum134 = 0;\n  let maxPrimeDigitSum135 = 0;\n  let maxPrimeDigitSum136 = 0;\n  let maxPrimeDigitSum137 = 0;\n  let maxPrimeDigitSum138 = 0;\n  let maxPrimeDigitSum139 = 0;\n  let maxPrimeDigitSum140 = 0;\n  let maxPrimeDigitSum141 = 0;\n  let maxPrimeDigitSum142 = 0;\n  let maxPrimeDigitSum143 = 0;\n  let maxPrimeDigitSum144 = 0;\n  let maxPrimeDigitSum145 = 0;\n  let maxPrimeDigitSum146 = 0;\n  let maxPrimeDigitSum147 = 0;\n  let maxPrimeDigitSum148 = 0;\n  let maxPrimeDigitSum", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCases({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCases({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCases({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCases({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCases({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCases = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCases", "gc": "<|endoftext|>/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCases({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCases({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCases({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCases({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCases({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCases = (dict) => {\n  const keys = Object.keys(dict);\n  let isAllKeysStringsInLowerCase = true;\n  let isAllKeysStringsInUpperCase = true;\n  keys.forEach(key => {\n    const key = key.trim();\n    const value = dict[key];\n    if (value && typeof value === \"string\") {\n      if (value.toLowerCase() === key.toLowerCase()) {\n        isAllKeysStringsInLowerCase = false;\n      } else if (value.toUpperCase() === key.toUpperCase()) {\n        isAllKeysStringsInUpperCase = false;\n      }\n    }\n  });\n  return isAllKeysStringsInLowerCase || isAllKeysStringsInUpperCase;\n};\n\n/*\n  Given a string, return true if all characters are lowercase or all \n  characters are uppercase, else return false.\n  The function should return false is the given string is empty.\n  Examples:\n  checkStringCases(\"a\") should return true.\n  checkStringCases(\"A\") should return false.\n  checkStringCases(\"aB\") should return false.\n  checkStringCases(\"aBc\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aBcD\") should return false.\n  checkStringCases(\"aB", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "gc": "<|endoftext|>/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n    i++;\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the integers that\n  are divisible by n.\n  for example:\n  divisibleBy(5) =>[2,3]\n  divisibleBy(11) => [2,3,5,7]\n  divisibleBy(0) => []\n  divisibleBy(20) => [2,3,5,7,11,13,17,19]\n  divisibleBy(1) => []\n  divisibleBy(18) => [2,3,5,7,11,13,17]\n  */\nconst divisibleBy = (n) => {\n  let divisors = [];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      divisors.push(i);\n    }\n    i++;\n  }\n  return divisors;\n};\n\n/*Implement a function that takes an integer and returns an array of the integers that\n  are divisible by n and less than n.\n  for example:\n  divisibleByLessThan(5) =>[2,3]\n  divisibleByLessThan(11) => [2,3,5,7]\n  divisibleByLessThan(0) => []\n  divisibleByLessThan(20) => [2,3,5,7,11,13,17,19]\n  divisibleByLessThan(1) => []\n  divisibleByLessThan(18) => [2,3,5,7,11,13,17]\n  */\nconst divisibleByLessThan = (n) => {\n  let divisors = [];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      divisors.push(i);\n    }\n    i++;\n  }\n  return divisors;\n};\n\n/*Implement a function that takes an integer and returns an array of the integers that\n  are divisible by n and greater than n.\n  for example:\n  divisibleByGreaterThan(5) =>[2,3]\n  divisibleByGreaterThan(11) => [2,3,5,7]\n  divisibleByGreaterThan(0) => []\n  divisibleByGreaterThan(20) => [2,3,5,7,11,13,17,19]\n  divisibleByGreaterThan(1) => []\n  divisibleByGreaterThan(18) => [2,3,5,7,11,13,17]\n  */\nconst divisibleByGreaterThan = (n) => {\n  let divisors = [];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      divisors.push(i);\n    }\n    i++;\n  }\n  return divisors;\n};\n\n/*Implement a function that takes an integer and returns an array of the integers that\n  are divisible by n and less than n and greater than n.\n  for example:\n  divisibleByLessThanAndGreaterThan(5) =>[2,3]\n  divisibleByLessThanAndGreaterThan(11) => [2,3,5,7]\n  divisibleByLessThanAndGreaterThan(0) => []\n  divisibleByLessThanAndGreaterThan(20) => [2,3,5,7,11,13,17,19]\n  divisibleByLessThanAndGreaterThan(1) => []\n  divisibleByLessThanAndGreaterThan(18) => [2,3,5,7,11,13,17]\n  */\nconst divisibleByLessThanAndGreaterThan = (n) => {\n  let divisors = [];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      divisors.push(i);\n    }\n    i++;\n  }\n  return divisors;\n};\n\n/*Implement a function that takes an integer and returns an array of the integers that\n  are divisible by n and less than n and greater than n.\n  for example:\n  divisibleByGreaterThanAndLessThan(5) =>[2,3]\n  divisibleByGreaterThanAndLessThan(11) => [2,3,5,7]\n  divisibleByGreaterThanAndLessThan(0) => []\n  divisibleByGreaterThanAndLessThan(20) => [2,3,5,7,11,13,17,19]\n  divisibleByGreaterThanAndLessThan(1) => []\n  divisibleByGreaterThanAndLessThan(18) => [2,3,5,7,11,13,17]\n  */\nconst divisibleByGreaterThanAndLessThan = (n) => {\n  let divisors = [];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      divisors.push(i);\n    }\n    i++;\n  }\n  return divisors;\n};\n\n/*Implement a function that takes an integer and returns an array of the integers that\n  are divisible by n and less than n and greater than n.\n  for example:\n  divisibleByLessThanAndGreaterThanAndLessThan(5) =>[2,3]\n  divisibleByLessThanAndGreaterThanAndLessThan(11) => [2,3,5,7]\n  divisibleByLessThanAndGreaterThanAndLessThan(0) => []\n  divisibleByLessThanAndGreaterThanAndLessThan(20) => [2,3,5,7,11,13,17,19]\n  divisibleByLessThanAndGreaterThanAndLessThan(1) => []\n  divisibleByLessThanAndGreaterThanAndLessThan(18) => [2,3,5,7,11,13,17]\n  */\nconst divisibleByLessThanAndGreaterThanAndLessThan = (n) => {\n  let divisors = [];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      divisors.push(i);\n    }\n    i++;\n  }\n  return divisors;\n};\n\n/*Implement a function that takes an integer and returns an array of the integers that\n  are divisible by n and less than n and greater than n.\n  for example:\n  divisibleByGreaterThanAndLessThanAndGreaterThan(5) =>[2,3]\n  divisibleByGreaterThanAndLessThanAndGreaterThan(11) => [2,3,5,7]\n  divisibleByGreaterThanAndLessThanAndGreaterThan(0) => []\n  divisibleByGreaterThanAndLessThanAndGreaterThan(20) => [2,3,5,7,11,13,17,19]\n  divisibleByGreaterThanAndLessThanAndGreaterThan(1) => []\n  divisibleByGreaterThanAndLessThanAndGreaterThan(18) => [2,3,5,7,11,13,17]\n  */\nconst divisibleByGreaterThanAndLessThanAndGreaterThan = (n) => {\n  let divisors = [];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      divisors.push(i);\n    }\n    i++;\n  }\n  return divisors;\n};\n\n/*Implement a function that takes an integer and returns an array of the integers that\n  are divisible by n and less than n and greater than n.\n  for example:\n  divisibleByLessThanAndGreaterThanAndLessThan(5) =>[2,3]\n  divisibleByLessThanAndGreaterThanAndLessThan(11) => [2,3,", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "gc": "<|endoftext|>/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let product = 1;\n  \n  while (b) {\n    product = product * b;\n    b = a % b;\n    a = Math.floor(a / b);\n  }\n  return product;\n}\n\n/*Complete the function that takes two integers and returns \n  the sum of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  sum(148, 412) should return 148.\n  sum(19, 28) should return 28.\n  sum(2020, 1851) should return 1851.\n  sum(14,-15) should return 14.\n  */\nconst sum = (a, b) => {\n  let sum = 0;\n  \n  while (b) {\n    sum = sum + b;\n    b = a % b;\n    a = Math.floor(a / b);\n  }\n  return sum;\n}\n\n/*Complete the function that takes two integers and returns \n  the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  difference(148, 412) should return -412.\n  difference(19, 28) should return 28.\n  difference(2020, 1851) should return 1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  \n  while (b) {\n    difference = difference + b;\n    b = a % b;\n    a = Math.floor(a / b);\n  }\n  return difference;\n}\n\n/*Complete the function that takes two integers and returns \n  the absolute value of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absolute(148, 412) should return 148.\n  absolute(19, 28) should return 28.\n  absolute(2020, 1851) should return 1851.\n  absolute(14,-15) should return 14.\n  */\nconst absolute = (a, b) => {\n  let absolute = 0;\n  \n  while (b) {\n    absolute = absolute + b;\n    b = a % b;\n    a = Math.floor(a / b);\n  }\n  return absolute;\n}\n\n/*Complete the function that takes two integers and returns \n  the square root of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  sqrt(148, 412) should return 412.\n  sqrt(19, 28) should return 28.\n  sqrt(2020, 1851) should return 1851.\n  sqrt(14,-15) should return 14.\n  */\nconst sqrt = (a, b) => {\n  let sqrt = 0;\n  \n  while (b) {\n    sqrt = sqrt + b;\n    b = a % b;\n    a = Math.floor(a / b);\n  }\n  return sqrt;\n}\n\n/*Complete the function that takes two integers and returns \n  the inverse of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  inverse(148, 412) should return 148.\n  inverse(19, 28) should return 28.\n  inverse(2020, 1851) should return 1851.\n  inverse(14,-15) should return 14.\n  */\nconst inverse = (a, b) => {\n  let inverse = 0;\n  \n  while (b) {\n    inverse = inverse + b;\n    b = a % b;\n    a = Math.floor(a / b);\n  }\n  return inverse;\n}\n\n/*Complete the function that takes two integers and returns \n  the factorial of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  factorial(148, 412) should return 120.\n  factorial(19, 28) should return 120.\n  factorial(2020, 1851) should return 120.\n  factorial(14,-15) should return 120.\n  */\nconst factorial = (a, b) => {\n  let factorial = 1;\n  \n  while (b) {\n    factorial = factorial * b;\n    b = a % b;\n    a = Math.floor(a / b);\n  }\n  return factorial;\n}\n\n/*Complete the function that takes two integers and returns \n  the remainder of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  remainder(148, 412) should return 412.\n  remainder(19, 28) should return 28.\n  remainder(2020, 1851) should return 1851.\n  remainder(14,-15) should return 14.\n  */\nconst remainder = (a, b) => {\n  let remainder = 0;\n  \n  while (b) {\n    remainder = remainder + b;\n    b = a % b;\n    a = Math.floor(a / b);\n  }\n  return remainder;\n}\n\n/*Complete the function that takes two integers and returns \n  the factorial of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  factorial2(148, 412) should return 120.\n  factorial2(19, 28) should return 120.\n  factorial2(2020, 1851) should return 120.\n  factorial2(14,-15) should return 120.\n  */\nconst factorial2 = (a, b) => {\n  let factorial = 1;\n  \n  while (b) {\n    factorial = factorial * b;\n    b = a % b;\n    a = Math.floor(a / b);\n  }\n  return factorial;\n}\n\n/*Complete the function that takes two integers and returns \n  the remainder of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  remainder2(148, 412) should return 412.\n  remainder2(19, 28) should return 28.\n  remainder2(2020, 1851) should return 1851.\n  remainder2(14,-15) should return 14.\n  */\nconst remainder2 = (a, b) => {\n  let remainder = 0;\n  \n  while (b) {\n    remainder = remainder + b;\n    b = a % b;\n    a = Math.floor(a / b);\n  }\n  return remainder;\n}\n\n/*Complete the function that takes two integers and returns \n  the factorial of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  factorial3(148, 412) should return 120.\n  factorial3(19, 28) should return 120.\n  factorial3(2020, 1851) should return 120.\n  factorial3(14,-15) should return 120.\n  */\nconst factorial3 = (a, b) => {\n  let factorial = 1;\n  \n  while (b) {\n    factorial = factorial * b;\n    b = a % b;\n    a = Math.floor(a / b);\n  }\n  return factorial;\n}\n\n/*Complete the function that takes two integers and returns \n  the remainder of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  remainder3(148, 412) should return 412.\n  remainder3(19, 28) should return 28.\n  remainder3(2020, 1851) should return 1851.\n  remainder3(14,-15) should return 14.\n  */\nconst remainder3 = (a, b) => {\n  let remainder = 0;\n  \n  while (b) {\n    remainder = remainder + b;\n    b = a % b;\n    a = Math.floor(a / b);\n  }\n  return remainder;\n}\n\n/*Complete the function that takes two integers and returns \n  the factorial of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  factorial4(148, 412) should return 120.\n  factorial4(19, 28) should return 120.\n  factorial4(2020, 1851) should return 120.\n  factori", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "gc": "<|endoftext|>/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let upperVowels = ['A', 'E', 'I', 'O', 'U'];\n  let vowelsLength = vowels.length;\n  let upperVowelsLength = upperVowels.length;\n  let vowelsIndex = 0;\n  let upperVowelsIndex = 0;\n  let vowelsIndex2 = 0;\n  let upperVowelsIndex2 = 0;\n  let vowelsIndex3 = 0;\n  let upperVowelsIndex3 = 0;\n  let vowelsIndex4 = 0;\n  let upperVowelsIndex4 = 0;\n  let vowelsIndex5 = 0;\n  let upperVowelsIndex5 = 0;\n  let vowelsIndex6 = 0;\n  let upperVowelsIndex6 = 0;\n  let vowelsIndex7 = 0;\n  let upperVowelsIndex7 = 0;\n  let vowelsIndex8 = 0;\n  let upperVowelsIndex8 = 0;\n  let vowelsIndex9 = 0;\n  let upperVowelsIndex9 = 0;\n  let vowelsIndex10 = 0;\n  let upperVowelsIndex10 = 0;\n  let vowelsIndex11 = 0;\n  let upperVowelsIndex11 = 0;\n  let vowelsIndex12 = 0;\n  let upperVowelsIndex12 = 0;\n  let vowelsIndex13 = 0;\n  let upperVowelsIndex13 = 0;\n  let vowelsIndex14 = 0;\n  let upperVowelsIndex14 = 0;\n  let vowelsIndex15 = 0;\n  let upperVowelsIndex15 = 0;\n  let vowelsIndex16 = 0;\n  let upperVowelsIndex16 = 0;\n  let vowelsIndex17 = 0;\n  let upperVowelsIndex17 = 0;\n  let vowelsIndex18 = 0;\n  let upperVowelsIndex18 = 0;\n  let vowelsIndex19 = 0;\n  let upperVowelsIndex19 = 0;\n  let vowelsIndex20 = 0;\n  let upperVowelsIndex20 = 0;\n  let vowelsIndex21 = 0;\n  let upperVowelsIndex21 = 0;\n  let vowelsIndex22 = 0;\n  let upperVowelsIndex22 = 0;\n  let vowelsIndex23 = 0;\n  let upperVowelsIndex23 = 0;\n  let vowelsIndex24 = 0;\n  let upperVowelsIndex24 = 0;\n  let vowelsIndex25 = 0;\n  let upperVowelsIndex25 = 0;\n  let vowelsIndex26 = 0;\n  let upperVowelsIndex26 = 0;\n  let vowelsIndex27 = 0;\n  let upperVowelsIndex27 = 0;\n  let vowelsIndex28 = 0;\n  let upperVowelsIndex28 = 0;\n  let vowelsIndex29 = 0;\n  let upperVowelsIndex29 = 0;\n  let vowelsIndex30 = 0;\n  let upperVowelsIndex30 = 0;\n  let vowelsIndex31 = 0;\n  let upperVowelsIndex31 = 0;\n  let vowelsIndex32 = 0;\n  let upperVowelsIndex32 = 0;\n  let vowelsIndex33 = 0;\n  let upperVowelsIndex33 = 0;\n  let vowelsIndex34 = 0;\n  let upperVowelsIndex34 = 0;\n  let vowelsIndex35 = 0;\n  let upperVowelsIndex35 = 0;\n  let vowelsIndex36 = 0;\n  let upperVowelsIndex36 = 0;\n  let vowelsIndex37 = 0;\n  let upperVowelsIndex37 = 0;\n  let vowelsIndex38 = 0;\n  let upperVowelsIndex38 = 0;\n  let vowelsIndex39 = 0;\n  let upperVowelsIndex39 = 0;\n  let vowelsIndex40 = 0;\n  let upperVowelsIndex40 = 0;\n  let vowelsIndex41 = 0;\n  let upperVowelsIndex41 = 0;\n  let vowelsIndex42 = 0;\n  let upperVowelsIndex42 = 0;\n  let vowelsIndex43 = 0;\n  let upperVowelsIndex43 = 0;\n  let vowelsIndex44 = 0;\n  let upperVowelsIndex44 = 0;\n  let vowelsIndex45 = 0;\n  let upperVowelsIndex45 = 0;\n  let vowelsIndex46 = 0;\n  let upperVowelsIndex46 = 0;\n  let vowelsIndex47 = 0;\n  let upperVowelsIndex47 = 0;\n  let vowelsIndex48 = 0;\n  let upperVowelsIndex48 = 0;\n  let vowelsIndex49 = 0;\n  let upperVowelsIndex49 = 0;\n  let vowelsIndex50 = 0;\n  let upperVowelsIndex50 = 0;\n  let vowelsIndex51 = 0;\n  let upperVowelsIndex51 = 0;\n  let vowelsIndex52 = 0;\n  let upperVowelsIndex52 = 0;\n  let vowelsIndex53 = 0;\n  let upperVowelsIndex53 = 0;\n  let vowelsIndex54 = 0;\n  let upperVowelsIndex54 = 0;\n  let vowelsIndex55 = 0;\n  let upperVowelsIndex55 = 0;\n  let vowelsIndex56 = 0;\n  let upperVowelsIndex56 = 0;\n  let vowelsIndex57 = 0;\n  let upperVowelsIndex57 = 0;\n  let vowelsIndex58 = 0;\n  let upperVowelsIndex58 = 0;\n  let vowelsIndex59 = 0;\n  let upperVowelsIndex59 = 0;\n  let vowelsIndex60 = 0;\n  let upperVowelsIndex60 = 0;\n  let vowelsIndex61 = 0;\n  let upperVowelsIndex61 = 0;\n  let vowelsIndex62 = 0;\n  let upperVowelsIndex62 = 0;\n  let vowelsIndex63 = 0;\n  let upperVowelsIndex63 = 0;\n  let vowelsIndex64 = 0;\n  let upperVowelsIndex64 = 0;\n  let vowelsIndex65 = 0;\n  let upperVowelsIndex65 = 0;\n  let vowelsIndex66 = 0;\n  let upperVowelsIndex66 = 0;\n  let vowelsIndex67 = 0;\n  let upperVowelsIndex67 = 0;\n  let vowelsIndex68 = 0;\n  let upperVowelsIndex68 = 0;\n  let vowelsIndex69 = 0;\n  let upperVowelsIndex69 = 0;\n  let vowelsIndex70 = 0;\n  let upperVowelsIndex70 = 0;\n  let vowelsIndex71 = 0;\n  let upperVowelsIndex71 = 0;\n  let vowelsIndex72 = 0;\n  let upperVowelsIndex72 = 0;\n  let vowelsIndex73 = 0;\n  let upperVowelsIndex73 = 0;\n  let vowelsIndex74 = 0;\n  let upperVowelsIndex74 = 0;\n  let vowelsIndex75 = 0;\n  let upperVowelsIndex75 = 0;\n  let vowelsIndex76 = 0;\n  let upperVowelsIndex76 = 0;\n  let vowelsIndex77 = 0;\n  let upperVowelsIndex77 = 0;\n  let vowelsIndex78 = 0;\n  let upperVowelsIndex78 = 0;\n  let vowelsIndex79 = 0;\n  let upperVowelsIndex79 = 0;\n  let vowelsIndex80 = 0;\n  let upperVowelsIndex80 = 0;\n  let vowelsIndex81 = 0;\n  let upperVowelsIndex81 = 0;\n  let vowelsIndex82 = 0;\n  let upperVowelsIndex82 = 0;\n  let vowelsIndex83 = 0;\n  let upperVowelsIndex83 = 0;\n  let vowelsIndex84 = 0;\n  let upperVow", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closerIntegers(\"10\")\n  10\n  >>> closerIntegers(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closerIntegers(\"14.5\") should\n  return 15 and closerIntegers(\"-14.5\") should return -15.\n  */\nconst closerIntegers = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closerIntegers", "gc": "<|endoftext|>/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closerIntegers(\"10\")\n  10\n  >>> closerIntegers(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closerIntegers(\"14.5\") should\n  return 15 and closerIntegers(\"-14.5\") should return -15.\n  */\nconst closerIntegers = (value) => {\n  const [integer, fraction] = value.split(\".\");\n  const [first, second] = fraction.split(\".\");\n  const [firstInteger, secondInteger] = integer.split(\".\");\n  const [firstFraction, secondFraction] = fraction.split(\".\");\n  const [firstFractionInteger, secondFractionInteger] = fractionInteger.split(\".\");\n  const [firstFractionFraction, secondFractionFraction] = fractionFraction.split(\".\");\n  const [firstFractionFractionInteger, secondFractionFractionInteger] = fractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFraction, secondFractionFractionFractionFraction] = fractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionInteger] = fractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFractionFractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFractionFractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFractionFractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFractionFractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFractionFractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFractionFractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFractionFractionFractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFractionFractionFractionFractionFractionFractionFraction.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionInteger, secondFractionFractionFractionFractionFractionFractionFractionInteger] = fractionFractionFractionFractionFractionFractionFractionFractionInteger.split(\".\");\n  const [firstFractionFractionFractionFractionFractionFractionFractionFractionFraction, secondFractionFractionFractionFractionFractionFractionFractionFractionFraction] = fractionFractionFractionFraction", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
