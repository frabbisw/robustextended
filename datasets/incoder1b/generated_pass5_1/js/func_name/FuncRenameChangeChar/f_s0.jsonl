{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hasclosEElemEntS([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasclosEElemEntS([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasclosEElemEntS = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasclosEElemEntS", "gc": "<|endoftext|>/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hasclosEElemEntS([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasclosEElemEntS([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasclosEElemEntS = (numbers, threshold) => {\n  const [firstNum, secondNum] = numbers;\n  const firstNumNum = firstNum * firstNum;\n  const secondNumNum = secondNum * secondNum;\n  const firstNumNum2 = firstNumNum * secondNumNum;\n  const secondNumNum2 = secondNumNum * firstNumNum2;\n  const firstNumNum3 = firstNumNum2 * secondNumNum2;\n  const secondNumNum3 = secondNumNum2 * firstNumNum3;\n  const firstNumNum4 = firstNumNum3 * secondNumNum3;\n  const secondNumNum4 = secondNumNum3 * firstNumNum4;\n  const firstNumNum5 = firstNumNum4 * secondNumNum4;\n  const secondNumNum5 = secondNumNum4 * firstNumNum5;\n  const firstNumNum6 = firstNumNum5 * secondNumNum5;\n  const secondNumNum6 = secondNumNum5 * firstNumNum6;\n  const firstNumNum7 = firstNumNum6 * secondNumNum6;\n  const secondNumNum7 = secondNumNum6 * firstNumNum7;\n  const firstNumNum8 = firstNumNum7 * secondNumNum7;\n  const secondNumNum8 = secondNumNum7 * firstNumNum8;\n  const firstNumNum9 = firstNumNum8 * secondNumNum8;\n  const secondNumNum9 = secondNumNum8 * firstNumNum9;\n  const firstNumNum10 = firstNumNum9 * secondNumNum9;\n  const secondNumNum10 = secondNumNum9 * firstNumNum10;\n  const firstNumNum11 = firstNumNum10 * secondNumNum10;\n  const secondNumNum11 = secondNumNum10 * firstNumNum11;\n  const firstNumNum12 = firstNumNum11 * secondNumNum11;\n  const secondNumNum12 = secondNumNum11 * firstNumNum12;\n  const firstNumNum13 = firstNumNum12 * secondNumNum12;\n  const secondNumNum13 = secondNumNum12 * firstNumNum13;\n  const firstNumNum14 = firstNumNum13 * secondNumNum13;\n  const secondNumNum14 = secondNumNum13 * firstNumNum14;\n  const firstNumNum15 = firstNumNum14 * secondNumNum14;\n  const secondNumNum15 = secondNumNum14 * firstNumNum15;\n  const firstNumNum16 = firstNumNum15 * secondNumNum15;\n  const secondNumNum16 = secondNumNum15 * firstNumNum16;\n  const firstNumNum17 = firstNumNum16 * secondNumNum16;\n  const secondNumNum17 = secondNumNum16 * firstNumNum17;\n  const firstNumNum18 = firstNumNum17 * secondNumNum17;\n  const secondNumNum18 = secondNumNum17 * firstNumNum18;\n  const firstNumNum19 = firstNumNum18 * secondNumNum18;\n  const secondNumNum19 = secondNumNum18 * firstNumNum19;\n  const firstNumNum20 = firstNumNum19 * secondNumNum19;\n  const secondNumNum20 = secondNumNum19 * firstNumNum20;\n  const firstNumNum21 = firstNumNum20 * secondNumNum20;\n  const secondNumNum21 = secondNumNum20 * firstNumNum21;\n  const firstNumNum22 = firstNumNum21 * secondNumNum21;\n  const secondNumNum22 = secondNumNum21 * firstNumNum22;\n  const firstNumNum23 = firstNumNum22 * secondNumNum22;\n  const secondNumNum23 = secondNumNum22 * firstNumNum23;\n  const firstNumNum24 = firstNumNum23 * secondNumNum23;\n  const secondNumNum24 = secondNumNum23 * firstNumNum24;\n  const firstNumNum25 = firstNumNum24 * secondNumNum24;\n  const secondNumNum25 = secondNumNum24 * firstNumNum25;\n  const firstNumNum26 = firstNumNum25 * secondNumNum25;\n  const secondNumNum26 = secondNumNum25 * firstNumNum26;\n  const firstNumNum27 = firstNumNum26 * secondNumNum26;\n  const secondNumNum27 = secondNumNum26 * firstNumNum27;\n  const firstNumNum28 = firstNumNum27 * secondNumNum27;\n  const secondNumNum28 = secondNumNum27 * firstNumNum28;\n  const firstNumNum29 = firstNumNum28 * secondNumNum28;\n  const secondNumNum29 = secondNumNum28 * firstNumNum29;\n  const firstNumNum30 = firstNumNum29 * secondNumNum29;\n  const secondNumNum30 = secondNumNum29 * firstNumNum30;\n  const firstNumNum31 = firstNumNum30 * secondNumNum30;\n  const secondNumNum31 = secondNumNum30 * firstNumNum31;\n  const firstNumNum32 = firstNumNum31 * secondNumNum31;\n  const secondNumNum32 = secondNumNum31 * firstNumNum32;\n  const firstNumNum33 = firstNumNum32 * secondNumNum32;\n  const secondNumNum33 = secondNumNum32 * firstNumNum33;\n  const firstNumNum34 = firstNumNum33 * secondNumNum33;\n  const secondNumNum34 = secondNumNum33 * firstNumNum34;\n  const firstNumNum35 = firstNumNum34 * secondNumNum34;\n  const secondNumNum35 = secondNumNum34 * firstNumNum35;\n  const firstNumNum36 = firstNumNum35 * secondNumNum35;\n  const secondNumNum36 = secondNumNum35 * firstNumNum36;\n  const firstNumNum37 = firstNumNum36 * secondNumNum36;\n  const secondNumNum37 = secondNumNum36 * firstNumNum37;\n  const firstNumNum38 = firstNumNum37 * secondNumNum37;\n  const secondNumNum38 = secondNumNum37 * firstNumNum38;\n  const firstNumNum39 = firstNumNum38 * secondNumNum38;\n  const secondNumNum39 = secondNumNum38 * firstNumNum39;\n  const firstNumNum40 = firstNumNum39 * secondNumNum39;\n  const secondNumNum40 = secondNumNum39 * firstNumNum40;\n  const firstNumNum41 = firstNumNum40 * secondNumNum40;\n  const secondNumNum41 = secondNumNum40 * firstNumNum41;\n  const firstNumNum42 = firstNumNum41 * secondNumNum41;\n  const secondNumNum42 = secondNumNum41 * firstNumNum42;\n  const firstNumNum43 = firstNumNum42 * secondNumNum42;\n  const secondNumNum43 = secondNumNum42 * firstNumNum43;\n  const firstNumNum44 = firstNumNum43 * secondNumNum43;\n  const secondNumNum44 = secondNumNum43 * firstNumNum44;\n  const firstNumNum45 = firstNumNum44 * secondNumNum44;\n  const secondNumNum45 = secondNumNum44 * first", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> sepAratEPareNGrOups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst sepAratEPareNGrOups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "sepAratEPareNGrOups", "gc": "<|endoftext|>/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> sepAratEPareNGrOups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst sepAratEPareNGrOups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  const paren_group_strings = [];\n  let paren_group_string = '';\n  for (let i = 0; i < paren_groups.length; i++) {\n    paren_group_string += paren_groups[i];\n    if (paren_group_string === '(') {\n      paren_group_strings.push(paren_group_string);\n      paren_group_string = '';\n    }\n  }\n  if (paren_group_string!== '' && paren_group_string!=='') {\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> sepAratEPareNGrOups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst sepAratEPareNGrOups2 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  const paren_group_strings = [];\n  let paren_group_string = '';\n  for (let i = 0; i < paren_groups.length; i++) {\n    paren_group_string += paren_groups[i];\n    if (paren_group_string === '(') {\n      paren_group_strings.push(paren_group_string);\n      paren_group_string = '';\n    }\n  }\n  if (paren_group_string!== '' && paren_group_string!=='') {\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> sepAratEPareNGrOups2('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst sepAratEPareNGrOups3 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  const paren_group_strings = [];\n  let paren_group_string = '';\n  for (let i = 0; i < paren_groups.length; i++) {\n    paren_group_string += paren_groups[i];\n    if (paren_group_string === '(') {\n      paren_group_strings.push(paren_group_string);\n      paren_group_string = '';\n    }\n  }\n  if (paren_group_string!== '' && paren_group_string!=='') {\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> sepAratEPareNGrOups3('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst sepAratEPareNGrOups4 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  const paren_group_strings = [];\n  let paren_group_string = '';\n  for (let i = 0; i < paren_groups.length; i++) {\n    paren_group_string += paren_groups[i];\n    if (paren_group_string === '(') {\n      paren_group_strings.push(paren_group_string);\n      paren_group_string = '';\n    }\n  }\n  if (paren_group_string!== '' && paren_group_string!=='') {\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> sepAratEPareNGrOups4('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst sepAratEPareNGrOups5 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  const paren_group_strings = [];\n  let paren_group_string = '';\n  for (let i = 0; i < paren_groups.length; i++) {\n    paren_group_string += paren_groups[i];\n    if (paren_group_string === '(') {\n      paren_group_strings.push(paren_group_string);\n      paren_group_string = '';\n    }\n  }\n  if (paren_group_string!== '' && paren_group_string!=='') {\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> sepAratEPareNGrOups5('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst sepAratEPareNGrOups6 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  const paren_group_strings = [];\n  let paren_group_string = '';\n  for (let i = 0; i < paren_groups.length; i++) {\n    paren_group_string += paren_groups[i];\n    if (paren_group_string === '(') {\n      paren_group_strings.push(paren_group_string);\n      paren_group_string = '';\n    }\n  }\n  if (paren_group_string!== '' && paren_group_string!=='') {\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> sepAratEPareNGrOups6('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst sepAratEPareNGrOups7 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  const paren_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPAlinDrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPAlinDrome", "gc": "<|endoftext|>/* Test if gniven strig is a palindrome */\nconst isPAlinDrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let palindrome = '';\n  let longestPalindrome = '';\n  let reversedString = '';\n  let prefix = '';\n  let suffix = '';\n  let reversedPrefix = '';\n  let reversedSuffix = '';\n  let palindromeLength = 0;\n  let palindromeLength2 = 0;\n  let palindromeLength3 = 0;\n  let palindromeLength4 = 0;\n  let palindromeLength5 = 0;\n  let palindromeLength6 = 0;\n  let palindromeLength7 = 0;\n  let palindromeLength8 = 0;\n  let palindromeLength9 = 0;\n  let palindromeLength10 = 0;\n  let palindromeLength11 = 0;\n  let palindromeLength12 = 0;\n  let palindromeLength13 = 0;\n  let palindromeLength14 = 0;\n  let palindromeLength15 = 0;\n  let palindromeLength16 = 0;\n  let palindromeLength17 = 0;\n  let palindromeLength18 = 0;\n  let palindromeLength19 = 0;\n  let palindromeLength20 = 0;\n  let palindromeLength21 = 0;\n  let palindromeLength22 = 0;\n  let palindromeLength23 = 0;\n  let palindromeLength24 = 0;\n  let palindromeLength25 = 0;\n  let palindromeLength26 = 0;\n  let palindromeLength27 = 0;\n  let palindromeLength28 = 0;\n  let palindromeLength29 = 0;\n  let palindromeLength30 = 0;\n  let palindromeLength31 = 0;\n  let palindromeLength32 = 0;\n  let palindromeLength33 = 0;\n  let palindromeLength34 = 0;\n  let palindromeLength35 = 0;\n  let palindromeLength36 = 0;\n  let palindromeLength37 = 0;\n  let palindromeLength38 = 0;\n  let palindromeLength39 = 0;\n  let palindromeLength40 = 0;\n  let palindromeLength41 = 0;\n  let palindromeLength42 = 0;\n  let palindromeLength43 = 0;\n  let palindromeLength44 = 0;\n  let palindromeLength45 = 0;\n  let palindromeLength46 = 0;\n  let palindromeLength47 = 0;\n  let palindromeLength48 = 0;\n  let palindromeLength49 = 0;\n  let palindromeLength50 = 0;\n  let palindromeLength51 = '';\n  let palindromeLength52 = '';\n  let palindromeLength53 = '';\n  let palindromeLength54 = '';\n  let palindromeLength55 = '';\n  let palindromeLength56 = '';\n  let palindromeLength57 = '';\n  let palindromeLength58 = '';\n  let palindromeLength59 = '';\n  let palindromeLength60 = '';\n  let palindromeLength61 = '';\n  let palindromeLength62 = '';\n  let palindromeLength63 = '';\n  let palindromeLength64 = '';\n  let palindromeLength65 = '';\n  let palindromeLength66 = '';\n  let palindromeLength67 = '';\n  let palindromeLength68 = '';\n  let palindromeLength69 = '';\n  let palindromeLength70 = '';\n  let palindromeLength71 = '';\n  let palindromeLength72 = '';\n  let palindromeLength73 = '';\n  let palindromeLength74 = '';\n  let palindromeLength75 = '';\n  let palindromeLength76 = '';\n  let palindromeLength77 = '';\n  let palindromeLength78 = '';\n  let palindromeLength79 = '';\n  let palindromeLength80 = '';\n  let palindromeLength81 = '';\n  let palindromeLength82 = '';\n  let palindromeLength83 = '';\n  let palindromeLength84 = '';\n  let palindromeLength85 = '';\n  let palindromeLength86 = '';\n  let palindromeLength87 = '';\n  let palindromeLength88 = '';\n  let palindromeLength89 = '';\n  let palindromeLength90 = '';\n  let palindromeLength91 = '';\n  let palindromeLength92 = '';\n  let palindromeLength93 = '';\n  let palindromeLength94 = '';\n  let palindromeLength95 = '';\n  let palindromeLength96 = '';\n  let palindromeLength97 = '';\n  let palindromeLength98 = '';\n  let palindromeLength99 = '';\n  let palindromeLength100 = '';\n  let palindromeLength101 = '';\n  let palindromeLength102 = '';\n  let palindromeLength103 = '';\n  let palindromeLength104 = '';\n  let palindromeLength105 = '';\n  let palindromeLength106 = '';\n  let palindromeLength107 = '';\n  let palindromeLength108 = '';\n  let palindromeLength109 = '';\n  let palindromeLength110 = '';\n  let palindromeLength111 = '';\n  let palindromeLength112 = '';\n  let palindromeLength113 = '';\n  let palindromeLength114 = '';\n  let palindromeLength115 = '';\n  let palindromeLength116 = '';\n  let palindromeLength117 = '';\n  let palindromeLength118 = '';\n  let palindromeLength119 = '';\n  let palindromeLength120 = '';\n  let palindromeLength121 = '';\n  let palindromeLength122 = '';\n  let palindromeLength123 = '';\n  let palindromeLength124 = '';\n  let palindromeLength125 = '';\n  let palindromeLength126 = '';\n  let palindromeLength127 = '';\n  let palindromeLength128 = '';\n  let palindromeLength129 = '';\n  let palindromeLength130 = '';\n  let palindromeLength131 = '';\n  let palindromeLength132 = '';\n  let palindromeLength133 = '';\n  let palindromeLength134 = '';\n  let palindromeLength135 = '';\n  let palindromeLength136 = '';\n  let palindromeLength137 = '';\n  let palindromeLength138 = '';\n  let palindromeLength139 = '';\n  let palindromeLength140 = '';\n  let palindromeLength141 = '';\n  let palindromeLength142 = '';\n  let palindromeLength143 = '';\n  let palindromeLength144 = '';\n  let palindromeLength145 = '';\n  let palindromeLength146 = '';\n  let palindromeLength147 = '';\n  let palindromeLength148 = '';\n  let palindromeLength149", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makEAPiLe(3)\n  [3, 5, 7]\n  */\nconst makEAPiLe = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makEAPiLe", "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makEAPiLe(3)\n  [3, 5, 7]\n  */\nconst makEAPiLe = (n) => {\n  const levels = [\n    [],\n    [],\n    [],\n  ];\n  for (let i = 1; i <= n; i += 1) {\n    levels[n % 2? i : (i + 1)].push(1);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makEAPiLe(3)\n  [3, 5, 7]\n  */\nconst makEAPiLe2 = (n) => {\n  const levels = [\n    [],\n    [],\n    [],\n  ];\n  for (let i = 1; i <= n; i += 1) {\n    levels[n % 2? i : (i + 1)].push(1);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makEAPiLe(3)\n  [3, 5, 7]\n  */\nconst makEAPiLe3 = (n) => {\n  const levels = [\n    [],\n    [],\n    [],\n  ];\n  for (let i = 1; i <= n; i += 1) {\n    levels[n % 2? i : (i + 1)].push(1);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makEAPiLe(3)\n  [3, 5, 7]\n  */\nconst makEAPiLe4 = (n) => {\n  const levels = [\n    [],\n    [],\n    [],\n  ];\n  for (let i = 1; i <= n; i += 1) {\n    levels[n % 2? i : (i + 1)].push(1);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makEAPiLe(3)\n  [3, 5, 7]\n  */\nconst makEAPiLe5 = (n) => {\n  const levels = [\n    [],\n    [],\n    [],\n  ];\n  for (let i = 1; i <= n; i += 1) {\n    levels[n % 2? i : (i + 1)].push(1);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makEAPiLe(3)\n  [3, 5, 7]\n  */\nconst makEAPiLe6 = (n) => {\n  const levels = [\n    [],\n    [],\n    [],\n  ];\n  for (let i = 1; i <= n; i += 1) {\n    levels[n % 2? i : (i + 1)].push(1);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makEAPiLe(3)\n  [3, 5, 7]\n  */\nconst makEAPiLe7 = (n) => {\n  const levels = [\n    [],\n    [],\n    [],\n  ];\n  for (let i = 1; i <= n; i += 1) {\n    levels[n % 2? i : (i + 1)].push(1);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makEAPiLe(3)\n  [3, 5, 7]\n  */\nconst makEAPiLe8 = (n) => {\n  const levels = [\n    [],\n    [],\n    [],\n  ];\n  for (let i = 1; i <= n; i += 1) {\n    levels[n % 2? i : (i + 1)].push(1);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makEAPiLe(3)\n  [3, 5, 7]\n  */\nconst makEAPiLe9 = (n) => {\n  const levels = [\n    [],\n    [],\n    [],\n  ];\n  for (let i = 1; i <= n; i += 1) {\n    levels[n % 2? i : (i + 1)].push(1);\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makEAPiLe(3)\n  [3, 5, 7]\n  */\nconst makEAPiLe10 = (n) => {\n  const levels = [\n    [],\n    [],\n    [],\n  ];\n  for (let i = 1; i <= n; i += 1", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  worDsStRing(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worDsStRing(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worDsStRing = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "worDsStRing", "gc": "<|endoftext|>/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  worDsStRing(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worDsStRing(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worDsStRing = (s) => {\n  let words = s.split(\" \");\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i]);\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  worDsStRing(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worDsStRing(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worDsStRing = s => {\n  let words = s.split(\" \");\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i]);\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  worDsStRing(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worDsStRing(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worDsStRing = s => {\n  let words = s.split(\" \");\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i]);\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  worDsStRing(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worDsStRing(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worDsStRing = s => {\n  let words = s.split(\" \");\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i]);\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  worDsStRing(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worDsStRing(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worDsStRing = s => {\n  let words = s.split(\" \");\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i]);\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  worDsStRing(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worDsStRing(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worDsStRing = s => {\n  let words = s.split(\" \");\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i]);\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  worDsStRing(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worDsStRing(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worDsStRing = s => {\n  let words = s.split(\" \");\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i]);\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  worDsStRing(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worDsStRing(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worDsStRing = s => {\n  let words = s.split(\" \");\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i]);\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  worDsStRing(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worDsStRing(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worDsStRing = s => {\n  let words = s.split(\" \");\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i]);\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  worDsStRing(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worDsStRing(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worDsStRing = s => {\n  let words = s.split(\" \");\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i]);\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  worDsStRing(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  worDsStRing(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst worDsStRing = s => {\n  let words = s.split(\" \");\n  let result = [];\n  for (let i = 0; i < words.length; i++) {\n    result.push(words[i]);\n  }\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  choOseNUm(12, 15) = 14\n  choOseNUm(13, 12) = -1\n  */\nconst choOseNUm = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "choOseNUm", "gc": "<|endoftext|>/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  choOseNUm(12, 15) = 14\n  choOseNUm(13, 12) = -1\n  */\nconst choOseNUm = (x, y) => {\n  let result = 0;\n  let temp;\n  \n  if (x < y) {\n    temp = x;\n    x = y;\n    y = temp;\n  }\n  \n  do {\n    temp = x % y;\n    x = y;\n    y = temp;\n  } while (x!== 0);\n  \n  return y;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest odd integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  choOseNUm(12, 15) = 15\n  choOseNUm(13, 12) = -1\n  */\nconst choOseNUm = (x, y) => {\n  let result = 0;\n  let temp;\n  \n  if (x < y) {\n    temp = x;\n    x = y;\n    y = temp;\n  }\n  \n  do {\n    temp = x % y;\n    x = y;\n    y = temp;\n  } while (x!== 0);\n  \n  return y;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  choOseNUm(12, 15) = 15\n  choOseNUm(13, 12) = -1\n  */\nconst choOseNUm = (x, y) => {\n  let result = 0;\n  let temp;\n  \n  if (x < y) {\n    temp = x;\n    x = y;\n    y = temp;\n  }\n  \n  do {\n    temp = x % y;\n    x = y;\n    y = temp;\n  } while (x!== 0);\n  \n  return y;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  choOseNUm(12, 15) = 15\n  choOseNUm(13, 12) = -1\n  */\nconst choOseNUm = (x, y) => {\n  let result = 0;\n  let temp;\n  \n  if (x < y) {\n    temp = x;\n    x = y;\n    y = temp;\n  }\n  \n  do {\n    temp = x % y;\n    x = y;\n    y = temp;\n  } while (x!== 0);\n  \n  return y;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  choOseNUm(12, 15) = 15\n  choOseNUm(13, 12) = -1\n  */\nconst choOseNUm = (x, y) => {\n  let result = 0;\n  let temp;\n  \n  if (x < y) {\n    temp = x;\n    x = y;\n    y = temp;\n  }\n  \n  do {\n    temp = x % y;\n    x = y;\n    y = temp;\n  } while (x!== 0);\n  \n  return y;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  choOseNUm(12, 15) = 15\n  choOseNUm(13, 12) = -1\n  */\nconst choOseNUm = (x, y) => {\n  let result = 0;\n  let temp;\n  \n  if (x < y) {\n    temp = x;\n    x = y;\n    y = temp;\n  }\n  \n  do {\n    temp = x % y;\n    x = y;\n    y = temp;\n  } while (x!== 0);\n  \n  return y;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  choOseNUm(12, 15) = 15\n  choOseNUm(13, 12) = -1\n  */\nconst choOseNUm = (x, y) => {\n  let result = 0;\n  let temp;\n  \n  if (x < y) {\n    temp = x;\n    x = y;\n    y = temp;\n  }\n  \n  do {\n    temp = x % y;\n    x = y;\n    y = temp;\n  } while (x!== 0);\n  \n  return y;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  choOseNUm(12, 15) = 15\n  choOseNUm(13, 12) = -1\n  */\nconst choOseNUm = (x, y) => {\n  let result = 0;\n  let temp;\n  \n  if (x < y) {\n    temp = x;\n    x = y;\n    y = temp;\n  }\n  \n  do {\n    temp = x % y;\n    x = y;\n    y = temp;\n  } while (x!== 0);\n  \n  return y;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  choOseNUm(12, 15) = 15\n  choOseNUm(13, 12) = -1\n  */\nconst choOseNUm = (x, y) => {\n  let result = 0;\n  let temp;\n  \n  if (x < y) {\n    temp = x;\n    x = y;\n    y = temp;\n  }\n  \n  do {\n    temp = x % y;\n    x = y;\n    y = temp;\n  } while (x!== 0);\n  \n  return y;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  choOseNUm(12, 15) = 15\n  choOseNUm(13, 12) = -1\n  */\nconst choOseNUm = (x, y) => {\n  let result = 0;\n  let temp;\n  \n  if (x < y) {\n    temp = x;\n    x = y;\n    y = temp;\n  }\n  \n  do {\n    temp = x % y;\n    x = y;\n    y = temp;\n  } while (x!== 0);\n  \n  return y;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  choOseNUm(12, 15) = 15\n  choOseNUm(13, 12) = -1\n  */\nconst choOseNUm = (x, y) => {\n  let result = 0;\n  let temp;\n  \n  if (x < y) {\n    temp = x;\n    x = y;\n    y = temp;\n  }\n  \n  do {\n    temp = x % y;\n    x = y;\n    y = temp;\n  } while (x!== 0);\n  \n  return y;\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  choOseNUm(12, 15) = 15\n  choOseNUm(13, 12) = -1\n  */\nconst choOseNUm = (x, y) => {\n  let result = 0;\n  let temp;\n  \n  if (x < y) {\n    temp = x;\n    x = y;\n    y = temp;\n  }\n  \n  do {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  rouNdedavg(1, 5) => \"0b11\"\n  rouNdedavg(7, 5) => -1\n  rouNdedavg(10, 20) => \"0b1111\"\n  rouNdedavg(20, 33) => \"0b11010\"\n  */\nconst rouNdedavg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "rouNdedavg", "gc": "<|endoftext|>/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  rouNdedavg(1, 5) => \"0b11\"\n  rouNdedavg(7, 5) => -1\n  rouNdedavg(10, 20) => \"0b1111\"\n  rouNdedavg(20, 33) => \"0b11010\"\n  */\nconst rouNdedavg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    count++;\n  }\n  for (let i = 1; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  return binary;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  sum of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  rouSedavg(1, 5) => \"0b11\"\n  rouSedavg(7, 5) => -1\n  rouSedavg(10, 20) => \"0b1111\"\n  rouSedavg(20, 33) => \"0b11010\"\n  */\nconst rouSedavg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    count++;\n  }\n  for (let i = 1; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  return binary;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  difference of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  rouDedavg(1, 5) => \"0b11\"\n  rouDedavg(7, 5) => -1\n  rouDedavg(10, 20) => \"0b1111\"\n  rouDedavg(20, 33) => \"0b11010\"\n  */\nconst rouDedavg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    count++;\n  }\n  for (let i = 1; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  return binary;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  difference of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  rouDedavg(1, 5) => \"0b11\"\n  rouDedavg(7, 5) => -1\n  rouDedavg(10, 20) => \"0b1111\"\n  rouDedavg(20, 33) => \"0b11010\"\n  */\nconst rouDedavg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    count++;\n  }\n  for (let i = 1; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  return binary;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  difference of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  rouDedavg(1, 5) => \"0b11\"\n  rouDedavg(7, 5) => -1\n  rouDedavg(10, 20) => \"0b1111\"\n  rouDedavg(20, 33) => \"0b11010\"\n  */\nconst rouDedavg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    count++;\n  }\n  for (let i = 1; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  return binary;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  difference of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  rouDedavg(1, 5) => \"0b11\"\n  rouDedavg(7, 5) => -1\n  rouDedavg(10, 20) => \"0b1111\"\n  rouDedavg(20, 33) => \"0b11010\"\n  */\nconst rouDedavg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    count++;\n  }\n  for (let i = 1; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  return binary;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  difference of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  rouDedavg(1, 5) => \"0b11\"\n  rouDedavg(7, 5) => -1\n  rouDedavg(10, 20) => \"0b1111\"\n  rouDedavg(20, 33) => \"0b11010\"\n  */\nconst rouDedavg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    count++;\n  }\n  for (let i = 1; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  return binary;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  difference of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  rouDedavg(1, 5) => \"0b11\"\n  rouDedavg(7, 5) => -1\n  rouDedavg(10, 20) => \"0b1111\"\n  rouDedavg(20, 33) => \"0b11010\"\n  */\nconst rouDedavg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n    count++;\n  }\n  for (let i = 1; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  binary = sum.toString(2);\n  return binary;\n};\n\n/*\n  You are given two positive integers n and m, and your task is to compute the\n  difference of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  rouDedavg", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniQueDIgits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniQueDIgits([152, 323, 1422, 10])\n  []\n  */\nconst uniQueDIgits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniQueDIgits", "gc": "<|endoftext|>/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniQueDIgits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniQueDIgits([152, 323, 1422, 10])\n  []\n  */\nconst uniQueDIgits = (x) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let temp = 0\n  while (i + j < x.length) {\n    if (x[i] % 2 === 0) {\n      temp = x[i]\n      x[i] = x[j]\n      x[j] = temp\n      i++\n      j++\n    } else {\n      temp = 0\n      k++\n    }\n  }\n  while (i + k < x.length) {\n    if (x[i] % 2 === 0) {\n      temp = x[i]\n      x[i] = x[k]\n      x[k] = temp\n      i++\n      k++\n    } else {\n      temp = 0\n      k++\n    }\n  }\n  return x\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniQueDIgits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniQueDIgits([152, 323, 1422, 10])\n  []\n  */\nconst uniQueDIgitsOdd = (x) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let temp = 0\n  while (i + j < x.length) {\n    if (x[i] % 2 === 1) {\n      temp = x[i]\n      x[i] = x[j]\n      x[j] = temp\n      i++\n      j++\n    } else {\n      temp = 0\n      k++\n    }\n  }\n  while (i + k < x.length) {\n    if (x[i] % 2 === 1) {\n      temp = x[i]\n      x[i] = x[k]\n      x[k] = temp\n      i++\n      k++\n    } else {\n      temp = 0\n      k++\n    }\n  }\n  return x\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniQueDIgits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniQueDIgits([152, 323, 1422, 10])\n  []\n  */\nconst uniQueDIgitsEven = (x) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let temp = 0\n  while (i + j < x.length) {\n    if (x[i] % 2 === 0) {\n      temp = x[i]\n      x[i] = x[j]\n      x[j] = temp\n      i++\n      j++\n    } else {\n      temp = 0\n      k++\n    }\n  }\n  while (i + k < x.length) {\n    if (x[i] % 2 === 0) {\n      temp = x[i]\n      x[i] = x[k]\n      x[k] = temp\n      i++\n      k++\n    } else {\n      temp = 0\n      k++\n    }\n  }\n  return x\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd digit and even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniQueDIgits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniQueDIgits([152, 323, 1422, 10])\n  []\n  */\nconst uniQueDIgitsOddEven = (x) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let temp = 0\n  while (i + j < x.length) {\n    if (x[i] % 2 === 1 && x[j] % 2 === 0) {\n      temp = x[i]\n      x[i] = x[j]\n      x[j] = temp\n      i++\n      j++\n    } else {\n      temp = 0\n      k++\n    }\n  }\n  while (i + k < x.length) {\n    if (x[i] % 2 === 1 && x[k] % 2 === 0) {\n      temp = x[i]\n      x[i] = x[k]\n      x[k] = temp\n      i++\n      k++\n    } else {\n      temp = 0\n      k++\n    }\n  }\n  return x\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd digit and even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniQueDIgits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniQueDIgits([152, 323, 1422, 10])\n  []\n  */\nconst uniQueDIgitsOddEvenOdd = (x) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let temp = 0\n  while (i + j < x.length) {\n    if (x[i] % 2 === 1 && x[j] % 2 === 1 && x[k] % 2 === 1) {\n      temp = x[i]\n      x[i] = x[j]\n      x[j] = temp\n      i++\n      j++\n    } else {\n      temp = 0\n      k++\n    }\n  }\n  while (i + k < x.length) {\n    if (x[i] % 2 === 1 && x[j] % 2 === 1 && x[k] % 2 === 1) {\n      temp = x[i]\n      x[i] = x[k]\n      x[k] = temp\n      i++\n      k++\n    } else {\n      temp = 0\n      k++\n    }\n  }\n  return x\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd digit and even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniQueDIgits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniQueDIgits([152, 323, 1422, 10])\n  []\n  */\nconst uniQueDIgitsOddEvenEvenOdd = (x) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let temp = 0\n  while (i + j < x.length) {\n    if (x[i] % 2 === 1 && x[j] % 2 === 1 && x[k] % 2 === 1) {\n      temp = x[i]\n      x[i] = x[j]\n      x[j] = temp\n      i++\n      j++\n    } else {\n      temp = 0\n      k++\n    }\n  }\n  while (i + k < x.length) {\n    if (x[i] % 2 === 1 && x[j] % 2 === 1 && x[k] % 2 === 1) {\n      temp = x[i]\n      x[i] = x[k]\n      x[k] = temp\n      i++\n      k++\n    } else {\n      temp = 0\n      k++\n    }\n  }\n  return x\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd digit and even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniQueDIgits([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniQueDIgits([152, 323, 1422, 10])\n  []\n  */\nconst uniQueDIgitsOddEvenOddEvenOdd = (x) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let temp = 0\n  while (i + j < x.length) {\n    if (x[i] % 2 === 1 && x[j] % 2 ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLEngtH = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLEngtH", "gc": "<|endoftext|>/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLEngtH = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH2 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH3 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH4 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH5 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH6 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH7 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH8 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH9 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH10 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH11 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH12 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH13 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH14 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH15 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH16 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH17 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH18 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH19 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH20 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH21 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH22 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH23 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH24 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const newArr = reversed.map((digit) => {\n    return digit.name;\n  });\n  return newArr;\n};\n\nconst byLEngtH25 = arr => {\n  const sorted = arr.sort((a, b) => a - b);\n  const ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "gc": "<|endoftext|>/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const factorial = (n) => {\n    if (n % 2 === 0) {\n      return n * factorial(n - 1);\n    }\n    return 1;\n  };\n  return factorial(n);\n};\n\n/* Implement the function g that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  g(5) == [1, 2, 6, 24, 15]\n  */\nconst g = (n) => {\n  const gcd = (n) => {\n    if (n % 2 === 0) {\n      return n * gcd(n - 1);\n    }\n    return 1;\n  };\n  return gcd(n);\n};\n\n/* Implement the function h that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  h(5) == [1, 2, 6, 24, 15]\n  */\nconst h = (n) => {\n  const gcd = (n) => {\n    if (n % 2 === 0) {\n      return n * h(n - 1);\n    }\n    return 1;\n  };\n  return gcd(n);\n};\n\n/* Implement the function i that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  i(5) == [1, 2, 6, 24, 15]\n  */\nconst i = (n) => {\n  const gcd = (n) => {\n    if (n % 2 === 0) {\n      return n * i(n - 1);\n    }\n    return 1;\n  };\n  return gcd(n);\n};\n\n/* Implement the function j that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  j(5) == [1, 2, 6, 24, 15]\n  */\nconst j = (n) => {\n  const gcd = (n) => {\n    if (n % 2 === 0) {\n      return n * j(n - 1);\n    }\n    return 1;\n  };\n  return gcd(n);\n};\n\n/* Implement the function k that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  k(5) == [1, 2, 6, 24, 15]\n  */\nconst k = (n) => {\n  const gcd = (n) => {\n    if (n % 2 === 0) {\n      return n * k(n - 1);\n    }\n    return 1;\n  };\n  return gcd(n);\n};\n\n/* Implement the function l that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  l(5) == [1, 2, 6, 24, 15]\n  */\nconst l = (n) => {\n  const gcd = (n) => {\n    if (n % 2 === 0) {\n      return n * l(n - 1);\n    }\n    return 1;\n  };\n  return gcd(n);\n};\n\n/* Implement the function m that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  m(5) == [1, 2, 6, 24, 15]\n  */\nconst m = (n) => {\n  const gcd = (n) => {\n    if (n % 2 === 0) {\n      return n * m(n - 1);\n    }\n    return 1;\n  };\n  return gcd(n);\n};\n\n/* Implement the function n that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  n(5) == [1, 2, 6, 24, 15]\n  */\nconst n = (n) => {\n  const gcd = (n) => {\n    if (n % 2 === 0) {\n      return n * n(n - 1);\n    }\n    return 1;\n  };\n  return gcd(n);\n};\n\n/* Implement the function o that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  o(5) == [1, 2, 6, 24, 15]\n  */\nconst o = (n) => {\n  const gcd = (n) => {\n    if (n % 2 === 0) {\n      return n * o(n - 1);\n    }\n    return 1;\n  };\n  return gcd(n);\n};\n\n/* Implement the function p that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  p(5) == [1, 2, 6, 24, 15]\n  */\nconst p = (n) => {\n  const gcd = (n) => {\n    if (n % 2 === 0) {\n      return n * p(n - 1);\n    }\n    return 1;\n  };\n  return gcd(n);\n};\n\n/* Implement the function q that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  q(5) == [1, 2, 6, 24, 15]\n  */\nconst q = (n) => {\n  const gcd = (n) => {\n    if (n % 2 === 0) {\n      return n * q(n - 1);", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst eveNOddpalinDroMe = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "eveNOddpalinDroMe", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst eveNOddpalinDroMe = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(2, n), inclusive.\n\nconst eveNOddpalinDroMe = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(3, n), inclusive.\n\nconst eveNOddpalinDroMe = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(4, n), inclusive.\n\nconst eveNOddpalinDroMe = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(5, n), inclusive.\n\nconst eveNOddpalinDroMe = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(6, n), inclusive.\n\nconst eveNOddpalinDroMe = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(7, n), inclusive.\n\nconst eveNOddpalinDroMe = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(8, n), inclusive.\n\nconst eveNOddpalinDroMe = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(9, n), inclusive.\n\nconst eveNOddpalinDroMe = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(10, n), inclusive.\n\nconst eveNOddpalinDroMe = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(11, n), inclusive.\n\nconst eveNOddpalinDroMe = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(12, n), inclusive.\n\nconst eveNOddpalinDroMe = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(13, n), inclusive.\n\nconst eveNOddpalinDroMe = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      even", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function couNtNuMs which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> couNtNuMs([]) == 0\n  >>> couNtNuMs([-1, 11, -11]) == 1\n  >>> couNtNuMs([1, 1, 2]) == 3\n  */\nconst couNtNuMs = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "couNtNuMs", "gc": "<|endoftext|>/*\n  Write a function couNtNuMs which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> couNtNuMs([]) == 0\n  >>> couNtNuMs([-1, 11, -11]) == 1\n  >>> couNtNuMs([1, 1, 2]) == 3\n  */\nconst couNtNuMs = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a function couNtNuMs which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> couNtNuMs([]) == 0\n  >>> couNtNuMs([-1, 11, -11]) == 1\n  >>> couNtNuMs([1, 1, 2]) == 3\n  */\nconst couNtNuMs = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a function couNtNuMs which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> couNtNuMs([]) == 0\n  >>> couNtNuMs([-1, 11, -11]) == 1\n  >>> couNtNuMs([1, 1, 2]) == 3\n  */\nconst couNtNuMs = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a function couNtNuMs which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> couNtNuMs([]) == 0\n  >>> couNtNuMs([-1, 11, -11]) == 1\n  >>> couNtNuMs([1, 1, 2]) == 3\n  */\nconst couNtNuMs = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a function couNtNuMs which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> couNtNuMs([]) == 0\n  >>> couNtNuMs([-1, 11, -11]) == 1\n  >>> couNtNuMs([1, 1, 2]) == 3\n  */\nconst couNtNuMs = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a function couNtNuMs which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> couNtNuMs([]) == 0\n  >>> couNtNuMs([-1, 11, -11]) == 1\n  >>> couNtNuMs([1, 1, 2]) == 3\n  */\nconst couNtNuMs = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a function couNtNuMs which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> couNtNuMs([]) == 0\n  >>> couNtNuMs([-1, 11, -11]) == 1\n  >>> couNtNuMs([1, 1, 2]) == 3\n  */\nconst couNtNuMs = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a function couNtNuMs which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> couNtNuMs([]) == 0\n  >>> couNtNuMs([-1, 11, -11]) == 1\n  >>> couNtNuMs([1, 1, 2]) == 3\n  */\nconst couNtNuMs = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a function couNtNuMs which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> couNtNuMs([]) == 0\n  >>> couNtNuMs([-1, 11, -11]) == 1\n  >>> couNtNuMs([1, 1, 2]) == 3\n  */\nconst couNtNuMs = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a function couNtNuMs which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> couNtNuMs([]) == 0\n  >>> couNtNuMs([-1, 11, -11]) == 1\n  >>> couNtNuMs([1, 1, 2]) == 3\n  */\nconst couNtNuMs = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a function couNtNuMs which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> couNtNuMs([]) == 0\n  >>> couNtNuMs([-1, 11, -11]) == 1\n  >>> cou", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  movEOneball([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  movEOneball([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst movEOneball = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "movEOneball", "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  movEOneball([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  movEOneball([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst movEOneball = (arr) => {\n  let len = arr.length;\n  let arr1 = arr.slice(0);\n  let arr2 = arr.slice(0);\n  let arr3 = arr.slice(0);\n  let arr4 = arr.slice(0);\n  let arr5 = arr.slice(0);\n  let arr6 = arr.slice(0);\n  let arr7 = arr.slice(0);\n  let arr8 = arr.slice(0);\n  let arr9 = arr.slice(0);\n  let arr10 = arr.slice(0);\n  let arr11 = arr.slice(0);\n  let arr12 = arr.slice(0);\n  let arr13 = arr.slice(0);\n  let arr14 = arr.slice(0);\n  let arr15 = arr.slice(0);\n  let arr16 = arr.slice(0);\n  let arr17 = arr.slice(0);\n  let arr18 = arr.slice(0);\n  let arr19 = arr.slice(0);\n  let arr20 = arr.slice(0);\n  let arr21 = arr.slice(0);\n  let arr22 = arr.slice(0);\n  let arr23 = arr.slice(0);\n  let arr24 = arr.slice(0);\n  let arr25 = arr.slice(0);\n  let arr26 = arr.slice(0);\n  let arr27 = arr.slice(0);\n  let arr28 = arr.slice(0);\n  let arr29 = arr.slice(0);\n  let arr30 = arr.slice(0);\n  let arr31 = arr.slice(0);\n  let arr32 = arr.slice(0);\n  let arr33 = arr.slice(0);\n  let arr34 = arr.slice(0);\n  let arr35 = arr.slice(0);\n  let arr36 = arr.slice(0);\n  let arr37 = arr.slice(0);\n  let arr38 = arr.slice(0);\n  let arr39 = arr.slice(0);\n  let arr40 = arr.slice(0);\n  let arr41 = arr.slice(0);\n  let arr42 = arr.slice(0);\n  let arr43 = arr.slice(0);\n  let arr44 = arr.slice(0);\n  let arr45 = arr.slice(0);\n  let arr46 = arr.slice(0);\n  let arr47 = arr.slice(0);\n  let arr48 = arr.slice(0);\n  let arr49 = arr.slice(0);\n  let arr50 = arr.slice(0);\n  let arr51 = arr.slice(0);\n  let arr52 = arr.slice(0);\n  let arr53 = arr.slice(0);\n  let arr54 = arr.slice(0);\n  let arr55 = arr.slice(0);\n  let arr56 = arr.slice(0);\n  let arr57 = arr.slice(0);\n  let arr58 = arr.slice(0);\n  let arr59 = arr.slice(0);\n  let arr60 = arr.slice(0);\n  let arr61 = arr.slice(0);\n  let arr62 = arr.slice(0);\n  let arr63 = arr.slice(0);\n  let arr64 = arr.slice(0);\n  let arr65 = arr.slice(0);\n  let arr66 = arr.slice(0);\n  let arr67 = arr.slice(0);\n  let arr68 = arr.slice(0);\n  let arr69 = arr.slice(0);\n  let arr70 = arr.slice(0);\n  let arr71 = arr.slice(0);\n  let arr72 = arr.slice(0);\n  let arr73 = arr.slice(0);\n  let arr74 = arr.slice(0);\n  let arr75 = arr.slice(0);\n  let arr76 = arr.slice(0);\n  let arr77 = arr.slice(0);\n  let arr78 = arr.slice(0);\n  let arr79 = arr.slice(0);\n  let arr80 = arr.slice(0);\n  let arr81 = arr.slice(0);\n  let arr82 = arr.slice(0);\n  let arr83 = arr.slice(0);\n  let arr84 = arr.slice(0);\n  let arr85 = arr.slice(0);\n  let arr86 = arr.slice(0);\n  let arr87 = arr.slice(0);\n  let arr88 = arr.slice(0);\n  let arr89 = arr.slice(0);\n  let arr90 = arr.slice(0);\n  let arr91 = arr.slice(0);\n  let arr92 = arr.slice(0);\n  let arr93 = arr.slice(0);\n  let arr94 = arr.slice(0);\n  let arr95 = arr.slice(0);\n  let arr96 = arr.slice(0);\n  let arr97 = arr.slice(0);\n  let arr98 = arr.slice(0);\n  let arr99 = arr.slice(0);\n  let arr100 = arr.slice(0);\n  let arr101 = arr.slice(0);\n  let arr102 = arr.slice(0);\n  let arr103 = arr.slice(0);\n  let arr104 = arr.slice(0);\n  let arr105 = arr.slice(0);\n  let arr106 = arr.slice(0);\n  let arr107 = arr.slice(0);\n  let arr108 = arr.slice(0);\n  let arr109 = arr.slice(0);\n  let arr110 = arr.slice(0);\n  let arr111 = arr.slice(0);\n  let arr112 = arr.slice(0);\n  let arr113 = arr.slice(0);\n  let arr114 = arr.slice(0);\n  let arr115 = arr.slice(0);\n  let arr116 = arr.slice(0);\n  let arr117 = arr.slice(0);\n  let arr118 = arr.slice(0);\n  let arr119 = arr.slice(0);\n  let arr120 = arr.slice(0);\n  let arr121 = arr.slice(0);\n  let arr122 = arr.slice(0);\n  let arr123 = arr.slice(0);\n  let arr124 = arr.slice(0);\n  let arr125 = arr.slice(0);\n  let arr126 = arr.slice(0);\n  let arr127 = arr.slice(0);\n  let arr128 = arr.slice(0);\n  let arr129 = arr.slice(0);\n  let arr130 = arr.slice(0);\n  let arr131 = arr.slice(0);\n  let arr132 = arr.slice(0);\n  let arr133 = arr.slice(0);\n  let arr134 = arr.slice(0);\n  let arr135 = arr.slice(0);\n  let arr136 = arr.slice(0);\n  let arr137 = arr.slice(0);\n  let arr138 = arr.slice(0);\n  let arr139 = arr.slice(0);\n  let arr140 = arr.slice(0);\n  let arr141 = arr.slice(0);\n  let arr142 = arr.slice(0);\n  let arr143 = arr.slice(0);\n  let arr144 = arr.slice(0);\n  let arr145 = arr.slice(0);\n  let arr146 = arr.slice(0);\n  let arr147 = arr.slice(0);\n  let arr148 = arr.slice(0);\n  let arr149 = arr.slice(0);\n  let arr150 = arr.slice(0);\n  let arr151 = arr.slice(0);\n  let arr152 = arr.slice(0);\n  let arr153 = arr.slice(0);\n  let arr154 = arr.slice(0);\n  let arr155 = arr.slice(0);\n  let arr156 = arr.slice(0);\n  let arr157 = arr.slice(0);\n  let arr158 = arr.slice(0);\n  let arr159 = arr.slice(0);\n  let arr160 = arr.slice(0);\n  let arr161 = arr.slice(0);\n  let arr162 = arr.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> strIngXOr('010', '110')\n  '100'\n  */\nconst strIngXOr = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "strIngXOr", "gc": "<|endoftext|>/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> strIngXOr('010', '110')\n  '100'\n  */\nconst strIngXOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> strIngAnd('010', '110')\n  '100'\n  */\nconst strIngAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> strIngOr('010', '110')\n  '100'\n  */\nconst strIngOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> strIngAnd('010', '110')\n  '100'\n  */\nconst strIngAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> strIngOr('010', '110')\n  '100'\n  */\nconst strIngAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> strIngAnd('010', '110')\n  '100'\n  */\nconst strIngAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> strIngAnd('010', '110')\n  '100'\n  */\nconst strIngAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> strIngAnd('010', '110')\n  '100'\n  */\nconst strIngAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> strIngAnd('010', '110')\n  '100'\n  */\nconst strIngAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> strIngAnd('010', '110')\n  '100'\n  */\nconst strIngAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> strIngAnd('010', '110')\n  '100'\n  */\nconst strIngAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> strIngAnd('010', '110')\n  '100'\n  */\nconst strIngAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> strIngAnd('010', '110')\n  '100'\n  */\nconst strIngAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> strIngAnd('010', '110')\n  '100'\n  */\nconst strIngAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> strIngAnd('010', '110')\n  '100'\n  */\nconst strIngAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> strIngAnd('010', '110')\n  '100'\n  */\nconst strIngAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> strIngAnd('010', '110')\n  '100'\n  */\nconst strIngAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) + b.charAt(i) + '';\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> strIng", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an excHangE of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of excHangEd elements between lst1 and lst2.\n  If it is possible to excHangE elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  excHangE([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  excHangE([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst excHangE = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "excHangE", "gc": "<|endoftext|>/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an excHangE of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of excHangEd elements between lst1 and lst2.\n  If it is possible to excHangE elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  excHangE([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  excHangE([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst excHangE = (lst1, lst2) => {\n  if (lst1.length < lst2.length) {\n    return false\n  }\n  let result\n  if (lst1.length === lst2.length) {\n    result = true\n  } else {\n    result = false\n  }\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== lst2[i] % 2) {\n      result = false\n      break\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that takes two lists of numbers and determines whether it\n  is possible to perform an excHangE of elements between them to make\n  lst1 a list of only odd numbers.\n  There is no limit on the number of excHangEd elements between lst1 and lst2.\n  If it is possible to excHangE elements between the lst1 and lst2 to make\n  all the elements of lst1 to be odd, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  excHangE([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  excHangE([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst excHangE = (lst1, lst2) => {\n  if (lst1.length < lst2.length) {\n    return false\n  }\n  let result\n  if (lst1.length === lst2.length) {\n    result = true\n  } else {\n    result = false\n  }\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === lst2[i] % 2) {\n      result = false\n      break\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that takes two lists of numbers and determines whether it\n  is possible to perform an excHangE of elements between them to make\n  lst1 a list of only even numbers.\n  There is no limit on the number of excHangEd elements between lst1 and lst2.\n  If it is possible to excHangE elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  excHangE([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  excHangE([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst excHangE = (lst1, lst2) => {\n  if (lst1.length < lst2.length) {\n    return false\n  }\n  let result\n  if (lst1.length === lst2.length) {\n    result = true\n  } else {\n    result = false\n  }\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== lst2[i] % 2) {\n      result = false\n      break\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that takes two lists of numbers and determines whether it\n  is possible to perform an excHangE of elements between them to make\n  lst1 a list of only odd numbers.\n  There is no limit on the number of excHangEd elements between lst1 and lst2.\n  If it is possible to excHangE elements between the lst1 and lst2 to make\n  all the elements of lst1 to be odd, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  excHangE([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  excHangE([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst excHangE = (lst1, lst2) => {\n  if (lst1.length < lst2.length) {\n    return false\n  }\n  let result\n  if (lst1.length === lst2.length) {\n    result = true\n  } else {\n    result = false\n  }\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === lst2[i] % 2) {\n      result = false\n      break\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that takes two lists of numbers and determines whether it\n  is possible to perform an excHangE of elements between them to make\n  lst1 a list of only odd numbers.\n  There is no limit on the number of excHangEd elements between lst1 and lst2.\n  If it is possible to excHangE elements between the lst1 and lst2 to make\n  all the elements of lst1 to be odd, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  excHangE([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  excHangE([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst excHangE = (lst1, lst2) => {\n  if (lst1.length < lst2.length) {\n    return false\n  }\n  let result\n  if (lst1.length === lst2.length) {\n    result = true\n  } else {\n    result = false\n  }\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== lst2[i] % 2) {\n      result = false\n      break\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that takes two lists of numbers and determines whether it\n  is possible to perform an excHangE of elements between them to make\n  lst1 a list of only odd numbers.\n  There is no limit on the number of excHangEd elements between lst1 and lst2.\n  If it is possible to excHangE elements between the lst1 and lst2 to make\n  all the elements of lst1 to be odd, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  excHangE([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  excHangE([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst excHangE = (lst1, lst2) => {\n  if (lst1.length < lst2.length) {\n    return false\n  }\n  let result\n  if (lst1.length === lst2.length) {\n    result = true\n  } else {\n    result = false\n  }\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== lst2[i] % 2) {\n      result = false\n      break\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that takes two lists of numbers and determines whether it\n  is possible to perform an excHangE of elements between them to make\n  lst1 a list of only odd numbers.\n  There is no limit on the number of excHangEd elements between lst1 and lst2.\n  If it is possible to excHangE elements between the lst1 and lst2 to make\n  all the elements of lst1 to be odd, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  excHangE([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  excHangE([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst excHangE = (lst1, lst2) => {\n  if (lst1.length < lst2.length) {\n    return false\n  }\n  let result\n  if (lst1.length === lst2.length) {\n    result = true\n  } else {\n    result = false\n  }\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === lst2[i] % 2) {\n      result = false", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  hisTogrAm('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  hisTogrAm('a b b a') == {'a': 2, 'b': 2}\n  hisTogrAm('a b c a b') == {'a': 2, 'b': 2}\n  hisTogrAm('b b b b a') == {'b': 4}\n  hisTogrAm('') == {}\n\n  */\nconst hisTogrAm = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "hisTogrAm", "gc": "<|endoftext|>/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  hisTogrAm('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  hisTogrAm('a b b a') == {'a': 2, 'b': 2}\n  hisTogrAm('a b c a b') == {'a': 2, 'b': 2}\n  hisTogrAm('b b b b a') == {'b': 4}\n  hisTogrAm('') == {}\n\n  */\nconst hisTogrAm = (test) => {\n  const letters = test.split(' ');\n  const letterMap = {};\n  let maxCount = 0;\n  let maxLetter;\n  let letter;\n\n  for (let i = 0; i < letters.length; i++) {\n    letter = letters[i];\n    if (letterMap[letter]) {\n      letterMap[letter]++;\n    } else {\n      letterMap[letter] = 1;\n    }\n  }\n\n  for (let letter in letterMap) {\n    if (letterMap[letter] > maxCount) {\n      maxCount = letterMap[letter];\n      maxLetter = letter;\n    }\n  }\n\n  return { [maxLetter]: maxCount };\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  hisTogrAm('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  hisTogrAm('a b b a') == {'a': 2, 'b': 2}\n  hisTogrAm('a b c a b') == {'a': 2, 'b': 2}\n  hisTogrAm('b b b b a') == {'b': 4}\n  hisTogrAm('') == {}\n\n  */\nconst hisTogrAm = (test) => {\n  const letters = test.split(' ');\n  const letterMap = {};\n  let maxCount = 0;\n  let maxLetter;\n  let letter;\n\n  for (let i = 0; i < letters.length; i++) {\n    letter = letters[i];\n    if (letterMap[letter]) {\n      letterMap[letter]++;\n    } else {\n      letterMap[letter] = 1;\n    }\n  }\n\n  for (let letter in letterMap) {\n    if (letterMap[letter] > maxCount) {\n      maxCount = letterMap[letter];\n      maxLetter = letter;\n    }\n  }\n\n  return { [maxLetter]: maxCount };\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  hisTogrAm('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  hisTogrAm('a b b a') == {'a': 2, 'b': 2}\n  hisTogrAm('a b c a b') == {'a': 2, 'b': 2}\n  hisTogrAm('b b b b a') == {'b': 4}\n  hisTogrAm('') == {}\n\n  */\nconst hisTogrAm = (test) => {\n  const letters = test.split(' ');\n  const letterMap = {};\n  let maxCount = 0;\n  let maxLetter;\n  let letter;\n\n  for (let i = 0; i < letters.length; i++) {\n    letter = letters[i];\n    if (letterMap[letter]) {\n      letterMap[letter]++;\n    } else {\n      letterMap[letter] = 1;\n    }\n  }\n\n  for (let letter in letterMap) {\n    if (letterMap[letter] > maxCount) {\n      maxCount = letterMap[letter];\n      maxLetter = letter;\n    }\n  }\n\n  return { [maxLetter]: maxCount };\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  hisTogrAm('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  hisTogrAm('a b b a') == {'a': 2, 'b': 2}\n  hisTogrAm('a b c a b') == {'a': 2, 'b': 2}\n  hisTogrAm('b b b b a') == {'b': 4}\n  hisTogrAm('') == {}\n\n  */\nconst hisTogrAm = (test) => {\n  const letters = test.split(' ');\n  const letterMap = {};\n  let maxCount = 0;\n  let maxLetter;\n  let letter;\n\n  for (let i = 0; i < letters.length; i++) {\n    letter = letters[i];\n    if (letterMap[letter]) {\n      letterMap[letter]++;\n    } else {\n      letterMap[letter] = 1;\n    }\n  }\n\n  for (let letter in letterMap) {\n    if (letterMap[letter] > maxCount) {\n      maxCount = letterMap[letter];\n      maxLetter = letter;\n    }\n  }\n\n  return { [maxLetter]: maxCount };\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  hisTogrAm('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  hisTogrAm('a b b a') == {'a': 2, 'b': 2}\n  hisTogrAm('a b c a b') == {'a': 2, 'b': 2}\n  hisTogrAm('b b b b a') == {'b': 4}\n  hisTogrAm('') == {}\n\n  */\nconst hisTogrAm = (test) => {\n  const letters = test.split(' ');\n  const letterMap = {};\n  let maxCount = 0;\n  let maxLetter;\n  let letter;\n\n  for (let i = 0; i < letters.length; i++) {\n    letter = letters[i];\n    if (letterMap[letter]) {\n      letterMap[letter]++;\n    } else {\n      letterMap[letter] = 1;\n    }\n  }\n\n  for (let letter in letterMap) {\n    if (letterMap[letter] > maxCount) {\n      maxCount = letterMap[letter];\n      maxLetter = letter;\n    }\n  }\n\n  return { [maxLetter]: maxCount };\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  hisTogrAm('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  hisTogrAm('a b b a') == {'a': 2, 'b': 2}\n  hisTogrAm('a b c a b') == {'a': 2, 'b': 2}\n  hisTogrAm('b b b b a') == {'b': 4}\n  hisTogrAm('') == {}\n\n  */\nconst hisTogrAm = (test) => {\n  const letters = test.split(' ');\n  const letterMap = {};\n  let maxCount = 0;\n  let maxLetter;\n  let letter;\n\n  for (let i = 0; i < letters.length; i++) {\n    letter = letters[i];\n    if (letterMap[letter]) {\n      letterMap[letter]++;\n    } else {\n      letterMap[letter] = 1;\n    }\n  }\n\n  for (let letter in letterMap) {\n    if (letterMap[letter] > maxCount) {\n      maxCount = letterMap[letter];\n      maxLetter = letter;\n    }\n  }\n\n  return { [maxLetter]: maxCount };\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letter", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst revErsedeletE = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "revErsedeletE", "gc": "<|endoftext|>/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst revErsedeletE = (s, c) => {\n  let rev = s.split(\"\").reverse().join(\"\");\n  let rev_c = c.split(\"\").reverse().join(\"\");\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_c = rev + rev_c;\n  let rev_s = rev + rev_c;\n  let rev_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddcounT(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddcounT(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddcounT = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddcounT", "gc": "<|endoftext|>/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddcounT(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddcounT(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddcounT = (lst) => {\n  let result = [];\n  let num = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/)) {\n      num += 1;\n    }\n  }\n  result.push(num);\n  return result;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evencounT(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evencounT(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evencounT = (lst) => {\n  let result = [];\n  let num = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/)) {\n      num -= 1;\n    }\n  }\n  result.push(num);\n  return result;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of pairs of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of pairs of odd digits in the i'th string of the input.\n\n  >>> paircounT(['1234567'])\n  [\"the number of pairs of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> paircounT(['3',\"11111111\"])\n  [\"the number of pairs of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of pairs of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst paircounT = (lst) => {\n  let result = [];\n  let num = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/)) {\n      num += 1;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/)) {\n      num -= 1;\n    }\n  }\n  result.push(num);\n  return result;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of triples of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of triples of odd digits in the i'th string of the input.\n\n  >>> triplecounT(['1234567'])\n  [\"the number of triples of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> triplecounT(['3',\"11111111\"])\n  [\"the number of triples of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of triples of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst triplecounT = (lst) => {\n  let result = [];\n  let num = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/)) {\n      num += 1;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/)) {\n      num -= 1;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/)) {\n      num += 1;\n    }\n  }\n  result.push(num);\n  return result;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of quads of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of quads of odd digits in the i'th string of the input.\n\n  >>> quadcounT(['1234567'])\n  [\"the number of quads of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> quadcounT(['3',\"11111111\"])\n  [\"the number of quads of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of quads of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst quadcounT = (lst) => {\n  let result = [];\n  let num = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/)) {\n      num += 1;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/)) {\n      num -= 1;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/)) {\n      num += 1;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/)) {\n      num -= 1;\n    }\n  }\n  result.push(num);\n  return result;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of quints of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of quints of odd digits in the i'th string of the input.\n\n  >>> quintcounT(['1234567'])\n  [\"the number of quints of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> quintcounT(['3',\"11111111\"])\n  [\"the number of quints of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of quints of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst quintcounT = (lst) => {\n  let result = [];\n  let num = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/)) {\n      num += 1;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/)) {\n      num -= 1;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/)) {\n      num += 1;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/)) {\n      num -= 1;\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/)) {\n      num += 1;\n    }\n  }\n  result.push(num);\n  return result;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of hexadecimal elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of hexadecimal digits in the i'th string of the input.\n\n  >>> hexacounT(['1234567'])\n  [\"the number of hexadecimal elements 4n the str4ng 4 of the 4nput.\"]\n  >>> hexacounT(['3',\"11111111\"])\n  [\"the number of hexadecimal elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of hexadecimal elements 8n the str8ng 8 of the 8nput.\"]\n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minsubARraySUm([2, 3, 4, 1, 2, 4]) == 1\n  minsubARraySUm([-1, -2, -3]) == -6\n  */\nconst minsubARraySUm = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minsubARraySUm", "gc": "<|endoftext|>/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minsubARraySUm([2, 3, 4, 1, 2, 4]) == 1\n  minsubARraySUm([-1, -2, -3]) == -6\n  */\nconst minsubARraySUm = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxsubARraySUm([2, 3, 4, 1, 2, 4]) == 4\n  maxsubARraySUm([-1, -2, -3]) == -3\n  */\nconst maxsubARraySUm = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers nums, find the minimum number of non-empty sub-arrays\n  of nums.\n  Example\n  minsubArrayCount([2, 3, 4]) == 2\n  minsubArrayCount([3, -4, -3]) == 1\n  */\nconst minsubArrayCount = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers nums, find the maximum number of non-empty sub-arrays\n  of nums.\n  Example\n  maxsubArrayCount([2, 3, 4]) == 4\n  maxsubArrayCount([3, -4, -3]) == 3\n  */\nconst maxsubArrayCount = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers nums, find the number of non-empty sub-arrays\n  of nums.\n  Example\n  nums = [2, 3, 4]\n  nums = [3, -4, -3]\n  nums = [-4, -3]\n  nums = [-4]\n  nums = []\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-4]\n  nums = [-", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxfill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxfill", "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxfill = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const result = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://leetcode.com/problems/maximum-flow-problem/discuss/430143/Java-solution-for-the-maximum-flow-problem\n// https://", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sorTArrAy([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sorTArrAy([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sorTArrAy([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sorTArrAy = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sorTArrAy", "gc": "<|endoftext|>/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sorTArrAy([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sorTArrAy([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sorTArrAy([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sorTArrAy = (arr) => {\n  const arrLen = arr.length;\n  const arrAy = new Array(arrLen);\n  for (let i = 0; i < arrLen; i++) {\n    arrAy[i] = 0;\n  }\n  for (let i = 0; i < arrLen; i++) {\n    for (let j = 0; j < arrLen; j++) {\n      if (arr[i] === 1) {\n        arrAy[j] += 1;\n      }\n    }\n  }\n  return arrAy;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in descending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sorTArrAy([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sorTArrAy([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sorTArrAy([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sorTArrAyDesc = (arr) => {\n  const arrLen = arr.length;\n  const arrAy = new Array(arrLen);\n  for (let i = 0; i < arrLen; i++) {\n    arrAy[i] = 0;\n  }\n  for (let i = 0; i < arrLen; i++) {\n    for (let j = 0; j < arrLen; j++) {\n      if (arr[i] === 1) {\n        arrAy[j] += 1;\n      }\n    }\n  }\n  return arrAy;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order and\n  in descending order.\n\n  It must be implemented like this:\n  >>> sorTArrAyDesc([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sorTArrAyDesc([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sorTArrAyDesc([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sorTArrAyDescAy = (arr) => {\n  const arrLen = arr.length;\n  const arrAy = new Array(arrLen);\n  for (let i = 0; i < arrLen; i++) {\n    arrAy[i] = 0;\n  }\n  for (let i = 0; i < arrLen; i++) {\n    for (let j = 0; j < arrLen; j++) {\n      if (arr[i] === 1) {\n        arrAy[j] += 1;\n      }\n    }\n  }\n  return arrAy;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order and\n  in descending order and in ascending order.\n\n  It must be implemented like this:\n  >>> sorTArrAyDescAy([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sorTArrAyDescAy([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sorTArrAyDescAy([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sorTArrAyDescAyAy = (arr) => {\n  const arrLen = arr.length;\n  const arrAy = new Array(arrLen);\n  for (let i = 0; i < arrLen; i++) {\n    arrAy[i] = 0;\n  }\n  for (let i = 0; i < arrLen; i++) {\n    for (let j = 0; j < arrLen; j++) {\n      if (arr[i] === 1) {\n        arrAy[j] += 1;\n      }\n    }\n  }\n  return arrAy;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order and\n  in descending order and in ascending order and in descending order.\n\n  It must be implemented like this:\n  >>> sorTArrAyDescAyAy([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sorTArrAyDescAyAy([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sorTArrAyDescAyAy([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sorTArrAyDescAyAyDesc = (arr) => {\n  const arrLen = arr.length;\n  const arrAy = new Array(arrLen);\n  for (let i = 0; i < arrLen; i++) {\n    arrAy[i] = 0;\n  }\n  for (let i = 0; i < arrLen; i++) {\n    for (let j = 0; j < arrLen; j++) {\n      if (arr[i] === 1) {\n        arrAy[j] += 1;\n      }\n    }\n  }\n  return arrAy;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order and\n  in descending order and in ascending order and in descending order and\n  in ascending order and in descending order.\n\n  It must be implemented like this:\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorTArrAyDescAyAyDesc([-1, -2, 3, 1, 0]) == [-1, -2, 3, 1, 0]\n  >>> sorT", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selEctWOrds(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selEctWOrds(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selEctWOrds(\"simple white space\", 2) ==> []\n  selEctWOrds(\"Hello world\", 4) ==> [\"world\"]\n  selEctWOrds(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selEctWOrds = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selEctWOrds", "gc": "<|endoftext|>/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selEctWOrds(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selEctWOrds(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selEctWOrds(\"simple white space\", 2) ==> []\n  selEctWOrds(\"Hello world\", 4) ==> [\"world\"]\n  selEctWOrds(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selEctWOrds = (s, n) => {\n  let res = [];\n  let word = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let count = 0;\n  let temp = '';\n  let temp2 = '';\n  let temp3 = '';\n  let temp4 = '';\n  let temp5 = '';\n  let temp6 = '';\n  let temp7 = '';\n  let temp8 = '';\n  let temp9 = '';\n  let temp10 = '';\n  let temp11 = '';\n  let temp12 = '';\n  let temp13 = '';\n  let temp14 = '';\n  let temp15 = '';\n  let temp16 = '';\n  let temp17 = '';\n  let temp18 = '';\n  let temp19 = '';\n  let temp20 = '';\n  let temp21 = '';\n  let temp22 = '';\n  let temp23 = '';\n  let temp24 = '';\n  let temp25 = '';\n  let temp26 = '';\n  let temp27 = '';\n  let temp28 = '';\n  let temp29 = '';\n  let temp30 = '';\n  let temp31 = '';\n  let temp32 = '';\n  let temp33 = '';\n  let temp34 = '';\n  let temp35 = '';\n  let temp36 = '';\n  let temp37 = '';\n  let temp38 = '';\n  let temp39 = '';\n  let temp40 = '';\n  let temp41 = '';\n  let temp42 = '';\n  let temp43 = '';\n  let temp44 = '';\n  let temp45 = '';\n  let temp46 = '';\n  let temp47 = '';\n  let temp48 = '';\n  let temp49 = '';\n  let temp50 = '';\n  let temp51 = '';\n  let temp52 = '';\n  let temp53 = '';\n  let temp54 = '';\n  let temp55 = '';\n  let temp56 = '';\n  let temp57 = '';\n  let temp58 = '';\n  let temp59 = '';\n  let temp60 = '';\n  let temp61 = '';\n  let temp62 = '';\n  let temp63 = '';\n  let temp64 = '';\n  let temp65 = '';\n  let temp66 = '';\n  let temp67 = '';\n  let temp68 = '';\n  let temp69 = '';\n  let temp70 = '';\n  let temp71 = '';\n  let temp72 = '';\n  let temp73 = '';\n  let temp74 = '';\n  let temp75 = '';\n  let temp76 = '';\n  let temp77 = '';\n  let temp78 = '';\n  let temp79 = '';\n  let temp80 = '';\n  let temp81 = '';\n  let temp82 = '';\n  let temp83 = '';\n  let temp84 = '';\n  let temp85 = '';\n  let temp86 = '';\n  let temp87 = '';\n  let temp88 = '';\n  let temp89 = '';\n  let temp90 = '';\n  let temp91 = '';\n  let temp92 = '';\n  let temp93 = '';\n  let temp94 = '';\n  let temp95 = '';\n  let temp96 = '';\n  let temp97 = '';\n  let temp98 = '';\n  let temp99 = '';\n  let temp100 = '';\n  let temp101 = '';\n  let temp102 = '';\n  let temp103 = '';\n  let temp104 = '';\n  let temp105 = '';\n  let temp106 = '';\n  let temp107 = '';\n  let temp108 = '';\n  let temp109 = '';\n  let temp110 = '';\n  let temp111 = '';\n  let temp112 = '';\n  let temp113 = '';\n  let temp114 = '';\n  let temp115 = '';\n  let temp116 = '';\n  let temp117 = '';\n  let temp118 = '';\n  let temp119 = '';\n  let temp120 = '';\n  let temp121 = '';\n  let temp122 = '';\n  let temp123 = '';\n  let temp124 = '';\n  let temp125 = '';\n  let temp126 = '';\n  let temp127 = '';\n  let temp128 = '';\n  let temp129 = '';\n  let temp130 = '';\n  let temp131 = '';\n  let temp132 = '';\n  let temp133 = '';\n  let temp134 = '';\n  let temp135 = '';\n  let temp136 = '';\n  let temp137 = '';\n  let temp138 = '';\n  let temp139 = '';\n  let temp140 = '';\n  let temp141 = '';\n  let temp142 = '';\n  let temp143 = '';\n  let temp144 = '';\n  let temp145 = '';\n  let temp146 = '';\n  let temp147 = '';\n  let temp148 = '';\n  let temp149 = '';\n  let temp150 = '';\n  let temp151 = '';\n  let temp152 = '';\n  let temp153 = '';\n  let temp154 = '';\n  let temp155 = '';\n  let temp156 = '';\n  let temp157 = '';\n  let temp158 = '';\n  let temp159 = '';\n  let temp160 = '';\n  let temp161 = '';\n  let temp162 = '';\n  let temp163 = '';\n  let temp164 = '';\n  let temp165 = '';\n  let temp166 = '';\n  let temp167 = '';\n  let temp168 = '';\n  let temp169 = '';\n  let temp170 = '';\n  let temp171 = '';\n  let temp172 = '';\n  let temp173 = '';\n  let temp174 = '';\n  let temp175 = '';\n  let temp176 = '';\n  let temp177 = '';\n  let temp178 = '';\n  let temp179 = '';\n  let temp180 = '';\n  let temp181 = '';\n  let temp182 = '';\n  let temp183 = '';\n  let temp184 = '';\n  let temp185 = '';\n  let temp186 = '';\n  let temp187 = '';\n  let temp188 = '';\n  let temp189 = '';\n  let temp190 = '';\n  let temp191 = '';\n  let temp192 = '';\n  let temp193 = '';\n  let temp194 = '';\n  let temp195 = '';\n  let temp196 = '';\n  let temp197 = '';\n  let temp198 = '';\n  let temp199 = '';\n  let temp200 = '';\n  let temp201 = '';\n  let temp202 = '';\n  let temp203 = '';\n  let temp204 = '';\n  let temp205 = '';\n  let temp206 = '';\n  let temp207 = '';\n  let temp208 = '';\n  let temp209 = '';\n  let temp210 = '';\n  let temp211 = '';\n  let temp212 = '';\n  let temp213 = '';\n  let temp214 = '';\n  let temp215 = '';\n  let temp216 = '';\n  let temp217 = '';\n  let temp218 = '';\n  let temp219 = '';\n  let temp220 = '';\n  let temp221 = '';\n  let temp222 = '';\n  let temp223 = '';\n  let temp224 = '';\n  let temp225 = '';\n  let temp226 = '';\n  let temp227 = '';\n  let temp228 = '';\n  let temp229 = '';\n  let temp230 = '';\n  let temp231 = '';\n  let temp232 = '';\n  let temp233 = '';\n  let temp234 = '';\n  let temp235 = '';\n  let temp236 = '';\n  let temp237 = '';\n  let temp238 = '';\n  let temp239 = '';\n  let temp240 = '';\n  let temp241 = '';\n  let temp242 = '';\n  let temp243 = '';\n  let temp244 = '';\n  let temp245 = '';\n  let temp246 = '';\n  let temp247 = '';\n  let temp248 = '';\n  let temp249 = '';\n  let temp250 = '';\n  let temp251 = '';\n  let temp252 = '';\n  let temp253 = '';\n  let temp254 = '';\n  let temp255 = '';\n  let temp256 = '';\n  let temp257 = '';\n  let temp258 = '';\n  let temp259 = '';\n  let temp260 = '';\n  let temp", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  getclosEstVoWel(\"yogurt\") ==> \"u\"\n  getclosEstVoWel(\"FULL\") ==> \"U\"\n  getclosEstVoWel(\"quick\") ==> \"\"\n  getclosEstVoWel(\"ab\") ==> \"\"\n  */\nconst getclosEstVoWel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getclosEstVoWel", "gc": "<|endoftext|>/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  getclosEstVoWel(\"yogurt\") ==> \"u\"\n  getclosEstVoWel(\"FULL\") ==> \"U\"\n  getclosEstVoWel(\"quick\") ==> \"\"\n  getclosEstVoWel(\"ab\") ==> \"\"\n  */\nconst getclosEstVoWel = (word) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsArray = vowels.map(v => v.toLowerCase());\n  let vowelsArray2 = vowels.map(v => v.toUpperCase());\n  let vowelsArray3 = vowels.map(v => v.toUpperCase());\n  let vowelsArray4 = vowels.map(v => v.toLowerCase());\n  let vowelsArray5 = vowels.map(v => v.toLowerCase());\n  let vowelsArray6 = vowels.map(v => v.toLowerCase());\n  let vowelsArray7 = vowels.map(v => v.toLowerCase());\n  let vowelsArray8 = vowels.map(v => v.toLowerCase());\n  let vowelsArray9 = vowels.map(v => v.toLowerCase());\n  let vowelsArray10 = vowels.map(v => v.toLowerCase());\n  let vowelsArray11 = vowels.map(v => v.toLowerCase());\n  let vowelsArray12 = vowels.map(v => v.toLowerCase());\n  let vowelsArray13 = vowels.map(v => v.toLowerCase());\n  let vowelsArray14 = vowels.map(v => v.toLowerCase());\n  let vowelsArray15 = vowels.map(v => v.toLowerCase());\n  let vowelsArray16 = vowels.map(v => v.toLowerCase());\n  let vowelsArray17 = vowels.map(v => v.toLowerCase());\n  let vowelsArray18 = vowels.map(v => v.toLowerCase());\n  let vowelsArray19 = vowels.map(v => v.toLowerCase());\n  let vowelsArray20 = vowels.map(v => v.toLowerCase());\n  let vowelsArray21 = vowels.map(v => v.toLowerCase());\n  let vowelsArray22 = vowels.map(v => v.toLowerCase());\n  let vowelsArray23 = vowels.map(v => v.toLowerCase());\n  let vowelsArray24 = vowels.map(v => v.toLowerCase());\n  let vowelsArray25 = vowels.map(v => v.toLowerCase());\n  let vowelsArray26 = vowels.map(v => v.toLowerCase());\n  let vowelsArray27 = vowels.map(v => v.toLowerCase());\n  let vowelsArray28 = vowels.map(v => v.toLowerCase());\n  let vowelsArray29 = vowels.map(v => v.toLowerCase());\n  let vowelsArray30 = vowels.map(v => v.toLowerCase());\n  let vowelsArray31 = vowels.map(v => v.toLowerCase());\n  let vowelsArray32 = vowels.map(v => v.toLowerCase());\n  let vowelsArray33 = vowels.map(v => v.toLowerCase());\n  let vowelsArray34 = vowels.map(v => v.toLowerCase());\n  let vowelsArray35 = vowels.map(v => v.toLowerCase());\n  let vowelsArray36 = vowels.map(v => v.toLowerCase());\n  let vowelsArray37 = vowels.map(v => v.toLowerCase());\n  let vowelsArray38 = vowels.map(v => v.toLowerCase());\n  let vowelsArray39 = vowels.map(v => v.toLowerCase());\n  let vowelsArray40 = vowels.map(v => v.toLowerCase());\n  let vowelsArray41 = vowels.map(v => v.toLowerCase());\n  let vowelsArray42 = vowels.map(v => v.toLowerCase());\n  let vowelsArray43 = vowels.map(v => v.toLowerCase());\n  let vowelsArray44 = vowels.map(v => v.toLowerCase());\n  let vowelsArray45 = vowels.map(v => v.toLowerCase());\n  let vowelsArray46 = vowels.map(v => v.toLowerCase());\n  let vowelsArray47 = vowels.map(v => v.toLowerCase());\n  let vowelsArray48 = vowels.map(v => v.toLowerCase());\n  let vowelsArray49 = vowels.map(v => v.toLowerCase());\n  let vowelsArray50 = vowels.map(v => v.toLowerCase());\n  let vowelsArray51 = vowels.map(v => v.toLowerCase());\n  let vowelsArray52 = vowels.map(v => v.toLowerCase());\n  let vowelsArray53 = vowels.map(v => v.toLowerCase());\n  let vowelsArray54 = vowels.map(v => v.toLowerCase());\n  let vowelsArray55 = vowels.map(v => v.toLowerCase());\n  let vowelsArray56 = vowels.map(v => v.toLowerCase());\n  let vowelsArray57 = vowels.map(v => v.toLowerCase());\n  let vowelsArray58 = vowels.map(v => v.toLowerCase());\n  let vowelsArray59 = vowels.map(v => v.toLowerCase());\n  let vowelsArray60 = vowels.map(v => v.toLowerCase());\n  let vowelsArray61 = vowels.map(v => v.toLowerCase());\n  let vowelsArray62 = vowels.map(v => v.toLowerCase());\n  let vowelsArray63 = vowels.map(v => v.toLowerCase());\n  let vowelsArray64 = vowels.map(v => v.toLowerCase());\n  let vowelsArray65 = vowels.map(v => v.toLowerCase());\n  let vowelsArray66 = vowels.map(v => v.toLowerCase());\n  let vowelsArray67 = vowels.map(v => v.toLowerCase());\n  let vowelsArray68 = vowels.map(v => v.toLowerCase());\n  let vowelsArray69 = vowels.map(v => v.toLowerCase());\n  let vowelsArray70 = vowels.map(v => v.toLowerCase());\n  let vowelsArray71 = vowels.map(v => v.toLowerCase());\n  let vowelsArray72 = vowels.map(v => v.toLowerCase());\n  let vowelsArray73 = vowels.map(v => v.toLowerCase());\n  let vowelsArray74 = vowels.map(v => v.toLowerCase());\n  let vowelsArray75 = vowels.map(v => v.toLowerCase());\n  let vowelsArray76 = vowels.map(v => v.toLowerCase());\n  let vowelsArray77 = vowels.map(v => v.toLowerCase());\n  let vowelsArray78 = vowels.map(v => v.toLowerCase());\n  let vowelsArray79 = vowels.map(v => v.toLowerCase());\n  let vowelsArray80 = vowels.map(v => v.toLowerCase());\n  let vowelsArray81 = vowels.map(v => v.toLowerCase());\n  let vowelsArray82 = vowels.map(v => v.toLowerCase());\n  let vowelsArray83 = vowels.map(v => v.toLowerCase());\n  let vowelsArray84 = vowels.map(v => v.toLowerCase());\n  let vowelsArray85 = vowels.map(v => v.toLowerCase());\n  let vowelsArray86 = vowels.map(v => v.toLowerCase());\n  let vowelsArray87 = vowels.map(v => v.toLowerCase());\n  let vowelsArray88 = vowels.map(v => v.toLowerCase());\n  let vowelsArray89 = vowels.map(v => v.toLowerCase());\n  let vowelsArray90 = vowels.map(v => v.toLowerCase());\n  let vowelsArray91 = vowels.map(v => v.toLowerCase());\n  let vowelsArray92 = vowels.map(v => v.toLowerCase());\n  let vowelsArray93 = ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matChPaRens(['()(', ')']) == 'Yes'\n  matChPaRens([')', ')']) == 'No'\n  */\nconst matChPaRens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matChPaRens", "gc": "<|endoftext|>/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matChPaRens(['()(', ')']) == 'Yes'\n  matChPaRens([')', ')']) == 'No'\n  */\nconst matChPaRens = (lst) => {\n  let res = 'No';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the lonGest one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> lonGest([])\n\n  >>> lonGest(['a', 'b', 'c'])\n  'a'\n  >>> lonGest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst lonGest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "lonGest", "gc": "<|endoftext|>/* Out of list of strings, return the lonGest one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> lonGest([])\n\n  >>> lonGest(['a', 'b', 'c'])\n  'a'\n  >>> lonGest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst lonGest = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  let longest = 0\n  let longestString = ''\n  for (let i = 0; i < strings.length; i++) {\n    const string = strings[i]\n    if (string.length > longest) {\n      longest = string.length\n      longestString = string\n    }\n  }\n  return longestString\n}\n\n/**\n  Given a list of strings, return the longest one that starts with 'a'.\n  >>> longestStartingWith('abc')\n  'a'\n  >>> longestStartingWith('abcabc')\n  'abcabc'\n  >>> longestStartingWith('abcabcabc')\n  'abcabcabc'\n  >>> longestStartingWith('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maxImum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maxImum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maxImum", "gc": "<|endoftext|>/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maxImum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maxImum = (arr, k) => {\n  const len = arr.length;\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return [arr[maxIndex], maxIndex];\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySum = function(head) {\n  let sum = 0;\n  let max = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  max = Math.max(sum, max);\n  return max;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-ii/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumII = function(head) {\n  let sum = 0;\n  let max = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  max = Math.max(sum, max);\n  return max;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iii/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumIII = function(head) {\n  let sum = 0;\n  let max = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  max = Math.max(sum, max);\n  return max;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumIV = function(head) {\n  let sum = 0;\n  let max = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  max = Math.max(sum, max);\n  return max;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumV = function(head) {\n  let sum = 0;\n  let max = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  max = Math.max(sum, max);\n  return max;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-vi/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumVI = function(head) {\n  let sum = 0;\n  let max = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  max = Math.max(sum, max);\n  return max;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-vii/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumVII = function(head) {\n  let sum = 0;\n  let max = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  max = Math.max(sum, max);\n  return max;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-viii/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumVIII = function(head) {\n  let sum = 0;\n  let max = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  max = Math.max(sum, max);\n  return max;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumIV = function(head) {\n  let sum = 0;\n  let max = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  max = Math.max(sum, max);\n  return max;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumVV = function(head) {\n  let sum = 0;\n  let max = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  max = Math.max(sum, max);\n  return max;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-viii/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nvar findMaxSubArraySumVVI = function(head) {\n  let sum = 0;\n  let max = 0;\n  let curr = head;\n  while (curr) {\n    sum += curr.val;", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solUtioN([5, 8, 7, 1]) ==> 12\n  solUtioN([3, 3, 3, 3, 3]) ==> 9\n  solUtioN([30, 13, 24, 321]) ==>0\n  */\nconst solUtioN = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solUtioN", "gc": "<|endoftext|>/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solUtioN([5, 8, 7, 1]) ==> 12\n  solUtioN([3, 3, 3, 3, 3]) ==> 9\n  solUtioN([30, 13, 24, 321]) ==>0\n  */\nconst solUtioN = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solUtioN([5, 8, 7, 1]) ==> 12\n  solUtioN([3, 3, 3, 3, 3]) ==> 9\n  solUtioN([30, 13, 24, 321]) ==> 0\n  */\nconst solUtioNodd = (lst, index) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solUtioNodd([5, 8, 7, 1]) ==> 12\n  solUtioNodd([3, 3, 3, 3, 3]) ==> 9\n  solUtioNodd([30, 13, 24, 321]) ==> 0\n  */\nconst solUtioEven = (lst) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the odd elements that are in odd positions.\n  \n\n  Examples\n  solUtioEven([5, 8, 7, 1]) ==> 12\n  solUtioEven([3, 3, 3, 3, 3]) ==> 9\n  solUtioEven([30, 13, 24, 321]) ==> 0\n  */\nconst solUtioOdd = (lst, index) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solUtioOdd([5, 8, 7, 1]) ==> 12\n  solUtioOdd([3, 3, 3, 3, 3]) ==> 9\n  solUtioOdd([30, 13, 24, 321]) ==> 0\n  */\nconst solUtioEvenOdd = (lst, index) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solUtioEvenOdd([5, 8, 7, 1]) ==> 12\n  solUtioEvenOdd([3, 3, 3, 3, 3]) ==> 9\n  solUtioEvenOdd([30, 13, 24, 321]) ==> 0\n  */\nconst solUtioEvenOddOdd = (lst, index) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solUtioEvenOddOdd([5, 8, 7, 1]) ==> 12\n  solUtioEvenOddOdd([3, 3, 3, 3, 3]) ==> 9\n  solUtioEvenOddOdd([30, 13, 24, 321]) ==> 0\n  */\nconst solUtioEvenOddOddOdd = (lst, index) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solUtioEvenOddOddOdd([5, 8, 7, 1]) ==> 12\n  solUtioEvenOddOddOdd([3, 3, 3, 3, 3]) ==> 9\n  solUtioEvenOddOddOdd([30, 13, 24, 321]) ==> 0\n  */\nconst solUtioEvenOddOddOddOdd = (lst, index) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solUtioEvenOddOddOddOdd([5, 8, 7, 1]) ==> 12\n  solUtioEvenOddOddOddOddOdd([3, 3, 3, 3, 3]) ==> 9\n  solUtioEvenOddOddOddOddOdd([30, 13, 24, 321]) ==> 0\n  */\nconst solUtioEvenOddOddOddOddOdd = (lst, index) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solUtioEvenOddOddOddOddOdd([5, 8, 7, 1]) ==> 12\n  solUtioEvenOddOddOddOddOddOdd([3, 3, 3, 3, 3]) ==> 9\n  solUtioEvenOddOddOddOddOddOdd([30, 13, 24, 321]) ==> 0\n  */\nconst solUtioEvenOddOddOddOddOddOdd = (lst, index) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solUtioEvenOddOddOddOddOddOdd([5, 8, 7, 1]) ==> 12\n  solUtioEvenOddOddOddOddOddOddOdd([3, 3, 3, 3, 3]) ==> 9\n  solUtioEvenOddOddOddOddOddOddOdd([30, 13, 24, 321]) ==> 0\n  */\nconst solUtioEvenOddOddOddOddOddOddOdd = (lst, index) => {\n  let sum = 0;\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      sum += item;\n    }\n  });\n  return sum;\n};\n\n/*Given a non-empty ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addelemEnts = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addelemEnts", "gc": "<|endoftext|>/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addelemEnts = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most three digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 120 # sum of 111 + 21\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addelemEnts = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most four digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 240 # sum of 111 + 21\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addelemEnts = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most five digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 2400 # sum of 111 + 21\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addelemEnts = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most six digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 240000 # sum of 111 + 21\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addelemEnts = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most seven digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 2400000 # sum of 111 + 21\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addelemEnts = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most eight digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24000000 # sum of 111 + 21\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addelemEnts = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most nine digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 2400000000 # sum of 111 + 21\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addelemEnts = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most ten digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24000000000 # sum of 111 + 21\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addelemEnts = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most eleven digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 240000000000 # sum of 111 + 21\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addelemEnts = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 9) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most twenty digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24000000000000 # sum of 111 + 21\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addelemEnts = (arr, k", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getoddCOllatZ(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getoddCOllatZ = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getoddCOllatZ", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getoddCOllatZ(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getoddCOllatZ = (n) => {\n  let num = 1;\n  let prev = 1;\n  let next = 1;\n  let result = [];\n  while (num < n) {\n    if (num % 2 === 0) {\n      result.push(prev);\n      prev = num;\n    } else {\n      result.push(next);\n      next = num * prev + 1;\n    }\n    num = num + 1;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getoddCOllatZ(5) returns [1, 5, 16, 8, 4, 2] # The collatz sequence for 5 is [1, 5, 16, 8, 4, 2, 1], \n  so the even numbers are only 1, 5, 16, and 8.\n  */\nconst getoddCOllatZEven = (n) => {\n  let num = 1;\n  let prev = 1;\n  let next = 1;\n  let result = [];\n  while (num < n) {\n    if (num % 2 === 0) {\n      result.push(prev);\n      prev = num;\n    } else {\n      result.push(next);\n      next = num * prev + 1;\n    }\n    num = num + 1;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getoddCOllatZ(5) returns [1, 5, 16, 8, 4, 2] # The collatz sequence for 5 is [1, 5, 16, 8, 4, 2, 1], \n  so the prime numbers are only 1, 5, 16, and 8.\n  */\nconst getoddCOllatZPrime = (n) => {\n  let num = 1;\n  let prev = 1;\n  let next = 1;\n  let result = [];\n  while (num < n) {\n    if (num % 2 === 0) {\n      result.push(prev);\n      prev = num;\n    } else {\n      result.push(next);\n      next = num * prev + 1;\n    }\n    num = num + 1;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the natural numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getoddCOllatZ(5) returns [1, 5, 16, 8, 4, 2] # The collatz sequence for 5 is [1, 5, 16, 8, 4, 2, 1], \n  so the natural numbers are only 1, 5, 16, and 8.\n  */\nconst getoddCOllatZNatural = (n) => {\n  let num = 1;\n  let prev = 1;\n  let next = 1;\n  let result = [];\n  while (num < n) {\n    if (num % 2 === 0) {\n      result.push(prev);\n      prev = num;\n    } else {\n      result.push(next);\n      next = num * prev + 1;\n    }\n    num = num + 1;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the triangular numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getoddCOllatZ(5) returns [1, 5, 16, 8, 4, 2] # The collatz sequence for 5 is [1, 5, 16, 8, 4, 2, 1], \n  so the triangular numbers are only 1, 5, 16, and 8.\n  */\nconst getoddCOllatZTriangular = (n) => {\n  let num = 1;\n  let prev = 1;\n  let next = 1;\n  let result = [];\n  while (num < n) {\n    if (num % 2 === 0) {\n      result.push(prev);\n      prev = num;\n    } else {\n      result.push(next);\n      next = num * prev + 1;\n    }\n    num = num + 1;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getoddCOllatZ(5) returns [1, 5, 16, 8, 4, 2] # The collatz sequence for 5 is [1, 5, 16, 8, 4, 2, 1], \n  so the prime factors are only 1, 5, 16, and 8.\n  */\nconst getoddCOllatZPrimeFactor = (n) => {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  valIdDaTe('03-11-2000') => true\n\n  valIdDaTe('15-01-2012') => false\n\n  valIdDaTe('04-0-2040') => false\n\n  valIdDaTe('06-04-2020') => true\n\n  valIdDaTe('06/04/2020') => false\n  */\nconst valIdDaTe = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "valIdDaTe", "gc": "<|endoftext|>/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  valIdDaTe('03-11-2000') => true\n\n  valIdDaTe('15-01-2012') => false\n\n  valIdDaTe('04-0-2040') => false\n\n  valIdDaTe('06-04-2020') => true\n\n  valIdDaTe('06/04/2020') => false\n  */\nconst valIdDaTe = (date) => {\n  const dateArr = date.split('-');\n  const dateObj = new Date(dateArr[0] + '-' + dateArr[1] + '-' + dateArr[2]);\n  const dateDays = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate()).getDate();\n  const dateMonths = new Date(dateObj.getFullYear(), dateObj.getMonth()).getDate();\n  const dateYears = new Date(dateObj.getFullYear()).getDate();\n  const dateDaysMinusOne = dateDays - 1;\n  const dateDaysMinus30 = dateDays - 30;\n  const dateDaysMinus29 = dateDays - 29;\n  const dateDaysMinus12 = dateDays - 12;\n  const dateDaysMinus4 = dateDays - 4;\n  const dateDaysMinus6 = dateDays - 6;\n  const dateDaysMinus9 = dateDays - 9;\n  const dateDaysMinus11 = dateDays - 11;\n  const dateDaysMinus21 = dateDays - 21;\n  const dateDaysMinus31 = dateDays - 31;\n  const dateDaysMinus4 = dateDays - 4;\n  const dateDaysMinus5 = dateDays - 5;\n  const dateDaysMinus7 = dateDays - 7;\n  const dateDaysMinus8 = dateDays - 8;\n  const dateDaysMinus10 = dateDays - 10;\n  const dateDaysMinus12 = dateDays - 12;\n  const dateDaysMinus13 = dateDays - 13;\n  const dateDaysMinus14 = dateDays - 14;\n  const dateDaysMinus15 = dateDays - 15;\n  const dateDaysMinus16 = dateDays - 16;\n  const dateDaysMinus17 = dateDays - 17;\n  const dateDaysMinus18 = dateDays - 18;\n  const dateDaysMinus19 = dateDays - 19;\n  const dateDaysMinus20 = dateDays - 20;\n  const dateDaysMinus21 = dateDays - 21;\n  const dateDaysMinus22 = dateDays - 22;\n  const dateDaysMinus23 = dateDays - 23;\n  const dateDaysMinus24 = dateDays - 24;\n  const dateDaysMinus25 = dateDays - 25;\n  const dateDaysMinus26 = dateDays - 26;\n  const dateDaysMinus27 = dateDays - 27;\n  const dateDaysMinus28 = dateDays - 28;\n  const dateDaysMinus29 = dateDays - 29;\n  const dateDaysMinus30 = dateDays - 30;\n  const dateDaysMinus31 = dateDays - 31;\n  const dateDaysMinus32 = dateDays - 32;\n  const dateDaysMinus33 = dateDays - 33;\n  const dateDaysMinus34 = dateDays - 34;\n  const dateDaysMinus35 = dateDays - 35;\n  const dateDaysMinus36 = dateDays - 36;\n  const dateDaysMinus37 = dateDays - 37;\n  const dateDaysMinus38 = dateDays - 38;\n  const dateDaysMinus39 = dateDays - 39;\n  const dateDaysMinus40 = dateDays - 40;\n  const dateDaysMinus41 = dateDays - 41;\n  const dateDaysMinus42 = dateDays - 42;\n  const dateDaysMinus43 = dateDays - 43;\n  const dateDaysMinus44 = dateDays - 44;\n  const dateDaysMinus45 = dateDays - 45;\n  const dateDaysMinus46 = dateDays - 46;\n  const dateDaysMinus47 = dateDays - 47;\n  const dateDaysMinus48 = dateDays - 48;\n  const dateDaysMinus49 = dateDays - 49;\n  const dateDaysMinus50 = dateDays - 50;\n  const dateDaysMinus51 = dateDays - 51;\n  const dateDaysMinus52 = dateDays - 52;\n  const dateDaysMinus53 = dateDays - 53;\n  const dateDaysMinus54 = dateDays - 54;\n  const dateDaysMinus55 = dateDays - 55;\n  const dateDaysMinus56 = dateDays - 56;\n  const dateDaysMinus57 = dateDays - 57;\n  const dateDaysMinus58 = dateDays - 58;\n  const dateDaysMinus59 = dateDays - 59;\n  const dateDaysMinus60 = dateDays - 60;\n  const dateDaysMinus61 = dateDays - 61;\n  const dateDaysMinus62 = dateDays - 62;\n  const dateDaysMinus63 = dateDays - 63;\n  const dateDaysMinus64 = dateDays - 64;\n  const dateDaysMinus65 = dateDays - 65;\n  const dateDaysMinus66 = dateDays - 66;\n  const dateDaysMinus67 = dateDays - 67;\n  const dateDaysMinus68 = dateDays - 68;\n  const dateDaysMinus69 = dateDays - 69;\n  const dateDaysMinus70 = dateDays - 70;\n  const dateDaysMinus71 = dateDays - 71;\n  const dateDaysMinus72 = dateDays - 72;\n  const dateDaysMinus73 = dateDays - 73;\n  const dateDaysMinus74 = dateDays - 74;\n  const dateDaysMinus75 = dateDays - 75;\n  const dateDaysMinus76 = dateDays - 76;\n  const dateDaysMinus77 = dateDays - 77;\n  const dateDaysMinus78 = dateDays - 78;\n  const dateDaysMinus79 = dateDays - 79;\n  const dateDaysMinus80 = dateDays - 80;\n  const dateDaysMinus81 = dateDays - 81;\n  const dateDaysMinus82 = dateDays - 82;\n  const dateDaysMinus83 = dateDays - 83;\n  const dateDaysMinus84 = dateDays - 84;\n  const dateDaysMinus85 = dateDays - 85;\n  const dateDaysMinus86 = dateDays - 86;\n  const dateDaysMinus87 = dateDays - 87;\n  const dateDays", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splItWoRds(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splItWoRds(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splItWoRds(\"abcdef\") == 3\n  */\nconst splItWoRds = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splItWoRds", "gc": "<|endoftext|>/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splItWoRds(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splItWoRds(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splItWoRds(\"abcdef\") == 3\n  */\nconst splItWoRds = (txt) => {\n  const words = txt.split(/\\s+/);\n  const numWords = words.length;\n  let numLowerCaseLetters = 0;\n  let numOddOrder = 0;\n  for (let i = 0; i < numWords; i++) {\n    const word = words[i];\n    const letter = word.toLowerCase();\n    if (letter === 'a' || letter === 'b' || letter === 'c' || letter === 'd' || letter === 'e' || letter === 'f' || letter === 'g' || letter === 'h' || letter === 'i' || letter === 'j' || letter === 'k' || letter === 'l' || letter ==='m' || letter === 'n' || letter === 'o' || letter === 'p' || letter === 'q' || letter === 'r' || letter ==='s' || letter === 't' || letter === 'u' || letter === 'v' || letter === 'w' || letter === 'x' || letter === 'y' || letter === 'z') {\n      numLowerCaseLetters++;\n    } else if (letter === 'A' || letter === 'B' || letter === 'C' || letter === 'D' || letter === 'E' || letter === 'F' || letter === 'G' || letter === 'H' || letter === 'I' || letter === 'J' || letter === 'K' || letter === 'L' || letter === 'M' || letter === 'N' || letter === 'O' || letter === 'P' || letter === 'Q' || letter === 'R' || letter === 'S' || letter === 'T' || letter === 'U' || letter === 'V' || letter === 'W' || letter === 'X' || letter === 'Y' || letter === 'Z') {\n      numOddOrder++;\n    }\n  }\n  return [numLowerCaseLetters, numOddOrder];\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of upper-case letters with odd order in the\n  alphabet, ord('a') = 65, ord('b') = 66,... ord('z') = 90\n  Examples\n  splItWoRds(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splItWoRds(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splItWoRds(\"abcdef\") == 3\n  */\nconst splItWoRds = (txt) => {\n  const words = txt.split(/\\s+/);\n  const numWords = words.length;\n  let numUpperCaseLetters = 0;\n  let numOddOrder = 0;\n  for (let i = 0; i < numWords; i++) {\n    const word = words[i];\n    const letter = word.toUpperCase();\n    if (letter === 'A' || letter === 'B' || letter === 'C' || letter === 'D' || letter === 'E' || letter === 'F' || letter === 'G' || letter === 'H' || letter === 'I' || letter === 'J' || letter === 'K' || letter === 'L' || letter === 'M' || letter === 'N' || letter === 'O' || letter === 'P' || letter === 'Q' || letter === 'R' || letter === 'S' || letter === 'T' || letter === 'U' || letter === 'V' || letter === 'W' || letter === 'X' || letter === 'Y' || letter === 'Z') {\n      numUpperCaseLetters++;\n    } else if (letter === 'a' || letter === 'b' || letter === 'c' || letter === 'd' || letter === 'e' || letter === 'f' || letter === 'g' || letter === 'h' || letter === 'i' || letter === 'j' || letter === 'k' || letter === 'l' || letter ==='m' || letter === 'n' || letter === 'o' || letter === 'p' || letter === 'q' || letter === 'r' || letter ==='s' || letter === 't' || letter === 'u' || letter === 'v' || letter === 'w' || letter === 'x' || letter === 'y' || letter === 'z') {\n      numOddOrder++;\n    }\n  }\n  return [numUpperCaseLetters, numOddOrder];\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with even order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splItWoRds(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splItWoRds(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splItWoRds(\"abcdef\") == 3\n  */\nconst splItWoRds = (txt) => {\n  const words = txt.split(/\\s+/);\n  const numWords = words.length;\n  let numLowerCaseLetters = 0;\n  let numOddOrder = 0;\n  for (let i = 0; i < numWords; i++) {\n    const word = words[i];\n    const letter = word.toLowerCase();\n    if (letter === 'A' || letter === 'B' || letter === 'C' || letter === 'D' || letter === 'E' || letter === 'F' || letter === 'G' || letter === 'H' || letter === 'I' || letter === 'J' || letter === 'K' || letter === 'L' || letter === 'M' || letter === 'N' || letter === 'O' || letter === 'P' || letter === 'Q' || letter === 'R' || letter === 'S' || letter === 'T' || letter === 'U' || letter === 'V' || letter === 'W' || letter === 'X' || letter === 'Y' || letter === 'Z') {\n      numLowerCaseLetters++;\n    } else if (letter === 'a' || letter === 'b' || letter === 'c' || letter === 'd' || letter === 'e' || letter === 'f' || letter === 'g' || letter === 'h' || letter === 'i' || letter === 'j' || letter === 'k' || letter === 'l' || letter ==='m' || letter === 'n' || letter === 'o' || letter === 'p' || letter === 'q' || letter === 'r' || letter ==='s' || letter === 't' || letter === 'u' || letter === 'v' || letter === 'w' || letter === 'x' || letter === 'y' || letter === 'z') {\n      numOddOrder++;\n    }\n  }\n  return [numLowerCaseLetters, numOddOrder];\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of upper-case letters with even order in the\n  alphabet, ord('a') = 65, ord('b') = 66,... ord('z') = 90\n  Examples\n  splItWoRds(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splItWoRds(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splItWoRds(\"abcdef\") == 3\n  */\nconst splItWoRds = (txt) => {\n  const words = txt.split(/\\s+/);\n  const numWords = words.length;\n  let numUpperCaseLetters = 0;\n  let numOddOrder = 0;\n  for (let i = 0; i < numWords; i++) {\n    const word = words[i];\n    const letter = word.toUpperCase();\n    if (letter === 'A' || letter === 'B' || letter === 'C' || letter === 'D' || letter === 'E' || letter === 'F' || letter === 'G' || letter === 'H' || letter === 'I' || letter === 'J' || letter === 'K' || letter === 'L' || letter === 'M' || letter === 'N' || letter === 'O' || letter === 'P' || ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSOrteD([5]) ➞ true\n  isSOrteD([1, 2, 3, 4, 5]) ➞ true\n  isSOrteD([1, 3, 2, 4, 5]) ➞ false\n  isSOrteD([1, 2, 3, 4, 5, 6]) ➞ true\n  isSOrteD([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSOrteD([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSOrteD([1, 2, 2, 3, 3, 4]) ➞ true\n  isSOrteD([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSOrteD = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSOrteD", "gc": "<|endoftext|>/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSOrteD([5]) ➞ true\n  isSOrteD([1, 2, 3, 4, 5]) ➞ true\n  isSOrteD([1, 3, 2, 4, 5]) ➞ false\n  isSOrteD([1, 2, 3, 4, 5, 6]) ➞ true\n  isSOrteD([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSOrteD([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSOrteD([1, 2, 2, 3, 3, 4]) ➞ true\n  isSOrteD([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSOrteD = (lst) => {\n  const seen = new Set()\n  return lst.every((num) => {\n    if (seen.has(num)) return false\n    seen.add(num)\n    return true\n  })\n}\n\n/* Given a list of numbers, return whether or not they are sorted\n  in descending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isDOrte([5]) ➞ true\n  isDOrte([1, 2, 3, 4, 5]) ➞ true\n  isDOrte([1, 3, 2, 4, 5]) ➞ false\n  isDOrte([1, 2, 3, 4, 5, 6]) ➞ true\n  isDOrte([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isDOrte([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isDOrte([1, 2, 2, 3, 3, 4]) ➞ true\n  isDOrte([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isDOrte = (lst) => {\n  const seen = new Set()\n  return lst.every((num) => {\n    if (seen.has(num)) return false\n    seen.add(num)\n    return true\n  })\n}\n\n/* Given a list of numbers, return whether or not they are sorted\n  in ascending order and in descending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isAscDesc([5]) ➞ true\n  isAscDesc([1, 2, 3, 4, 5]) ➞ true\n  isAscDesc([1, 3, 2, 4, 5]) ➞ false\n  isAscDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isAscDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isAscDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isAscDesc([1, 2, 2, 3, 3, 4]) ➞ true\n  isAscDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isAscDesc = (lst) => {\n  const seen = new Set()\n  return lst.every((num) => {\n    if (seen.has(num)) return false\n    seen.add(num)\n    return true\n  })\n}\n\n/* Given a list of numbers, return whether or not they are sorted\n  in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order and in descending order and in ascending order ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intErseCtion of these two \n  intervals is a prime number.\n  Example, the intErseCtion of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intErseCtion is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intErseCtion((1, 2), (2, 3)) ==> \"NO\"\n  intErseCtion((-1, 1), (0, 4)) ==> \"NO\"\n  intErseCtion((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intErseCtion = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intErseCtion", "gc": "<|endoftext|>/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intErseCtion of these two \n  intervals is a prime number.\n  Example, the intErseCtion of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intErseCtion is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intErseCtion((1, 2), (2, 3)) ==> \"NO\"\n  intErseCtion((-1, 1), (0, 4)) ==> \"NO\"\n  intErseCtion((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intErseCtion = (interval1, interval2) => {\n  const isPrime = (num) => {\n    if (num < 2) return false;\n    if (num === 2) return true;\n    if (num % 2 === 0) return false;\n    for (let i = 2; i <= Math.sqrt(num); i++) {\n      if (num % i === 0) {\n        return false;\n      }\n    }\n    return true;\n  };\n  const isIntersect = (num1, num2) => {\n    const num1Num = num1.reduce((acc, cur) => acc + cur, 0);\n    const num2Num = num2.reduce((acc, cur) => acc + cur, 0);\n    if (num1Num === num2Num) return true;\n    if (num1Num < num2Num) return isIntersect(num1, num1.slice(1));\n    if (num2Num < num1Num) return isIntersect(num2, num2.slice(1));\n    return false;\n  };\n  const isIntersect2 = (num1, num2) => {\n    const num1Num = num1.reduce((acc, cur) => acc + cur, 0);\n    const num2Num = num2.reduce((acc, cur) => acc + cur, 0);\n    if (num1Num === num2Num) return true;\n    if (num1Num < num2Num) return isIntersect2(num1, num1.slice(1));\n    if (num2Num < num1Num) return isIntersect2(num2, num2.slice(1));\n    return false;\n  };\n  const isIntersect3 = (num1, num2) => {\n    const num1Num = num1.reduce((acc, cur) => acc + cur, 0);\n    const num2Num = num2.reduce((acc, cur) => acc + cur, 0);\n    if (num1Num === num2Num) return true;\n    if (num1Num < num2Num) return isIntersect3(num1, num1.slice(1));\n    if (num2Num < num1Num) return isIntersect3(num2, num2.slice(1));\n    return false;\n  };\n  const isIntersect4 = (num1, num2) => {\n    const num1Num = num1.reduce((acc, cur) => acc + cur, 0);\n    const num2Num = num2.reduce((acc, cur) => acc + cur, 0);\n    if (num1Num === num2Num) return true;\n    if (num1Num < num2Num) return isIntersect4(num1, num1.slice(1));\n    if (num2Num < num1Num) return isIntersect4(num2, num2.slice(1));\n    return false;\n  };\n  const isIntersect5 = (num1, num2) => {\n    const num1Num = num1.reduce((acc, cur) => acc + cur, 0);\n    const num2Num = num2.reduce((acc, cur) => acc + cur, 0);\n    if (num1Num === num2Num) return true;\n    if (num1Num < num2Num) return isIntersect5(num1, num1.slice(1));\n    if (num2Num < num1Num) return isIntersect5(num2, num2.slice(1));\n    return false;\n  };\n  const isIntersect6 = (num1, num2) => {\n    const num1Num = num1.reduce((acc, cur) => acc + cur, 0);\n    const num2Num = num2.reduce((acc, cur) => acc + cur, 0);\n    if (num1Num === num2Num) return true;\n    if (num1Num < num2Num) return isIntersect6(num1, num1.slice(1));\n    if (num2Num < num1Num) return isIntersect6(num2, num2.slice(1));\n    return false;\n  };\n  const isIntersect7 = (num1, num2) => {\n    const num1Num = num1.reduce((acc, cur) => acc + cur, 0);\n    const num2Num = num2.reduce((acc, cur) => acc + cur, 0);\n    if (num1Num === num2Num) return true;\n    if (num1Num < num2Num) return isIntersect7(num1, num1.slice(1));\n    if (num2Num < num1Num) return isIntersect7(num2, num2.slice(1));\n    return false;\n  };\n  const isIntersect8 = (num1, num2) => {\n    const num1Num = num1.reduce((acc, cur) => acc + cur, 0);\n    const num2Num = num2.reduce((acc, cur) => acc + cur, 0);\n    if (num1Num === num2Num) return true;\n    if (num1Num < num2Num) return isIntersect8(num1, num1.slice(1));\n    if (num2Num < num1Num) return isIntersect8(num2, num2.slice(1));\n    return false;\n  };\n  const isIntersect9 = (num1, num2) => {\n    const num1Num = num1.reduce((acc, cur) => acc + cur, 0);\n    const num2Num = num2.reduce((acc, cur) => acc + cur, 0);\n    if (num1Num === num2Num) return true;\n    if (num1Num < num2Num) return isIntersect9(num1, num1.slice(1));\n    if (num2Num < num1Num) return isIntersect9(num2, num2.slice(1));\n    return false;\n  };\n  const isIntersect10 = (num1, num2) => {\n    const num1Num = num1.reduce((acc, cur) => acc + cur, 0);\n    const num2Num = num2.reduce((acc, cur) => acc + cur, 0);\n    if (num1Num === num2Num) return true;\n    if (num1Num < num2Num) return isIntersect10(num1, num1.slice(1));\n    if (num2Num < num1Num) return isIntersect10(num2, num2.slice(1));\n    return false;\n  };\n  const isIntersect11 = (num1, num2) => {\n    const num1Num = num1.reduce((acc, cur) => acc + cur, 0);\n    const num2Num = num2.reduce((acc, cur) => acc + cur, 0);\n    if (num1Num === num2Num) return true;\n    if (num1Num < num2Num) return isIntersect11(num1, num1.slice(1));\n    if (num2Num < num1Num) return isIntersect11(num2, num2.slice(1));\n    return false;\n  };\n  const isIntersect12 = (num1, num2) => {\n    const num1Num = num1.reduce((acc, cur) => acc + cur, 0);\n    const num2Num = num2.reduce((acc, cur) => acc + cur, 0);\n    if (num1Num === num2Num) return true;\n    if (num1Num < num2Num) return isIntersect12(num1, num1.slice(1));\n    if (num2Num < num1Num) return isIntersect12(num2, num2.slice(1));\n    return false;\n  };\n  const isIntersect13 = (num1, num2) => {\n    const num1Num = num1.reduce", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> proDSigNs([1, 2, 2, -4]) == -9\n  >>> proDSigNs([0, 1]) == 0\n  >>> proDSigNs([]) == null\n  */\nconst proDSigNs = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "proDSigNs", "gc": "<|endoftext|>/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> proDSigNs([1, 2, 2, -4]) == -9\n  >>> proDSigNs([0, 1]) == 0\n  >>> proDSigNs([]) == null\n  */\nconst proDSigNs = (arr) => {\n  const signs = [-1, 0, 1];\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += signs[arr[i]];\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> proDSigNs([1, 2, 2, -4]) == -9\n  >>> proDSigNs([0, 1]) == 0\n  >>> proDSigNs([]) == null\n  */\nconst proDSigNs2 = (arr) => {\n  const signs = [-1, 0, 1];\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += signs[arr[i]] * Math.pow(arr[i], 2);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> proDSigNs([1, 2, 2, -4]) == -9\n  >>> proDSigNs([0, 1]) == 0\n  >>> proDSigNs([]) == null\n  */\nconst proDSigNs3 = (arr) => {\n  const signs = [-1, 0, 1];\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += signs[arr[i]] * Math.pow(arr[i], 3);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> proDSigNs([1, 2, 2, -4]) == -9\n  >>> proDSigNs([0, 1]) == 0\n  >>> proDSigNs([]) == null\n  */\nconst proDSigNs4 = (arr) => {\n  const signs = [-1, 0, 1];\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += signs[arr[i]] * Math.pow(arr[i], 4);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> proDSigNs([1, 2, 2, -4]) == -9\n  >>> proDSigNs([0, 1]) == 0\n  >>> proDSigNs([]) == null\n  */\nconst proDSigNs5 = (arr) => {\n  const signs = [-1, 0, 1];\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += signs[arr[i]] * Math.pow(arr[i], 5);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> proDSigNs([1, 2, 2, -4]) == -9\n  >>> proDSigNs([0, 1]) == 0\n  >>> proDSigNs([]) == null\n  */\nconst proDSigNs6 = (arr) => {\n  const signs = [-1, 0, 1];\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += signs[arr[i]] * Math.pow(arr[i], 6);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> proDSigNs([1, 2, 2, -4]) == -9\n  >>> proDSigNs([0, 1]) == 0\n  >>> proDSigNs([]) == null\n  */\nconst proDSigNs7 = (arr) => {\n  const signs = [-1, 0, 1];\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += signs[arr[i]] * Math.pow(arr[i], 7);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> proDSigNs([1, 2, 2, -4]) == -9\n  >>> proDSigNs([0, 1]) == 0\n  >>> proDSigNs([]) == null\n  */\nconst proDSigNs8 = (arr) => {\n  const signs = [-1, 0, 1];\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += signs[arr[i]] * Math.pow(arr[i], 8);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> proDSigNs([1, 2, 2, -4]) == -9\n  >>> proDSigNs([0, 1]) == 0\n  >>> proDSigNs([]) == null\n  */\nconst proDSigNs9 = (arr) => {\n  const signs = [-1, 0, 1];\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += signs[arr[i]] * Math.pow(arr[i], 9);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> proDSigNs([1, 2, 2, -4]) == -9\n  >>> proDSigNs([0, 1]) == 0\n  >>> proDSigNs([]) == null\n  */\nconst proDSigNs10 = (arr) => {\n  const signs = [-1, 0, 1];\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += signs[arr[i]] * Math.pow(arr[i], 10);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> proDSigNs([1, 2, 2, -4]) == -9\n  >>> proDSigNs([0, 1]) == 0\n  >>> proDSigNs([]) == null\n  */\nconst proDSigNs11 = (arr) => {\n  const signs = [-1, 0, 1];\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += signs[arr[i]] * Math.pow(arr[i], 11);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minpath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minpath", "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minpath = (grid, k) => {\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  const lst_C = new Array(grid.length).fill(0);\n  const lst_D = new Array(grid.length).fill(0);\n  const lst_E = new Array(grid.length).fill(0);\n  const lst_F = new Array(grid.length).fill(0);\n  const lst_G = new Array(grid.length).fill(0);\n  const lst_H = new Array(grid.length).fill(0);\n  const lst_I = new Array(grid.length).fill(0);\n  const lst_J = new Array(grid.length).fill(0);\n  const lst_K = new Array(grid.length).fill(0);\n  const lst_L = new Array(grid.length).fill(0);\n  const lst_M = new Array(grid.length).fill(0);\n  const lst_N = new Array(grid.length).fill(0);\n  const lst_O = new Array(grid.length).fill(0);\n  const lst_P = new Array(grid.length).fill(0);\n  const lst_Q = new Array(grid.length).fill(0);\n  const lst_R = new Array(grid.length).fill(0);\n  const lst_S = new Array(grid.length).fill(0);\n  const lst_T = new Array(grid.length).fill(0);\n  const lst_U = new Array(grid.length).fill(0);\n  const lst_V = new Array(grid.length).fill(0);\n  const lst_W = new Array(grid.length).fill(0);\n  const lst_X = new Array(grid.length).fill(0);\n  const lst_Y = new Array(grid.length).fill(0);\n  const lst_Z = new Array(grid.length).fill(0);\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        lst_A[j] += 1;\n      } else if (grid[i][j] === 0) {\n        lst_B[j] += 1;\n      } else if (grid[i][j] === -1) {\n        lst_C[j] += 1;\n      } else if (grid[i][j] === -2) {\n        lst_D[j] += 1;\n      } else if (grid[i][j] === -3) {\n        lst_E[j] += 1;\n      } else if (grid[i][j] === -4) {\n        lst_F[j] += 1;\n      } else if (grid[i][j] === -5) {\n        lst_G[j] += 1;\n      } else if (grid[i][j] === -6) {\n        lst_H[j] += 1;\n      } else if (grid[i][j] === -7) {\n        lst_I[j] += 1;\n      } else if (grid[i][j] === -8) {\n        lst_J[j] += 1;\n      } else if (grid[i][j] === -9) {\n        lst_K[j] += 1;\n      } else if (grid[i][j] === -10) {\n        lst_L[j] += 1;\n      } else if (grid[i][j] === -11) {\n        lst_M[j] += 1;\n      } else if (grid[i][j] === -12) {\n        lst_N[j] += 1;\n      } else if (grid[i][j] === -13) {\n        lst_O[j] += 1;\n      } else if (grid[i][j] === -14) {\n        lst_P[j] += 1;\n      } else if (grid[i][j] === -15) {\n        lst_Q[j] += 1;\n      } else if (grid[i][j] === -16) {\n        lst_R[j] += 1;\n      } else if (grid[i][j] === -17) {\n        lst_S[j] += 1;\n      } else if (grid[i][j] === -18) {\n        lst_T[j] += 1;\n      } else if (grid[i][j] === -19) {\n        lst_U[j] += 1;\n      } else if (grid[i][j] === -20) {\n        lst_V[j] += 1;\n      } else if (grid[i][j] === -21) {\n        lst_W[j] += 1;\n      } else if (grid[i][j] === -22) {\n        lst_X[j] += 1;\n      } else if (grid[i][j] === -23) {\n        lst_Y[j] += 1;\n      } else if (grid[i][j] === -24) {\n        lst_Z[j] += 1;\n      }\n    }\n  }\n\n  const lst_A1 = lst_A.sort((a, b) => a - b);\n  const lst_B1 = lst_B.sort((a, b) => a - b);\n  const lst_C1 = lst_C.sort((a, b) => a - b);\n  const lst_D1 = lst_D.sort((a, b) => a - b);\n  const lst_E1 = lst_E.sort((a, b) => a - b);\n  const lst_F1 = lst_F.sort((a, b) => a - b);\n  const lst_G1 = lst_G.sort((a, b) => a - b);\n  const lst_H1 = lst_H.sort((a, b) => a - b);\n  const lst_I1 = lst_I.sort((a, b) => a - b);\n  const lst_J1 = lst_J.sort((a, b) => a - b);\n  const lst_K1 = lst_K.sort((a, b) => a - b);\n  const lst_L1 = lst_L.sort((a, b) => a - b);\n  const lst_M1 = lst_M.sort((a, b) => a - b);\n  const lst_N1 = lst_N.sort((a, b) => a - b);\n  const lst_O1 = lst_O.sort((a, b) => a - b);\n  const lst_P1 = lst_P.sort((a, b) => a - b);\n  const lst_Q1 = lst_Q.sort((a, b) => a - b);\n  const lst_R1 = lst_R.sort((a, b) => a - b);\n  const lst_S1 = lst_S.sort((a, b) => a - b);\n  const lst_T1 = lst_T.sort((a, b) => a - b);\n  const lst_U1 = lst_U.sort((a, b) => a - b);\n  const lst_V1 = lst_V.sort((a, b) => a - b);\n  const lst_W1 = lst_W.sort((a, b) => a - b);\n  const lst_X1 = lst_X.sort((a, b) => a - b);\n  const lst_Y1 = lst_Y.sort((a, b) => a - b);\n  const lst_Z1 = lst_Z.sort((a, b) => a - b);\n\n  let lst_A2 = lst_A1.filter((x, i, arr) => arr.indexOf(x) === i);\n  let lst_B2 = lst_B1.filter((x, i, arr) => arr.indexOf(x) === i);\n  let lst_C2 = lst_C1.filter((x, i, arr) => arr.indexOf(x) === i);\n  let lst_D2 = lst_D1.filter((x, i, arr) => arr.indexOf(x) === i);\n  let lst_E2 = lst_E1.filter((x, i, arr) => arr.indexOf(x) === i);\n  let lst_F2 = lst_F1.filter((x, i, ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR(3, 5)\n  1\n  >>> greAtesTCommOnDIvisoR(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greAtesTCommOnDIvisoR", "gc": "<|endoftext|>/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR(3, 5)\n  1\n  >>> greAtesTCommOnDIvisoR(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR = (a, b) => {\n  const aDivisor = a % b;\n  const bDivisor = b % a;\n  return aDivisor > bDivisor? aDivisor : bDivisor;\n};\n\n/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR2 = (a, b) => {\n  const aDivisor = a % b;\n  const bDivisor = b % a;\n  return aDivisor > bDivisor? bDivisor : aDivisor;\n};\n\n/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR2(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR3 = (a, b) => {\n  const aDivisor = a % b;\n  const bDivisor = b % a;\n  return aDivisor > bDivisor? bDivisor : aDivisor;\n};\n\n/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR3(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR4 = (a, b) => {\n  const aDivisor = a % b;\n  const bDivisor = b % a;\n  return aDivisor > bDivisor? bDivisor : aDivisor;\n};\n\n/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR4(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR5 = (a, b) => {\n  const aDivisor = a % b;\n  const bDivisor = b % a;\n  return aDivisor > bDivisor? bDivisor : aDivisor;\n};\n\n/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR5(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR6 = (a, b) => {\n  const aDivisor = a % b;\n  const bDivisor = b % a;\n  return aDivisor > bDivisor? bDivisor : aDivisor;\n};\n\n/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR6(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR7 = (a, b) => {\n  const aDivisor = a % b;\n  const bDivisor = b % a;\n  return aDivisor > bDivisor? bDivisor : aDivisor;\n};\n\n/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR7(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR8 = (a, b) => {\n  const aDivisor = a % b;\n  const bDivisor = b % a;\n  return aDivisor > bDivisor? bDivisor : aDivisor;\n};\n\n/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR8(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR9 = (a, b) => {\n  const aDivisor = a % b;\n  const bDivisor = b % a;\n  return aDivisor > bDivisor? bDivisor : aDivisor;\n};\n\n/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR9(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR10 = (a, b) => {\n  const aDivisor = a % b;\n  const bDivisor = b % a;\n  return aDivisor > bDivisor? bDivisor : aDivisor;\n};\n\n/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR10(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR11 = (a, b) => {\n  const aDivisor = a % b;\n  const bDivisor = b % a;\n  return aDivisor > bDivisor? bDivisor : aDivisor;\n};\n\n/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR11(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR12 = (a, b) => {\n  const aDivisor = a % b;\n  const bDivisor = b % a;\n  return aDivisor > bDivisor? bDivisor : aDivisor;\n};\n\n/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR12(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR13 = (a, b) => {\n  const aDivisor = a % b;\n  const bDivisor = b % a;\n  return aDivisor > bDivisor? bDivisor : aDivisor;\n};\n\n/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR13(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR14 = (a, b) => {\n  const aDivisor = a % b;\n  const bDivisor = b % a;\n  return aDivisor > bDivisor? bDivisor : aDivisor;\n};\n\n/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR14(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR15 = (a, b) => {\n  const aDivisor = a % b;\n  const bDivisor = b % a;\n  return aDivisor > bDivisor? bDivisor : aDivisor;\n};\n\n/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR15(25, 15)\n  5\n  */\nconst greAtesTCommOnDIvisoR16 = (a, b) => {\n  const aDivisor = a % b;\n  const bDivisor = b % a;\n  return aDivisor > bDivisor? bDivisor : aDivisor;\n};\n\n/* Return a greatest common divisor of two integers a and b\n  >>> greAtesTCommOnDIvisoR16(25, 15)\n  5\n  */\nconst greA", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "gc": "<|endoftext|>/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  if (n <= 1) return [n, n, n, 1];\n  return [\n    tri(n - 1) + tri(n - 2) + tri(n + 1),\n    tri(n - 1) + tri(n - 2) + tri(n),\n    tri(n - 1) + tri(n),\n    tri(n - 1),\n  ];\n};\n\n/*\n  Given a non-negative integer number n, you have to\n  return a list of the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fib = (n) => {\n  if (n <= 1) return [n, n, n, 1];\n  return [\n    fib(n - 1) + fib(n - 2) + fib(n - 3),\n    fib(n - 1) + fib(n - 2) + fib(n - 4),\n    fib(n - 1) + fib(n - 2),\n    fib(n - 1),\n  ];\n};\n\n/*\n  Given a non-negative integer number n, you have to\n  return a list of the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return [n, n, n, 1];\n  return [\n    fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 3),\n    fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 4),\n    fibonacci(n - 1) + fibonacci(n - 2),\n    fibonacci(n - 1),\n  ];\n};\n\n/*\n  Given a non-negative integer number n, you have to\n  return a list of the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return [n, n, n, 1];\n  return [\n    fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 3),\n    fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 4),\n    fibonacci(n - 1) + fibonacci(n - 2),\n    fibonacci(n - 1),\n  ];\n};\n\n/*\n  Given a non-negative integer number n, you have to\n  return a list of the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return [n, n, n, 1];\n  return [\n    fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 3),\n    fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 4),\n    fibonacci(n - 1) + fibonacci(n - 2),\n    fibonacci(n - 1),\n  ];\n};\n\n/*\n  Given a non-negative integer number n, you have to\n  return a list of the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return [n, n, n, 1];\n  return [\n    fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 3),\n    fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 4),\n    fibonacci(n - 1) + fibonacci(n - 2),\n    fibonacci(n - 1),\n  ];\n};\n\n/*\n  Given a non-negative integer number n, you have to\n  return a list of the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return [n, n, n, 1];\n  return [\n    fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 3),\n    fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 4),\n    fibonacci(n - 1) + fibonacci(n - 2),\n    fibonacci(n - 1),\n  ];\n};\n\n/*\n  Given a non-negative integer number n, you have to\n  return a list of the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return [n, n, n, 1];\n  return [\n    fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 3),\n    fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 4),\n    fibonacci(n - 1) + fibonacci(n - 2),\n    fibonacci(n - 1),\n  ];\n};\n\n/*\n  Given a non-negative integer number n, you have to\n  return a list of the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return [n, n, n, 1];\n  return [\n    fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 3),\n    fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 4),\n    fibonacci(n - 1) + fibonacci(n - 2),\n    fibonacci(n - 1),\n  ];\n};\n\n/*\n  Given a non-negative integer number n, you have to\n  return a list of the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return [n, n, n, 1];\n  return [\n    fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 3),\n    fibonacci(n - 1) + fibonacci(n - 2) + fibonacci(n - 4),\n    fibonacci(n - 1) + fibonacci(n - 2),\n    fibonacci(n - 1),\n  ];\n};\n\n/*\n  Given a non-negative integer number n, you have to\n  return a list of the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd digIts.\n  Return 0 if all digIts are even.\n  For example:\n  digIts(1)  == 1\n  digIts(4)  == 0\n  digIts(235) == 15\n  */\nconst digIts = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digIts", "gc": "<|endoftext|>/*Given a positive integer n, return the product of the odd digIts.\n  Return 0 if all digIts are even.\n  For example:\n  digIts(1)  == 1\n  digIts(4)  == 0\n  digIts(235) == 15\n  */\nconst digIts = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the even digIts.\n  Return 0 if all digIts are odd.\n  For example:\n  digIts(1)  == 1\n  digIts(4)  == 0\n  digIts(235) == 15\n  */\nconst evenDigIts = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the odd powers.\n  Return 0 if all powers are odd.\n  For example:\n  powers(1)  == 1\n  powers(4)  == 0\n  powers(235) == 15\n  */\nconst oddPowers = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the even powers.\n  Return 0 if all powers are even.\n  For example:\n  powers(1)  == 1\n  powers(4)  == 0\n  powers(235) == 15\n  */\nconst evenPowers = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the odd powers.\n  Return 0 if all powers are odd.\n  For example:\n  powers(1)  == 1\n  powers(4)  == 0\n  powers(235) == 15\n  */\nconst oddPowers2 = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the even powers.\n  Return 0 if all powers are even.\n  For example:\n  powers(1)  == 1\n  powers(4)  == 0\n  powers(235) == 15\n  */\nconst evenPowers2 = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the odd powers.\n  Return 0 if all powers are odd.\n  For example:\n  powers(1)  == 1\n  powers(4)  == 0\n  powers(235) == 15\n  */\nconst oddPowers3 = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the even powers.\n  Return 0 if all powers are even.\n  For example:\n  powers(1)  == 1\n  powers(4)  == 0\n  powers(235) == 15\n  */\nconst evenPowers3 = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the odd powers.\n  Return 0 if all powers are odd.\n  For example:\n  powers(1)  == 1\n  powers(4)  == 0\n  powers(235) == 15\n  */\nconst oddPowers4 = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the even powers.\n  Return 0 if all powers are even.\n  For example:\n  powers(1)  == 1\n  powers(4)  == 0\n  powers(235) == 15\n  */\nconst evenPowers4 = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the odd powers.\n  Return 0 if all powers are odd.\n  For example:\n  powers(1)  == 1\n  powers(4)  == 0\n  powers(235) == 15\n  */\nconst oddPowers5 = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the even powers.\n  Return 0 if all powers are even.\n  For example:\n  powers(1)  == 1\n  powers(4)  == 0\n  powers(235) == 15\n  */\nconst evenPowers5 = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the odd powers.\n  Return 0 if all powers are odd.\n  For example:\n  powers(1)  == 1\n  powers(4)  == 0\n  powers(235) == 15\n  */\nconst oddPowers6 = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the even powers.\n  Return 0 if all powers are even.\n  For example:\n  powers(1)  == 1\n  powers(4)  == 0\n  powers(235) == 15\n  */\nconst evenPowers6 = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the odd powers.\n  Return 0 if all powers are odd.\n  For example:\n  powers(1)  == 1\n  powers(4)  == 0\n  powers(235) == 15\n  */\nconst oddPowers7 = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the even powers.\n  Return 0 if all powers are even.\n  For example:\n  powers(1)  == 1\n  powers(4)  == 0\n  powers(235) == 15\n  */\nconst evenPowers7 = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 1) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the odd powers.\n  Return 0 if all powers are odd.\n  For example:\n  powers(1)  == 1\n  powers(4)  == 0\n  powers(235) == 15\n  */\nconst oddPowers8 = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the even powers.\n  Return 0 if all powers are even.\n  For example:\n  powers(1)  == 1\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNEsteD('[[]]') ➞ true\n  isNEsteD('[]]]]]]][[[[[]') ➞ false\n  isNEsteD('[][]') ➞ false\n  isNEsteD('[]') ➞ false\n  isNEsteD('[[][]]') ➞ true\n  isNEsteD('[[]][[') ➞ true\n  */\nconst isNEsteD = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNEsteD", "gc": "<|endoftext|>/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNEsteD('[[]]') ➞ true\n  isNEsteD('[]]]]]]][[[[[]') ➞ false\n  isNEsteD('[][]') ➞ false\n  isNEsteD('[]') ➞ false\n  isNEsteD('[[][]]') ➞ true\n  isNEsteD('[[]][[') ➞ true\n  */\nconst isNEsteD = (string) => {\n  const nestingDepth = 0;\n  const nestingStack = [];\n  let nestingLevel = 0;\n  let nestingIsValid = true;\n  let nestingIsNested = false;\n  let nestingIsOpen = false;\n  let nestingIsClosed = false;\n  let nestingIsOpenParenthesis = false;\n  let nestingIsCloseParenthesis = false;\n  let nestingIsOpenBracket = false;\n  let nestingIsCloseBracket = false;\n  let nestingIsOpenSquareBracket = false;\n  let nestingIsCloseSquareBracket = false;\n  let nestingIsOpenParenthesisParenthesis = false;\n  let nestingIsCloseParenthesisParenthesis = false;\n  let nestingIsOpenBracketParenthesis = false;\n  let nestingIsCloseBracketParenthesis = false;\n  let nestingIsOpenSquareBracketParenthesis = false;\n  let nestingIsCloseSquareBracketParenthesis = false;\n  let nestingIsOpenParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenBracketParenthesisParenthesis = false;\n  let nestingIsCloseBracketParenthesisParenthesis = false;\n  let nestingIsOpenSquareBracketParenthesisParenthesis = false;\n  let nestingIsCloseSquareBracketParenthesisParenthesis = false;\n  let nestingIsOpenParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenBracketParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseBracketParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenSquareBracketParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseSquareBracketParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenSquareBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseSquareBracketParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenBracketParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenSquareBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseSquareBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenBracketParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseBracketParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenSquareBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseSquareBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenBracketParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseBracketParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenSquareBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseSquareBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenBracketParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenSquareBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseSquareBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenSquareBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseSquareBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenSquareBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseSquareBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseParenthesisParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsOpenBracketParenthesisParenthesisParenthesisParenthesis = false;\n  let nestingIsCloseBracketParenthesisParenthesisParenthesi", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumsquaRes = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumsquaRes", "gc": "<|endoftext|>/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumsquaRes = (lst) => {\n  let sum = 0;\n  let sumsq = 0;\n  let sumsq2 = 0;\n  let sumsq3 = 0;\n  let sumsq4 = 0;\n  let sumsq5 = 0;\n  let sumsq6 = 0;\n  let sumsq7 = 0;\n  let sumsq8 = 0;\n  let sumsq9 = 0;\n  let sumsq10 = 0;\n  let sumsq11 = 0;\n  let sumsq12 = 0;\n  let sumsq13 = 0;\n  let sumsq14 = 0;\n  let sumsq15 = 0;\n  let sumsq16 = 0;\n  let sumsq17 = 0;\n  let sumsq18 = 0;\n  let sumsq19 = 0;\n  let sumsq20 = 0;\n  let sumsq21 = 0;\n  let sumsq22 = 0;\n  let sumsq23 = 0;\n  let sumsq24 = 0;\n  let sumsq25 = 0;\n  let sumsq26 = 0;\n  let sumsq27 = 0;\n  let sumsq28 = 0;\n  let sumsq29 = 0;\n  let sumsq30 = 0;\n  let sumsq31 = 0;\n  let sumsq32 = 0;\n  let sumsq33 = 0;\n  let sumsq34 = 0;\n  let sumsq35 = 0;\n  let sumsq36 = 0;\n  let sumsq37 = 0;\n  let sumsq38 = 0;\n  let sumsq39 = 0;\n  let sumsq40 = 0;\n  let sumsq41 = 0;\n  let sumsq42 = 0;\n  let sumsq43 = 0;\n  let sumsq44 = 0;\n  let sumsq45 = 0;\n  let sumsq46 = 0;\n  let sumsq47 = 0;\n  let sumsq48 = 0;\n  let sumsq49 = 0;\n  let sumsq50 = 0;\n  let sumsq51 = 0;\n  let sumsq52 = 0;\n  let sumsq53 = 0;\n  let sumsq54 = 0;\n  let sumsq55 = 0;\n  let sumsq56 = 0;\n  let sumsq57 = 0;\n  let sumsq58 = 0;\n  let sumsq59 = 0;\n  let sumsq60 = 0;\n  let sumsq61 = 0;\n  let sumsq62 = 0;\n  let sumsq63 = 0;\n  let sumsq64 = 0;\n  let sumsq65 = 0;\n  let sumsq66 = 0;\n  let sumsq67 = 0;\n  let sumsq68 = 0;\n  let sumsq69 = 0;\n  let sumsq70 = 0;\n  let sumsq71 = 0;\n  let sumsq72 = 0;\n  let sumsq73 = 0;\n  let sumsq74 = 0;\n  let sumsq75 = 0;\n  let sumsq76 = 0;\n  let sumsq77 = 0;\n  let sumsq78 = 0;\n  let sumsq79 = 0;\n  let sumsq80 = 0;\n  let sumsq81 = 0;\n  let sumsq82 = 0;\n  let sumsq83 = 0;\n  let sumsq84 = 0;\n  let sumsq85 = 0;\n  let sumsq86 = 0;\n  let sumsq87 = 0;\n  let sumsq88 = 0;\n  let sumsq89 = 0;\n  let sumsq90 = 0;\n  let sumsq91 = 0;\n  let sumsq92 = 0;\n  let sumsq93 = 0;\n  let sumsq94 = 0;\n  let sumsq95 = 0;\n  let sumsq96 = 0;\n  let sumsq97 = 0;\n  let sumsq98 = 0;\n  let sumsq99 = 0;\n  let sumsq100 = 0;\n  let sumsq101 = 0;\n  let sumsq102 = 0;\n  let sumsq103 = 0;\n  let sumsq104 = 0;\n  let sumsq105 = 0;\n  let sumsq106 = 0;\n  let sumsq107 = 0;\n  let sumsq108 = 0;\n  let sumsq109 = 0;\n  let sumsq110 = 0;\n  let sumsq111 = 0;\n  let sumsq112 = 0;\n  let sumsq113 = 0;\n  let sumsq114 = 0;\n  let sumsq115 = 0;\n  let sumsq116 = 0;\n  let sumsq117 = 0;\n  let sumsq118 = 0;\n  let sumsq119 = 0;\n  let sumsq120 = 0;\n  let sumsq121 = 0;\n  let sumsq122 = 0;\n  let sumsq123 = 0;\n  let sumsq124 = 0;\n  let sumsq125 = 0;\n  let sumsq126 = 0;\n  let sumsq127 = 0;\n  let sumsq128 = 0;\n  let sumsq129 = 0;\n  let sumsq130 = 0;\n  let sumsq131 = 0;\n  let sumsq132 = 0;\n  let sumsq133 = 0;\n  let sumsq134 = 0;\n  let sumsq135 = 0;\n  let sumsq136 = 0;\n  let sumsq137 = 0;\n  let sumsq138 = 0;\n  let sumsq139 = 0;\n  let sumsq140 = 0;\n  let sumsq141 = 0;\n  let sumsq142 = 0;\n  let sumsq143 = 0;\n  let sumsq144 = 0;\n  let sumsq145 = 0;\n  let sumsq146 = 0;\n  let sumsq147 = 0;\n  let sumsq148 = 0;\n  let sumsq149 = 0;\n  let sumsq150 = 0;\n  let sumsq151 = 0;\n  let sumsq152 = 0;\n  let sumsq153 = 0;\n  let sumsq154 = 0;\n  let sumsq155 = 0;\n  let sumsq156 = 0;\n  let sumsq157 = 0;\n  let sumsq158 = 0;\n  let sumsq159 = 0;\n  let sumsq160 = 0;\n  let sumsq161 = 0;\n  let sumsq162 = 0;\n  let sumsq163 = 0;\n  let sumsq164 = 0;\n  let sumsq165 = 0;\n  let sumsq166 = 0;\n  let sumsq167 = 0;\n  let sumsq168 = 0;\n  let sumsq169 = 0;\n  let sumsq170 = 0;\n  let sumsq171 = 0;\n  let sumsq172 = 0;\n  let sumsq173 = 0;\n  let sumsq174 = 0;\n  let sumsq175 = 0;\n  let sumsq176 = 0;\n  let sumsq177 = 0;\n  let sumsq178 = 0;\n  let sumsq179 = 0;\n  let sumsq180 = 0;\n  let sumsq181 = 0;\n  let sumsq182 = 0;\n  let sumsq183 = 0;\n  let sumsq184 = 0;\n  let sumsq185 = 0;\n  let sumsq186 = 0;\n  let sumsq187 = 0;\n  let sumsq188 = 0;\n  let sumsq189 = 0;\n  let sumsq190 = 0;\n  let sumsq191 = 0;\n  let sumsq192 = 0;\n  let sumsq193 = 0;\n  let sumsq194 = 0;\n  let sumsq195 = 0;\n  let sumsq196 = 0;\n  let sumsq197 = 0;\n  let sumsq198 = 0;\n  let sumsq199 = 0;\n  let sumsq200 = 0;\n  let sumsq201 = 0;\n  let sumsq202 = 0;\n  let sumsq203 = 0;\n  let sumsq204 = 0;\n  let sumsq205 = 0;\n  let sumsq206 = 0;\n  let sumsq207 = 0;\n  let sumsq208 = 0;\n  let sumsq209 = 0;\n  let sumsq210 = 0;\n  let sumsq211 = 0;\n  let sumsq212 = 0;\n  let sumsq213 = 0;\n  let sumsq214 = 0;\n  let sumsq215 = 0;\n  let sumsq216 = 0;\n  let sumsq217 = 0;\n  let sumsq218 = 0;\n  let sumsq219 = 0;\n  let sumsq220 = 0;\n  let sumsq221 = 0;\n  let sumsq222 = 0;\n  let sumsq223 = 0;\n  let sumsq224 = 0;\n  let sumsq225 = 0;\n  let sumsq226 = 0;\n  let sumsq227 = 0;\n  let sumsq228 = 0;\n  let sumsq229 = 0;\n  let sumsq230 = 0;\n  let sumsq231 = 0;\n  let sumsq232 = 0;\n  let sumsq233 = 0;\n  let sumsq234 = 0;\n  let sumsq235 = 0;\n  let sumsq236 = 0;\n  let sumsq237 = 0;\n  let sumsq238 = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  cheCkIflastCHarisALeTter(\"apple pie\") ➞ false\n  cheCkIflastCHarisALeTter(\"apple pi e\") ➞ true\n  cheCkIflastCHarisALeTter(\"apple pi e \") ➞ false\n  cheCkIflastCHarisALeTter(\"\") ➞ false\n  */\nconst cheCkIflastCHarisALeTter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "cheCkIflastCHarisALeTter", "gc": "<|endoftext|>/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  cheCkIflastCHarisALeTter(\"apple pie\") ➞ false\n  cheCkIflastCHarisALeTter(\"apple pi e\") ➞ true\n  cheCkIflastCHarisALeTter(\"apple pi e \") ➞ false\n  cheCkIflastCHarisALeTter(\"\") ➞ false\n  */\nconst cheCkIflastCHarisALeTter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isLastCharAWord = lastChar ==='' || lastChar === '-' || lastChar === '_';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  cheCkIflastCHarisALeTter(\"apple pie\") ➞ false\n  cheCkIflastCHarisALeTter(\"apple pi e\") ➞ true\n  cheCkIflastCHarisALeTter(\"apple pi e \") ➞ false\n  cheCkIflastCHarisALeTter(\"\") ➞ false\n  */\nconst cheCkIflastCHarisALeTter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isLastCharAWord = lastChar ==='' || lastChar === '-' || lastChar === '_';\n  return isLastCharAWord && lastChar!== '.';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  cheCkIflastCHarisALeTter(\"apple pie\") ➞ false\n  cheCkIflastCHarisALeTter(\"apple pi e\") ➞ true\n  cheCkIflastCHarisALeTter(\"apple pi e \") ➞ false\n  cheCkIflastCHarisALeTter(\"\") ➞ false\n  */\nconst cheCkIflastCHarisALeTter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isLastCharAWord = lastChar ==='' || lastChar === '-' || lastChar === '_';\n  return isLastCharAWord && lastChar!== '.' && lastChar!== '-' && lastChar!== '_';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  cheCkIflastCHarisALeTter(\"apple pie\") ➞ false\n  cheCkIflastCHarisALeTter(\"apple pi e\") ➞ true\n  cheCkIflastCHarisALeTter(\"apple pi e \") ➞ false\n  cheCkIflastCHarisALeTter(\"\") ➞ false\n  */\nconst cheCkIflastCHarisALeTter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isLastCharAWord = lastChar ==='' || lastChar === '-' || lastChar === '_';\n  return isLastCharAWord && lastChar!== '.' && lastChar!== '-' && lastChar!== '_' && lastChar!== '.';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  cheCkIflastCHarisALeTter(\"apple pie\") ➞ false\n  cheCkIflastCHarisALeTter(\"apple pi e\") ➞ true\n  cheCkIflastCHarisALeTter(\"apple pi e \") ➞ false\n  cheCkIflastCHarisALeTter(\"\") ➞ false\n  */\nconst cheCkIflastCHarisALeTter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isLastCharAWord = lastChar ==='' || lastChar === '-' || lastChar === '_';\n  return isLastCharAWord && lastChar!== '.' && lastChar!== '-' && lastChar!== '_' && lastChar!== '.' && lastChar!== '-' && lastChar!== '_';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  cheCkIflastCHarisALeTter(\"apple pie\") ➞ false\n  cheCkIflastCHarisALeTter(\"apple pi e\") ➞ true\n  cheCkIflastCHarisALeTter(\"apple pi e \") ➞ false\n  cheCkIflastCHarisALeTter(\"\") ➞ false\n  */\nconst cheCkIflastCHarisALeTter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isLastCharAWord = lastChar ==='' || lastChar === '-' || lastChar === '_';\n  return isLastCharAWord && lastChar!== '.' && lastChar!== '-' && lastChar!== '_' && lastChar!== '.' && lastChar!== '-' && lastChar!== '_' && lastChar!== '.';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  cheCkIflastCHarisALeTter(\"apple pie\") ➞ false\n  cheCkIflastCHarisALeTter(\"apple pi e\") ➞ true\n  cheCkIflastCHarisALeTter(\"apple pi e \") ➞ false\n  cheCkIflastCHarisALeTter(\"\") ➞ false\n  */\nconst cheCkIflastCHarisALeTter = (txt) => {\n  const lastChar = txt.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canarraNge([1,2,4,3,5]) = 3\n  canarraNge([1,2,3]) = -1\n  */\nconst canarraNge = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canarraNge", "gc": "<|endoftext|>/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canarraNge([1,2,4,3,5]) = 3\n  canarraNge([1,2,3]) = -1\n  */\nconst canarraNge = (arr) => {\n  let max = 0;\n  let index = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > arr[max]) {\n      max = i;\n      index = i;\n    }\n  }\n  return index;\n};\n\n/*\n  Given an array of numbers, return a new array which contains all the\n  numbers which are divisible by all numbers in the original array. For\n  example, [1,2,3] and [1,2,3] are both divisible by 3, so return [1,2,3].\n\n  Examples:\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = []\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,2]\n  divisible([1,2,3]) = [1,", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  larGestsmallEstintegErs([2, 4, 1, 3, 5, 7]) == (null, 1)\n  larGestsmallEstintegErs([]) == (null, null)\n  larGestsmallEstintegErs([0]) == (null, null)\n  */\nconst larGestsmallEstintegErs = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "larGestsmallEstintegErs", "gc": "<|endoftext|>/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  larGestsmallEstintegErs([2, 4, 1, 3, 5, 7]) == (null, 1)\n  larGestsmallEstintegErs([]) == (null, null)\n  larGestsmallEstintegErs([0]) == (null, null)\n  */\nconst larGestsmallEstintegErs = (lst) => {\n  let largest = Infinity;\n  let smallest = -Infinity;\n  let largestPositive = null;\n  let smallestPositive = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      largest = Math.max(largest, lst[i]);\n      smallest = Math.min(smallest, lst[i]);\n      if (lst[i] > 0) {\n        if (lst[i] > largestPositive) {\n          largestPositive = lst[i];\n        }\n      }\n      if (lst[i] < smallestPositive) {\n        smallestPositive = lst[i];\n      }\n    }\n  }\n  return [largestPositive, smallestPositive];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  larGestsmallEstintegErs([2, 4, 1, 3, 5, 7]) == (null, 1)\n  larGestsmallEstintegErs([]) == (null, null)\n  larGestsmallEstintegErs([0]) == (null, null)\n  */\nconst larGestbigEstintegErs = (lst) => {\n  let largest = Infinity;\n  let smallest = -Infinity;\n  let largestPositive = null;\n  let smallestPositive = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      largest = Math.max(largest, lst[i]);\n      smallest = Math.min(smallest, lst[i]);\n      if (lst[i] > 0) {\n        if (lst[i] > largestPositive) {\n          largestPositive = lst[i];\n        }\n      }\n      if (lst[i] < smallestPositive) {\n        smallestPositive = lst[i];\n      }\n    }\n  }\n  return [largestPositive, smallestPositive];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  larGestbigEstintegErs([2, 4, 1, 3, 5, 7]) == (null, 1)\n  larGestbigEstintegErs([]) == (null, null)\n  larGestbigEstintegErs([0]) == (null, null)\n  */\nconst larGestbigEstintegErsBig = (lst) => {\n  let largest = Infinity;\n  let smallest = -Infinity;\n  let largestPositive = null;\n  let smallestPositive = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      largest = Math.max(largest, lst[i]);\n      smallest = Math.min(smallest, lst[i]);\n      if (lst[i] > 0) {\n        if (lst[i] > largestPositive) {\n          largestPositive = lst[i];\n        }\n      }\n      if (lst[i] < smallestPositive) {\n        smallestPositive = lst[i];\n      }\n    }\n  }\n  return [largestPositive, smallestPositive];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  larGestbigEstintegErs([2, 4, 1, 3, 5, 7]) == (null, 1)\n  larGestbigEstintegErs([]) == (null, null)\n  larGestbigEstintegErs([0]) == (null, null)\n  */\nconst larGestbigEstintegErsBigBig = (lst) => {\n  let largest = Infinity;\n  let smallest = -Infinity;\n  let largestPositive = null;\n  let smallestPositive = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      largest = Math.max(largest, lst[i]);\n      smallest = Math.min(smallest, lst[i]);\n      if (lst[i] > 0) {\n        if (lst[i] > largestPositive) {\n          largestPositive = lst[i];\n        }\n      }\n      if (lst[i] < smallestPositive) {\n        smallestPositive = lst[i];\n      }\n    }\n  }\n  return [largestPositive, smallestPositive];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  larGestbigEstintegErs([2, 4, 1, 3, 5, 7]) == (null, 1)\n  larGestbigEstintegErs([]) == (null, null)\n  larGestbigEstintegErs([0]) == (null, null)\n  */\nconst larGestbigEstintegErsBigBigBig = (lst) => {\n  let largest = Infinity;\n  let smallest = -Infinity;\n  let largestPositive = null;\n  let smallestPositive = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      largest = Math.max(largest, lst[i]);\n      smallest = Math.min(smallest, lst[i]);\n      if (lst[i] > 0) {\n        if (lst[i] > largestPositive) {\n          largestPositive = lst[i];\n        }\n      }\n      if (lst[i] < smallestPositive) {\n        smallestPositive = lst[i];\n      }\n    }\n  }\n  return [largestPositive, smallestPositive];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  larGestbigEstintegErs([2, 4, 1, 3, 5, 7]) == (null, 1)\n  larGestbigEstintegErs([]) == (null, null)\n  larGestbigEstintegErs([0]) == (null, null)\n  */\nconst larGestbigEstintegErsBigBigBigBigBig = (lst) => {\n  let largest = Infinity;\n  let smallest = -Infinity;\n  let largestPositive = null;\n  let smallestPositive = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      largest = Math.max(largest, lst[i]);\n      smallest = Math.min(smallest, lst[i]);\n      if (lst[i] > 0) {\n        if (lst[i] > largestPositive) {\n          largestPositive = lst[i];\n        }\n      }\n      if (lst[i] < smallestPositive) {\n        smallestPositive = lst[i];\n      }\n    }\n  }\n  return [largestPositive, smallestPositive];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  larGestbigEstintegErs([2, 4, 1, 3, 5, 7]) == (null, 1)\n  larGestbigEstintegErs([]) == (null, null)\n  larGestbigEstintegErs([0]) == (null, null)\n  */\nconst larGestbigEstintegErsBigBigBigBigBigBig = (lst) => {\n  let largest = Infinity;\n  let smallest = -Infinity;\n  let lar", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be . or ,\n\n  comPareone(1, 2.5) ➞ 2.5\n  comPareone(1, \"2,3\") ➞ \"2,3\"\n  comPareone(\"5,1\", \"6\") ➞ \"6\"\n  comPareone(\"1\", 1) ➞ null\n  */\nconst comPareone = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "comPareone", "gc": "<|endoftext|>/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  comPareone(1, 2.5) ➞ 2.5\n  comPareone(1, \"2,3\") ➞ \"2,3\"\n  comPareone(\"5,1\", \"6\") ➞ \"6\"\n  comPareone(\"1\", 1) ➞ null\n  */\nconst comPareone = (a, b) => {\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType!== bType) {\n    return null;\n  }\n  if (aType === \"string\") {\n    const aString = a.split(\",\");\n    const bString = b.split(\",\");\n    if (aString.length!== bString.length) {\n      return null;\n    }\n    for (let i = 0; i < aString.length; i++) {\n      if (aString[i]!== bString[i]) {\n        return null;\n      }\n    }\n    return aString;\n  }\n  if (aType === \"number\") {\n    if (a === b) {\n      return null;\n    }\n    if (a > b) {\n      return null;\n    }\n    if (a < b) {\n      return null;\n    }\n    return a;\n  }\n  return null;\n};\n\n/**\n * Create a function that takes integers, floats, or strings representing\n * real numbers, and returns the smaller variable in its given variable type.\n * Return null if the values are equal.\n * Note: If a real number is represented as a string, the floating point might be. or,\n\n  comPareone(-1, 2.5) ➞ -2.5\n  comPareone(-1, \"2,3\") ➞ \"2,3\"\n  comPareone(\"5,1\", \"6\") ➞ \"6\"\n  comPareone(\"1\", 1) ➞ null\n  */\nconst comPareone = (a, b) => {\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType!== bType) {\n    return null;\n  }\n  if (aType === \"string\") {\n    const aString = a.split(\",\");\n    const bString = b.split(\",\");\n    if (aString.length!== bString.length) {\n      return null;\n    }\n    for (let i = 0; i < aString.length; i++) {\n      if (aString[i]!== bString[i]) {\n        return null;\n      }\n    }\n    return aString;\n  }\n  if (aType === \"number\") {\n    if (a === b) {\n      return null;\n    }\n    if (a < b) {\n      return null;\n    }\n    if (a > b) {\n      return null;\n    }\n    return a;\n  }\n  return null;\n};\n\n/**\n * Create a function that takes integers, floats, or strings representing\n * real numbers, and returns the larger variable in its given variable type.\n * Return null if the values are equal.\n * Note: If a real number is represented as a string, the floating point might be. or,\n\n  comPareone(0, 2.5) ➞ 0\n  comPareone(0, \"2,3\") ➞ \"2,3\"\n  comPareone(\"5,1\", \"6\") ➞ \"6\"\n  comPareone(\"1\", 1) ➞ null\n  */\nconst comPareoneZero = (a, b) => {\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType!== bType) {\n    return null;\n  }\n  if (aType === \"string\") {\n    const aString = a.split(\",\");\n    const bString = b.split(\",\");\n    if (aString.length!== bString.length) {\n      return null;\n    }\n    for (let i = 0; i < aString.length; i++) {\n      if (aString[i]!== bString[i]) {\n        return null;\n      }\n    }\n    return aString;\n  }\n  if (aType === \"number\") {\n    if (a === b) {\n      return null;\n    }\n    if (a < b) {\n      return null;\n    }\n    if (a > b) {\n      return null;\n    }\n    return a;\n  }\n  return null;\n};\n\n/**\n * Create a function that takes integers, floats, or strings representing\n * real numbers, and returns the smaller variable in its given variable type.\n * Return null if the values are equal.\n * Note: If a real number is represented as a string, the floating point might be. or,\n\n  comPareoneOne(-1, 2.5) ➞ -2.5\n  comPareoneOne(-1, \"2,3\") ➞ \"2,3\"\n  comPareone(\"5,1\", \"6\") ➞ \"6\"\n  comPareone(\"1\", 1) ➞ null\n  */\nconst comPareoneOne = (a, b) => {\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType!== bType) {\n    return null;\n  }\n  if (aType === \"string\") {\n    const aString = a.split(\",\");\n    const bString = b.split(\",\");\n    if (aString.length!== bString.length) {\n      return null;\n    }\n    for (let i = 0; i < aString.length; i++) {\n      if (aString[i]!== bString[i]) {\n        return null;\n      }\n    }\n    return aString;\n  }\n  if (aType === \"number\") {\n    if (a === b) {\n      return null;\n    }\n    if (a < b) {\n      return null;\n    }\n    if (a > b) {\n      return null;\n    }\n    return a;\n  }\n  return null;\n};\n\n/**\n * Create a function that takes integers, floats, or strings representing\n * real numbers, and returns the larger variable in its given variable type.\n * Return null if the values are equal.\n * Note: If a real number is represented as a string, the floating point might be. or,\n\n  comPareoneTwo(-1, 2.5) ➞ -2.5\n  comPareoneTwo(-1, \"2,3\") ➞ \"2,3\"\n  comPareone(\"5,1\", \"6\") ➞ \"6\"\n  comPareone(\"1\", 1) ➞ null\n  */\nconst comPareoneTwo = (a, b) => {\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType!== bType) {\n    return null;\n  }\n  if (aType === \"string\") {\n    const aString = a.split(\",\");\n    const bString = b.split(\",\");\n    if (aString.length!== bString.length) {\n      return null;\n    }\n    for (let i = 0; i < aString.length; i++) {\n      if (aString[i]!== bString[i]) {\n        return null;\n      }\n    }\n    return aString;\n  }\n  if (aType === \"number\") {\n    if (a === b) {\n      return null;\n    }\n    if (a > b) {\n      return null;\n    }\n    if (a < b) {\n      return null;\n    }\n    return a;\n  }\n  return null;\n};\n\n/**\n * Create a function that takes integers, floats, or strings representing\n * real numbers, and returns the smaller variable in its given variable type.\n * Return null if the values are equal.\n * Note: If a real number is represented as a string, the floating point might be. or,\n\n  comPareoneThree(-1, 2.5) ➞ -2.5\n  comPareoneThree(-1, \"2,3\") ➞ \"2,3\"\n  comPareone(\"5,1\", \"6\") ➞ \"6\"\n  comPareone(\"1\", 1) ➞ null\n  */\nconst comPareoneThree = (a, b) => {\n  const aType = typeof a;\n  const bType = typeof b;\n  if (aType!== bType) {\n    return null;\n  }\n  if (aType === \"string\") {\n    const aString = a.split(\",\");\n    const bString = b.split(\",\");\n    if (aString.length!== bString.length) {\n      return null;\n    }\n    for (let i = 0; i < aString.length; i++) {\n      if (aString[i]!== bString[i]) {\n        return null;\n      }\n    }\n    return aString;\n  }\n  if (aType === \"number\") {\n    if (a === b) {\n      return null;\n    }\n    if (a > b) {\n      return null;\n    }\n    if (a < b) {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEQualtoSumeveN(4) == false\n  isEQualtoSumeveN(6) == false\n  isEQualtoSumeveN(8) == true\n  */\nconst isEQualtoSumeveN = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEQualtoSumeveN", "gc": "<|endoftext|>/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEQualtoSumeveN(4) == false\n  isEQualtoSumeveN(6) == false\n  isEQualtoSumeveN(8) == true\n  */\nconst isEQualtoSumeveN = (n) => {\n  let isEQualtoSumeve = true;\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sum2 = 0;\n  let sum3 = 0;\n  let sum4 = 0;\n  let sum5 = 0;\n  let sum6 = 0;\n  let sum7 = 0;\n  let sum8 = 0;\n  let sum9 = 0;\n  let sum10 = 0;\n  let sum11 = 0;\n  let sum12 = 0;\n  let sum13 = 0;\n  let sum14 = 0;\n  let sum15 = 0;\n  let sum16 = 0;\n  let sum17 = 0;\n  let sum18 = 0;\n  let sum19 = 0;\n  let sum20 = 0;\n  let sum21 = 0;\n  let sum22 = 0;\n  let sum23 = 0;\n  let sum24 = 0;\n  let sum25 = 0;\n  let sum26 = 0;\n  let sum27 = 0;\n  let sum28 = 0;\n  let sum29 = 0;\n  let sum30 = 0;\n  let sum31 = 0;\n  let sum32 = 0;\n  let sum33 = 0;\n  let sum34 = 0;\n  let sum35 = 0;\n  let sum36 = 0;\n  let sum37 = 0;\n  let sum38 = 0;\n  let sum39 = 0;\n  let sum40 = 0;\n  let sum41 = 0;\n  let sum42 = 0;\n  let sum43 = 0;\n  let sum44 = 0;\n  let sum45 = 0;\n  let sum46 = 0;\n  let sum47 = 0;\n  let sum48 = 0;\n  let sum49 = 0;\n  let sum50 = 0;\n  let sum51 = 0;\n  let sum52 = 0;\n  let sum53 = 0;\n  let sum54 = 0;\n  let sum55 = 0;\n  let sum56 = 0;\n  let sum57 = 0;\n  let sum58 = 0;\n  let sum59 = 0;\n  let sum60 = 0;\n  let sum61 = 0;\n  let sum62 = 0;\n  let sum63 = 0;\n  let sum64 = 0;\n  let sum65 = 0;\n  let sum66 = 0;\n  let sum67 = 0;\n  let sum68 = 0;\n  let sum69 = 0;\n  let sum70 = 0;\n  let sum71 = 0;\n  let sum72 = 0;\n  let sum73 = 0;\n  let sum74 = 0;\n  let sum75 = 0;\n  let sum76 = 0;\n  let sum77 = 0;\n  let sum78 = 0;\n  let sum79 = 0;\n  let sum80 = 0;\n  let sum81 = 0;\n  let sum82 = 0;\n  let sum83 = 0;\n  let sum84 = 0;\n  let sum85 = 0;\n  let sum86 = 0;\n  let sum87 = 0;\n  let sum88 = 0;\n  let sum89 = 0;\n  let sum90 = 0;\n  let sum91 = 0;\n  let sum92 = 0;\n  let sum93 = 0;\n  let sum94 = 0;\n  let sum95 = 0;\n  let sum96 = 0;\n  let sum97 = 0;\n  let sum98 = 0;\n  let sum99 = 0;\n  let sum100 = 0;\n  let sum101 = 0;\n  let sum102 = 0;\n  let sum103 = 0;\n  let sum104 = 0;\n  let sum105 = 0;\n  let sum106 = 0;\n  let sum107 = 0;\n  let sum108 = 0;\n  let sum109 = 0;\n  let sum110 = 0;\n  let sum111 = 0;\n  let sum112 = 0;\n  let sum113 = 0;\n  let sum114 = 0;\n  let sum115 = 0;\n  let sum116 = 0;\n  let sum117 = 0;\n  let sum118 = 0;\n  let sum119 = 0;\n  let sum120 = 0;\n  let sum121 = 0;\n  let sum122 = 0;\n  let sum123 = 0;\n  let sum124 = 0;\n  let sum125 = 0;\n  let sum126 = 0;\n  let sum127 = 0;\n  let sum128 = 0;\n  let sum129 = 0;\n  let sum130 = 0;\n  let sum131 = 0;\n  let sum132 = 0;\n  let sum133 = 0;\n  let sum134 = 0;\n  let sum135 = 0;\n  let sum136 = 0;\n  let sum137 = 0;\n  let sum138 = 0;\n  let sum139 = 0;\n  let sum140 = 0;\n  let sum141 = 0;\n  let sum142 = 0;\n  let sum143 = 0;\n  let sum144 = 0;\n  let sum145 = 0;\n  let sum146 = 0;\n  let sum147 = 0;\n  let sum148 = 0;\n  let sum149 = 0;\n  let sum150 = 0;\n  let sum151 = 0;\n  let sum152 = 0;\n  let sum153 = 0;\n  let sum154 = 0;\n  let sum155 = 0;\n  let sum156 = 0;\n  let sum157 = 0;\n  let sum158 = 0;\n  let sum159 = 0;\n  let sum160 = 0;\n  let sum161 = 0;\n  let sum162 = 0;\n  let sum163 = 0;\n  let sum164 = 0;\n  let sum165 = 0;\n  let sum166 = 0;\n  let sum167 = 0;\n  let sum168 = 0;\n  let sum169 = 0;\n  let sum170 = 0;\n  let sum171 = 0;\n  let sum172 = 0;\n  let sum173 = 0;\n  let sum174 = 0;\n  let sum175 = 0;\n  let sum176 = 0;\n  let sum177 = 0;\n  let sum178 = 0;\n  let sum179 = 0;\n  let sum180 = 0;\n  let sum181 = 0;\n  let sum182 = 0;\n  let sum183 = 0;\n  let sum184 = 0;\n  let sum185 = 0;\n  let sum186 = 0;\n  let sum187 = 0;\n  let sum188 = 0;\n  let sum189 = 0;\n  let sum190 = 0;\n  let sum191 = 0;\n  let sum192 = 0;\n  let sum193 = 0;\n  let sum194 = 0;\n  let sum195 = 0;\n  let sum196 = 0;\n  let sum197 = 0;\n  let sum198 = 0;\n  let sum199 = 0;\n  let sum200 = 0;\n  let sum201 = 0;\n  let sum202 = 0;\n  let sum203 = 0;\n  let sum204 = 0;\n  let sum205 = 0;\n  let sum206 = 0;\n  let sum207 = 0;\n  let sum208 = 0;\n  let sum209 = 0;\n  let sum210 = 0;\n  let sum211 = 0;\n  let sum212 = 0;\n  let sum213 = 0;\n  let sum214 = 0;\n  let sum215 = 0;\n  let sum216 = 0;\n  let sum217 = 0;\n  let sum218 = 0;\n  let sum219 = 0;\n  let sum220 = 0;\n  let sum221 = 0;\n  let sum222 = 0;\n  let sum223 = 0;\n  let sum224 = 0;\n  let sum225 = 0;\n  let sum226 = 0;\n  let sum227 = 0;\n  let sum228 = 0;\n  let sum229 = 0;\n  let sum230 = 0;\n  let sum231 = 0;\n  let sum232 = 0;\n  let sum233 = 0;\n  let sum234 = 0;\n  let sum235 = 0;\n  let sum236 = 0;\n  let sum237 = 0;\n  let sum238 = 0;\n  let sum239 = 0;\n  let sum240 = 0;\n  let sum241 = 0;\n  let sum242 = 0;\n  let sum243 = 0;\n  let sum244 = 0;\n  let sum245 = 0;\n  let sum246 = 0;\n  let sum247 = 0;\n  let sum248 = 0;\n  let sum249 = 0;\n  let sum250 = 0;\n  let sum251 = 0;\n  let sum252 = 0;\n  let sum253 = 0;\n  let sum254 = 0;\n  let sum255 = 0;\n  let sum256 = 0;\n  let sum257 = 0;\n  let sum258 = 0;\n  let sum259 = 0;\n  let sum260 = 0;\n  let sum261 = 0;\n  let sum262 = 0;\n  let sum263 = 0;\n  let sum264 = 0;\n  let sum265 = 0;\n  let sum266 = 0;\n  let sum267 = 0;\n  let sum268 = 0;\n  let sum269 = 0;\n  let sum270 = 0;\n  let sum271 = 0;\n  let sum272 = 0;\n  let sum273 = 0;\n  let sum274 = 0;\n  let sum275 = 0;\n  let sum276 = 0;\n  let sum277 = 0;\n  let sum278 = 0;\n  let sum279 = 0;\n  let sum280 = 0;\n  let sum281 = 0;\n  let sum282 = 0;\n  let sum283 = 0;\n  let sum284 = 0;\n  let sum285 = 0;\n  let sum286 = 0;\n  let sum287 = 0;\n  let sum288", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> speCialfactoRiaL(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst speCialfactoRiaL = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "speCialfactoRiaL", "gc": "<|endoftext|>/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> speCialfactoRiaL(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst speCialfactoRiaL = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * speCialfactoRiaL(n - 1) + n * speCialfactoRiaL(n - 2) * speCialfactoRiaL(n - 3) * speCialfactoRiaL(n - 4) * speCialfactoRiaL(n - 5);\n};\n\n/*\n  Given a positive integer n, return the factorial of n modulo n.\n  For example, given n = 4, the factorial of 4 is 4.\n  Given n = 5, the factorial of 5 is 120.\n  Given n = 6, the factorial of 6 is 720.\n  Given n = 7, the factorial of 7 is 5040.\n  Given n = 8, the factorial of 8 is 3628.\n  Given n = 9, the factorial of 9 is 3628.\n  Given n = 10, the factorial of 10 is 3628.\n  Given n = 11, the factorial of 11 is 3628.\n  Given n = 12, the factorial of 12 is 3628.\n  Given n = 13, the factorial of 13 is 3628.\n  Given n = 14, the factorial of 14 is 3628.\n  Given n = 15, the factorial of 15 is 3628.\n  Given n = 16, the factorial of 16 is 3628.\n  Given n = 17, the factorial of 17 is 3628.\n  Given n = 18, the factorial of 18 is 3628.\n  Given n = 19, the factorial of 19 is 3628.\n  Given n = 20, the factorial of 20 is 3628.\n  Given n = 21, the factorial of 21 is 3628.\n  Given n = 22, the factorial of 22 is 3628.\n  Given n = 23, the factorial of 23 is 3628.\n  Given n = 24, the factorial of 24 is 3628.\n  Given n = 25, the factorial of 25 is 3628.\n  Given n = 26, the factorial of 26 is 3628.\n  Given n = 27, the factorial of 27 is 3628.\n  Given n = 28, the factorial of 28 is 3628.\n  Given n = 29, the factorial of 29 is 3628.\n  Given n = 30, the factorial of 30 is 3628.\n  Given n = 31, the factorial of 31 (mod n) is 3628.\n  Given n = 32, the factorial of 32 (mod n) is 3628.\n  Given n = 33, the factorial of 33 (mod n) is 3628.\n  Given n = 34, the factorial of 34 (mod n) is 3628.\n  Given n = 35, the factorial of 35 (mod n) is 3628.\n  Given n = 36, the factorial of 36 (mod n) is 3628.\n  Given n = 37, the factorial of 37 (mod n) is 3628.\n  Given n = 38, the factorial of 38 (mod n) is 3628.\n  Given n = 39, the factorial of 39 (mod n) is 3628.\n  Given n = 39, the factorial of 39 (mod n) is 3628.\n  Given n = 40, the factorial of 40 (mod n) is 3628.\n  Given n = 41, the factorial of 41 (mod n) is 3628.\n  Given n = 42, the factorial of 42 (mod n) is 3628.\n  Given n = 43, the factorial of 43 (mod n) is 3628.\n  Given n = 44, the factorial of 44 (mod n) is 3628.\n  Given n = 45, the factorial of 45 (mod n) is 3628.\n  Given n = 46, the factorial of 46 (mod n) is 3628.\n  Given n = 47, the factorial of 47 (mod n) is 3628.\n  Given n = 48, the factorial of 48 (mod n) is 3628.\n  Given n = 49, the factorial of 49 (mod n) is 3628.\n  Given n = 50, the factorial of 50 (mod n) is 3628.\n  Given n = 51, the factorial of 51 (mod n) is 3628.\n  Given n = 52, the factorial of 52 (mod n) is 3628.\n  Given n = 53, the factorial of 53 (mod n) is 3628.\n  Given n = 54, the factorial of 54 (mod n) is 3628.\n  Given n = 55, the factorial of 55 (mod n) is 3628.\n  Given n = 56, the factorial of 56 (mod n) is 3628.\n  Given n = 57, the factorial of 57 (mod n) is 3628.\n  Given n = 58, the factorial of 58 (mod n) is 3628.\n  Given n = 59, the factorial of 59 (mod n) is 3628.\n  Given n = 60, the factorial of 60 (mod n) is 3628.\n  Given n = 61, the factorial of 61 (mod n) is 3628.\n  Given n = 62, the factorial of 62 (mod n) is 3628.\n  Given n = 63, the factorial of 63 (mod n) is 3628.\n  Given n = 64, the factorial of 64 (mod n) is 3628.\n  Given n = 65, the factorial of 65 (mod n) is 3628.\n  Given n = 66, the factorial of 66 (mod n) is 3628.\n  Given n = 67, the factorial of 67 (mod n) is 3628.\n  Given n = 68, the factorial of 68 (mod n) is 3628.\n  Given n = 69, the factorial of 69 (mod n) is 3628.\n  Given n = 70, the factorial of 70 (mod n) is 3628.\n  Given n = 71, the factorial of 71 (mod n) is 3628.\n  Given n = 72, the factorial of 72 (mod n) is 3628.\n  Given n = 73, the factorial of 73 (mod n) is 3628.\n  Given n = 74, the factorial of 74 (mod n) is 3628.\n  Given n = 75, the factorial of 75 (mod n) is 3628.\n  Given n = 76, the factorial of 76 (mod n) is 3628.\n  Given n = 77, the factorial of 77 (mod n) is 3628.\n  Given n = 78, the factorial of 78 (mod n) is 3628.\n  Given n = 79, the factorial of 79 (mod n) is 3628.\n  Given n = 80, the factorial of 80 (mod n) is 3628.\n  Given n = 81, the factorial of 81 (mod n) is 3628.\n  Given n = 82, the factorial of 82 (mod n) is 3628.\n  Given n = 83, the factorial of 83 (mod n) is 3628.\n  Given n = 84, the factorial of 84 (mod n) is 3628.\n  Given n = 85, the factorial of 85 (mod n) is 3628.\n  Given n = 86, the factorial of 86 (mod n) is 3628.\n  Given n = 87, the factorial of 87 (mod n) is 3628.\n  Given n = 88, the factorial of 88 (mod n) is 3628.\n  Given n = 89, the factorial of 89 (mod n) is 3628.\n  Given n = 90, the factorial of 90 (mod n) is 3628.\n  Given n = 91, the factorial ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allprefIxes", "gc": "<|endoftext|>/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes2 = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes3 = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes4 = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes5 = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes6 = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes7 = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes8 = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes9 = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes10 = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes11 = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes12 = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes13 = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes14 = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes15 = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes16 = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes17 = (string) => {\n  let ixes = []\n  let ix = 0\n  let len = string.length\n  while (len > ix) {\n    ixes[ix++] = string.charCodeAt(len)\n    len--\n  }\n  return ixes\n}\n\n/* Return list of all prefixes from shortest to longest of the input string\n  >>> allprefIxes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allprefIxes", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixspacEs(\"Example\") == \"Example\"\n  fixspacEs(\"Example 1\") == \"Example_1\"\n  fixspacEs(\" Example 2\") == \"_Example_2\"\n  fixspacEs(\" Example   3\") == \"_Example-3\"\n  */\nconst fixspacEs = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixspacEs", "gc": "<|endoftext|>/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixspacEs(\"Example\") == \"Example\"\n  fixspacEs(\"Example 1\") == \"Example_1\"\n  fixspacEs(\" Example 2\") == \"_Example_2\"\n  fixspacEs(\" Example   3\") == \"_Example-3\"\n  */\nconst fixspacEs = (text) => {\n  let newtext = text;\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'');\n  newtext = newtext.replace(/\\s+/g,'", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filENamEChecK(\"example.txt\") # => 'Yes'\n  filENamEChecK(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filENamEChecK = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "filENamEChecK", "gc": "<|endoftext|>/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filENamEChecK(\"example.txt\") # => 'Yes'\n  filENamEChecK(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filENamEChecK = (file_name) => {\n  const regex = /^([a-zA-Z0-9]){3,}\\.([a-zA-Z]){2,}$/;\n  return regex.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filENamEChecK(\"example.txt\") # => 'Yes'\n  filENamEChecK(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filENamEChecK = (file_name) => {\n  const regex = /^([a-zA-Z0-9]){3,}\\.([a-zA-Z]){2,}$/;\n  return regex.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filENamEChecK(\"example.txt\") # => 'Yes'\n  filENamEChecK(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filENamEChecK = (file_name) => {\n  const regex = /^([a-zA-Z0-9]){3,}\\.([a-zA-Z]){2,}$/;\n  return regex.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filENamEChecK(\"example.txt\") # => 'Yes'\n  filENamEChecK(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filENamEChecK = (file_name) => {\n  const regex = /^([a-zA-Z0-9]){3,}\\.([a-zA-Z]){2,}$/;\n  return regex.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filENamEChecK(\"example.txt\") # => 'Yes'\n  filENamEChecK(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filENamEChecK = (file_name) => {\n  const regex = /^([a-zA-Z0-9]){3,}\\.([a-zA-Z]){2,}$/;\n  return regex.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filENamEChecK(\"example.txt\") # => 'Yes'\n  filENamEChecK(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filENamEChecK = (file_name) => {\n  const regex = /^([a-zA-Z0-9]){3,}\\.([a-zA-Z]){2,}$/;\n  return regex.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filENamEChecK(\"example.txt\") # => 'Yes'\n  filENamEChecK(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filENamEChecK = (file_name) => {\n  const regex = /^([a-zA-Z0-9]){3,}\\.([a-zA-Z]){2,", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumsquaRes = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumsquaRes", "gc": "<|endoftext|>/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumsquaRes = (lst) => {\n  let sum = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a \n  multiple of 3 and will square its entry if its index is a multiple of 4 and not a multiple of 3. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst cubedRes = (lst) => {\n  let sum = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a \n  multiple of 3 and will square its entry if its index is a multiple of 4 and not a multiple of 3. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst cubedSquareRes = (lst) => {\n  let sum = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a \n  multiple of 3 and will square its entry if its index is a multiple of 4 and not a multiple of 3. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst cubedSquareSquareRes = (lst) => {\n  let sum = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a \n  multiple of 3 and will square its entry if its index is a multiple of 4 and not a multiple of 3. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst cubedSquareSquareSquareRes = (lst) => {\n  let sum = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a \n  multiple of 3 and will square its entry if its index is a multiple of 4 and not a multiple of 3. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst cubedSquareSquareSquareSquareRes = (lst) => {\n  let sum = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a \n  multiple of 3 and will square its entry if its index is a multiple of 4 and not a multiple of 3. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst cubedSquareSquareSquareSquareSquareRes = (lst) => {\n  let sum = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a \n  multiple of 3 and will square its entry if its index is a multiple of 4 and not a multiple of 3. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst cubedSquareSquareSquareSquareSquareSquareRes = (lst) => {\n  let sum = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worDsInsenteNce = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "worDsInsenteNce", "gc": "<|endoftext|>/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worDsInsenteNce = (sentence) => {\n    const words = sentence.split(\" \");\n    let newWords = [];\n    for (let i = 0; i < words.length; i++) {\n        let isPrime = true;\n        for (let j = 0; j < words.length; j++) {\n            if (words[j]!== words[i]) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) {\n            newWords.push(words[i]);\n        }\n    }\n    return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worDsInsenteNce2 = () => {\n    const words = `this is a test\nlets go for swimming`;\n    let newWords = [];\n    for (let i = 0; i < words.length; i++) {\n        let isPrime = true;\n        for (let j = 0; j < words.length; j++) {\n            if (words[j]!== words[i]) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) {\n            newWords.push(words[i]);\n        }\n    }\n    return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worDsInsenteNce3 = () => {\n    const words = `this is a test\nlets go for swimming`;\n    let newWords = [];\n    for (let i = 0; i < words.length; i++) {\n        let isPrime = true;\n        for (let j = 0; j < words.length; j++) {\n            if (words[j]!== words[i]) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) {\n            newWords.push(words[i]);\n        }\n    }\n    return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worDsInsenteNce4 = () => {\n    const words = `this is a test\nlets go for swimming`;\n    let newWords = [];\n    for (let i = 0; i < words.length; i++) {\n        let isPrime = true;\n        for (let j = 0; j < words.length; j++) {\n            if (words[j]!== words[i]) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) {\n            newWords.push(words[i]);\n        }\n    }\n    return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worDsInsenteNce5 = () => {\n    const words = `this is a test\nlets go for swimming`;\n    let newWords = [];\n    for (let i = 0; i < words.length; i++) {\n        let isPrime = true;\n        for (let j = 0; j < words.length; j++) {\n            if (words[j]!== words[i]) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) {\n            newWords.push(words[i]);\n        }\n    }\n    return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worDsInsenteNce6 = () => {\n    const words = `this is a test\nlets go for swimming`;\n    let newWords = [];\n    for (let i = 0; i < words.length; i++) {\n        let isPrime = true;\n        for (let j = 0; j < words.length; j++) {\n            if (words[j]!== words[i]) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) {\n            newWords.push(words[i]);\n        }\n    }\n    return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst worDsInsenteNce7 = () => {\n    const words = `this is a test\nlets go for swimming`;\n    let newWords = [];\n    for (let i = 0; i < words.length; i++) {\n        let isPrime = true;\n        for (let j = 0; j < words.length; j++) {\n            if (words[j]!== words[i]) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) {\n            newWords.push(words[i]);\n        }\n    }\n    return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simPlifY the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simPlifY(\"1/5\", \"5/1\") = true\n  simPlifY(\"1/6\", \"2/1\") = false\n  simPlifY(\"7/10\", \"10/2\") = false\n  */\nconst simPlifY = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simPlifY", "gc": "<|endoftext|>/*Your task is to implement a function that will simPlifY the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simPlifY(\"1/5\", \"5/1\") = true\n  simPlifY(\"1/6\", \"2/1\") = false\n  simPlifY(\"7/10\", \"10/2\") = false\n  */\nconst simPlifY = (x, n) => {\n  let isPlif = false;\n  let isPlif2 = false;\n  let isPlif3 = false;\n  let isPlif4 = false;\n  let isPlif5 = false;\n  let isPlif6 = false;\n  let isPlif7 = false;\n  let isPlif8 = false;\n  let isPlif9 = false;\n  let isPlif10 = false;\n  let isPlif11 = false;\n  let isPlif12 = false;\n  let isPlif13 = false;\n  let isPlif14 = false;\n  let isPlif15 = false;\n  let isPlif16 = false;\n  let isPlif17 = false;\n  let isPlif18 = false;\n  let isPlif19 = false;\n  let isPlif20 = false;\n  let isPlif21 = false;\n  let isPlif22 = false;\n  let isPlif23 = false;\n  let isPlif24 = false;\n  let isPlif25 = false;\n  let isPlif26 = false;\n  let isPlif27 = false;\n  let isPlif28 = false;\n  let isPlif29 = false;\n  let isPlif30 = false;\n  let isPlif31 = false;\n  let isPlif32 = false;\n  let isPlif33 = false;\n  let isPlif34 = false;\n  let isPlif35 = false;\n  let isPlif36 = false;\n  let isPlif37 = false;\n  let isPlif38 = false;\n  let isPlif39 = false;\n  let isPlif40 = false;\n  let isPlif41 = false;\n  let isPlif42 = false;\n  let isPlif43 = false;\n  let isPlif44 = false;\n  let isPlif45 = false;\n  let isPlif46 = false;\n  let isPlif47 = false;\n  let isPlif48 = false;\n  let isPlif49 = false;\n  let isPlif50 = false;\n  let isPlif51 = false;\n  let isPlif52 = false;\n  let isPlif53 = false;\n  let isPlif54 = false;\n  let isPlif55 = false;\n  let isPlif56 = false;\n  let isPlif57 = false;\n  let isPlif58 = false;\n  let isPlif59 = false;\n  let isPlif60 = false;\n  let isPlif61 = false;\n  let isPlif62 = false;\n  let isPlif63 = false;\n  let isPlif64 = false;\n  let isPlif65 = false;\n  let isPlif66 = false;\n  let isPlif67 = false;\n  let isPlif68 = false;\n  let isPlif69 = false;\n  let isPlif70 = false;\n  let isPlif71 = false;\n  let isPlif72 = false;\n  let isPlif73 = false;\n  let isPlif74 = false;\n  let isPlif75 = false;\n  let isPlif76 = false;\n  let isPlif77 = false;\n  let isPlif78 = false;\n  let isPlif79 = false;\n  let isPlif80 = false;\n  let isPlif81 = false;\n  let isPlif82 = false;\n  let isPlif83 = false;\n  let isPlif84 = false;\n  let isPlif85 = false;\n  let isPlif86 = false;\n  let isPlif87 = false;\n  let isPlif88 = false;\n  let isPlif89 = false;\n  let isPlif90 = false;\n  let isPlif91 = false;\n  let isPlif92 = false;\n  let isPlif93 = false;\n  let isPlif94 = false;\n  let isPlif95 = false;\n  let isPlif96 = false;\n  let isPlif97 = false;\n  let isPlif98 = false;\n  let isPlif99 = false;\n  let isPlif100 = false;\n  let isPlif101 = false;\n  let isPlif102 = false;\n  let isPlif103 = false;\n  let isPlif104 = false;\n  let isPlif105 = false;\n  let isPlif106 = false;\n  let isPlif107 = false;\n  let isPlif108 = false;\n  let isPlif109 = false;\n  let isPlif110 = false;\n  let isPlif111 = false;\n  let isPlif112 = false;\n  let isPlif113 = false;\n  let isPlif114 = false;\n  let isPlif115 = false;\n  let isPlif116 = false;\n  let isPlif117 = false;\n  let isPlif118 = false;\n  let isPlif119 = false;\n  let isPlif120 = false;\n  let isPlif121 = false;\n  let isPlif122 = false;\n  let isPlif123 = false;\n  let isPlif124 = false;\n  let isPlif125 = false;\n  let isPlif126 = false;\n  let isPlif127 = false;\n  let isPlif128 = false;\n  let isPlif129 = false;\n  let isPlif130 = false;\n  let isPlif131 = false;\n  let isPlif132 = false;\n  let isPlif133 = false;\n  let isPlif134 = false;\n  let isPlif135 = false;\n  let isPlif136 = false;\n  let isPlif137 = false;\n  let isPlif138 = false;\n  let isPlif139 = false;\n  let isPlif140 = false;\n  let isPlif141 = false;\n  let isPlif142 = false;\n  let isPlif143 = false;\n  let isPlif144 = false;\n  let isPlif145 = false;\n  let isPlif146 = false;\n  let isPlif147 = false;\n  let isPlif148 = false;\n  let isPlif149 = false;\n  let isPlif150 = false;\n  let isPlif151 = false;\n  let isPlif152 = false;\n  let isPlif153 = false;\n  let isPlif154 = false;\n  let isPlif155 = false;\n  let isPlif156 = false;\n  let isPlif157 = false;\n  let isPlif158 = false;\n  let isPlif159 = false;\n  let isPlif160 = false;\n  let isPlif161 = false;\n  let isPlif162 = false;\n  let isPlif163 = false;\n  let isPlif164 = false;\n  let isPlif165 = false;\n  let isPlif166 = false;\n  let isPlif167 = false;\n  let isPlif168 = false;\n  let isPlif169 = false;\n  let isPlif170 = false;\n  let isPlif171 = false;\n  let isPlif172 = false;\n  let isPlif173 = false;\n  let isPlif174 = false;\n  let isPlif175 = false;\n  let isPlif176 = false;\n  let isPlif177 = false;\n  let isPlif178 = false;\n  let isPlif179 = false;\n  let isPlif180 = false;\n  let isPlif181 = false;\n  let isPlif182 = false;\n  let isPlif183 = false;\n  let isPlif184 = false;\n  let isP", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordErBypointS([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> ordErBypointS([]) == []\n  */\nconst ordErBypointS = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "ordErBypointS", "gc": "<|endoftext|>/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordErBypointS([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> ordErBypointS([]) == []\n  */\nconst ordErBypointS = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum % 10 === 0) {\n      result.push(nums[i]);\n      sum -= nums[i];\n      index++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in descending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordErBypointD([1, 11, -1, -11, -12]) == [11, -11, -11, -11, -12]\n  >>> ordErBypointD([]) == []\n  */\nconst ordErBypointD = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum % 10 === 0) {\n      result.push(nums[i]);\n      sum -= nums[i];\n      index++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordErBypointS([1, 11, -1, -11, -12]) == [11, -11, -11, -11, -12]\n  >>> ordErBypointS([]) == []\n  */\nconst ordErBypoint = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum % 10 === 0) {\n      result.push(nums[i]);\n      sum -= nums[i];\n      index++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in descending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordErBypointD([1, 11, -1, -11, -12]) == [11, -11, -11, -11, -12]\n  >>> ordErBypointD([]) == []\n  */\nconst ordErBypointD = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum % 10 === 0) {\n      result.push(nums[i]);\n      sum -= nums[i];\n      index++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordErBypointS([1, 11, -1, -11, -12]) == [11, -11, -11, -11, -12]\n  >>> ordErBypointS([]) == []\n  */\nconst ordErBypoint = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum % 10 === 0) {\n      result.push(nums[i]);\n      sum -= nums[i];\n      index++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in descending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordErBypointD([1, 11, -1, -11, -12]) == [11, -11, -11, -11, -12]\n  >>> ordErBypointD([]) == []\n  */\nconst ordErBypointD = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum % 10 === 0) {\n      result.push(nums[i]);\n      sum -= nums[i];\n      index++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordErBypointS([1, 11, -1, -11, -12]) == [11, -11, -11, -11, -12]\n  >>> ordErBypointS([]) == []\n  */\nconst ordErBypoint = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum % 10 === 0) {\n      result.push(nums[i]);\n      sum -= nums[i];\n      index++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in descending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordErBypointD([1, 11, -1, -11, -12]) == [11, -11, -11, -11, -12]\n  >>> ordErBypointD([]) == []\n  */\nconst ordErBypointD = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum % 10 === 0) {\n      result.push(nums[i]);\n      sum -= nums[i];\n      index++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> ordErBypointS([1, 11, -1, -11, -12]) == [11, -11, -11, -11, -12]\n  >>> ordErBypointS([]) == []\n  */\nconst ordErBypoint = (nums) => {\n  let sum = 0;\n  let index = 0;\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    result.push(nums[i]);\n  }\n  for (let i = 0; i < nums.length; i++) {\n    if (sum % 10 === 0) {\n      result.push(nums[i]);\n      sum -= nums[i];\n      index++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in descending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  speCialfilteR([15, -73, 14, -15]) => 1 \n  speCialfilteR([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst speCialfilteR = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "speCialfilteR", "gc": "<|endoftext|>/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  speCialfilteR([15, -73, 14, -15]) => 1 \n  speCialfilteR([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst speCialfilteR = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even (1, 3, 5, 7, 9).\n  For example:\n  speCialfilteR([15, -73, 14, -15]) => 1 \n  speCialfilteR([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst speCialfilteC = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (3, 5, 7, 9).\n  For example:\n  speCialfilteR([15, -73, 14, -15]) => 1 \n  speCialfilteR([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst speCialfilteB = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even (3, 5, 7, 9).\n  For example:\n  speCialfilteR([15, -73, 14, -15]) => 1 \n  speCialfilteR([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst speCialfilteA = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (3, 5, 7, 9).\n  For example:\n  speCialfilteR([15, -73, 14, -15]) => 1 \n  speCialfilteR([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst speCialfilte = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even (3, 5, 7, 9).\n  For example:\n  speCialfilteR([15, -73, 14, -15]) => 1 \n  speCialfilteR([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst speCialfilteB = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (3, 5, 7, 9).\n  For example:\n  speCialfilteR([15, -73, 14, -15]) => 1 \n  speCialfilteR([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst speCialfilteA = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even (3, 5, 7, 9).\n  For example:\n  speCialfilteR([15, -73, 14, -15]) => 1 \n  speCialfilteR([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst speCialfilte = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (3, 5, 7, 9).\n  For example:\n  speCialfilteR([15, -73, 14, -15]) => 1 \n  speCialfilteR([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst speCialfilteB = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even (3, 5, 7, 9).\n  For example:\n  speCialfilteR([15, -73, 14, -15]) => 1 \n  speCialfilteR([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst speCialfilteA = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (3, 5, 7, 9).\n  For example:\n  speCialfilteR([15, -73, 14, -15]) => 1 \n  speCialfilteR([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst speCialfilte = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even (3, 5, 7, 9).\n  For example:\n  speCialfilteR([15, -73, 14, -15]) => 1 \n  speCialfilteR([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst speCialfilteB = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (3, 5, 7, 9).\n  For example:\n  speCialfilteR([15, -73, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getmaxTRipleS = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getmaxTRipleS", "gc": "<|endoftext|>/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getmaxTRipleS = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(x => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 2\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getmaxTRiplesN = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(x => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getmaxTRiplesN2 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(x => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 4\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getmaxTRiplesN3 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(x => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 5\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getmaxTRiplesN4 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(x => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 6\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getmaxTRiplesN5 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(x => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 7\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getmaxTRiplesN6 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(x => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 8\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getmaxTRiplesN7 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(x => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 9\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getmaxTRiplesN8 = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.filter(x => x % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "gc": "<|endoftext|>/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1Orbit = orbits[planet1]\n  const planet2Orbit = orbits[planet2]\n  const planet1OrbitOrbit = planet1OrbitOrbits[planet1]\n  const planet2OrbitOrbit = planet2OrbitOrbits[planet2]\n  const planet1OrbitOrbitOrbits = planet1OrbitOrbitOrbits.filter(\n    orbit => orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sorTedLIstSuM = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sorTedLIstSuM", "gc": "<|endoftext|>/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sorTedLIstSuM = (lst) => {\n  let newLst = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 0) {\n      newLst.push(lst[i]);\n    }\n  }\n  return newLst.sort((a, b) => a.length - b.length);\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sorTedLIstSuM = (lst) => {\n  let newLst = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 0) {\n      newLst.push(lst[i]);\n    }\n  }\n  return newLst.sort((a, b) => a.length - b.length);\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sorTedLIstSuM = (lst) => {\n  let newLst = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 0) {\n      newLst.push(lst[i]);\n    }\n  }\n  return newLst.sort((a, b) => a.length - b.length);\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sorTedLIstSuM = (lst) => {\n  let newLst = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 0) {\n      newLst.push(lst[i]);\n    }\n  }\n  return newLst.sort((a, b) => a.length - b.length);\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sorTedLIstSuM = (lst) => {\n  let newLst = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 0) {\n      newLst.push(lst[i]);\n    }\n  }\n  return newLst.sort((a, b) => a.length - b.length);\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sorTedLIstSuM = (lst) => {\n  let newLst = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 0) {\n      newLst.push(lst[i]);\n    }\n  }\n  return newLst.sort((a, b) => a.length - b.length);\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sorTedLIstSuM = (lst) => {\n  let newLst = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 0) {\n      newLst.push(lst[i]);\n    }\n  }\n  return newLst.sort((a, b) => a.length - b.length);\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabeti", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> strIngSEquenCe(0)\n  '0'\n  >>> strIngSEquenCe(5)\n  '0 1 2 3 4 5'\n  */\nconst strIngSEquenCe = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "strIngSEquenCe", "gc": "<|endoftext|>/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> strIngSEquenCe(0)\n  '0'\n  >>> strIngSEquenCe(5)\n  '0 1 2 3 4 5'\n  */\nconst strIngSEquenCe = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += '0';\n  }\n  return s;\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '0'.\n * If n is less than the number of digits in n, return '0'.\n * If n is greater than the number of digits in n, return '", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOry(7, 34, 12) == 34\n  for xOry(15, 8, 5) == 5\n  \n  */\nconst xOry = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOry", "gc": "<|endoftext|>/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOry(7, 34, 12) == 34\n  for xOry(15, 8, 5) == 5\n  \n  */\nconst xOry = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    return y\n  }\n  \n  if (n % 2 === 0) {\n    return x\n  }\n  \n  if (n % 3 === 0) {\n    return y\n  }\n  \n  if (n % 5 === 0) {\n    return y\n  }\n  \n  return x\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOry(7, 34, 12) == 34\n  for xOry(15, 8, 5) == 5\n  \n  */\nconst xOry = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    return y\n  }\n  \n  if (n % 2 === 0) {\n    return x\n  }\n  \n  if (n % 3 === 0) {\n    return y\n  }\n  \n  if (n % 5 === 0) {\n    return y\n  }\n  \n  return x\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOry(7, 34, 12) == 34\n  for xOry(15, 8, 5) == 5\n  \n  */\nconst xOry = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    return y\n  }\n  \n  if (n % 2 === 0) {\n    return x\n  }\n  \n  if (n % 3 === 0) {\n    return y\n  }\n  \n  if (n % 5 === 0) {\n    return y\n  }\n  \n  return x\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOry(7, 34, 12) == 34\n  for xOry(15, 8, 5) == 5\n  \n  */\nconst xOry = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    return y\n  }\n  \n  if (n % 2 === 0) {\n    return x\n  }\n  \n  if (n % 3 === 0) {\n    return y\n  }\n  \n  if (n % 5 === 0) {\n    return y\n  }\n  \n  return x\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOry(7, 34, 12) == 34\n  for xOry(15, 8, 5) == 5\n  \n  */\nconst xOry = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    return y\n  }\n  \n  if (n % 2 === 0) {\n    return x\n  }\n  \n  if (n % 3 === 0) {\n    return y\n  }\n  \n  if (n % 5 === 0) {\n    return y\n  }\n  \n  return x\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOry(7, 34, 12) == 34\n  for xOry(15, 8, 5) == 5\n  \n  */\nconst xOry = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    return y\n  }\n  \n  if (n % 2 === 0) {\n    return x\n  }\n  \n  if (n % 3 === 0) {\n    return y\n  }\n  \n  if (n % 5 === 0) {\n    return y\n  }\n  \n  return x\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOry(7, 34, 12) == 34\n  for xOry(15, 8, 5) == 5\n  \n  */\nconst xOry = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    return y\n  }\n  \n  if (n % 2 === 0) {\n    return x\n  }\n  \n  if (n % 3 === 0) {\n    return y\n  }\n  \n  if (n % 5 === 0) {\n    return y\n  }\n  \n  return x\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOry(7, 34, 12) == 34\n  for xOry(15, 8, 5) == 5\n  \n  */\nconst xOry = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    return y\n  }\n  \n  if (n % 2 === 0) {\n    return x\n  }\n  \n  if (n % 3 === 0) {\n    return y\n  }\n  \n  if (n % 5 === 0) {\n    return y\n  }\n  \n  return x\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOry(7, 34, 12) == 34\n  for xOry(15, 8, 5) == 5\n  \n  */\nconst xOry = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    return y\n  }\n  \n  if (n % 2 === 0) {\n    return x\n  }\n  \n  if (n % 3 === 0) {\n    return y\n  }\n  \n  if (n % 5 === 0) {\n    return y\n  }\n  \n  return x\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOry(7, 34, 12) == 34\n  for xOry(15, 8, 5) == 5\n  \n  */\nconst xOry = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    return y\n  }\n  \n  if (n % 2 === 0) {\n    return x\n  }\n  \n  if (n % 3 === 0) {\n    return y\n  }\n  \n  if (n % 5 === 0) {\n    return y\n  }\n  \n  return x\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOry(7, 34, 12) == 34\n  for xOry(15, 8, 5) == 5\n  \n  */\nconst xOry = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    return y\n  }\n  \n  if (n % 2 === 0) {\n    return x\n  }\n  \n  if (n % 3 === 0) {\n    return y\n  }\n  \n  if (n % 5 === 0) {\n    return y\n  }\n  \n  return x\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOry(7, 34, 12) == 34\n  for xOry(15, 8, 5) == 5\n  \n  */\nconst xOry = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    return y\n  }\n  \n  if (n % 2 === 0) {\n    return x\n  }\n  \n  if (n % 3 === 0) {\n    return y\n  }\n  \n  if (n % 5 === 0) {\n    return y\n  }\n  \n  return x\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOry(7, 34, 12) == 34\n  for xOry(15, 8, 5) == 5\n  \n  */\nconst xOry = (n, x, y) => {\n  if (n < 2 || n > 100) {\n    return y\n  }\n  \n  if (n % 2 === 0) {\n    return x\n  }\n  \n  if (n % 3 === 0) {\n    return y\n  }\n  \n  if (n % 5 === 0) {\n    return y\n  }\n  \n  return x\n}\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOry(7, 34, 12) == 34\n  for xOry(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  douBleTHeDifFerEnce([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  douBleTHeDifFerEnce([-1, -2, 0]) == 0\n  douBleTHeDifFerEnce([9, -2]) == 81\n  douBleTHeDifFerEnce([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douBleTHeDifFerEnce = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "douBleTHeDifFerEnce", "gc": "<|endoftext|>/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  douBleTHeDifFerEnce([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  douBleTHeDifFerEnce([-1, -2, 0]) == 0\n  douBleTHeDifFerEnce([9, -2]) == 81\n  douBleTHeDifFerEnce([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douBleTHeDifFerEnce = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  douBleTHeDifFerEnce([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  douBleTHeDifFerEnce([-1, -2, 0]) == -1\n  douBleTHeDifFerEnce([9, -2]) == 81\n  douBleTHeDifFerEnce([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douBleTHeDifFerEnceEven = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3. Ignore numbers that are negative or not integers.\n  douBleTHeDifFerEnceEven([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  douBleTHeDifFerEnceEven([-1, -2, 0]) == -1\n  douBleTHeDifFerEnceEven([9, -2]) == 81\n  douBleTHeDifFerEnceEven([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douBleTHeDifFerEnceDivisible = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3. Ignore numbers that are negative or not integers.\n  douBleTHeDifFerEnceDivisible([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  douBleTHeDifFerEnceDivisible([-1, -2, 0]) == -1\n  douBleTHeDifFerEnceDivisible([9, -2]) == 81\n  douBleTHeDifFerEnceDivisible([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douBleTHeDifFerEnceDivisibleEven = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3. Ignore numbers that are negative or not integers.\n  douBleTHeDifFerEnceDivisibleEven([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  douBleTHeDifFerEnceDivisibleEven([-1, -2, 0]) == -1\n  douBleTHeDifFerEnceDivisibleEven([9, -2]) == 81\n  douBleTHeDifFerEnceDivisibleEven([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douBleTHeDifFerEnceDivisibleDivisible = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3. Ignore numbers that are negative or not integers.\n  douBleTHeDifFerEnceDivisibleDivisible([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  douBleTHeDifFerEnceDivisibleDivisible([-1, -2, 0]) == -1\n  douBleTHeDifFerEnceDivisibleDivisible([9, -2]) == 81\n  douBleTHeDifFerEnceDivisibleDivisible([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douBleTHeDifFerEnceDivisibleDivisibleEven = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3. Ignore numbers that are negative or not integers.\n  douBleTHeDifFerEnceDivisibleDivisibleEven([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  douBleTHeDifFerEnceDivisibleDivisibleEven([-1, -2, 0]) == -1\n  douBleTHeDifFerEnceDivisibleDivisibleEven([9, -2]) == 81\n  douBleTHeDifFerEnceDivisibleDivisibleEven([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douBleTHeDifFerEnceDivisibleDivisibleDivisible = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3. Ignore numbers that are negative or not integers.\n  douBleTHeDifFerEnceDivisibleDivisibleDivisible([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  douBleTHeDifFerEnceDivisibleDivisibleDivisible([-1, -2, 0]) == -1\n  douBleTHeDifFerEnceDivisibleDivisibleDivisible([9, -2]) == 81\n  douBleTHeDifFerEnceDivisibleDivisibleDivisible([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst douBleTHeDifFerEnceDivisibleDivisibleDivisibleEven = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3. Ignore numbers that are negative or not ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  comPare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  comPare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst comPare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "comPare", "gc": "<|endoftext|>/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  comPare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  comPare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst comPare = (game, guess) => {\n  const gameScores = game.map((score) => score);\n  const gameGuesses = game.map((score) => score);\n  const gameGuessesLength = gameGuesses.length;\n  const gameGuessesIndexes = gameGuesses.map((score, index) => index);\n  const gameGuessesGuesses = gameGuesses.map((score, index) => gameGuesses[index]);\n  const gameGuessesGuessesLength = gameGuessesGuesses.length;\n  const gameGuessesGuessesIndexes = gameGuessesGuesses.map((score, index) => index);\n  const gameGuessesGuessesGuesses = gameGuessesGuesses.map((score, index) => gameGuessesGuesses[index]);\n  const gameGuessesGuessesGuessesLength = gameGuessesGuessesGuesses.length;\n  const gameGuessesGuessesGuessesIndexes = gameGuessesGuessesGuesses.map((score, index) => index);\n  const gameGuessesGuessesGuessesGuesses = gameGuessesGuessesGuesses.map((score, index) => gameGuessesGuessesGuesses[index]);\n  const gameGuessesGuessesGuessesLength = gameGuessesGuessesGuessesGuesses.length;\n  const gameGuessesGuessesGuessesGuessesIndexes = gameGuessesGuessesGuessesGuesses.map((score, index) => index);\n  const gameGuessesGuessesGuessesGuesses = gameGuessesGuessesGuessesGuesses.map((score, index) => gameGuessesGuessesGuesses[index]);\n  const gameGuessesGuessesGuessesLength = gameGuessesGuessesGuessesGuesses.length;\n  const gameGuessesGuessesGuessesGuessesIndexes = gameGuessesGuessesGuessesGuesses.map((score, index) => index);\n  const gameGuessesGuessesGuessesGuessesGuesses = gameGuessesGuessesGuessesGuesses.map((score, index) => gameGuessesGuessesGuesses[index]);\n  const gameGuessesGuessesGuessesLength = gameGuessesGuessesGuessesGuesses.length;\n  const gameGuessesGuessesGuessesGuessesIndexes = gameGuessesGuessesGuessesGuesses.map((score, index) => index);\n  const gameGuessesGuessesGuessesGuessesGuesses = gameGuessesGuessesGuessesGuesses.map((score, index) => gameGuessesGuessesGuesses[index]);\n  const gameGuessesGuessesGuessesLength = gameGuessesGuessesGuessesGuesses.length;\n  const gameGuessesGuessesGuessesGuessesIndexes = gameGuessesGuessesGuessesGuesses.map((score, index) => index);\n  const gameGuessesGuessesGuessesGuessesGuesses = gameGuessesGuessesGuessesGuesses.map((score, index) => gameGuessesGuessesGuesses[index]);\n  const gameGuessesGuessesGuessesLength = gameGuessesGuessesGuessesGuesses.length;\n  const gameGuessesGuessesGuessesGuessesIndexes = gameGuessesGuessesGuessesGuesses.map((score, index) => index);\n  const gameGuessesGuessesGuessesGuessesGuesses = gameGuessesGuessesGuessesGuesses.map((score, index) => gameGuessesGuessesGuesses[index]);\n  const gameGuessesGuessesGuessesLength = gameGuessesGuessesGuessesGuesses.length;\n  const gameGuessesGuessesGuessesGuessesGuessesIndexes = gameGuessesGuessesGuessesGuesses.map((score, index) => index);\n  const gameGuessesGuessesGuessesGuessesGuesses = gameGuessesGuessesGuessesGuesses.map((score, index) => gameGuessesGuessesGuesses[index]);\n  const gameGuessesGuessesGuessesLength = gameGuessesGuessesGuessesGuesses.length;\n  const gameGuessesGuessesGuessesGuessesGuessesIndexes = gameGuessesGuessesGuessesGuesses.map((score, index) => index);\n  const gameGuessesGuessesGuessesGuessesGuesses = gameGuessesGuessesGuessesGuesses.map((score, index) => gameGuessesGuessesGuesses[index]);\n  const gameGuessesGuessesGuessesLength = gameGuessesGuessesGuessesGuesses.length;\n  const gameGuessesGuessesGuessesGuessesGuessesIndexes = gameGuessesGuessesGuessesGuesses.map((score, index) => index);\n  const gameGuessesGuessesGuessesGuessesGuesses = gameGuessesGuessesGuessesGuesses.map((score, index) => gameGuessesGuessesGuesses[index]);\n  const gameGuessesGuessesGuessesLength = gameGuessesGuessesGuessesGuesses.length;\n  const gameGuessesGuessesGuessesGuessesGuessesIndexes = gameGuessesGuessesGuessesGuesses.map((score, index) => index);\n  const gameGuessesGuessesGuessesGuessesGuesses = gameGuessesGuessesGuessesGuesses.map((score, index) => gameGuessesGuessesGuesses[index]);\n  const gameGuessesGuessesGuessesLength = gameGuessesGuessesGuessesGuesses.length;\n  const gameGuessesGuessesGuessesGuessesGuessesIndexes = gameGuessesGuessesG", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strOngeStExtEnsIon('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strOngeStExtEnsIon = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strOngeStExtEnsIon", "gc": "<|endoftext|>/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strOngeStExtEnsIon('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strOngeStExtEnsIon = (class_name, extensions) => {\n  let strOngeStExtEnsIon = '';\n  let strOngeStExtEnsIonStr = '';\n  let strOngeStExtEnsIonStrLen = 0;\n  let strOngeStExtEnsIonStrLenMax = 0;\n  let strOngeStExtEnsIonStrLenMin = 0;\n  let strOngeStExtEnsIonStrLenMaxLen = 0;\n  let strOngeStExtEnsIonStrLenMinLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExtEnsIonStrLenMinLenLen = 0;\n  let strOngeStExtEnsIonStrLenMaxLenLen = 0;\n  let strOngeStExt", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycPattErnChEck(\"abcd\",\"abd\") => false\n  cycPattErnChEck(\"hello\",\"ell\") => true\n  cycPattErnChEck(\"whassup\",\"psus\") => false\n  cycPattErnChEck(\"abab\",\"baa\") => true\n  cycPattErnChEck(\"efef\",\"eeff\") => false\n  cycPattErnChEck(\"himenss\",\"simen\") => true\n  */\nconst cycPattErnChEck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycPattErnChEck", "gc": "<|endoftext|>/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycPattErnChEck(\"abcd\",\"abd\") => false\n  cycPattErnChEck(\"hello\",\"ell\") => true\n  cycPattErnChEck(\"whassup\",\"psus\") => false\n  cycPattErnChEck(\"abab\",\"baa\") => true\n  cycPattErnChEck(\"efef\",\"eeff\") => false\n  cycPattErnChEck(\"himenss\",\"simen\") => true\n  */\nconst cycPattErnChEck = (a, b) => {\n  let aArr = a.split('');\n  let bArr = b.split('');\n  let aLen = aArr.length;\n  let bLen = bArr.length;\n  let aRot = aArr.slice().reverse();\n  let bRot = bArr.slice().reverse();\n  let aRotLen = aRot.length;\n  let bRotLen = bRot.length;\n  let aRotRot = aRot.slice().reverse();\n  let bRotRot = bRot.slice().reverse();\n  let aRotRotLen = aRotRot.length;\n  let bRotRotLen = bRotRot.length;\n  let aRotRotRot = aRotRot.slice().reverse();\n  let bRotRotRot = bRotRot.slice().reverse();\n  let aRotRotRotLen = aRotRotRot.length;\n  let bRotRotRotLen = bRotRotRot.length;\n  let aRotRotRotRot = aRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotRotLen = aRotRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRot = aRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRot.slice().reverse();\n  let bRotRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotRotLen = aRotRotRotRotRot.length;\n  let bRotRotRotRotRotLen = bRotRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRot = aRotRotRot.slice().reverse();\n  let bRotRotRotRot = bRotRotRot.slice().reverse();\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRot", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      eveNOddcount(-12) ==> (1, 1)\n      eveNOddcount(123) ==> (1, 2)\n  */\nconst eveNOddcount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "eveNOddcount", "gc": "<|endoftext|>/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      eveNOddcount(-12) ==> (1, 1)\n      eveNOddcount(123) ==> (1, 2)\n  */\nconst eveNOddcount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let numStr = num.toString();\n  let numLen = numStr.length;\n  for (let i = 0; i < numLen; i++) {\n    if (numStr[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      eveNOddcount('abc') ==> (1, 2)\n      eveNOddcount('ab') ==> (1, 0)\n      eveNOddcount('abcde') ==> (2, 2)\n      eveNOddcount('abcde') ==> (2, 0)\n      eveNOddcount('abcde') ==> (2, 1)\n      eveNOddcount('abcde') ==> (2, 2)\n      eveNOddcount('abcde') ==> (2, 3)\n      eveNOddcount('abcde') ==> (2, 4)\n      eveNOddcount('abcde') ==> (2, 5)\n      eveNOddcount('abcde') ==> (2, 6)\n      eveNOddcount('abcde') ==> (2, 7)\n      eveNOddcount('abcde') ==> (2, 8)\n      eveNOddcount('abcde') ==> (2, 9)\n      eveNOddcount('abcde') ==> (2, 10)\n      eveNOddcount('abcde') ==> (2, 11)\n      eveNOddcount('abcde') ==> (2, 12)\n      eveNOddcount('abcde') ==> (2, 13)\n      eveNOddcount('abcde') ==> (2, 14)\n      eveNOddcount('abcde') ==> (2, 15)\n      eveNOddcount('abcde') ==> (2, 16)\n      eveNOddcount('abcde') ==> (2, 17)\n      eveNOddcount('abcde') ==> (2, 18)\n      eveNOddcount('abcde') ==> (2, 19)\n      eveNOddcount('abcde') ==> (2, 20)\n      eveNOddcount('abcde') ==> (2, 21)\n      eveNOddcount('abcde') ==> (2, 22)\n      eveNOddcount('abcde') ==> (2, 23)\n      eveNOddcount('abcde') ==> (2, 24)\n      eveNOddcount('abcde') ==> (2, 25)\n      eveNOddcount('abcde') ==> (2, 26)\n      eveNOddcount('abcde') ==> (2, 27)\n      eveNOddcount('abcde') ==> (2, 28)\n      eveNOddcount('abcde') ==> (2, 29)\n      eveNOddcount('abcde') ==> (2, 30)\n      eveNOddcount('abcde') ==> (2, 31)\n      eveNOddcount('abcde') ==> (2, 32)\n      eveNOddcount('abcde') ==> (2, 33)\n      eveNOddcount('abcde') ==> (2, 34)\n      eveNOddcount('abcde') ==> (2, 35)\n      eveNOddcount('abcde') ==> (2, 36)\n      eveNOddcount('abcde') ==> (2, 37)\n      eveNOddcount('abcde') ==> (2, 38)\n      eveNOddcount('abcde') ==> (2, 39)\n      eveNOddcount('abcde') ==> (2, 40)\n      eveNOddcount('abcde') ==> (2, 41)\n      eveNOddcount('abcde') ==> (2, 42)\n      eveNOddcount('abcde') ==> (2, 43)\n      eveNOddcount('abcde') ==> (2, 44)\n      eveNOddcount('abcde') ==> (2, 45)\n      eveNOddcount('abcde') ==> (2, 46)\n      eveNOddcount('abcde') ==> (2, 47)\n      eveNOddcount('abcde') ==> (2, 48)\n      eveNOddcount('abcde') ==> (2, 49)\n      eveNOddcount('abcde') ==> (2, 50)\n      eveNOddcount('abcde') ==> (2, 51)\n      eveNOddcount('abcde') ==> (2, 52)\n      eveNOddcount('abcde') ==> (2, 53)\n      eveNOddcount('abcde') ==> (2, 54)\n      eveNOddcount('abcde') ==> (2, 55)\n      eveNOddcount('abcde') ==> (2, 56)\n      eveNOddcount('abcde') ==> (2, 57)\n      eveNOddcount('abcde') ==> (2, 58)\n      eveNOddcount('abcde') ==> (2, 59)\n      eveNOddcount('abcde') ==> (2, 60)\n      eveNOddcount('abcde') ==> (2, 61)\n      eveNOddcount('abcde') ==> (2, 62)\n      eveNOddcount('abcde') ==> (2, 63)\n      eveNOddcount('abcde') ==> (2, 64)\n      eveNOddcount('abcde') ==> (2, 65)\n      eveNOddcount('abcde') ==> (2, 66)\n      eveNOddcount('abcde') ==> (2, 67)\n      eveNOddcount('abcde') ==> (2, 68)\n      eveNOddcount('abcde') ==> (2, 69)\n      eveNOddcount('abcde') ==> (2, 70)\n      eveNOddcount('abcde') ==> (2, 71)\n      eveNOddcount('abcde') ==> (2, 72)\n      eveNOddcount('abcde') ==> (2, 73)\n      eveNOddcount('abcde') ==> (2, 74)\n      eveNOddcount('abcde') ==> (2, 75)\n      eveNOddcount('abcde') ==> (2, 76)\n      eveNOddcount('abcde') ==> (2, 77)\n      eveNOddcount('abcde') ==> (2, 78)\n      eveNOddcount('abcde') ==> (2, 79)\n      eveNOddcount('abcde') ==> (2, 80)\n      eveNOddcount('abcde') ==> (2, 81)\n      eveNOddcount('abcde') ==> (2, 82)\n      eveNOddcount('abcde') ==> (2, 83)\n      eveNOddcount('abcde') ==> (2, 84)\n      eveNOddcount('abcde') ==> (2, 85)\n      eveNOddcount('abcde') ==> (2, 86)\n      eveNOddcount('abcde') ==> (2, 87)\n      eveNOddcount('abcde') ==> (2, 88)\n      eveNOddcount('abcde') ==> (2, 89)\n      eveNOddcount('abcde') ==> (2, 90)\n      eveNOddcount('abcde') ==> (2, 91)\n      eveNOddcount('abcde') ==> (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> inttoMiNiRomAn(19) == 'xix'\n  >>> inttoMiNiRomAn(152) == 'clii'\n  >>> inttoMiNiRomAn(426) == 'cdxxvi'\n  */\nconst inttoMiNiRomAn = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "inttoMiNiRomAn", "gc": "<|endoftext|>/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> inttoMiNiRomAn(19) == 'xix'\n  >>> inttoMiNiRomAn(152) == 'clii'\n  >>> inttoMiNiRomAn(426) == 'cdxxvi'\n  */\nconst inttoMiNiRomAn = (number) => {\n  let str = '';\n  let i = 0;\n  let num = (number + '');\n  while (i < num.length) {\n    const c = num.charAt(i);\n    if (c >= 'A' && c <= 'Z') {\n      str += c;\n      i++;\n    } else if (c >= 'a' && c <= 'z') {\n      str += c;\n      i++;\n    } else if (c >= '0' && c <= '9') {\n      str += c;\n      i++;\n    } else {\n      str += '0';\n      i++;\n    }\n  }\n  return str.charAt(0).toLowerCase() + str.slice(1);\n};\n\n/*\n  Given a positive integer, obtain its hexadecimal equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> inttoHexaNiRomAn(19) == '0xxix'\n  >>> inttoHexaNiRomAn(152) == '0xclii'\n  >>> inttoHexaNiRomAn(426) == '0xcdxxvi'\n  */\nconst inttoHexaNiRomAn = (number) => {\n  let str = '';\n  let i = 0;\n  let num = (number + '');\n  while (i < num.length) {\n    const c = num.charAt(i);\n    if (c >= 'A' && c <= 'Z') {\n      str += c;\n      i++;\n    } else if (c >= 'a' && c <= 'z') {\n      str += c;\n      i++;\n    } else if (c >= '0' && c <= '9') {\n      str += c;\n      i++;\n    } else {\n      str += '0';\n      i++;\n    }\n  }\n  return str.charAt(0).toLowerCase() + str.slice(1);\n};\n\n/*\n  Given a positive integer, obtain its octal equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> inttoOctaNiRomAn(19) == '0o19'\n  >>> inttoOctaNiRomAn(152) == '0o152'\n  >>> inttoOctaNiRomAn(426) == '0o426'\n  */\nconst inttoOctaNiRomAn = (number) => {\n  let str = '';\n  let i = 0;\n  let num = (number + '');\n  while (i < num.length) {\n    const c = num.charAt(i);\n    if (c >= 'A' && c <= 'Z') {\n      str += c;\n      i++;\n    } else if (c >= 'a' && c <= 'z') {\n      str += c;\n      i++;\n    } else if (c >= '0' && c <= '9') {\n      str += c;\n      i++;\n    } else {\n      str += '0';\n      i++;\n    }\n  }\n  return str.charAt(0).toLowerCase() + str.slice(1);\n};\n\n/*\n  Given a positive integer, obtain its binary equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> inttoBinNiRomAn(19) == '0bxix'\n  >>> inttoBinNiRomAn(152) == '0bclii'\n  >>> inttoBinNiRomAn(426) == '0bcdxxvi'\n  */\nconst inttoBinNiRomAn = (number) => {\n  let str = '';\n  let i = 0;\n  let num = (number + '');\n  while (i < num.length) {\n    const c = num.charAt(i);\n    if (c >= 'A' && c <= 'Z') {\n      str += c;\n      i++;\n    } else if (c >= 'a' && c <= 'z') {\n      str += c;\n      i++;\n    } else if (c >= '0' && c <= '9') {\n      str += c;\n      i++;\n    } else {\n      str += '0';\n      i++;\n    }\n  }\n  return str.charAt(0).toLowerCase() + str.slice(1);\n};\n\n/*\n  Given a positive integer, obtain its decimal equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> inttoDecNiRomAn(19) == '19'\n  >>> inttoDecNiRomAn(152) == '152'\n  >>> inttoDecNiRomAn(426) == '426'\n  */\nconst inttoDecNiRomAn = (number) => {\n  let str = '';\n  let i = 0;\n  let num = (number + '');\n  while (i < num.length) {\n    const c = num.charAt(i);\n    if (c >= 'A' && c <= 'Z') {\n      str += c;\n      i++;\n    } else if (c >= 'a' && c <= 'z') {\n      str += c;\n      i++;\n    } else if (c >= '0' && c <= '9') {\n      str += c;\n      i++;\n    } else {\n      str += '0';\n      i++;\n    }\n  }\n  return str.charAt(0).toLowerCase() + str.slice(1);\n};\n\n/*\n  Given a positive integer, obtain its hexadecimal equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> inttoHexaDecNiRomAn(19) == '0x19'\n  >>> inttoHexaDecNiRomAn(152) == '0x152'\n  >>> inttoHexaDecNiRomAn(426) == '0x426'\n  */\nconst inttoHexaDecNiRomAn = (number) => {\n  let str = '';\n  let i = 0;\n  let num = (number + '');\n  while (i < num.length) {\n    const c = num.charAt(i);\n    if (c >= 'A' && c <= 'Z') {\n      str += c;\n      i++;\n    } else if (c >= 'a' && c <= 'z') {\n      str += c;\n      i++;\n    } else if (c >= '0' && c <= '9') {\n      str += c;\n      i++;\n    } else {\n      str += '0';\n      i++;\n    }\n  }\n  return str.charAt(0).toLowerCase() + str.slice(1);\n};\n\n/*\n  Given a positive integer, obtain its octal equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> inttoOctaDecNiRomAn(19) == '0o19'\n  >>> inttoOctaDecNiRomAn(152) == '0o152'\n  >>> inttoOctaDecNiRomAn(426) == '0o426'\n  */\nconst inttoOctaDecNiRomAn = (number) => {\n  let str = '';\n  let i = 0;\n  let num = (number + '');\n  while (i < num.length) {\n    const c = num.charAt(i);\n    if (c >= 'A' && c <= 'Z') {\n      str += c;\n      i++;\n    } else if (c >= 'a' && c <= 'z') {\n      str += c;\n      i++;\n    } else if (c >= '0' && c <= '9') {\n      str += c;\n      i++;\n    } else {\n      str += '0';\n      i++;\n    }\n  }\n  return str.charAt(0).toLowerCase() + str.slice(1);\n};\n\n/*\n  Given a positive integer, obtain its binary equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rigHtAnGleTrIanGle(3, 4, 5) == true\n  rigHtAnGleTrIanGle(1, 2, 3) == false\n  */\nconst rigHtAnGleTrIanGle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rigHtAnGleTrIanGle", "gc": "<|endoftext|>/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rigHtAnGleTrIanGle(3, 4, 5) == true\n  rigHtAnGleTrIanGle(1, 2, 3) == false\n  */\nconst rigHtAnGleTrIanGle = (a, b, c) => {\n  const aLen = a.length;\n  const bLen = b.length;\n  const cLen = c.length;\n  const aLen2 = aLen * aLen;\n  const bLen2 = bLen * bLen;\n  const cLen2 = cLen * cLen;\n  const aLen3 = aLen2 * aLen;\n  const bLen3 = bLen2 * bLen;\n  const cLen3 = cLen2 * cLen;\n  const aLen4 = aLen3 * aLen;\n  const bLen4 = bLen3 * bLen;\n  const cLen4 = cLen3 * cLen;\n  const aLen5 = aLen4 * aLen;\n  const bLen5 = bLen4 * bLen;\n  const cLen5 = cLen4 * cLen;\n  const aLen6 = aLen5 * aLen;\n  const bLen6 = bLen5 * bLen;\n  const cLen6 = cLen5 * cLen;\n  const aLen7 = aLen6 * aLen;\n  const bLen7 = bLen6 * bLen;\n  const cLen7 = cLen6 * cLen;\n  const aLen8 = aLen7 * aLen;\n  const bLen8 = bLen7 * bLen;\n  const cLen8 = cLen7 * cLen;\n  const aLen9 = aLen8 * aLen;\n  const bLen9 = bLen8 * bLen;\n  const cLen9 = cLen8 * cLen;\n  const aLen10 = aLen9 * aLen;\n  const bLen10 = bLen9 * bLen;\n  const cLen10 = cLen9 * cLen;\n  const aLen11 = aLen10 * aLen;\n  const bLen11 = bLen10 * bLen;\n  const cLen11 = cLen10 * cLen;\n  const aLen12 = aLen11 * aLen;\n  const bLen12 = bLen11 * bLen;\n  const cLen12 = cLen11 * cLen;\n  const aLen13 = aLen12 * aLen;\n  const bLen13 = bLen12 * bLen;\n  const cLen13 = cLen12 * cLen;\n  const aLen14 = aLen13 * aLen;\n  const bLen14 = bLen13 * bLen;\n  const cLen14 = cLen13 * cLen;\n  const aLen15 = aLen14 * aLen;\n  const bLen15 = bLen14 * bLen;\n  const cLen15 = cLen14 * cLen;\n  const aLen16 = aLen15 * aLen;\n  const bLen16 = bLen15 * bLen;\n  const cLen16 = cLen15 * cLen;\n  const aLen17 = aLen16 * aLen;\n  const bLen17 = bLen16 * bLen;\n  const cLen17 = cLen16 * cLen;\n  const aLen18 = aLen17 * aLen;\n  const bLen18 = bLen17 * bLen;\n  const cLen18 = cLen17 * cLen;\n  const aLen19 = aLen18 * aLen;\n  const bLen19 = bLen18 * bLen;\n  const cLen19 = cLen18 * cLen;\n  const aLen20 = aLen19 * aLen;\n  const bLen20 = bLen19 * bLen;\n  const cLen20 = cLen19 * cLen;\n  const aLen21 = aLen20 * aLen;\n  const bLen21 = bLen20 * bLen;\n  const cLen21 = cLen20 * cLen;\n  const aLen22 = aLen21 * aLen;\n  const bLen22 = bLen21 * bLen;\n  const cLen22 = cLen21 * cLen;\n  const aLen23 = aLen22 * aLen;\n  const bLen23 = bLen22 * bLen;\n  const cLen23 = cLen22 * cLen;\n  const aLen24 = aLen23 * aLen;\n  const bLen24 = bLen23 * bLen;\n  const cLen24 = cLen23 * cLen;\n  const aLen25 = aLen24 * aLen;\n  const bLen25 = bLen24 * bLen;\n  const cLen25 = cLen24 * cLen;\n  const aLen26 = aLen25 * aLen;\n  const bLen26 = bLen25 * bLen;\n  const cLen26 = cLen25 * cLen;\n  const aLen27 = aLen26 * aLen;\n  const bLen27 = bLen26 * bLen;\n  const cLen27 = cLen26 * cLen;\n  const aLen28 = aLen27 * aLen;\n  const bLen28 = bLen27 * bLen;\n  const cLen28 = cLen27 * cLen;\n  const aLen29 = aLen28 * aLen;\n  const bLen29 = bLen28 * bLen;\n  const cLen29 = cLen28 * cLen;\n  const aLen30 = aLen29 * aLen;\n  const bLen30 = bLen29 * bLen;\n  const cLen30 = cLen29 * cLen;\n  const aLen31 = aLen30 * aLen;\n  const bLen31 = bLen30 * bLen;\n  const cLen31 = cLen30 * cLen;\n  const aLen32 = aLen31 * aLen;\n  const bLen32 = bLen31 * bLen;\n  const cLen32 = cLen31 * cLen;\n  const aLen33 = aLen32 * aLen;\n  const bLen33 = bLen32 * bLen;\n  const cLen33 = cLen32 * cLen;\n  const aLen34 = aLen33 * aLen;\n  const bLen34 = bLen33 * bLen;\n  const cLen34 = cLen33 * cLen;\n  const aLen35 = aLen34 * aLen;\n  const bLen35 = bLen34 * bLen;\n  const cLen35 = cLen34 * cLen;\n  const aLen36 = aLen35 * aLen;\n  const bLen36 = bLen35 * bLen;\n  const cLen36 = cLen35 * cLen;\n  const aLen37 = aLen36 * aLen;\n  const bLen37 = bLen36 * bLen;\n  const cLen37 = cLen36 * cLen;\n  const aLen38 = aLen37 * aLen;\n  const bLen38 = bLen37 * bLen;\n  const cLen38 = cLen37 * cLen;\n  const aLen39 = aLen38 * aLen;\n  const bLen39 = bLen38 * bLen;\n  const cLen39 = cLen38 * cLen;\n  const aLen40 = aLen39 * aLen;\n  const bLen40 = bLen39 * bLen;\n  const cLen40 = cLen39 * cLen;\n  const aLen41 = aLen40 * aLen;\n  const bLen41 = bLen40 * bLen;\n  const cLen41 = cLen40 * cLen;\n  const aLen42 = aLen41 * aLen;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  finDMax([\"name\", \"of\", \"string\"]) === \"string\"\n  finDMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  finDMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst finDMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "finDMax", "gc": "<|endoftext|>/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  finDMax([\"name\", \"of\", \"string\"]) === \"string\"\n  finDMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  finDMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst finDMax = (words) => {\n  let maxLength = 0;\n  let maxWord = \"\";\n  let maxChar = 0;\n  let maxCharCount = 0;\n  let maxCharCount2 = 0;\n  let maxCharCount3 = 0;\n  let maxCharCount4 = 0;\n  let maxCharCount5 = 0;\n  let maxCharCount6 = 0;\n  let maxCharCount7 = 0;\n  let maxCharCount8 = 0;\n  let maxCharCount9 = 0;\n  let maxCharCount10 = 0;\n  let maxCharCount11 = 0;\n  let maxCharCount12 = 0;\n  let maxCharCount13 = 0;\n  let maxCharCount14 = 0;\n  let maxCharCount15 = 0;\n  let maxCharCount16 = 0;\n  let maxCharCount17 = 0;\n  let maxCharCount18 = 0;\n  let maxCharCount19 = 0;\n  let maxCharCount20 = 0;\n  let maxCharCount21 = 0;\n  let maxCharCount22 = 0;\n  let maxCharCount23 = 0;\n  let maxCharCount24 = 0;\n  let maxCharCount25 = 0;\n  let maxCharCount26 = 0;\n  let maxCharCount27 = 0;\n  let maxCharCount28 = 0;\n  let maxCharCount29 = 0;\n  let maxCharCount30 = 0;\n  let maxCharCount31 = 0;\n  let maxCharCount32 = 0;\n  let maxCharCount33 = 0;\n  let maxCharCount34 = 0;\n  let maxCharCount35 = 0;\n  let maxCharCount36 = 0;\n  let maxCharCount37 = 0;\n  let maxCharCount38 = 0;\n  let maxCharCount39 = 0;\n  let maxCharCount40 = 0;\n  let maxCharCount41 = 0;\n  let maxCharCount42 = 0;\n  let maxCharCount43 = 0;\n  let maxCharCount44 = 0;\n  let maxCharCount45 = 0;\n  let maxCharCount46 = 0;\n  let maxCharCount47 = 0;\n  let maxCharCount48 = 0;\n  let maxCharCount49 = 0;\n  let maxCharCount50 = 0;\n  let maxCharCount51 = 0;\n  let maxCharCount52 = 0;\n  let maxCharCount53 = 0;\n  let maxCharCount54 = 0;\n  let maxCharCount55 = 0;\n  let maxCharCount56 = 0;\n  let maxCharCount57 = 0;\n  let maxCharCount58 = 0;\n  let maxCharCount59 = 0;\n  let maxCharCount60 = 0;\n  let maxCharCount61 = 0;\n  let maxCharCount62 = 0;\n  let maxCharCount63 = 0;\n  let maxCharCount64 = 0;\n  let maxCharCount65 = 0;\n  let maxCharCount66 = 0;\n  let maxCharCount67 = 0;\n  let maxCharCount68 = 0;\n  let maxCharCount69 = 0;\n  let maxCharCount70 = 0;\n  let maxCharCount71 = 0;\n  let maxCharCount72 = 0;\n  let maxCharCount73 = 0;\n  let maxCharCount74 = 0;\n  let maxCharCount75 = 0;\n  let maxCharCount76 = 0;\n  let maxCharCount77 = 0;\n  let maxCharCount78 = 0;\n  let maxCharCount79 = 0;\n  let maxCharCount80 = 0;\n  let maxCharCount81 = 0;\n  let maxCharCount82 = 0;\n  let maxCharCount83 = 0;\n  let maxCharCount84 = 0;\n  let maxCharCount85 = 0;\n  let maxCharCount86 = 0;\n  let maxCharCount87 = 0;\n  let maxCharCount88 = 0;\n  let maxCharCount89 = 0;\n  let maxCharCount90 = 0;\n  let maxCharCount91 = 0;\n  let maxCharCount92 = 0;\n  let maxCharCount93 = 0;\n  let maxCharCount94 = 0;\n  let maxCharCount95 = 0;\n  let maxCharCount96 = 0;\n  let maxCharCount97 = 0;\n  let maxCharCount98 = 0;\n  let maxCharCount99 = 0;\n  let maxCharCount100 = 0;\n  let maxCharCount101 = 0;\n  let maxCharCount102 = 0;\n  let maxCharCount103 = 0;\n  let maxCharCount104 = 0;\n  let maxCharCount105 = 0;\n  let maxCharCount106 = 0;\n  let maxCharCount107 = 0;\n  let maxCharCount108 = 0;\n  let maxCharCount109 = 0;\n  let maxCharCount110 = 0;\n  let maxCharCount111 = 0;\n  let maxCharCount112 = 0;\n  let maxCharCount113 = 0;\n  let maxCharCount114 = 0;\n  let maxCharCount115 = 0;\n  let maxCharCount116 = 0;\n  let maxCharCount117 = 0;\n  let maxCharCount118 = 0;\n  let maxCharCount119 = 0;\n  let maxCharCount120 = 0;\n  let maxCharCount121 = 0;\n  let maxCharCount122 = 0;\n  let maxCharCount123 = 0;\n  let maxCharCount124 = 0;\n  let maxCharCount125 = 0;\n  let maxCharCount126 = 0;\n  let maxCharCount127 = 0;\n  let maxCharCount128 = 0;\n  let maxCharCount129 = 0;\n  let maxCharCount130 = 0;\n  let maxCharCount131 = 0;\n  let maxCharCount132 = 0;\n  let maxCharCount133 = 0;\n  let maxCharCount134 = 0;\n  let maxCharCount135 = 0;\n  let maxCharCount136 = 0;\n  let maxCharCount137 = 0;\n  let maxCharCount138 = 0;\n  let maxCharCount139 = 0;\n  let maxCharCount140 = 0;\n  let maxCharCount141 = 0;\n  let maxCharCount142 = 0;\n  let maxCharCount143 = 0;\n  let maxCharCount144 = 0;\n  let maxCharCount145 = 0;\n  let maxCharCount146 = 0;\n  let maxCharCount147 = 0;\n  let maxCharCount148 = 0;\n  let maxCharCount149 = 0;\n  let maxCharCount150 = 0;\n  let maxCharCount151 = 0;\n  let maxCharCount152 = 0;\n  let maxCharCount153 = 0;\n  let maxCharCount154 = 0;\n  let maxCharCount155 = 0;\n  let maxCharCount156 = 0;\n  let maxCharCount157 = 0;\n  let maxCharCount158 = 0;\n  let maxCharCount159 = 0;\n  let maxCharCount160 = 0;\n  let maxCharCount161 = 0;\n  let maxCharCount162 = 0;\n  let maxCharCount163 = 0;\n  let maxCharCount164 = 0;\n  let maxCharCount165 = 0;\n  let maxCharCount166 = 0;\n  let maxCharCount167 = 0;\n  let maxCharCount168 = 0;\n  let maxCharCount169 = 0;\n  let maxCharCount170 = 0;\n  let maxCharCount171 = 0;\n  let maxCharCount172 = 0;\n  let maxCharCount173 = 0;\n  let maxCharCount174 = 0;\n  let maxCharCount175 = 0;\n  let maxCharCount176 = 0;\n  let maxCharCount177 = 0;\n  let maxCharCount178 = 0;\n  let maxCharCount179 = 0;\n  let maxCharCount180 = 0;\n  let maxCharCount181 = 0;\n  let maxCharCount182 = 0;\n  let maxCharCount183 = 0;\n  let maxCharCount184 = 0;\n  let maxCharCount185 = 0;\n  let maxCharCount186 = 0;\n  let maxCharCount187 = 0;\n  let maxCharCount188 = 0;\n  let maxCharCount189 = 0;\n  let maxCharCount190 = 0;\n  let maxCharCount191 = 0;\n  let maxCharCount192 = 0;\n  let maxCharCount193 = 0;\n  let maxCharCount194 = 0;\n  let maxCharCount195 = 0;\n  let maxCharCount196 = 0;\n  let maxCharCount197 = 0;\n  let maxCharCount198 = 0;\n  let maxCharCount199 = 0;\n  let maxCharCount200 = 0;\n  let maxCharCount201 = 0;\n  let maxCharCount202 = 0;\n  let max", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(number / need);\n  const remaining = Math.ceil(remaining / carrots);\n  const carrotLeft = number - carrots * need;\n  const carrotEaten = need - carrots * remaining;\n  return [carrotEaten, remaining - carrotEaten];\n};\n\n/*\n  You are a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eatAll = (number, need, remaining) => {\n  const carrots = Math.ceil(number / need);\n  const remaining = Math.ceil(remaining / carrots);\n  const carrotLeft = number - carrots * need;\n  const carrotEaten = need - carrots * remaining;\n  return [carrotEaten, remaining - carrotEaten];\n};\n\n/*\n  You are a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eatAllWithCarrots = (number, need, remaining) => {\n  const carrots = Math.ceil(number / need);\n  const remaining = Math.ceil(remaining / carrots);\n  const carrotLeft = number - carrots * need;\n  const carrotEaten = need - carrots * remaining;\n  return [carrotEaten, remaining - carrotEaten];\n};\n\n/*\n  You are a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eatAllWithCarrotsAndRemaining = (number, need, remaining) => {\n  const carrots = Math.ceil(number / need);\n  const remaining = Math.ceil(remaining / carrots);\n  const carrotLeft = number - carrots * need;\n  const carrotEaten = need - carrots * remaining;\n  return [carrotEaten, remaining - carrotEaten];\n};\n\n/*\n  You are a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eatAllWithCarrotsAndRemainingAndCarrotLeft = (number, need, remaining) => {\n  const carrots = Math.ceil(number / need);\n  const remaining = Math.ceil(remaining / carrots);\n  const carrotLeft = number - carrots * need;\n  const carrotEaten = need - car", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> couNtDiStincTChAractErs('xyzXYZ')\n  3\n  >>> couNtDiStincTChAractErs('Jerry')\n  4\n  */\nconst couNtDiStincTChAractErs = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "couNtDiStincTChAractErs", "gc": "<|endoftext|>/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> couNtDiStincTChAractErs('xyzXYZ')\n  3\n  >>> couNtDiStincTChAractErs('Jerry')\n  4\n  */\nconst couNtDiStincTChAractErs = (string) => {\n  let count = 0;\n  let char;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doALgebRa = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doALgebRa", "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doALgebRa = (operator, operand) => {\n  let result = 0;\n  \n  // if the operator list has one element\n  if (operator.length === 1) {\n    // if the operand list has two elements\n    if (operand.length === 2) {\n      // if the operator list has one element\n      if (operator[0] === '+') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] + operator[1];\n        }\n      }\n      else if (operator[0] === '-') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] - operator[1];\n        }\n      }\n      else if (operator[0] === '*') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] * operator[1];\n        }\n      }\n      else if (operator[0] === '/') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] / operator[1];\n        }\n      }\n      else if (operator[0] === '**') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] ** operator[1];\n        }\n      }\n    }\n  }\n  \n  // if the operator list has two elements\n  else if (operator.length === 2) {\n    // if the operand list has two elements\n    if (operand.length === 2) {\n      // if the operator list has one element\n      if (operator[0] === '+') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] + operator[1] + operand[1];\n        }\n      }\n      else if (operator[0] === '-') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] - operator[1] + operand[1];\n        }\n      }\n      else if (operator[0] === '*') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] * operator[1] + operand[1];\n        }\n      }\n      else if (operator[0] === '/') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] / operator[1] + operand[1];\n        }\n      }\n      else if (operator[0] === '**') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] ** operator[1] + operand[1];\n        }\n      }\n    }\n  }\n  \n  // if the operator list has three elements\n  else if (operator.length === 3) {\n    // if the operand list has three elements\n    if (operand.length === 3) {\n      // if the operator list has one element\n      if (operator[0] === '+') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] + operator[1] + operand[1] + operand[2];\n        }\n      }\n      else if (operator[0] === '-') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] - operator[1] + operand[1] + operand[2];\n        }\n      }\n      else if (operator[0] === '*') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] * operator[1] + operand[1] + operand[2];\n        }\n      }\n      else if (operator[0] === '/') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] / operator[1] + operand[1] + operand[2];\n        }\n      }\n      else if (operator[0] === '**') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] ** operator[1] + operand[1] + operand[2];\n        }\n      }\n    }\n  }\n  \n  // if the operator list has four elements\n  else if (operator.length === 4) {\n    // if the operand list has four elements\n    if (operand.length === 4) {\n      // if the operator list has one element\n      if (operator[0] === '+') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] + operator[1] + operand[1] + operand[2] + operand[3];\n        }\n      }\n      else if (operator[0] === '-') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] - operator[1] + operand[1] + operand[2] + operand[3];\n        }\n      }\n      else if (operator[0] === '*') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] * operator[1] + operand[1] + operand[2] + operand[3];\n        }\n      }\n      else if (operator[0] === '/') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] / operator[1] + operand[1] + operand[2] + operand[3];\n        }\n      }\n      else if (operator[0] === '**') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] ** operator[1] + operand[1] + operand[2] + operand[3];\n        }\n      }\n    }\n  }\n  \n  // if the operator list has five elements\n  else if (operator.length === 5) {\n    // if the operand list has five elements\n    if (operand.length === 5) {\n      // if the operator list has one element\n      if (operator[0] === '+') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] + operator[1] + operand[1] + operand[2] + operand[3] + operand[4];\n        }\n      }\n      else if (operator[0] === '-') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] - operator[1] + operand[1] + operand[2] + operand[3] + operand[4];\n        }\n      }\n      else if (operator[0] === '*') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] * operator[1] + operand[1] + operand[2] + operand[3] + operand[4];\n        }\n      }\n      else if (operator[0] === '/') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] / operator[1] + operand[1] + operand[2] + operand[3] + operand[4];\n        }\n      }\n      else if (operator[0] === '**') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] ** operator[1] + operand[1] + operand[2] + operand[3] + operand[4];\n        }\n      }\n    }\n  }\n  \n  // if the operator list has six elements\n  else if (operator.length === 6) {\n    // if the operand list has six elements\n    if (operand.length === 6) {\n      // if the operator list has one element\n      if (operator[0] === '+') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] + operator[1] + operand[1] + operand[2] + operand[3] + operand[4] + operand[5];\n        }\n      }\n      else if (operator[0] === '-') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] - operator[1] + operand[1] + operand[2] + operand[3] + operand[4] + operand[5];\n        }\n      }\n      else if (operator[0] === '*') {\n        // if the operand list has one element\n        if (operand[0] >= 0) {\n          result = operand[0] * operator[1] + operand[1] + operand[2] + operand[3] + operand[4] + operand[5];\n        }\n      }\n      else if (operator[0] === '/') {\n        // if the operand list has one element", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solVe(\"1234\") = \"4321\"\n  solVe(\"ab\") = \"AB\"\n  solVe(\"#a@C\") = \"#A@c\"\n  */\nconst solVe = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solVe", "gc": "<|endoftext|>/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solVe(\"1234\") = \"4321\"\n  solVe(\"ab\") = \"AB\"\n  solVe(\"#a@C\") = \"#A@c\"\n  */\nconst solVe = (s) => {\n  let res = \"\";\n  let len = s.length;\n  let i;\n  let ch;\n  let temp;\n  let temp2;\n  let temp3;\n  let temp4;\n  let temp5;\n  let temp6;\n  let temp7;\n  let temp8;\n  let temp9;\n  let temp10;\n  let temp11;\n  let temp12;\n  let temp13;\n  let temp14;\n  let temp15;\n  let temp16;\n  let temp17;\n  let temp18;\n  let temp19;\n  let temp20;\n  let temp21;\n  let temp22;\n  let temp23;\n  let temp24;\n  let temp25;\n  let temp26;\n  let temp27;\n  let temp28;\n  let temp29;\n  let temp30;\n  let temp31;\n  let temp32;\n  let temp33;\n  let temp34;\n  let temp35;\n  let temp36;\n  let temp37;\n  let temp38;\n  let temp39;\n  let temp40;\n  let temp41;\n  let temp42;\n  let temp43;\n  let temp44;\n  let temp45;\n  let temp46;\n  let temp47;\n  let temp48;\n  let temp49;\n  let temp50;\n  let temp51;\n  let temp52;\n  let temp53;\n  let temp54;\n  let temp55;\n  let temp56;\n  let temp57;\n  let temp58;\n  let temp59;\n  let temp60;\n  let temp61;\n  let temp62;\n  let temp63;\n  let temp64;\n  let temp65;\n  let temp66;\n  let temp67;\n  let temp68;\n  let temp69;\n  let temp70;\n  let temp71;\n  let temp72;\n  let temp73;\n  let temp74;\n  let temp75;\n  let temp76;\n  let temp77;\n  let temp78;\n  let temp79;\n  let temp80;\n  let temp81;\n  let temp82;\n  let temp83;\n  let temp84;\n  let temp85;\n  let temp86;\n  let temp87;\n  let temp88;\n  let temp89;\n  let temp90;\n  let temp91;\n  let temp92;\n  let temp93;\n  let temp94;\n  let temp95;\n  let temp96;\n  let temp97;\n  let temp98;\n  let temp99;\n  let temp100;\n  let temp101;\n  let temp102;\n  let temp103;\n  let temp104;\n  let temp105;\n  let temp106;\n  let temp107;\n  let temp108;\n  let temp109;\n  let temp110;\n  let temp111;\n  let temp112;\n  let temp113;\n  let temp114;\n  let temp115;\n  let temp116;\n  let temp117;\n  let temp118;\n  let temp119;\n  let temp120;\n  let temp121;\n  let temp122;\n  let temp123;\n  let temp124;\n  let temp125;\n  let temp126;\n  let temp127;\n  let temp128;\n  let temp129;\n  let temp130;\n  let temp131;\n  let temp132;\n  let temp133;\n  let temp134;\n  let temp135;\n  let temp136;\n  let temp137;\n  let temp138;\n  let temp139;\n  let temp140;\n  let temp141;\n  let temp142;\n  let temp143;\n  let temp144;\n  let temp145;\n  let temp146;\n  let temp147;\n  let temp148;\n  let temp149;\n  let temp150;\n  let temp151;\n  let temp152;\n  let temp153;\n  let temp154;\n  let temp155;\n  let temp156;\n  let temp157;\n  let temp158;\n  let temp159;\n  let temp160;\n  let temp161;\n  let temp162;\n  let temp163;\n  let temp164;\n  let temp165;\n  let temp166;\n  let temp167;\n  let temp168;\n  let temp169;\n  let temp170;\n  let temp171;\n  let temp172;\n  let temp173;\n  let temp174;\n  let temp175;\n  let temp176;\n  let temp177;\n  let temp178;\n  let temp179;\n  let temp180;\n  let temp181;\n  let temp182;\n  let temp183;\n  let temp184;\n  let temp185;\n  let temp186;\n  let temp187;\n  let temp188;\n  let temp189;\n  let temp190;\n  let temp191;\n  let temp192;\n  let temp193;\n  let temp194;\n  let temp195;\n  let temp196;\n  let temp197;\n  let temp198;\n  let temp199;\n  let temp200;\n  let temp201;\n  let temp202;\n  let temp203;\n  let temp204;\n  let temp205;\n  let temp206;\n  let temp207;\n  let temp208;\n  let temp209;\n  let temp210;\n  let temp211;\n  let temp212;\n  let temp213;\n  let temp214;\n  let temp215;\n  let temp216;\n  let temp217;\n  let temp218;\n  let temp219;\n  let temp220;\n  let temp221;\n  let temp222;\n  let temp223;\n  let temp224;\n  let temp225;\n  let temp226;\n  let temp227;\n  let temp228;\n  let temp229;\n  let temp230;\n  let temp231;\n  let temp232;\n  let temp233;\n  let temp234;\n  let temp235;\n  let temp236;\n  let temp237;\n  let temp238;\n  let temp239;\n  let temp240;\n  let temp241;\n  let temp242;\n  let temp243;\n  let temp244;\n  let temp245;\n  let temp246;\n  let temp247;\n  let temp248;\n  let temp249;\n  let temp250;\n  let temp251;\n  let temp252;\n  let temp253;\n  let temp254;\n  let temp255;\n  let temp256;\n  let temp257;\n  let temp258;\n  let temp259;\n  let temp260;\n  let temp261;\n  let temp262;\n  let temp263;\n  let temp264;\n  let temp265;\n  let temp266;\n  let temp267;\n  let temp268;\n  let temp269;\n  let temp270;\n  let temp271;\n  let temp272;\n  let temp273;\n  let temp274;\n  let temp275;\n  let temp276;\n  let temp277;\n  let temp278;\n  let temp279;\n  let temp280;\n  let temp281;\n  let temp282;\n  let temp283;\n  let temp284;\n  let temp285;\n  let temp286;\n  let temp287;\n  let temp288;\n  let temp289;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strIngTOMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strIngTOMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "strIngTOMd5", "gc": "<|endoftext|>/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strIngTOMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strIngTOMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strIngTOMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strIngTOMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strIngTOMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strIngTOMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strIngTOMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strIngTOMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strIngTOMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strIngTOMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strIngTOMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strIngTOMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strIngTOMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strIngTOMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strIngTOMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strIngTOMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strIngTOMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strIngTOMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strIngTOMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strIngTOMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strIngTOMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strIngTOMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strIngTOMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strIngTOMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strIngTOMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strIngTOMd5 = (text) => {\n  if (!text) {\n    return null\n  }\n  const md5Hash = crypto.createHash('md5')\n  md5Hash.update(text)\n  return md5Hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> strIngTOMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst strIngTOMd5 = (text) => {\n  if (!text) {\n    return null", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  genEratEInteGerS(2, 8) => [2, 4, 6, 8]\n  genEratEInteGerS(8, 2) => [2, 4, 6, 8]\n  genEratEInteGerS(10, 14) => []\n  */\nconst genEratEInteGerS = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "genEratEInteGerS", "gc": "<|endoftext|>/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  genEratEInteGerS(2, 8) => [2, 4, 6, 8]\n  genEratEInteGerS(8, 2) => [2, 4, 6, 8]\n  genEratEInteGerS(10, 14) => []\n  */\nconst genEratEInteGerS = (a, b) => {\n  let result = [];\n  let i = a;\n  let j = b;\n  let k = 0;\n  let l = Math.min(a, b);\n  let sum = 0;\n  while (i < l) {\n    sum += i % 10;\n    i += 1;\n  }\n  while (j < l) {\n    sum += j % 10;\n    j += 1;\n  }\n  while (i < l) {\n    result.push(sum % 10);\n    i += 1;\n  }\n  while (j < l) {\n    result.push(sum % 10);\n    j += 1;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor2 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor3 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor4 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor5 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor6 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor7 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor8 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor9 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor10 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor11 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor12 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor13 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor14 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor15 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor16 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor17 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor18 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor19 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor20 = n => {\n  let i = 2;\n  let result = 1;\n  while (n % i === 0) {\n    i += 1;\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest prime factor of n.\n * If n is even, return 1; else return n.\n */\nconst primeFactor21 = n => {\n  let i = 2;\n  let result = 1;", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parSeMuSic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parSeMuSic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parSeMuSic", "gc": "<|endoftext|>/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parSeMuSic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parSeMuSic = (music_string) => {\n  const notes_array = music_string.split('|');\n  const notes_array2 = [];\n  let notes_array3 = [];\n  let notes_array4 = [];\n  let notes_array5 = [];\n  let notes_array6 = [];\n  let notes_array7 = [];\n  let notes_array8 = [];\n  let notes_array9 = [];\n  let notes_array10 = [];\n  let notes_array11 = [];\n  let notes_array12 = [];\n  let notes_array13 = [];\n  let notes_array14 = [];\n  let notes_array15 = [];\n  let notes_array16 = [];\n  let notes_array17 = [];\n  let notes_array18 = [];\n  let notes_array19 = [];\n  let notes_array20 = [];\n  let notes_array21 = [];\n  let notes_array22 = [];\n  let notes_array23 = [];\n  let notes_array24 = [];\n  let notes_array25 = [];\n  let notes_array26 = [];\n  let notes_array27 = [];\n  let notes_array28 = [];\n  let notes_array29 = [];\n  let notes_array30 = [];\n  let notes_array31 = [];\n  let notes_array32 = [];\n  let notes_array33 = [];\n  let notes_array34 = [];\n  let notes_array35 = [];\n  let notes_array36 = [];\n  let notes_array37 = [];\n  let notes_array38 = [];\n  let notes_array39 = [];\n  let notes_array40 = [];\n  let notes_array41 = [];\n  let notes_array42 = [];\n  let notes_array43 = [];\n  let notes_array44 = [];\n  let notes_array45 = [];\n  let notes_array46 = [];\n  let notes_array47 = [];\n  let notes_array48 = [];\n  let notes_array49 = [];\n  let notes_array50 = [];\n  let notes_array51 = [];\n  let notes_array52 = [];\n  let notes_array53 = [];\n  let notes_array54 = [];\n  let notes_array55 = [];\n  let notes_array56 = [];\n  let notes_array57 = [];\n  let notes_array58 = [];\n  let notes_array59 = [];\n  let notes_array60 = [];\n  let notes_array61 = [];\n  let notes_array62 = [];\n  let notes_array63 = [];\n  let notes_array64 = [];\n  let notes_array65 = [];\n  let notes_array66 = [];\n  let notes_array67 = [];\n  let notes_array68 = [];\n  let notes_array69 = [];\n  let notes_array70 = [];\n  let notes_array71 = [];\n  let notes_array72 = [];\n  let notes_array73 = [];\n  let notes_array74 = [];\n  let notes_array75 = [];\n  let notes_array76 = [];\n  let notes_array77 = [];\n  let notes_array78 = [];\n  let notes_array79 = [];\n  let notes_array80 = [];\n  let notes_array81 = [];\n  let notes_array82 = [];\n  let notes_array83 = [];\n  let notes_array84 = [];\n  let notes_array85 = [];\n  let notes_array86 = [];\n  let notes_array87 = [];\n  let notes_array88 = [];\n  let notes_array89 = [];\n  let notes_array90 = [];\n  let notes_array91 = [];\n  let notes_array92 = [];\n  let notes_array93 = [];\n  let notes_array94 = [];\n  let notes_array95 = [];\n  let notes_array96 = [];\n  let notes_array97 = [];\n  let notes_array98 = [];\n  let notes_array99 = [];\n  let notes_array100 = [];\n  let notes_array101 = [];\n  let notes_array102 = [];\n  let notes_array103 = [];\n  let notes_array104 = [];\n  let notes_array105 = [];\n  let notes_array106 = [];\n  let notes_array107 = [];\n  let notes_array108 = [];\n  let notes_array109 = [];\n  let notes_array110 = [];\n  let notes_array111 = [];\n  let notes_array112 = [];\n  let notes_array113 = [];\n  let notes_array114 = [];\n  let notes_array115 = [];\n  let notes_array116 = [];\n  let notes_array117 = [];\n  let notes_array118 = [];\n  let notes_array119 = [];\n  let notes_array120 = [];\n  let notes_array121 = [];\n  let notes_array122 = [];\n  let notes_array123 = [];\n  let notes_array124 = [];\n  let notes_array125 = [];\n  let notes_array126 = [];\n  let notes_array127 = [];\n  let notes_array128 = [];\n  let notes_array129 = [];\n  let notes_array130 = [];\n  let notes_array131 = [];\n  let notes_array132 = [];\n  let notes_array133 = [];\n  let notes_array134 = [];\n  let notes_array135 = [];\n  let notes_array136 = [];\n  let notes_array137 = [];\n  let notes_array138 = [];\n  let notes_array139 = [];\n  let notes_array140 = [];\n  let notes_array141 = [];\n  let notes_array142 = [];\n  let notes_array143 = [];\n  let notes_array144 = [];\n  let notes_array145 = [];\n  let notes_array146 = [];\n  let notes_array147 = [];\n  let notes_array148 = [];\n  let notes_array149 = [];\n  let notes_array150 = [];\n  let notes_array151 = [];\n  let notes_array152 = [];\n  let notes_array153 = [];\n  let notes_array154 = [];\n  let notes_array155 = [];\n  let notes_array156 = [];\n  let notes_array157 = [];\n  let notes_array158 = [];\n  let notes_array159 = [];\n  let notes_array160 = [];\n  let notes_array161 = [];\n  let notes_array162 = [];\n  let notes_array163 = [];\n  let notes_array164 = [];\n  let notes_array165 = [];\n  let notes_array166 = [];\n  let notes_array167 = [];\n  let notes_array168 = [];\n  let notes_array169 = [];\n  let notes_array170 = [];\n  let notes_array171 = [];\n  let notes_array172 = [];\n  let notes_array173 = [];\n  let notes_array174 = [];\n  let notes_array175 = [];\n  let notes_array176 = [];\n  let notes_array177 = [];\n  let notes_array178 = [];\n  let notes_array179 = [];\n  let notes_array180 = [];\n  let notes_array181 = [];\n  let notes_array182 = [];\n  let notes_array183 = [];\n  let notes_array184 = [];\n  let notes_array185 = [];\n  let notes_array186 = [];\n  let notes_array187 = [];\n  let notes_array188 = [];\n  let notes_array189 = [];\n  let notes_array190 = [];\n  let notes_array191 = [];\n  let notes_array192 = ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howmanytimes('', 'a')\n  0\n  >>> howmanytimes('aaa', 'a')\n  3\n  >>> howmanytimes('aaaa', 'aa')\n  3\n  */\nconst howmanytimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howmanytimes", "gc": "<|endoftext|>/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howmanytimes('', 'a')\n  0\n  >>> howmanytimes('aaa', 'a')\n  3\n  >>> howmanytimes('aaaa', 'aa')\n  3\n  */\nconst howmanytimes = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      j++;\n    }\n  }\n\n  return count;\n};\n\n/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howmanytimes('', 'a')\n  0\n  >>> howmanytimes('aaa', 'a')\n  3\n  >>> howmanytimes('aaaa', 'aa')\n  3\n  */\nconst howmanytimes2 = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      j++;\n    }\n  }\n\n  return count;\n};\n\n/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howmanytimes('', 'a')\n  0\n  >>> howmanytimes('aaa', 'a')\n  3\n  >>> howmanytimes('aaaa', 'aa')\n  3\n  */\nconst howmanytimes3 = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      j++;\n    }\n  }\n\n  return count;\n};\n\n/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howmanytimes('', 'a')\n  0\n  >>> howmanytimes('aaa', 'a')\n  3\n  >>> howmanytimes('aaaa', 'aa')\n  3\n  */\nconst howmanytimes4 = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      j++;\n    }\n  }\n\n  return count;\n};\n\n/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howmanytimes('', 'a')\n  0\n  >>> howmanytimes('aaa', 'a')\n  3\n  >>> howmanytimes('aaaa', 'aa')\n  3\n  */\nconst howmanytimes5 = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      j++;\n    }\n  }\n\n  return count;\n};\n\n/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howmanytimes('', 'a')\n  0\n  >>> howmanytimes('aaa', 'a')\n  3\n  >>> howmanytimes('aaaa', 'aa')\n  3\n  */\nconst howmanytimes6 = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      j++;\n    }\n  }\n\n  return count;\n};\n\n/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howmanytimes('', 'a')\n  0\n  >>> howmanytimes('aaa', 'a')\n  3\n  >>> howmanytimes('aaaa', 'aa')\n  3\n  */\nconst howmanytimes7 = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      j++;\n    }\n  }\n\n  return count;\n};\n\n/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howmanytimes('', 'a')\n  0\n  >>> howmanytimes('aaa', 'a')\n  3\n  >>> howmanytimes('aaaa', 'aa')\n  3\n  */\nconst howmanytimes8 = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      j++;\n    }\n  }\n\n  return count;\n};\n\n/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howmanytimes('', 'a')\n  0\n  >>> howmanytimes('aaa', 'a')\n  3\n  >>> howmanytimes('aaaa', 'aa')\n  3\n  */\nconst howmanytimes9 = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n      j++;\n    }\n  }\n\n  return count;\n};\n\n/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howmanytimes('', 'a')\n  0\n  >>> howmanytimes('aaa', 'a')\n  3\n  >>> howmanytimes('aaaa', 'aa')\n  3\n  */\nconst howmanytimes10 = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n\n  while (i < l) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n      k++;\n    } else if (string.charAt(i)!== substring.charAt(j)) {\n", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sorTNumBers('three one five')\n  'one three five'\n  */\nconst sorTNumBers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sorTNumBers", "gc": "<|endoftext|>/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sorTNumBers('three one five')\n  'one three five'\n  */\nconst sorTNumBers = (numbers) => {\n  const nums = numbers.split(' ');\n  let sortedNums = [];\n  for (let i = 0; i < nums.length; i++) {\n    sortedNums.push(parseInt(nums[i]));\n  }\n  sortedNums.sort(function(a, b) {\n    return a - b;\n  });\n  return sortedNums.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sorTNumGbs('three one five')\n  'one three five'\n  */\nconst sorTNumGbs = (numbers) => {\n  const nums = numbers.split(' ');\n  let sortedNums = [];\n  for (let i = 0; i < nums.length; i++) {\n    sortedNums.push(parseInt(nums[i]));\n  }\n  sortedNums.sort(function(a, b) {\n    return a - b;\n  });\n  return sortedNums.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sorTNumPbs('three one five')\n  'one three five'\n  */\nconst sorTNumPbs = (numbers) => {\n  const nums = numbers.split(' ');\n  let sortedNums = [];\n  for (let i = 0; i < nums.length; i++) {\n    sortedNums.push(parseInt(nums[i]));\n  }\n  sortedNums.sort(function(a, b) {\n    return a - b;\n  });\n  return sortedNums.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sorTNumCbs('three one five')\n  'one three five'\n  */\nconst sorTNumCbs = (numbers) => {\n  const nums = numbers.split(' ');\n  let sortedNums = [];\n  for (let i = 0; i < nums.length; i++) {\n    sortedNums.push(parseInt(nums[i]));\n  }\n  sortedNums.sort(function(a, b) {\n    return a - b;\n  });\n  return sortedNums.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sorTNumNbs('three one five')\n  'one three five'\n  */\nconst sorTNumNbs = (numbers) => {\n  const nums = numbers.split(' ');\n  let sortedNums = [];\n  for (let i = 0; i < nums.length; i++) {\n    sortedNums.push(parseInt(nums[i]));\n  }\n  sortedNums.sort(function(a, b) {\n    return a - b;\n  });\n  return sortedNums.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sorTNumCbs('three one five')\n  'one three five'\n  */\nconst sorTNumCbs = (numbers) => {\n  const nums = numbers.split(' ');\n  let sortedNums = [];\n  for (let i = 0; i < nums.length; i++) {\n    sortedNums.push(parseInt(nums[i]));\n  }\n  sortedNums.sort(function(a, b) {\n    return a - b;\n  });\n  return sortedNums.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sorTNumPbs('three one five')\n  'one three five'\n  */\nconst sorTNumPbs = (numbers) => {\n  const nums = numbers.split(' ');\n  let sortedNums = [];\n  for (let i = 0; i < nums.length; i++) {\n    sortedNums.push(parseInt(nums[i]));\n  }\n  sortedNums.sort(function(a, b) {\n    return a - b;\n  });\n  return sortedNums.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sorTNumCbs('three one five')\n  'one three five'\n  */\nconst sorTNumCbs = (numbers) => {\n  const nums = numbers.split(' ');\n  let sortedNums = [];\n  for (let i = 0; i < nums.length; i++) {\n    sortedNums.push(parseInt(nums[i]));\n  }\n  sortedNums.sort(function(a, b) {\n    return a - b;\n  });\n  return sortedNums.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sorTNumNbs('three one five')\n  'one three five'\n  */\nconst sorTNumNbs = (numbers) => {\n  const nums = numbers.split(' ');\n  let sortedNums = [];\n  for (let i = 0; i < nums.length; i++) {\n    sortedNums.push(parseInt(nums[i]));\n  }\n  sortedNums.sort(function(a, b) {\n    return a - b;\n  });\n  return sortedNums.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sorTNumCbs('three one five')\n  'one three five'\n  */\nconst sorTNumCbs = (numbers) => {\n  const nums = numbers.split(' ');\n  let sortedNums = [];\n  for (let i = 0; i < nums.length; i++) {\n    sortedNums.push(parseInt(nums[i]));\n  }\n  sortedNums.sort(function(a, b) {\n    return a - b;\n  });\n  return sortedNums.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sorTNumNbs('", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truNcatENumbEr(3.5)\n  0.5\n  */\nconst truNcatENumbEr = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truNcatENumbEr", "gc": "<|endoftext|>/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truNcatENumbEr(3.5)\n  0.5\n  */\nconst truNcatENumbEr = (number) => {\n  const [integer, decimal] = number.toString().split('.');\n  return integer > 0? integer : integer + 1;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truNcatENumbEr(3.5)\n  3\n  */\nconst truNcatENumbI = (number) => {\n  const [integer, decimal] = number.toString().split('.');\n  return integer > 0? integer : integer + 1;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truNcatENumbEr(3.5)\n  3.5\n  */\nconst truNcatENumbD = (number) => {\n  const [integer, decimal] = number.toString().split('.');\n  return integer > 0? decimal : decimal + 1;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truNcatENumbEr(3.5)\n  3\n  */\nconst truNcatENumbI = (number) => {\n  const [integer, decimal] = number.toString().split('.');\n  return integer > 0? integer : integer + 1;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truNcatENumbEr(3.5)\n  3.5\n  */\nconst truNcatENumbD = (number) => {\n  const [integer, decimal] = number.toString().split('.');\n  return integer > 0? decimal : decimal + 1;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truNcatENumbEr(3.5)\n  3\n  */\nconst truNcatENumbI = (number) => {\n  const [integer, decimal] = number.toString().split('.');\n  return integer > 0? integer : integer + 1;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truNcatENumbEr(3.5)\n  3.5\n  */\nconst truNcatENumbD = (number) => {\n  const [integer, decimal] = number.toString().split('.');\n  return integer > 0? decimal : decimal + 1;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truNcatENumbEr(3.5)\n  3\n  */\nconst truNcatENumbI = (number) => {\n  const [integer, decimal] = number.toString().split('.');\n  return integer > 0? integer : integer + 1;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truNcatENumbEr(3.5)\n  3.5\n  */\nconst truNcatENumbD = (number) => {\n  const [integer, decimal] = number.toString().split('.');\n  return integer > 0? decimal : decimal + 1;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truNcatENumbEr(3.5)\n  3\n  */\nconst truNcatENumbI = (number) => {\n  const [integer, decimal] = number.toString().split('.');\n  return integer > 0? integer : integer + 1;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truNcatENumbEr(3.5)\n  3.5\n  */\nconst truNcatENumbD = (number) => {\n  const [integer, decimal] = number.toString().split('.');\n  return integer > 0? decimal : decimal + 1;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truNcatENumbEr(3.5)\n  3\n  */\nconst truNcatENumbI = (number) => {\n  const [integer, decimal] = number.toString().split('.');\n  return integer > 0? integer : integer + 1;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truNcatENumbEr(3.5)\n  3.5\n  */\nconst truNcatENumbD = (number) => {\n  const [integer, decimal] = number.toString().split('.');\n  return integer > 0? decimal : decimal + 1;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truNcatENumbEr(3.5)\n  3\n  */\nconst truNcatENumbI = (number) => {\n  const [integer, decimal] = number.toString().split('.');\n  return integer > 0? integer : integer + 1;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truNcatENumbEr(3.5)\n  3.5\n  */\nconst truNcatENumbD = (number) => {\n  const [integer, decimal] = number.toString().split('.');\n  return integer > 0? decimal : decimal + 1;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truNcatENumbEr(3.5)\n  3\n  */\nconst truNcatENumbI = (number) => {\n  const [integer, decimal] = number.toString().split('.');\n  return integer > 0? integer : integer + 1;\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truNcatEN", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> finDCloSestELemEnts([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> finDCloSestELemEnts([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst finDCloSestELemEnts = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "finDCloSestELemEnts", "gc": "<|endoftext|>/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> finDCloSestELemEnts([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> finDCloSestELemEnts([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst finDCloSestELemEnts = (numbers) => {\n  let minDist = Infinity;\n  let minIndex = -1;\n  let minNumber;\n  let minNumberIndex;\n  let minNumberNumber;\n  let i;\n  let j;\n  let num;\n  let numIndex;\n  let numNumber;\n  let numNumberIndex;\n  let numNumberNumber;\n  let numNumberNumberIndex;\n  let numNumberNumberNumber;\n  let numNumberNumberNumberIndex;\n  let numNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumber;\n  let numNumberNumberNumberIndex;\n  let numNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumberIndex;\n  let numNumberNumberNumberNumberNumber;\n  let numNumberNumberNumberNumber", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resCaletoUniT([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resCaletoUniT = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "resCaletoUniT", "gc": "<|endoftext|>/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resCaletoUniT([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resCaletoUniT = (numbers) => {\n  const [minNum, maxNum] = numbers.reduce((acc, curr) => {\n    if (curr <= minNum) {\n      acc.push(0);\n    } else if (curr <= maxNum) {\n      acc.push(1);\n    } else {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return [minNum, maxNum];\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resCaletoUniT([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resCaletoUniT = (numbers) => {\n  const [minNum, maxNum] = numbers.reduce((acc, curr) => {\n    if (curr <= minNum) {\n      acc.push(0);\n    } else if (curr <= maxNum) {\n      acc.push(1);\n    } else {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return [minNum, maxNum];\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resCaletoUniT([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resCaletoUniT = (numbers) => {\n  const [minNum, maxNum] = numbers.reduce((acc, curr) => {\n    if (curr <= minNum) {\n      acc.push(0);\n    } else if (curr <= maxNum) {\n      acc.push(1);\n    } else {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return [minNum, maxNum];\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resCaletoUniT([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resCaletoUniT = (numbers) => {\n  const [minNum, maxNum] = numbers.reduce((acc, curr) => {\n    if (curr <= minNum) {\n      acc.push(0);\n    } else if (curr <= maxNum) {\n      acc.push(1);\n    } else {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return [minNum, maxNum];\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resCaletoUniT([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resCaletoUniT = (numbers) => {\n  const [minNum, maxNum] = numbers.reduce((acc, curr) => {\n    if (curr <= minNum) {\n      acc.push(0);\n    } else if (curr <= maxNum) {\n      acc.push(1);\n    } else {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return [minNum, maxNum];\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resCaletoUniT([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resCaletoUniT = (numbers) => {\n  const [minNum, maxNum] = numbers.reduce((acc, curr) => {\n    if (curr <= minNum) {\n      acc.push(0);\n    } else if (curr <= maxNum) {\n      acc.push(1);\n    } else {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return [minNum, maxNum];\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resCaletoUniT([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resCaletoUniT = (numbers) => {\n  const [minNum, maxNum] = numbers.reduce((acc, curr) => {\n    if (curr <= minNum) {\n      acc.push(0);\n    } else if (curr <= maxNum) {\n      acc.push(1);\n    } else {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return [minNum, maxNum];\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resCaletoUniT([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resCaletoUniT = (numbers) => {\n  const [minNum, maxNum] = numbers.reduce((acc, curr) => {\n    if (curr <= minNum) {\n      acc.push(0);\n    } else if (curr <= maxNum) {\n      acc.push(1);\n    } else {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return [minNum, maxNum];\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resCaletoUniT([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resCaletoUniT = (numbers) => {\n  const [minNum, maxNum] = numbers.reduce((acc, curr) => {\n    if (curr <= minNum) {\n      acc.push(0);\n    } else if (curr <= maxNum) {\n      acc.push(1);\n    } else {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return [minNum, maxNum];\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resCaletoUniT([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resCaletoUniT = (numbers) => {\n  const [minNum, maxNum] = numbers.reduce((acc, curr) => {\n    if (curr <= minNum) {\n      acc.push(0);\n    } else if (curr <= maxNum) {\n      acc.push(1);\n    } else {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return [minNum, maxNum];\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> resCaletoUniT([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst resCaletoUniT = (numbers) => {\n  const [minNum, maxNum] = numbers.reduce((acc, curr) => {\n    if (curr <= minNum) {\n      acc.push(0);\n    } else if (curr <= maxNum", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values only for integers\n  >>> filTerINtegeRs(['a', 3.14, 5])\n  [5]\n  >>> filTerINtegeRs([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filTerINtegeRs = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filTerINtegeRs", "gc": "<|endoftext|>/* Filter given list of any python values only for integers\n  >>> filTerINtegeRs(['a', 3.14, 5])\n  [5]\n  >>> filTerINtegeRs([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filTerINtegeRs = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/* Filter given list of any python values only for integers\n  >>> filTerINtegeRs(['a', 3.14, 5])\n  [5]\n  >>> filTerINtegeRs([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filTerINtegeRsNoNaN = (values) => {\n  return values.filter(v => typeof v === 'number' && v!== NaN);\n};\n\n/* Filter given list of any python values only for integers\n  >>> filTerINtegeRs(['a', 3.14, 5])\n  [5]\n  >>> filTerINtegeRs([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filTerINtegeRsNoNaNNoNaN = (values) => {\n  return values.filter(v => typeof v === 'number' && v!== NaN && v!== NaN);\n};\n\n/* Filter given list of any python values only for integers\n  >>> filTerINtegeRs(['a', 3.14, 5])\n  [5]\n  >>> filTerINtegeRs([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filTerINtegeRsNoNaNNoNaNNoNaN = (values) => {\n  return values.filter(v => typeof v === 'number' && v!== NaN && v!== NaN && v!== NaN);\n};\n\n/* Filter given list of any python values only for integers\n  >>> filTerINtegeRs(['a', 3.14, 5])\n  [5]\n  >>> filTerINtegeRs([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filTerINtegeRsNoNaNNoNaNNoNaNNoNaN = (values) => {\n  return values.filter(v => typeof v === 'number' && v!== NaN && v!== NaN && v!== NaN && v!== NaN);\n};\n\n/* Filter given list of any python values only for integers\n  >>> filTerINtegeRs(['a', 3.14, 5])\n  [5]\n  >>> filTerINtegeRs([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filTerINtegeRsNoNaNNoNaNNoNaNNoNaNNoNaN = (values) => {\n  return values.filter(v => typeof v === 'number' && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN);\n};\n\n/* Filter given list of any python values only for integers\n  >>> filTerINtegeRs(['a', 3.14, 5])\n  [5]\n  >>> filTerINtegeRs([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filTerINtegeRsNoNaNNoNaNNoNaNNoNaNNoNaNNoNaN = (values) => {\n  return values.filter(v => typeof v === 'number' && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN);\n};\n\n/* Filter given list of any python values only for integers\n  >>> filTerINtegeRs(['a', 3.14, 5])\n  [5]\n  >>> filTerINtegeRs([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filTerINtegeRsNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaN = (values) => {\n  return values.filter(v => typeof v === 'number' && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN);\n};\n\n/* Filter given list of any python values only for integers\n  >>> filTerINtegeRs(['a', 3.14, 5])\n  [5]\n  >>> filTerINtegeRs([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filTerINtegeRsNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaN = (values) => {\n  return values.filter(v => typeof v === 'number' && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN);\n};\n\n/* Filter given list of any python values only for integers\n  >>> filTerINtegeRs(['a', 3.14, 5])\n  [5]\n  >>> filTerINtegeRs([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filTerINtegeRsNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaN = (values) => {\n  return values.filter(v => typeof v === 'number' && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN);\n};\n\n/* Filter given list of any python values only for integers\n  >>> filTerINtegeRs(['a', 3.14, 5])\n  [5]\n  >>> filTerINtegeRs([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filTerINtegeRsNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaN = (values) => {\n  return values.filter(v => typeof v === 'number' && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN);\n};\n\n/* Filter given list of any python values only for integers\n  >>> filTerINtegeRs(['a', 3.14, 5])\n  [5]\n  >>> filTerINtegeRs([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filTerINtegeRsNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaN = (values) => {\n  return values.filter(v => typeof v === 'number' && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN);\n};\n\n/* Filter given list of any python values only for integers\n  >>> filTerINtegeRs(['a', 3.14, 5])\n  [5]\n  >>> filTerINtegeRs([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filTerINtegeRsNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaNNoNaN = (values) => {\n  return values.filter(v => typeof v === 'number' && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN && v!== NaN);\n};\n\n/* Filter given list of any python values only for integers\n  >>> filTerINtegeRs(['a', 3.14, 5])\n  [5]\n  >>> filTerINtegeRs([1, 2, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/23", "prompt": "/* Return length of given string\n  >>> strLen('')\n  0\n  >>> strLen('abc')\n  3\n  */\nconst strLen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strLen", "gc": "<|endoftext|>/* Return length of given string\n  >>> strLen('')\n  0\n  >>> strLen('abc')\n  3\n  */\nconst strLen = (string) => {\n  return string.length\n}\n\n/**\n * Return true if given string starts with given prefix\n * >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'b')\n  false\n  */\nconst startsWith = (string, prefix) => {\n  return string.indexOf(prefix) === 0\n}\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/**\n * Return true if given string starts with given substring\n * >>> startsWith('abc', 'b')\n  true\n  >>> startsWith('abc', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/**\n * Return true if given string ends with given substring\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  return string.indexOf(substring, string.length - substring.length)!== -1\n}\n\n/**\n * Return true if given string contains given substring\n * >>> contains('abc', 'b')\n  true\n  >>> contains('abc', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisOr(15)\n  5\n  */\nconst larGestdivisOr = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "larGestdivisOr", "gc": "<|endoftext|>/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisOr(15)\n  5\n  */\nconst larGestdivisOr = (n) => {\n  let largest = n;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      largest = divisor;\n      divisor *= 2;\n    }\n  }\n  return largest;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisAnd(15)\n  15\n  */\nconst larGestdivisAnd = (n) => {\n  let largest = n;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      largest = divisor;\n      divisor *= 2;\n    }\n  }\n  return largest;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisXor(15)\n  15\n  */\nconst larGestdivisXor = (n) => {\n  let largest = n;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      largest = divisor;\n      divisor *= 2;\n    }\n  }\n  return largest;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisDivide(15)\n  15\n  */\nconst larGestdivisDivide = (n) => {\n  let largest = n;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      largest = divisor;\n      divisor *= 2;\n    }\n  }\n  return largest;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisDivideAndRemainder(15)\n  15\n  */\nconst larGestdivisDivideAndRemainder = (n) => {\n  let largest = n;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      largest = divisor;\n      divisor *= 2;\n    }\n  }\n  return largest;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisDivideAndRemainderOr(15)\n  15\n  */\nconst larGestdivisDivideAndRemainderOr = (n) => {\n  let largest = n;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      largest = divisor;\n      divisor *= 2;\n    }\n  }\n  return largest;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisDivideAndRemainderAnd(15)\n  15\n  */\nconst larGestdivisDivideAndRemainderAnd = (n) => {\n  let largest = n;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      largest = divisor;\n      divisor *= 2;\n    }\n  }\n  return largest;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisDivideAndRemainderXor(15)\n  15\n  */\nconst larGestdivisDivideAndRemainderXor = (n) => {\n  let largest = n;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      largest = divisor;\n      divisor *= 2;\n    }\n  }\n  return largest;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisDivideAndRemainderDivide(15)\n  15\n  */\nconst larGestdivisDivideAndRemainderDivide = (n) => {\n  let largest = n;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      largest = divisor;\n      divisor *= 2;\n    }\n  }\n  return largest;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisDivideAndRemainderDivideOr(15)\n  15\n  */\nconst larGestdivisDivideAndRemainderDivideOr = (n) => {\n  let largest = n;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      largest = divisor;\n      divisor *= 2;\n    }\n  }\n  return largest;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisDivideAndRemainderDivideAnd(15)\n  15\n  */\nconst larGestdivisDivideAndRemainderDivideAnd = (n) => {\n  let largest = n;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      largest = divisor;\n      divisor *= 2;\n    }\n  }\n  return largest;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisDivideAndRemainderDivideXor(15)\n  15\n  */\nconst larGestdivisDivideAndRemainderDivideXor = (n) => {\n  let largest = n;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      largest = divisor;\n      divisor *= 2;\n    }\n  }\n  return largest;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisDivideAndRemainderDivideDivide(15)\n  15\n  */\nconst larGestdivisDivideAndRemainderDivide = (n) => {\n  let largest = n;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      largest = divisor;\n      divisor *= 2;\n    }\n  }\n  return largest;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisDivideAndRemainderDivideAndRemainder(15)\n  15\n  */\nconst larGestdivisDivideAndRemainderDivideAndRemainder = (n) => {\n  let largest = n;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      largest = divisor;\n      divisor *= 2;\n    }\n  }\n  return largest;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisDivideAndRemainderDivideAndRemainderOr(15)\n  15\n  */\nconst larGestdivisDivideAndRemainderDivideAndRemainderOr = (n) => {\n  let largest = n;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      largest = divisor;\n      divisor *= 2;\n    }\n  }\n  return largest;\n};\n\n/* Given a number n, find the largest number that divides n evenly, smaller than n\n  >>> larGestdivisDivideAndRemainderDivideAndRemainderAnd(15)\n  15\n  */\nconst larGestdivisDivideAndRemainderDivideAndRemainderAnd = (n) => {\n  let largest = n;\n  let divisor = 1;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> facToriZe(8)\n  [2, 2, 2]\n  >>> facToriZe(25)\n  [5, 5]\n  >>> facToriZe(70)\n  [2, 5, 7]\n  */\nconst facToriZe = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "facToriZe", "gc": "<|endoftext|>/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> facToriZe(8)\n  [2, 2, 2]\n  >>> facToriZe(25)\n  [5, 5]\n  >>> facToriZe(70)\n  [2, 5, 7]\n  */\nconst facToriZe = (n) => {\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> remOveDUplicAteS([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst remOveDUplicAteS = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "remOveDUplicAteS", "gc": "<|endoftext|>/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> remOveDUplicAteS([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst remOveDUplicAteS = (numbers) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    let number = numbers[i];\n    if (seen[number]) {\n      continue;\n    }\n    seen[number] = true;\n    result.push(number);\n  }\n  return result;\n};\n\n// ### removeOddNumbers\n// Remove all odd numbers from a list of integers.\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// [1, 3, 5, 6]\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumbers([1, 2, 3, 4, 5, 6])\n// []\n// >>> removeOddNumber", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> fliPCasE('Hello')\n  'hELLO'\n  */\nconst fliPCasE = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "fliPCasE", "gc": "<|endoftext|>/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> fliPCasE('Hello')\n  'hELLO'\n  */\nconst fliPCasE = (string) => {\n  return string.toLowerCase().split('').map((char) => char.toUpperCase()).join('');\n};\n\n/**\n  Given a string, flip uppercase characters to lowercase and lowercase to uppercase.\n  >>> fliPCasL('Hello')\n  'HELLO'\n  */\nconst fliPCasL = (string) => {\n  return string.toUpperCase().split('').map((char) => char.toLowerCase()).join('');\n};\n\n/**\n  Given a string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> fliPCasU('Hello')\n  'HELLO'\n  */\nconst fliPCasU = (string) => {\n  return string.toLowerCase().split('').map((char) => char.toUpperCase()).join('');\n};\n\n/**\n  Given a string, flip uppercase characters to lowercase and lowercase to uppercase.\n  >>> fliPCase('Hello')\n  'HELLO'\n  */\nconst fliPCase = (string) => {\n  return string.toUpperCase().split('').map((char) => char.toLowerCase()).join('');\n};\n\n/**\n  Given a string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> fliPCaseE('Hello')\n  'hELLO'\n  */\nconst fliPCaseE = (string) => {\n  return string.toLowerCase().split('').map((char) => char.toUpperCase()).join('');\n};\n\n/**\n  Given a string, flip uppercase characters to lowercase and lowercase to uppercase.\n  >>> fliPCaseL('Hello')\n  'HELLO'\n  */\nconst fliPCaseL = (string) => {\n  return string.toUpperCase().split('').map((char) => char.toLowerCase()).join('');\n};\n\n/**\n  Given a string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> fliPCaseU('Hello')\n  'HELLO'\n  */\nconst fliPCaseU = (string) => {\n  return string.toLowerCase().split('').map((char) => char.toUpperCase()).join('');\n};\n\n/**\n  Given a string, flip uppercase characters to lowercase and lowercase to uppercase.\n  >>> fliPCaseE('Hello')\n  'hELLO'\n  */\nconst fliPCaseE = (string) => {\n  return string.toLowerCase().split('').map((char) => char.toUpperCase()).join('');\n};\n\n/**\n  Given a string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> fliPCaseL('Hello')\n  'HELLO'\n  */\nconst fliPCaseL = (string) => {\n  return string.toUpperCase().split('').map((char) => char.toLowerCase()).join('');\n};\n\n/**\n  Given a string, flip uppercase characters to lowercase and lowercase to uppercase.\n  >>> fliPCaseU('Hello')\n  'HELLO'\n  */\nconst fliPCaseU = (string) => {\n  return string.toLowerCase().split('').map((char) => char.toUpperCase()).join('');\n};\n\n/**\n  Given a string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> fliPCaseE('Hello')\n  'hELLO'\n  */\nconst fliPCaseE = (string) => {\n  return string.toLowerCase().split('').map((char) => char.toUpperCase()).join('');\n};\n\n/**\n  Given a string, flip uppercase characters to lowercase and lowercase to uppercase.\n  >>> fliPCaseL('Hello')\n  'HELLO'\n  */\nconst fliPCaseL = (string) => {\n  return string.toUpperCase().split('').map((char) => char.toLowerCase()).join('');\n};\n\n/**\n  Given a string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> fliPCaseU('Hello')\n  'HELLO'\n  */\nconst fliPCaseU = (string) => {\n  return string.toLowerCase().split('').map((char) => char.toUpperCase()).join('');\n};\n\n/**\n  Given a string, flip uppercase characters to lowercase and lowercase to uppercase.\n  >>> fliPCaseE('Hello')\n  'hELLO'\n  */\nconst fliPCaseE = (string) => {\n  return string.toLowerCase().split('').map((char) => char.toUpperCase()).join('');\n};\n\n/**\n  Given a string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> fliPCaseL('Hello')\n  'HELLO'\n  */\nconst fliPCaseL = (string) => {\n  return string.toUpperCase().split('').map((char) => char.toLowerCase()).join('');\n};\n\n/**\n  Given a string, flip uppercase characters to lowercase and lowercase to uppercase.\n  >>> fliPCaseU('Hello')\n  'HELLO'\n  */\nconst fliPCaseU = (string) => {\n  return string.toLowerCase().split('').map((char) => char.toUpperCase()).join('');\n};\n\n/**\n  Given a string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> fliPCaseE('Hello')\n  'hELLO'\n  */\nconst fliPCaseE = (string) => {\n  return string.toLowerCase().split('').map((char) => char.toUpperCase()).join('');\n};\n\n/**\n  Given a string, flip uppercase characters to lowercase and lowercase to uppercase.\n  >>> fliPCaseL('Hello')\n  'HELLO'\n  */\nconst fliPCaseL = (string) => {\n  return string.toUpperCase().split('').map((char) => char.toLowerCase()).join('');\n};\n\n/**\n  Given a string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> fliPCaseU('Hello')\n  'HELLO'\n  */\nconst fliPCaseU = (string) => {\n  return string.toLowerCase().split('').map((char) => char.toUpperCase()).join('');\n};\n\n/**\n  Given a string, flip uppercase characters to lowercase and lowercase to uppercase.\n  >>> fliPCaseE('Hello')\n  'hELLO'\n  */\nconst fliPCaseE = (string) => {\n  return string.toLowerCase().split('').map((char) => char.toUpperCase()).join('');\n};\n\n/**\n  Given a string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> fliPCaseL('Hello')\n  'HELLO'\n  */\nconst fliPCaseL = (string) => {\n  return string.toUpperCase().split('').map((char) => char.toLowerCase()).join('');\n};\n\n/**\n  Given a string, flip uppercase characters to lowercase and lowercase to uppercase.\n  >>> fliPCaseU('Hello')\n  'HELLO'\n  */\nconst fliPCaseU = (string) => {\n  return string.toLowerCase().split('').map((char) => char.toUpperCase()).join('');\n};\n\n/**\n  Given a string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> fliPCaseE('Hello')\n  'hELLO'\n  */\nconst fliPCaseE = (string) => {\n  return string.toLowerCase().split('').map((char) => char.toUpperCase()).join('');\n};\n\n/**\n  Given a string, flip uppercase characters to lowercase and lowercase to uppercase.\n  >>> fliPCaseL('Hello')\n  'HELLO'\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> conCateNate([])\n  ''\n  >>> conCateNate(['a', 'b', 'c'])\n  'abc'\n  */\nconst conCateNate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "conCateNate", "gc": "<|endoftext|>/* Concatenate list of strings into a single string\n  >>> conCateNate([])\n  ''\n  >>> conCateNate(['a', 'b', 'c'])\n  'abc'\n  */\nconst conCateNate = (strings) => {\n  return strings.reduce((acc, cur) => acc + cur, \"\");\n};\n\n/* Convert string to number\n  >>> toNum('abc')\n  3\n  >>> toNum('123')\n  123\n  >>> toNum('123.45')\n  123.45\n  >>> toNum('123.45.67')\n  123.4567\n  >>> toNum('123.4567')\n  123.4567\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.4567.89')\n  123.456789\n  >>> toNum('123.", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filTerBYPrefIx([], 'a')\n  []\n  >>> filTerBYPrefIx(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filTerBYPrefIx = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filTerBYPrefIx", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filTerBYPrefIx([], 'a')\n  []\n  >>> filTerBYPrefIx(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filTerBYPrefIx = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/* Filter an input list of strings only for ones that end with a given suffix.\n  >>> filTerBYPrefIx([], 'a')\n  []\n  >>> filTerBYPrefIx(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filTerBYPrefIxEnd = (strings, suffix) => {\n  return strings.filter(s => s.endsWith(suffix));\n};\n\n/* Filter an input list of strings only for ones that do not start with a given prefix.\n  >>> filTerBYPrefIxEnd([], 'a')\n  []\n  >>> filTerBYPrefIxEnd(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filTerBYPrefIxEnd = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/* Filter an input list of strings only for ones that do not end with a given suffix.\n  >>> filTerBYPrefIxEnd([], 'a')\n  []\n  >>> filTerBYPrefIxEnd(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filTerBYPrefIxEnd = (strings, suffix) => {\n  return strings.filter(s =>!s.endsWith(suffix));\n};\n\n/* Filter an input list of strings only for ones that do not start with a given prefix or suffix.\n  >>> filTerBYPrefIxEnd([], 'a')\n  []\n  >>> filTerBYPrefIxEnd(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filTerBYPrefIxEnd = (strings, prefix, suffix) => {\n  return strings.filter(s =>!s.startsWith(prefix) ||!s.endsWith(suffix));\n};\n\n/* Filter an input list of strings only for ones that do not end with a given prefix or suffix.\n  >>> filTerBYPrefIxEnd([], 'a')\n  []\n  >>> filTerBYPrefIxEnd(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filTerBYPrefIxEnd = (strings, prefix, suffix) => {\n  return strings.filter(s =>!s.startsWith(prefix) ||!s.endsWith(suffix));\n};\n\n/* Filter an input list of strings only for ones that do not start with a given prefix or suffix.\n  >>> filTerBYPrefIxEnd([], 'a')\n  []\n  >>> filTerBYPrefIxEnd(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filTerBYPrefIxEnd = (strings, prefix, suffix) => {\n  return strings.filter(s =>!s.startsWith(prefix) ||!s.endsWith(suffix));\n};\n\n/* Filter an input list of strings only for ones that do not end with a given prefix or suffix.\n  >>> filTerBYPrefIxEnd([], 'a')\n  []\n  >>> filTerBYPrefIxEnd(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filTerBYPrefIxEnd = (strings, prefix, suffix) => {\n  return strings.filter(s =>!s.startsWith(prefix) ||!s.endsWith(suffix));\n};\n\n/* Filter an input list of strings only for ones that do not start with a given prefix or suffix.\n  >>> filTerBYPrefIxEnd([], 'a')\n  []\n  >>> filTerBYPrefIxEnd(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filTerBYPrefIxEnd = (strings, prefix, suffix) => {\n  return strings.filter(s =>!s.startsWith(prefix) ||!s.endsWith(suffix));\n};\n\n/* Filter an input list of strings only for ones that do not end with a given prefix or suffix.\n  >>> filTerBYPrefIxEnd([], 'a')\n  []\n  >>> filTerBYPrefIxEnd(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filTerBYPrefIxEnd = (strings, prefix, suffix) => {\n  return strings.filter(s =>!s.startsWith(prefix) ||!s.endsWith(suffix));\n};\n\n/* Filter an input list of strings only for ones that do not start with a given prefix or suffix.\n  >>> filTerBYPrefIxEnd([], 'a')\n  []\n  >>> filTerBYPrefIxEnd(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filTerBYPrefIxEnd = (strings, prefix, suffix) => {\n  return strings.filter(s =>!s.startsWith(prefix) ||!s.endsWith(suffix));\n};\n\n/* Filter an input list of strings only for ones that do not end with a given prefix or suffix.\n  >>> filTerBYPrefIxEnd([], 'a')\n  []\n  >>> filTerBYPrefIxEnd(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filTerBYPrefIxEnd = (strings, prefix, suffix) => {\n  return strings.filter(s =>!s.startsWith(prefix) ||!s.endsWith(suffix));\n};\n\n/* Filter an input list of strings only for ones that do not start with a given prefix or suffix.\n  >>> filTerBYPrefIxEnd([], 'a')\n  []\n  >>> filTerBYPrefIxEnd(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filTerBYPrefIxEnd = (strings, prefix, suffix) => {\n  return strings.filter(s =>!s.startsWith(prefix) ||!s.endsWith(suffix));\n};\n\n/* Filter an input list of strings only for ones that do not end with a given prefix or suffix.\n  >>> filTerBYPrefIxEnd([], 'a')\n  []\n  >>> filTerBYPrefIxEnd(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filTerBYPrefIxEnd = (strings, prefix, suffix) => {\n  return strings.filter(s =>!s.startsWith(prefix) ||!s.endsWith(suffix));\n};\n\n/* Filter an input list of strings only for ones that do not start with a given prefix or suffix.\n  >>> filTerBYPrefIxEnd([], 'a')\n  []\n  >>> filTerBYPrefIxEnd(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'cde', 'array']\n  */\nconst filTerBYPrefIxEnd = (strings, prefix, suffix) => {\n  return strings.filter(s =>!s.startsWith(prefix) ||!s.endsWith(suffix));\n};\n\n/* Filter an input list of strings only for ones that do not end with a given prefix or suffix.\n  >>> filTerBYPrefIxEnd([]", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belOwZeRo([1, 2, 3])\n  false\n  >>> belOwZeRo([1, 2, -4, 5])\n  true\n  */\nconst belOwZeRo = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belOwZeRo", "gc": "<|endoftext|>/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belOwZeRo([1, 2, 3])\n  false\n  >>> belOwZeRo([1, 2, -4, 5])\n  true\n  */\nconst belOwZeRo = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] < 0) {\n      balance -= operations[i];\n    } else {\n      balance += operations[i];\n    }\n  }\n  return balance <= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belOwZeRo([-4, -4, -4, -5])\n  false\n  >>> belOwZeRo([-4, -4, -4, -5])\n  true\n  */\nconst belOwZeRo2 = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] < 0) {\n      balance -= operations[i];\n    } else {\n      balance += operations[i];\n    }\n  }\n  return balance <= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belOwZeRo2([-4, -4, -4, -5])\n  false\n  >>> belOwZeRo2([-4, -4, -4, -5])\n  true\n  */\nconst belOwZeRo3 = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] < 0) {\n      balance -= operations[i];\n    } else {\n      balance += operations[i];\n    }\n  }\n  return balance <= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belOwZeRo3([-4, -4, -4, -5])\n  false\n  >>> belOwZeRo3([-4, -4, -4, -5])\n  true\n  */\nconst belOwZeRo4 = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] < 0) {\n      balance -= operations[i];\n    } else {\n      balance += operations[i];\n    }\n  }\n  return balance <= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belOwZeRo4([-4, -4, -4, -5])\n  false\n  >>> belOwZeRo4([-4, -4, -4, -5])\n  true\n  */\nconst belOwZeRo5 = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] < 0) {\n      balance -= operations[i];\n    } else {\n      balance += operations[i];\n    }\n  }\n  return balance <= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belOwZeRo5([-4, -4, -4, -5])\n  false\n  >>> belOwZeRo5([-4, -4, -4, -5])\n  true\n  */\nconst belOwZeRo6 = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] < 0) {\n      balance -= operations[i];\n    } else {\n      balance += operations[i];\n    }\n  }\n  return balance <= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belOwZeRo6([-4, -4, -4, -5])\n  false\n  >>> belOwZeRo6([-4, -4, -4, -5])\n  true\n  */\nconst belOwZeRo7 = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] < 0) {\n      balance -= operations[i];\n    } else {\n      balance += operations[i];\n    }\n  }\n  return balance <= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belOwZeRo7([-4, -4, -4, -5])\n  false\n  >>> belOwZeRo7([-4, -4, -4, -5])\n  true\n  */\nconst belOwZeRo8 = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] < 0) {\n      balance -= operations[i];\n    } else {\n      balance += operations[i];\n    }\n  }\n  return balance <= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belOwZeRo8([-4, -4, -4, -5])\n  false\n  >>> belOwZeRo8([-4, -4, -4, -5])\n  true\n  */\nconst belOwZeRo9 = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] < 0) {\n      balance -= operations[i];\n    } else {\n      balance += operations[i];\n    }\n  }\n  return balance <= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belOwZeRo9([-4, -4, -4, -5])\n  false\n  >>> belOwZeRo9([-4, -4, -4, -5])\n  true\n  */\nconst belOwZeRo10 = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] < 0) {\n      balance -= operations[i];\n    } else {\n      balance += operations[i];\n    }\n  }\n  return balance <= 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belOwZeRo10", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> getposiTive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getposiTive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getposiTive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getposiTive", "gc": "<|endoftext|>/*Return only positive numbers in the list.\n  >>> getposiTive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getposiTive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getposiTive = (l) => {\n  let positivo = []\n  l.forEach((n) => {\n    if (n > 0) {\n      positivo.push(n)\n    }\n  })\n  return positivo\n}\n\n/*Return only positive numbers in the list.\n  >>> getposiTive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getposiTive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getposiTir = (l) => {\n  let positivo = []\n  l.forEach((n) => {\n    if (n < 0) {\n      positivo.push(n)\n    }\n  })\n  return positivo\n}\n\n/*Return only positive numbers in the list.\n  >>> getposiTir([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getposiTir([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getposiTie = (l) => {\n  let positivo = []\n  l.forEach((n) => {\n    if (n < 0) {\n      positivo.push(n)\n    }\n  })\n  return positivo\n}\n\n/*Return only positive numbers in the list.\n  >>> getposiTie([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getposiTie([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getposiTiest = (l) => {\n  let positivo = []\n  l.forEach((n) => {\n    if (n < 0) {\n      positivo.push(n)\n    }\n  })\n  return positivo\n}\n\n/*Return only positive numbers in the list.\n  >>> getposiTiest([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getposiTiest([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getposiTiestPositivo = (l) => {\n  let positivo = []\n  l.forEach((n) => {\n    if (n > 0) {\n      positivo.push(n)\n    }\n  })\n  return positivo\n}\n\n/*Return only positive numbers in the list.\n  >>> getposiTiestPositivo([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getposiTiestPositivo([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getposiTiestPositivoTir = (l) => {\n  let positivo = []\n  l.forEach((n) => {\n    if (n < 0) {\n      positivo.push(n)\n    }\n  })\n  return positivo\n}\n\n/*Return only positive numbers in the list.\n  >>> getposiTiestPositivoTir([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getposiTiestPositivoTir([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getposiTiestPositivoTie = (l) => {\n  let positivo = []\n  l.forEach((n) => {\n    if (n < 0) {\n      positivo.push(n)\n    }\n  })\n  return positivo\n}\n\n/*Return only positive numbers in the list.\n  >>> getposiTiestPositivoTie([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getposiTiestPositivoTie([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getposiTiestPositivoTiest = (l) => {\n  let positivo = []\n  l.forEach((n) => {\n    if (n < 0) {\n      positivo.push(n)\n    }\n  })\n  return positivo\n}\n\n/*Return only positive numbers in the list.\n  >>> getposiTiestPositivoTiest([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getposiTiestPositivoTiest([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getposiTiestPositivoTiestPositivo = (l) => {\n  let positivo = []\n  l.forEach((n) => {\n    if (n > 0) {\n      positivo.push(n)\n    }\n  })\n  return positivo\n}\n\n/*Return only positive numbers in the list.\n  >>> getposiTiestPositivoTiestPositivo([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getposiTiestPositivoTiestPositivo([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getposiTiestPositivoTiestPositivoTir = (l) => {\n  let positivo = []\n  l.forEach((n) => {\n    if (n < 0) {\n      positivo.push(n)\n    }\n  })\n  return positivo\n}\n\n/*Return only positive numbers in the list.\n  >>> getposiTiestPositivoTiestPositivoTir([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getposiTiestPositivoTiestPositivoTir([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getposiTiestPositivoTiestPositivoTie = (l) => {\n  let positivo = []\n  l.forEach((n) => {\n    if (n < 0) {\n      positivo.push(n)\n    }\n  })\n  return positivo\n}\n\n/*Return only positive numbers in the list.\n  >>> getposiTiestPositivoTiestPositivoTiest([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getposiTiestPositivoTiestPositivoTiest([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getposiTiestPositivoTiestPositivoTiest = (l) => {\n  let positivo = []\n  l.forEach((n) => {\n    if (n < 0) {\n      positivo.push(n)\n    }\n  })\n  return positivo\n}\n\n/*Return only positive numbers in the list.\n  >>> getposiTiestPositivoTiestPositivoTiestPositivo([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getposiTiestPositivoTiestPositivoTiestPositivo([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getposiTiestPositivoTiestPositivoTiestPositi", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number is prime, and false otherwise.\n  >>> isPRime(6)\n  false\n  >>> isPRime(101)\n  true\n  >>> isPRime(11)\n  true\n  >>> isPRime(13441)\n  true\n  >>> isPRime(61)\n  true\n  >>> isPRime(4)\n  false\n  >>> isPRime(1)\n  false\n  */\nconst isPRime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPRime", "gc": "<|endoftext|>/*Return true if a given number is prime, and false otherwise.\n  >>> isPRime(6)\n  false\n  >>> isPRime(101)\n  true\n  >>> isPRime(11)\n  true\n  >>> isPRime(13441)\n  true\n  >>> isPRime(61)\n  true\n  >>> isPRime(4)\n  false\n  >>> isPRime(1)\n  false\n  */\nconst isPRime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 11 === 0) return false;\n  if (n % 13 === 0) return false;\n  if (n % 17 === 0) return false;\n  if (n % 19 === 0) return false;\n  if (n % 23 === 0) return false;\n  if (n % 29 === 0) return false;\n  if (n % 31 === 0) return false;\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  true\n  >>> isPrime(101)\n  false\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 11 === 0) return false;\n  if (n % 13 === 0) return false;\n  if (n % 17 === 0) return false;\n  if (n % 19 === 0) return false;\n  if (n % 23 === 0) return false;\n  if (n % 29 === 0) return false;\n  if (n % 31 === 0) return false;\n  if (isPrime(Math.floor(n / 2))) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  >>> isPrime(6)\n  true\n  >>> isPrime(101)\n  false\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 11 === 0) return false;\n  if (n % 13 === 0) return false;\n  if (n % 17 === 0) return false;\n  if (n % 19 === 0) return false;\n  if (n % 23 === 0) return false;\n  if (n % 29 === 0) return false;\n  if (n % 31 === 0) return false;\n  if (isPrime(Math.floor(n / 2))) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  >>> isPrime(6)\n  true\n  >>> isPrime(101)\n  false\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 11 === 0) return false;\n  if (n % 13 === 0) return false;\n  if (n % 17 === 0) return false;\n  if (n % 19 === 0) return false;\n  if (n % 23 === 0) return false;\n  if (n % 29 === 0) return false;\n  if (n % 31 === 0) return false;\n  if (isPrime(Math.floor(n / 2))) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  >>> isPrime(6)\n  true\n  >>> isPrime(101)\n  false\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 11 === 0) return false;\n  if (n % 13 === 0) return false;\n  if (n % 17 === 0) return false;\n  if (n % 19 === 0) return false;\n  if (n % 23 === 0) return false;\n  if (n % 29 === 0) return false;\n  if (n % 31 === 0) return false;\n  if (isPrime(Math.floor(n / 2))) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  >>> isPrime(6)\n  true\n  >>> isPrime(101)\n  false\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 11 === 0) return false;\n  if (n % 13 === 0) return false;\n  if (n % 17 === 0) return false;\n  if (n % 19 === 0) return false;\n  if (n % 23 === 0) return false;\n  if (n % 29 === 0) return false;\n  if (n % 31 === 0) return false;\n  if (isPrime(Math.floor(n / 2))) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  >>> isPrime(6)\n  true\n  >>> isPrime(101)\n  false\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 11 === 0) return false;\n  if (n % 13 === 0) return false;\n  if (n % 17 === 0) return false;\n  if (n % 19 === 0) return false;\n  if (n % 23 === 0) return false;\n  if (n % 29 === 0) return false;\n  if (n % 31 === 0) return false;\n  if (isPrime(Math.floor(n / 2))) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  >>> isPrime(6)\n  true\n  >>> isPrime(101)\n  false\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) return false;\n  if (n % ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polYnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst polY = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polYnomial.\n  findZero find x such that polY(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "polY", "gc": "<|endoftext|>/*\n  Evaluates polYnomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst polY = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polYnomial.\n  findZero find x such that polY(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let zero = Infinity;\n  let index = -1;\n  xs.forEach((item, index) => {\n    if (item === 0) {\n      zero = index;\n    }\n  });\n  return zero;\n}\n\n/*\n  xs are coefficients of a polYnomial.\n  findOne find x such that polY(x) = 1.\n  findOne returns only zero point, even if there are many.\n  Moreover, findOne only takes list xs having even number of coefficients\n  and smallest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findOne([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findOne([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findOne = (xs) => {\n  let one = -1;\n  let index = -1;\n  xs.forEach((item, index) => {\n    if (item === 1) {\n      one = index;\n    }\n  });\n  return one;\n}\n\n/*\n  xs are coefficients of a polYnomial.\n  findOne finds x such that polY(x) = 1.\n  findOne returns only zero point, even if there are many.\n  Moreover, findOne only takes list xs having even number of coefficients\n  and smallest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findOne([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findOne([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let zero = Infinity;\n  let index = -1;\n  xs.forEach((item, index) => {\n    if (item === 0) {\n      zero = index;\n    }\n  });\n  return zero;\n}\n\n/*\n  xs are coefficients of a polYnomial.\n  findOne finds x such that polY(x) = 1.\n  findOne returns only zero point, even if there are many.\n  Moreover, findOne only takes list xs having even number of coefficients\n  and smallest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findOne([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findOne([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findOne = (xs) => {\n  let one = -1;\n  let index = -1;\n  xs.forEach((item, index) => {\n    if (item === 1) {\n      one = index;\n    }\n  });\n  return one;\n}\n\n/*\n  xs are coefficients of a polYnomial.\n  findOne finds x such that polY(x) = 1.\n  findOne returns only zero point, even if there are many.\n  Moreover, findOne only takes list xs having even number of coefficients\n  and smallest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findOne([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findOne([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let zero = Infinity;\n  let index = -1;\n  xs.forEach((item, index) => {\n    if (item === 0) {\n      zero = index;\n    }\n  });\n  return zero;\n}\n\n/*\n  xs are coefficients of a polYnomial.\n  findOne finds x such that polY(x) = 1.\n  findOne returns only zero point, even if there are many.\n  Moreover, findOne only takes list xs having even number of coefficients\n  and smallest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findOne([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findOne([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findOne = (xs) => {\n  let one = -1;\n  let index = -1;\n  xs.forEach((item, index) => {\n    if (item === 1) {\n      one = index;\n    }\n  });\n  return one;\n}\n\n/*\n  xs are coefficients of a polYnomial.\n  findOne finds x such that polY(x) = 1.\n  findOne returns only zero point, even if there are many.\n  Moreover, findOne only takes list xs having even number of coefficients\n  and smallest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findOne([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findOne([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let zero = Infinity;\n  let index = -1;\n  xs.forEach((item, index) => {\n    if (item === 0) {\n      zero = index;\n    }\n  });\n  return zero;\n}\n\n/*\n  xs are coefficients of a polYnomial.\n  findOne finds x such that polY(x) = 1.\n  findOne returns only zero point, even if there are many.\n  Moreover, findOne only takes list xs having even number of coefficients\n  and smallest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findOne([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findOne([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findOne = (xs) => {\n  let one = -1;\n  let index = -1;\n  xs.forEach((item, index) => {\n    if (item === 1) {\n      one = index;\n    }\n  });\n  return one;\n}\n\n/*\n  xs are coefficients of a polYnomial.\n  findOne finds x such that polY(x) = 1.\n  findOne returns only zero point, even if there are many.\n  Moreover, findOne only takes list xs having even number of coefficients\n  and smallest non zero coefficient as it guarantees", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sorTThiRd([1, 2, 3])\n  [1, 2, 3]\n  >>> sorTThiRd([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sorTThiRd = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sorTThiRd", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sorTThiRd([1, 2, 3])\n  [1, 2, 3]\n  >>> sorTThiRd([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sorTThiRd = (l) => {\n  let l2 = l.slice();\n  let l3 = l2.slice();\n  let l4 = l3.slice();\n  let l5 = l4.slice();\n  let l6 = l5.slice();\n  let l7 = l6.slice();\n  let l8 = l7.slice();\n  let l9 = l8.slice();\n  let l10 = l9.slice();\n  let l11 = l10.slice();\n  let l12 = l11.slice();\n  let l13 = l12.slice();\n  let l14 = l13.slice();\n  let l15 = l14.slice();\n  let l16 = l15.slice();\n  let l17 = l16.slice();\n  let l18 = l17.slice();\n  let l19 = l18.slice();\n  let l20 = l19.slice();\n  let l21 = l20.slice();\n  let l22 = l21.slice();\n  let l23 = l22.slice();\n  let l24 = l23.slice();\n  let l25 = l24.slice();\n  let l26 = l25.slice();\n  let l27 = l26.slice();\n  let l28 = l27.slice();\n  let l29 = l28.slice();\n  let l30 = l29.slice();\n  let l31 = l30.slice();\n  let l32 = l31.slice();\n  let l33 = l32.slice();\n  let l34 = l33.slice();\n  let l35 = l34.slice();\n  let l36 = l35.slice();\n  let l37 = l36.slice();\n  let l38 = l37.slice();\n  let l39 = l38.slice();\n  let l40 = l39.slice();\n  let l41 = l40.slice();\n  let l42 = l41.slice();\n  let l43 = l42.slice();\n  let l44 = l43.slice();\n  let l45 = l44.slice();\n  let l46 = l45.slice();\n  let l47 = l46.slice();\n  let l48 = l47.slice();\n  let l49 = l48.slice();\n  let l50 = l49.slice();\n  let l51 = l50.slice();\n  let l52 = l51.slice();\n  let l53 = l52.slice();\n  let l54 = l53.slice();\n  let l55 = l54.slice();\n  let l56 = l55.slice();\n  let l57 = l56.slice();\n  let l58 = l57.slice();\n  let l59 = l58.slice();\n  let l60 = l59.slice();\n  let l61 = l60.slice();\n  let l62 = l61.slice();\n  let l63 = l62.slice();\n  let l64 = l63.slice();\n  let l65 = l64.slice();\n  let l66 = l65.slice();\n  let l67 = l66.slice();\n  let l68 = l67.slice();\n  let l69 = l68.slice();\n  let l70 = l69.slice();\n  let l71 = l70.slice();\n  let l72 = l71.slice();\n  let l73 = l72.slice();\n  let l74 = l73.slice();\n  let l75 = l74.slice();\n  let l76 = l75.slice();\n  let l77 = l76.slice();\n  let l78 = l77.slice();\n  let l79 = l78.slice();\n  let l80 = l79.slice();\n  let l81 = l80.slice();\n  let l82 = l81.slice();\n  let l83 = l82.slice();\n  let l84 = l83.slice();\n  let l85 = l84.slice();\n  let l86 = l85.slice();\n  let l87 = l86.slice();\n  let l88 = l87.slice();\n  let l89 = l88.slice();\n  let l90 = l89.slice();\n  let l91 = l90.slice();\n  let l92 = l91.slice();\n  let l93 = l92.slice();\n  let l94 = l93.slice();\n  let l95 = l94.slice();\n  let l96 = l95.slice();\n  let l97 = l96.slice();\n  let l98 = l97.slice();\n  let l99 = l98.slice();\n  let l100 = l99.slice();\n  let l101 = l100.slice();\n  let l102 = l101.slice();\n  let l103 = l102.slice();\n  let l104 = l103.slice();\n  let l105 = l104.slice();\n  let l106 = l105.slice();\n  let l107 = l106.slice();\n  let l108 = l107.slice();\n  let l109 = l108.slice();\n  let l110 = l109.slice();\n  let l111 = l110.slice();\n  let l112 = l111.slice();\n  let l113 = l112.slice();\n  let l114 = l113.slice();\n  let l115 = l114.slice();\n  let l116 = l115.slice();\n  let l117 = l116.slice();\n  let l118 = l117.slice();\n  let l119 = l118.slice();\n  let l120 = l119.slice();\n  let l121 = l120.slice();\n  let l122 = l121.slice();\n  let l123 = l122.slice();\n  let l124 = l123.slice();\n  let l125 = l124.slice();\n  let l126 = l125.slice();\n  let l127 = l126.slice();\n  let l128 = l127.slice();\n  let l129 = l128.slice();\n  let l130 = l129.slice();\n  let l131 = l130.slice();\n  let l132 = l131.slice();\n  let l133 = l132.slice();\n  let l134 = l133.slice();\n  let l135 = l134.slice();\n  let l136 = l135.slice();\n  let l137 = l136.slice();\n  let l138 = l137.slice();\n  let l139 = l138.slice();\n  let l140 = l139.slice();\n  let l141 = l140.slice();\n  let l142 = l141.slice();\n  let l143 = l142.slice();\n  let l144 = l143.slice();\n  let l145 = l144.slice();\n  let l146 = l145.slice();\n  let l147 = l146.slice();\n  let l148 = l147.slice();\n  let l149 = l148.slice();\n  let l150 = l149.slice();\n  let l151 = ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted uniQue elements in a list\n  >>> uniQue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniQue = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "uniQue", "gc": "<|endoftext|>/*Return sorted uniQue elements in a list\n  >>> uniQue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniQue = (l) => {\n  let res = [];\n  let i = l.length - 1;\n  let j = 0;\n  while (i >= 0 && j >= 0) {\n    if (l[i] === l[j]) {\n      res.push(l[i]);\n      i--;\n      j--;\n    } else {\n      res.push(l[j]);\n      j--;\n    }\n  }\n  return res;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniQue([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 123]\n  */\nconst uniQ = (l) => {\n  let res = [];\n  let i = l.length - 1;\n  let j = 0;\n  while (i >= 0 && j >= 0) {\n    if (l[i] === l[j]) {\n      res.push(l[i]);\n      i--;\n      j--;\n    } else {\n      res.push(l[j]);\n      j--;\n    }\n  }\n  return res;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniQ([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 123]\n  */\nconst uniQe = (l) => {\n  let res = [];\n  let i = l.length - 1;\n  let j = 0;\n  while (i >= 0 && j >= 0) {\n    if (l[i] === l[j]) {\n      res.push(l[i]);\n      i--;\n      j--;\n    } else {\n      res.push(l[j]);\n      j--;\n    }\n  }\n  return res;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniQe([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 123]\n  */\nconst uniQe = (l) => {\n  let res = [];\n  let i = l.length - 1;\n  let j = 0;\n  while (i >= 0 && j >= 0) {\n    if (l[i] === l[j]) {\n      res.push(l[i]);\n      i--;\n      j--;\n    } else {\n      res.push(l[j]);\n      j--;\n    }\n  }\n  return res;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniQe([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 123]\n  */\nconst uniQe = (l) => {\n  let res = [];\n  let i = l.length - 1;\n  let j = 0;\n  while (i >= 0 && j >= 0) {\n    if (l[i] === l[j]) {\n      res.push(l[i]);\n      i--;\n      j--;\n    } else {\n      res.push(l[j]);\n      j--;\n    }\n  }\n  return res;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniQe([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 123]\n  */\nconst uniQe = (l) => {\n  let res = [];\n  let i = l.length - 1;\n  let j = 0;\n  while (i >= 0 && j >= 0) {\n    if (l[i] === l[j]) {\n      res.push(l[i]);\n      i--;\n      j--;\n    } else {\n      res.push(l[j]);\n      j--;\n    }\n  }\n  return res;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniQe([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 123]\n  */\nconst uniQe = (l) => {\n  let res = [];\n  let i = l.length - 1;\n  let j = 0;\n  while (i >= 0 && j >= 0) {\n    if (l[i] === l[j]) {\n      res.push(l[i]);\n      i--;\n      j--;\n    } else {\n      res.push(l[j]);\n      j--;\n    }\n  }\n  return res;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniQe([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 123]\n  */\nconst uniQe = (l) => {\n  let res = [];\n  let i = l.length - 1;\n  let j = 0;\n  while (i >= 0 && j >= 0) {\n    if (l[i] === l[j]) {\n      res.push(l[i]);\n      i--;\n      j--;\n    } else {\n      res.push(l[j]);\n      j--;\n    }\n  }\n  return res;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniQe([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 123]\n  */\nconst uniQe = (l) => {\n  let res = [];\n  let i = l.length - 1;\n  let j = 0;\n  while (i >= 0 && j >= 0) {\n    if (l[i] === l[j]) {\n      res.push(l[i]);\n      i--;\n      j--;\n    } else {\n      res.push(l[j]);\n      j--;\n    }\n  }\n  return res;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniQe([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 123]\n  */\nconst uniQe = (l) => {\n  let res = [];\n  let i = l.length - 1;\n  let j = 0;\n  while (i >= 0 && j >= 0) {\n    if (l[i] === l[j]) {\n      res.push(l[i]);\n      i--;\n      j--;\n    } else {\n      res.push(l[j]);\n      j--;\n    }\n  }\n  return res;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniQe([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 123]\n  */\nconst uniQe = (l) => {\n  let res = [];\n  let i = l.length - 1;\n  let j = 0;\n  while (i >= 0 && j >= 0) {\n    if (l[i] === l[j]) {\n      res.push(l[i]);\n      i--;\n      j--;\n    } else {\n      res.push(l[j]);\n      j--;\n    }\n  }\n  return res;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniQe([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 123]\n  */\nconst uniQe = (l) => {\n  let res = [];\n  let i = l.length - 1;\n  let j = 0;\n  while (i >= 0 && j >= 0) {\n    if (l[i] === l[j]) {\n      res.push(l[i]);\n      i--;\n      j--;\n    } else {\n      res.push(l[j]);\n      j--;\n    }\n  }\n  return res;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniQe([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 123]\n  */\nconst uniQe = (l) => {\n  let res = [];\n  let i = l.length - 1;\n  let j = 0;\n  while (i >= 0 && j >= 0) {\n    if (l[i] === l[j]) {\n      res.push(l[i]);\n      i--;\n      j--;\n    } else {\n      res.push(l[j]);\n      j--;\n    }\n  }\n  return res;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniQe([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 123]\n  */\nconst uniQe = (l) => {\n  let res = [];\n  let i = l.length - 1;\n  let j = 0;\n  while (i >= 0 && j >= 0) {\n    if (l[i] === l[j]) {\n      res.push(l[i]);\n      i--;\n      j--;\n    } else {\n      res.push(l[j]);\n      j--;\n    }\n  }\n  return res;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniQe([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 2, 3, 3, 9, 123]\n  */\nconst uniQe = (l) => {\n  let res = [];\n  let i = l.length - 1;\n  let j = 0;", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum element in the list.\n  >>> maxelemEnt([1, 2, 3])\n  3\n  >>> maxelemEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxelemEnt = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxelemEnt", "gc": "<|endoftext|>/*Return maximum element in the list.\n  >>> maxelemEnt([1, 2, 3])\n  3\n  >>> maxelemEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxelemEnt = (l) => {\n  let max = 0;\n  let maxElem = null;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n      maxElem = i;\n    }\n  }\n  return maxElem;\n};\n\n/*Return minimum element in the list.\n  >>> minelemEnt([1, 2, 3])\n  1\n  >>> minelemEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst minelemEnt = (l) => {\n  let min = 0;\n  let minElem = null;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < min) {\n      min = l[i];\n      minElem = i;\n    }\n  }\n  return minElem;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumEnt([1, 2, 3])\n  6\n  >>> sumEnt([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -55\n  */\nconst sumEnt = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizZBuzZ(50)\n  0\n  >>> fizZBuzZ(78)\n  2\n  >>> fizZBuzZ(79)\n  3\n  */\nconst fizZBuzZ = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizZBuzZ", "gc": "<|endoftext|>/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizZBuzZ(50)\n  0\n  >>> fizZBuzZ(78)\n  2\n  >>> fizZBuzZ(79)\n  3\n  */\nconst fizZBuzZ = (n) => {\n  let count = 0;\n  let digit = n % 11;\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n    digit = n % 13;\n  }\n  if (digit === 7) {\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sorTEveN([1, 2, 3])\n  [1, 2, 3]\n  >>> sorTEveN([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sorTEveN = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sorTEveN", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sorTEveN([1, 2, 3])\n  [1, 2, 3]\n  >>> sorTEveN([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sorTEveN = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...even,...odd];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sorTEveOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sorTEveOdd([5, 6, 3, 4])\n  [4, 3, 2, 1]\n  */\nconst sorTEveOdd = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sorTEveEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sorTEveEven([5, 6, 3, 4])\n  [3, 4, 6, 5]\n  */\nconst sorTEveEven = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sorTEveOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sorTEveOddEven([5, 6, 3, 4])\n  [4, 3, 2, 1]\n  */\nconst sorTEveOddEven = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...even,...odd];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sorTEveEvenEvenOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sorTEveEvenEvenOdd([5, 6, 3, 4])\n  [4, 3, 2, 1]\n  */\nconst sorTEveEvenOdd = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sorTEveOddEvenEvenOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sorTEveOddEvenEvenOdd([5, 6, 3, 4])\n  [4, 3, 2, 1]\n  */\nconst sorTEveEvenEvenOdd = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sorTEveEvenEvenEvenOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sorTEveEvenEvenEvenOddEven([5, 6, 3, 4])\n  [4, 3, 2, 1]\n  */\nconst sorTEveEvenEvenEvenOddEven = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sorTEveEvenEvenEvenEvenOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sorTEveEvenEvenEvenEvenOddEven([5, 6, 3, 4])\n  [4, 3, 2, 1]\n  */\nconst sorTEveEvenEvenEvenEvenOddEven = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sorTEveEvenEvenEvenEvenEvenOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sorTEveEvenEvenEvenEvenEvenOddEven([5, 6, 3, 4])\n  [4, 3, 2, 1]\n  */\nconst sorTEveEvenEvenEvenEvenEvenOddEven = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sorTEveEvenEvenEvenEvenEvenEvenEvenOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sorTEveEvenEvenEvenEvenEvenEvenOddEven([5, 6, 3, 4])\n  [4, 3, 2, 1]\n  */\nconst sorTEveEvenEvenEvenEvenEvenEvenOddEven = (l) => {\n  let even = l.filter((item, index) => index % 2 === 0);\n  let odd = l.filter((item, index) => index % 2!== 0);\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sorTEveEvenEvenEvenEvenEvenEvenEvenOddEven([1, 2, 3])\n  [3, 2, 1]\n  >>> sorTEveEvenEvenEvenEvenEvenEvenOddEven([5, 6, 3, 4])\n  [4, 3, 2, 1]\n  */\nconst sorTEveEvenEvenEvenEvenEvenEvenOddEven = (l) => {\n  let even = l.filter((", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encOdeCYclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encOdeCYclic", "gc": "<|endoftext|>/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encOdeCYclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicOde = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicOdeCYclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicOde = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicOdeCYclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicOdeCYclicOde = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicOdeCYclicOdeCYclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicOdeCYclicOdeCYclicOde = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicOdeCYclicOdeCYclicOdeCYclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicOdeCYclicOdeCYclicOdeCYclicOde = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicOdeCYclicOdeCYclicOdeCYclicOdeCYclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/39", "prompt": "/*\n  priMeFiB returns n-th number that is a Fibonacci number and it's also prime.\n  >>> priMeFiB(1)\n  2\n  >>> priMeFiB(2)\n  3\n  >>> priMeFiB(3)\n  5\n  >>> priMeFiB(4)\n  13\n  >>> priMeFiB(5)\n  89\n  */\nconst priMeFiB = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "priMeFiB", "gc": "<|endoftext|>/*\n  priMeFiB returns n-th number that is a Fibonacci number and it's also prime.\n  >>> priMeFiB(1)\n  2\n  >>> priMeFiB(2)\n  3\n  >>> priMeFiB(3)\n  5\n  >>> priMeFiB(4)\n  13\n  >>> priMeFiB(5)\n  89\n  */\nconst priMeFiB = (n) => {\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let prime = true;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n\n  if (n <= 1) {\n    return n;\n  }\n\n  prime = false;\n  i = 2;\n  j = 1;\n  k = 1;\n  l = n;\n  m = 1;\n\n  while (true) {\n    if (l % 2 === 0) {\n      prime = false;\n      break;\n    }\n\n    if (l % i === 0) {\n      prime = false;\n      break;\n    }\n\n    if (l % j === 0) {\n      prime = false;\n      break;\n    }\n\n    if (l % k === 0) {\n      prime = false;\n      break;\n    }\n\n    if (l % m === 0) {\n      prime = false;\n      break;\n    }\n\n    if (l % k === 0 && l % m === 0) {\n      prime = false;\n      break;\n    }\n\n    if (l % m === 0 && l % k === 0) {\n      prime = false;\n      break;\n    }\n\n    if (l % k === 0 && l % m === 0 && l % n === 0) {\n      prime = false;\n      break;\n    }\n\n    if (l % m === 0 && l % k === 0 && l % n === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k === 0 && l % m === 0 && l % n === 1) {\n      prime = false;\n      break;\n    }\n\n    if (l % n === 0 && l % k", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meaNAbsOlutedevIatioN([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meaNAbsOlutedevIatioN = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meaNAbsOlutedevIatioN", "gc": "<|endoftext|>/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meaNAbsOlutedevIatioN([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meaNAbsOlutedevIatioN = (numbers) => {\n  const n = numbers.length;\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / n;\n  const deviations = numbers.map((x) => Math.abs(x - mean));\n  const meanDeviation = deviations.reduce((acc, x) => acc + x, 0) / n;\n  return Math.sqrt(meanDeviation);\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation\n  around the mean of this dataset.\n  Mean Squared Deviation is the average of the squared differences between each\n  element and a centerpoint (mean in this case):\n  MSD = average | x - x_mean |^2\n  >>> meaNAbsOlutedevIatioN([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst meaNAbsOlutedevIatioN2 = (numbers) => {\n  const n = numbers.length;\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / n;\n  const deviations = numbers.map((x) => Math.abs(x - mean));\n  const meanDeviation = deviations.reduce((acc, x) => acc + x, 0) / n;\n  return Math.sqrt(meanDeviation * meanDeviation);\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation\n  around the mean of this dataset.\n  Mean Squared Deviation is the average of the squared differences between each\n  element and a centerpoint (mean in this case):\n  MSD = average | x - x_mean |^2\n  >>> meaNAbsOlutedevIatioN([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst meaNAbsOlutedevIatioN3 = (numbers) => {\n  const n = numbers.length;\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / n;\n  const deviations = numbers.map((x) => Math.abs(x - mean));\n  const meanDeviation = deviations.reduce((acc, x) => acc + x, 0) / n;\n  return Math.sqrt(meanDeviation * meanDeviation * meanDeviation);\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation\n  around the mean of this dataset.\n  Mean Squared Deviation is the average of the squared differences between each\n  element and a centerpoint (mean in this case):\n  MSD = average | x - x_mean |^2\n  >>> meaNAbsOlutedevIatioN([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst meaNAbsOlutedevIatioN4 = (numbers) => {\n  const n = numbers.length;\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / n;\n  const deviations = numbers.map((x) => Math.abs(x - mean));\n  const meanDeviation = deviations.reduce((acc, x) => acc + x, 0) / n;\n  return Math.sqrt(meanDeviation * meanDeviation * meanDeviation * meanDeviation);\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation\n  around the mean of this dataset.\n  Mean Squared Deviation is the average of the squared differences between each\n  element and a centerpoint (mean in this case):\n  MSD = average | x - x_mean |^2\n  >>> meaNAbsOlutedevIatioN([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst meaNAbsOlutedevIatioN5 = (numbers) => {\n  const n = numbers.length;\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / n;\n  const deviations = numbers.map((x) => Math.abs(x - mean));\n  const meanDeviation = deviations.reduce((acc, x) => acc + x, 0) / n;\n  return Math.sqrt(meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation);\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation\n  around the mean of this dataset.\n  Mean Squared Deviation is the average of the squared differences between each\n  element and a centerpoint (mean in this case):\n  MSD = average | x - x_mean |^2\n  >>> meaNAbsOlutedevIatioN([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst meaNAbsOlutedevIatioN6 = (numbers) => {\n  const n = numbers.length;\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / n;\n  const deviations = numbers.map((x) => Math.abs(x - mean));\n  const meanDeviation = deviations.reduce((acc, x) => acc + x, 0) / n;\n  return Math.sqrt(meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation);\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation\n  around the mean of this dataset.\n  Mean Squared Deviation is the average of the squared differences between each\n  element and a centerpoint (mean in this case):\n  MSD = average | x - x_mean |^2\n  >>> meaNAbsOlutedevIatioN([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst meaNAbsOlutedevIatioN7 = (numbers) => {\n  const n = numbers.length;\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / n;\n  const deviations = numbers.map((x) => Math.abs(x - mean));\n  const meanDeviation = deviations.reduce((acc, x) => acc + x, 0) / n;\n  return Math.sqrt(meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation);\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation\n  around the mean of this dataset.\n  Mean Squared Deviation is the average of the squared differences between each\n  element and a centerpoint (mean in this case):\n  MSD = average | x - x_mean |^2\n  >>> meaNAbsOlutedevIatioN([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst meaNAbsOlutedevIatioN8 = (numbers) => {\n  const n = numbers.length;\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / n;\n  const deviations = numbers.map((x) => Math.abs(x - mean));\n  const meanDeviation = deviations.reduce((acc, x) => acc + x, 0) / n;\n  return Math.sqrt(meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation * meanDeviation * mean", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/40", "prompt": "/*\n  triPlessumTozerO takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triPlessumTozerO([1, 3, 5, 0])\n  false\n  >>> triPlessumTozerO([1, 3, -2, 1])\n  true\n  >>> triPlessumTozerO([1, 2, 3, 7])\n  false\n  >>> triPlessumTozerO([2, 4, -5, 3, 9, 7])\n  true\n  >>> triPlessumTozerO([1])\n  false\n  */\nconst triPlessumTozerO = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triPlessumTozerO", "gc": "<|endoftext|>/*\n  triPlessumTozerO takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triPlessumTozerO([1, 3, 5, 0])\n  false\n  >>> triPlessumTozerO([1, 3, -2, 1])\n  true\n  >>> triPlessumTozerO([1, 2, 3, 7])\n  false\n  >>> triPlessumTozerO([2, 4, -5, 3, 9, 7])\n  true\n  >>> triPlessumTozerO([1])\n  false\n  */\nconst triPlessumTozerO = (l) => {\n  let sum = 0;\n  let count = 0;\n  let flag = false;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0 && l[i + 1] === 0 && l[i + 2] === 0) {\n      flag = true;\n      sum += l[i];\n      count++;\n    }\n  }\n  return flag && count === 3;\n};\n\n/*\n  triPlessumTozerU takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triPlessumTozerU([1, 3, 5, 0])\n  false\n  >>> triPlessumTozerU([1, 3, -2, 1])\n  true\n  >>> triPlessumTozerU([1, 2, 3, 7])\n  false\n  >>> triPlessumTozerU([2, 4, -5, 3, 9, 7])\n  true\n  >>> triPlessumTozerU([1])\n  false\n  */\nconst triPlessumTozerU = (l) => {\n  let sum = 0;\n  let count = 0;\n  let flag = false;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0 && l[i + 1] === 0 && l[i + 2] === 0) {\n      flag = true;\n      sum += l[i];\n      count++;\n    }\n  }\n  return flag && count === 3;\n};\n\n/*\n  triPlessumTozerZ takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triPlessumTozerZ([1, 3, 5, 0])\n  false\n  >>> triPlessumTozerZ([1, 3, -2, 1])\n  true\n  >>> triPlessumTozerZ([1, 2, 3, 7])\n  false\n  >>> triPlessumTozerZ([2, 4, -5, 3, 9, 7])\n  true\n  >>> triPlessumTozerZ([1])\n  false\n  */\nconst triPlessumTozerZ = (l) => {\n  let sum = 0;\n  let count = 0;\n  let flag = false;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0 && l[i + 1] === 0 && l[i + 2] === 0) {\n      flag = true;\n      sum += l[i];\n      count++;\n    }\n  }\n  return flag && count === 3;\n};\n\n/*\n  triPlessumTozerI takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triPlessumTozerI([1, 3, 5, 0])\n  false\n  >>> triPlessumTozerI([1, 3, -2, 1])\n  true\n  >>> triPlessumTozerI([1, 2, 3, 7])\n  false\n  >>> triPlessumTozerI([2, 4, -5, 3, 9, 7])\n  true\n  >>> triPlessumTozerI([1])\n  false\n  */\nconst triPlessumTozerI = (l) => {\n  let sum = 0;\n  let count = 0;\n  let flag = false;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0 && l[i + 1] === 0 && l[i + 2] === 0) {\n      flag = true;\n      sum += l[i];\n      count++;\n    }\n  }\n  return flag && count === 3;\n};\n\n/*\n  triPlessumTozerS takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triPlessumTozerS([1, 3, 5, 0])\n  false\n  >>> triPlessumTozerS([1, 3, -2, 1])\n  true\n  >>> triPlessumTozerS([1, 2, 3, 7])\n  false\n  >>> triPlessumTozerS([2, 4, -5, 3, 9, 7])\n  true\n  >>> triPlessumTozerS([1])\n  false\n  */\nconst triPlessumTozerS = (l) => {\n  let sum = 0;\n  let count = 0;\n  let flag = false;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0 && l[i + 1] === 0 && l[i + 2] === 0) {\n      flag = true;\n      sum += l[i];\n      count++;\n    }\n  }\n  return flag && count === 3;\n};\n\n/*\n  triPlessumTozerT takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triPlessumTozerT([1, 3, 5, 0])\n  false\n  >>> triPlessumTozerT([1, 3, -2, 1])\n  true\n  >>> triPlessumTozerT([1, 2, 3, 7])\n  false\n  >>> triPlessumTozerT([2, 4, -5, 3, 9, 7])\n  true\n  >>> triPlessumTozerT([1])\n  false\n  */\nconst triPlessumTozerT = (l) => {\n  let sum = 0;\n  let count = 0;\n  let flag = false;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0 && l[i + 1] === 0 && l[i + 2] === 0) {\n      flag = true;\n      sum += l[i];\n      count++;\n    }\n  }\n  return flag && count === 3;\n};\n\n/*\n  triPlessumTozerF takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triPlessumTozerF([1, 3, 5, 0])\n  false\n  >>> triPlessumTozerF([1, 3, -2, 1])\n  true\n  >>> triPlessumTozerF([1, 2, 3, 7])\n  false\n  >>> triPlessumTozerF([2, 4, -5, 3, 9, 7])\n  true\n  >>> triPlessumTozerF([1])\n  false\n  */\nconst triPlessumTozerF = (l) => {\n  let sum = 0;\n  let count = 0;\n  let flag = false;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0 && l[i + 1] === 0 && l[i + 2] === 0) {\n      flag = true;\n      sum += l[i];\n      count++;\n    }\n  }\n  return flag && count === 3;\n};\n\n/*\n  triPlessumTozerG takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triPlessumTozerG([1, 3, 5, 0])\n  false\n  >>> triPlessumTozerG([1, 3, -2, 1])\n  true\n  >>> triPlessumTozerG([1, 2, 3, 7])\n  false\n  >>> triPlessumTozerG([2, 4, -5, 3, 9, 7])\n  true\n  >>> triPlessumTozerG([1])\n  false\n  */\nconst triPlessumTozerG = (l) => {\n  let sum = 0;\n  let count = 0;\n  let flag = false;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0 && l[i + 1] === 0 && l[i + 2] === 0) {\n      flag = true;\n      sum += l[i];\n      count++;\n    }\n  }\n  return flag && count === 3;\n};\n\n/*\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carracecolliSioN = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carracecolliSioN", "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carracecolliSioN = (n) => {\n  let collisions = 0;\n  let carsLeft = n;\n  let carsRight = n;\n  let carsSpeed = 0;\n  let carsDirection = 0;\n\n  while (true) {\n    collisions++;\n    carsLeft -= 1;\n    carsRight += 1;\n    carsSpeed += 1;\n    carsDirection += 1;\n\n    if (carsLeft <= 0) {\n      carsLeft = 0;\n    }\n    if (carsRight >= n) {\n      carsRight = n;\n    }\n    if (carsSpeed <= 0) {\n      carsSpeed = 0;\n    }\n    if (carsDirection <= 0) {\n      carsDirection = 0;\n    }\n  }\n  return collisions;\n};\n\n/*\n  Given a road network, determine if two roads collide.\n  \n  Inputs:\n    roadNetwork - a road network\n    road1 - a road to start with\n    road2 - a road to compare with\n  \n  Outputs:\n    true if roads collide, false otherwise\n*/\nconst collide = (roadNetwork, road1, road2) => {\n  let collisions = false;\n  let road1Cars = roadNetwork.roads[road1.id].cars;\n  let road2Cars = roadNetwork.roads[road2.id].cars;\n  let road1CarsLength = road1Cars.length;\n  let road2CarsLength = road2Cars.length;\n  let road1CarsIndex = 0;\n  let road2CarsIndex = 0;\n  let road1CarsSpeed = 0;\n  let road2CarsSpeed = 0;\n  let road1CarsDirection = 0;\n  let road2CarsDirection = 0;\n  let road1CarsCollisions = 0;\n  let road2CarsCollisions = 0;\n\n  while (true) {\n    if (road1CarsLength > 0 && road2CarsLength > 0) {\n      if (road1CarsCollisions === road2CarsCollisions) {\n        collisions = true;\n        break;\n      }\n      if (road1CarsCollisions > road2CarsCollisions) {\n        road1CarsCollisions = road2CarsCollisions;\n        road2CarsCollisions = road1CarsCollisions;\n      }\n      road1CarsCollisions++;\n      road2CarsCollisions++;\n      road1CarsIndex++;\n      road2CarsIndex++;\n      road1CarsSpeed += road1CarsCars[road1CarsIndex].speed;\n      road2CarsSpeed += road2CarsCars[road2CarsIndex].speed;\n      road1CarsDirection += road1CarsCars[road1CarsIndex].direction;\n      road2CarsDirection += road2CarsCars[road2CarsIndex].direction;\n      if (road1CarsDirection === road2CarsDirection) {\n        road1CarsDirection = 0;\n        road2CarsDirection = 0;\n      }\n    }\n    if (road1CarsLength === 0) {\n      road1CarsIndex = 0;\n      road2CarsIndex = 0;\n      road1CarsSpeed = 0;\n      road2CarsSpeed = 0;\n      road1CarsDirection = 0;\n      road2CarsDirection = 0;\n    }\n    if (road2CarsLength === 0) {\n      road1CarsIndex = 0;\n      road2CarsIndex = 0;\n      road1CarsSpeed = 0;\n      road2CarsSpeed = 0;\n      road1CarsDirection = 0;\n      road2CarsDirection = 0;\n    }\n    if (road1CarsIndex >= road1CarsLength) {\n      road1CarsIndex = 0;\n      road2CarsIndex = 0;\n      road1CarsSpeed = 0;\n      road2CarsSpeed = 0;\n      road1CarsDirection = 0;\n      road2CarsDirection = 0;\n    }\n    if (road2CarsIndex >= road2CarsLength) {\n      road1CarsIndex = 0;\n      road2CarsIndex = 0;\n      road1CarsSpeed = 0;\n      road2CarsSpeed = 0;\n      road1CarsDirection = 0;\n      road2CarsDirection = 0;\n    }\n    if (road1CarsCars[road1CarsIndex].speed === road2CarsCars[road2CarsIndex].speed) {\n      if (road1CarsCars[road1CarsIndex].direction === road2CarsCars[road2CarsIndex].direction) {\n        if (road1CarsCars[road1CarsIndex].speed > road2CarsCars[road2CarsIndex].speed) {\n          road1CarsSpeed = road2CarsCars[road2CarsIndex].speed;\n          road2CarsSpeed = road1CarsCars[road1CarsIndex].speed;\n          road1CarsDirection = road2CarsCars[road2CarsIndex].direction;\n          road2CarsDirection = road1CarsCars[road1CarsIndex].direction;\n        }\n        if (road1CarsCars[road1CarsIndex].speed < road2CarsCars[road2CarsIndex].speed) {\n          road1CarsSpeed = road2CarsCars[road2CarsIndex].speed;\n          road2CarsSpeed = road1CarsCars[road1CarsIndex].speed;\n          road1CarsDirection = road2CarsCars[road2CarsIndex].direction;\n          road2CarsDirection = road1CarsCars[road1CarsIndex].direction;\n        }\n        if (road1CarsCars[road1CarsIndex].direction === road2CarsCars[road2CarsIndex].direction) {\n          if (road1CarsCars[road1CarsIndex].speed > road2CarsCars[road2CarsIndex].speed) {\n            road1CarsSpeed = road2CarsCars[road2CarsIndex].speed;\n            road2CarsSpeed = road1CarsCars[road1CarsIndex].speed;\n            road1CarsDirection = road2CarsCars[road2CarsIndex].direction;\n            road2CarsDirection = road1CarsCars[road1CarsIndex].direction;\n          }\n          if (road1CarsCars[road1CarsIndex].speed < road2CarsCars[road2CarsIndex].speed) {\n            road1CarsSpeed = road2CarsCars[road2CarsIndex].speed;\n            road2CarsSpeed = road1CarsCars[road1CarsIndex].speed;\n            road1CarsDirection = road2CarsCars[road2CarsIndex].direction;\n            road2Cars", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incRLisT([1, 2, 3])\n  [2, 3, 4]\n  >>> incRLisT([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incRLisT = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incRLisT", "gc": "<|endoftext|>/*Return list with elements incremented by 1.\n  >>> incRLisT([1, 2, 3])\n  [2, 3, 4]\n  >>> incRLisT([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incRLisT = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    res.push(l[i] + 1);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decRLisT([1, 2, 3])\n  [2, 3, 4]\n  >>> decRLisT([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decRLisT = (l) => {\n  let res = [];\n  for (let i = 0; i < l.length; i++) {\n    res.push(l[i] - 1);\n  }\n  return res;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incRLisB([1, 2, 3])\n  [2, 3, 4]\n  >>> incRLisB([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incRLisB = (b) => {\n  let res = [];\n  for (let i = 0; i < b.length; i++) {\n    res.push(parseInt(b[i]) + 1);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decRLisB([1, 2, 3])\n  [2, 3, 4]\n  >>> decRLisB([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decRLisB = (b) => {\n  let res = [];\n  for (let i = 0; i < b.length; i++) {\n    res.push(parseInt(b[i]) - 1);\n  }\n  return res;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incRLisB([1, 2, 3])\n  [2, 3, 4]\n  >>> incRLisB([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incRLisBX = (b) => {\n  let res = [];\n  for (let i = 0; i < b.length; i++) {\n    res.push(parseInt(b[i]) + 1);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decRLisBX([1, 2, 3])\n  [2, 3, 4]\n  >>> decRLisBX([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decRLisBX = (b) => {\n  let res = [];\n  for (let i = 0; i < b.length; i++) {\n    res.push(parseInt(b[i]) - 1);\n  }\n  return res;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incRLisBX([1, 2, 3])\n  [2, 3, 4]\n  >>> incRLisBX([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incRLisBXB = (b) => {\n  let res = [];\n  for (let i = 0; i < b.length; i++) {\n    res.push(parseInt(b[i]) + 1);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decRLisBXB([1, 2, 3])\n  [2, 3, 4]\n  >>> decRLisBXB([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decRLisBXB = (b) => {\n  let res = [];\n  for (let i = 0; i < b.length; i++) {\n    res.push(parseInt(b[i]) - 1);\n  }\n  return res;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incRLisBXB([1, 2, 3])\n  [2, 3, 4]\n  >>> incRLisBXB([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incRLisBXBX = (b) => {\n  let res = [];\n  for (let i = 0; i < b.length; i++) {\n    res.push(parseInt(b[i]) + 1);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decRLisBXBX([1, 2, 3])\n  [2, 3, 4]\n  >>> decRLisBXBX([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decRLisBXBX = (b) => {\n  let res = [];\n  for (let i = 0; i < b.length; i++) {\n    res.push(parseInt(b[i]) - 1);\n  }\n  return res;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incRLisBXBX([1, 2, 3])\n  [2, 3, 4]\n  >>> incRLisBXBX([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incRLisBXBXB = (b) => {\n  let res = [];\n  for (let i = 0; i < b.length; i++) {\n    res.push(parseInt(b[i]) + 1);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decRLisBXBXB([1, 2, 3])\n  [2, 3, 4]\n  >>> decRLisBXBXB([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decRLisBXBXB = (b) => {\n  let res = [];\n  for (let i = 0; i < b.length; i++) {\n    res.push(parseInt(b[i]) - 1);\n  }\n  return res;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incRLisBXBXB([1, 2, 3])\n  [2, 3, 4]\n  >>> incRLisBXBXB([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incRLisBXBXBX = (b) => {\n  let res = [];\n  for (let i = 0; i < b.length; i++) {\n    res.push(parseInt(b[i]) + 1);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decRLisBXBXB([1, 2, 3])\n  [2, 3, 4]\n  >>> decRLisBXBXB([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decRLisBXBXB = (b) => {\n  let res = [];\n  for (let i = 0; i < b.length; i++) {\n    res.push(parseInt(b[i]) - 1);\n  }\n  return res;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incRLisBXBXB([1, 2, 3])\n  [2, 3, 4]\n  >>> incRLisBXBXB([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incRLisBXBXBX = (b) => {\n  let res = [];\n  for (let i = 0; i < b.length; i++) {\n    res.push(parseInt(b[i]) + 1);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decRLisBXBXB([1, 2, 3])\n  [2, 3, 4]\n  >>> decRLisBXBXB([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decRLisBXBXB = (b) => {\n  let res = [];\n  for (let i = 0; i < b.length; i++) {\n    res.push(parseInt(b[i]) - 1);\n  }\n  return res;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incRLisBXBXB([1, 2, 3])\n  [2, 3, 4]\n  >>> incRLisBXBXB([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  paiRsSuMToZeRo takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> paiRsSuMToZeRo([1, 3, 5, 0])\n  false\n  >>> paiRsSuMToZeRo([1, 3, -2, 1])\n  false\n  >>> paiRsSuMToZeRo([1, 2, 3, 7])\n  false\n  >>> paiRsSuMToZeRo([2, 4, -5, 3, 5, 7])\n  true\n  >>> paiRsSuMToZeRo([1])\n  false\n  */\nconst paiRsSuMToZeRo = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "paiRsSuMToZeRo", "gc": "<|endoftext|>/*\n  paiRsSuMToZeRo takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> paiRsSuMToZeRo([1, 3, 5, 0])\n  false\n  >>> paiRsSuMToZeRo([1, 3, -2, 1])\n  false\n  >>> paiRsSuMToZeRo([1, 2, 3, 7])\n  false\n  >>> paiRsSuMToZeRo([2, 4, -5, 3, 5, 7])\n  true\n  >>> paiRsSuMToZeRo([1])\n  false\n  */\nconst paiRsSuMToZeRo = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  paiRsSuMToZe takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> paiRsSuMToZe([1, 3, 5, 0])\n  false\n  >>> paiRsSuMToZe([1, 3, -2, 1])\n  false\n  >>> paiRsSuMToZe([1, 2, 3, 7])\n  false\n  >>> paiRsSuMToZe([2, 4, -5, 3, 5, 7])\n  true\n  >>> paiRsSuMToZe([1])\n  false\n  */\nconst paiRsSuMToZe = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  paiRsSuMToZe takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> paiRsSuMToZe([1, 3, 5, 0])\n  false\n  >>> paiRsSuMToZe([1, 3, -2, 1])\n  false\n  >>> paiRsSuMToZe([1, 2, 3, 7])\n  false\n  >>> paiRsSuMToZe([2, 4, -5, 3, 5, 7])\n  true\n  >>> paiRsSuMToZe([1])\n  false\n  */\nconst paiRsSuMToZe = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  paiRsSuMToZe takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> paiRsSuMToZe([1, 3, 5, 0])\n  false\n  >>> paiRsSuMToZe([1, 3, -2, 1])\n  false\n  >>> paiRsSuMToZe([1, 2, 3, 7])\n  false\n  >>> paiRsSuMToZe([2, 4, -5, 3, 5, 7])\n  true\n  >>> paiRsSuMToZe([1])\n  false\n  */\nconst paiRsSuMToZe = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  paiRsSuMToZe takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> paiRsSuMToZe([1, 3, 5, 0])\n  false\n  >>> paiRsSuMToZe([1, 3, -2, 1])\n  false\n  >>> paiRsSuMToZe([1, 2, 3, 7])\n  false\n  >>> paiRsSuMToZe([2, 4, -5, 3, 5, 7])\n  true\n  >>> paiRsSuMToZe([1])\n  false\n  */\nconst paiRsSuMToZe = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  paiRsSuMToZe takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> paiRsSuMToZe([1, 3, 5, 0])\n  false\n  >>> paiRsSuMToZe([1, 3, -2, 1])\n  false\n  >>> paiRsSuMToZe([1, 2, 3, 7])\n  false\n  >>> paiRsSuMToZe([2, 4, -5, 3, 5, 7])\n  true\n  >>> paiRsSuMToZe([1])\n  false\n  */\nconst paiRsSuMToZe = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  paiRsSuMToZe takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> paiRsSuMToZe([1, 3, 5, 0])\n  false\n  >>> paiRsSuMToZe([1, 3, -2, 1])\n  false\n  >>> paiRsSuMToZe([1, 2, 3, 7])\n  false\n  >>> paiRsSuMToZe([2, 4, -5, 3, 5, 7])\n  true\n  >>> paiRsSuMToZe([1])\n  false\n  */\nconst paiRsSuMToZe = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  paiRsSuMToZe takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> paiRsSuMToZe([1, 3, 5, 0])\n  false\n  >>> paiRsSuMToZe([1, 3, -2, 1])\n  false\n  >>> paiRsSuMToZe([1, 2, 3, 7])\n  false\n  >>> paiRsSuMToZe([2, 4, -5, 3, 5, 7])\n  true\n  >>> paiRsSuMToZe([1])\n  false\n  */\nconst paiRsSuMToZe = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  paiRsSuMToZe takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> paiRsSuMToZe([1, 3, 5, 0])\n  false\n  >>> paiRsSuMToZe([1, 3, -2, 1])\n  false\n  >>> paiRsSuMToZe([1, 2, 3, 7])\n  false\n  >>> paiRsSuMToZe([2, 4, -5, 3, 5, 7])\n  true\n  >>> paiRsSuMToZe([1])\n  false\n  */\nconst paiRsSuMToZe = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> chaNgeBAse(8, 3)\n  '22'\n  >>> chaNgeBAse(8, 2)\n  '1000'\n  >>> chaNgeBAse(7, 2)\n  '111'\n  */\nconst chaNgeBAse = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "chaNgeBAse", "gc": "<|endoftext|>/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> chaNgeBAse(8, 3)\n  '22'\n  >>> chaNgeBAse(8, 2)\n  '1000'\n  >>> chaNgeBAse(7, 2)\n  '111'\n  */\nconst chaNgeBAse = (x, base) => {\n  if (base < 10) {\n    return String(Number(x).toString(base))\n  }\n  return String(Number(x).toString(base)).replace(/0+$/, '')\n}\n\n/*\n  Convert a string to binary number.\n  >>> bin2NgeBAse('0b1010')\n  2\n  >>> bin2NgeBAse('0b1110')\n  4\n  >>> bin2NgeBAse('0b1101')\n  8\n  >>> bin2NgeBAse('0b111')\n  16\n  >>> bin2NgeBAse('0b11101')\n  32\n  >>> bin2NgeBAse('0b11101')\n  64\n  >>> bin2NgeBAse('0b11101')\n  128\n  >>> bin2NgeBAse('0b11101')\n  256\n  >>> bin2NgeBAse('0b11101')\n  512\n  >>> bin2NgeBAse('0b11101')\n  1024\n  >>> bin2NgeBAse('0b11101')\n  2048\n  >>> bin2NgeBAse('0b11101')\n  4096\n  >>> bin2NgeBAse('0b11101')\n  8192\n  >>> bin2NgeBAse('0b11101')\n  16384\n  >>> bin2NgeBAse('0b11101')\n  32768\n  >>> bin2NgeBAse('0b11101')\n  65536\n  >>> bin2NgeBAse('0b11101')\n  131072\n  >>> bin2NgeBAse('0b11101')\n  262144\n  >>> bin2NgeBAse('0b11101')\n  524288\n  >>> bin2NgeBAse('0b11101')\n  1048576\n  >>> bin2NgeBAse('0b11101')\n  2097152\n  >>> bin2NgeBAse('0b11101')\n  4194304\n  >>> bin2NgeBAse('0b11101')\n  8388608\n  >>> bin2NgeBAse('0b11101')\n  16777216\n  >>> bin2NgeBAse('0b11101')\n  33554432\n  >>> bin2NgeBAse('0b11101')\n  67108864\n  >>> bin2NgeBAse('0b11101')\n  134217728\n  >>> bin2NgeBAse('0b11101')\n  268435456\n  >>> bin2NgeBAse('0b11101')\n  536870912\n  >>> bin2NgeBAse('0b11101')\n  1073741824\n  >>> bin2NgeBAse('0b11101')\n  2147483648\n  >>> bin2NgeBAse('0b11101')\n  4294967296\n  >>> bin2NgeBAse('0b11101')\n  8589934592\n  >>> bin2NgeBAse('0b11101')\n  1677721680\n  >>> bin2NgeBAse('0b11101')\n  33554432080\n  >>> bin2NgeBAse('0b11101')\n  6710886480\n  >>> bin2NgeBAse('0b11101')\n  13421772880\n  >>> bin2NgeBAse('0b11101')\n  26843545600\n  >>> bin2NgeBAse('0b11101')\n  53687091200\n  >>> bin2NgeBAse('0b11101')\n  107374182400\n  >>> bin2NgeBAse('0b11101')\n  214748364800\n  >>> bin2NgeBAse('0b11101')\n  429496729600\n  >>> bin2NgeBAse('0b11101')\n  858993459200\n  >>> bin2NgeBAse('0b11101')\n  16777216800\n  >>> bin2NgeBAse('0b11101')\n  335544320800\n  >>> bin2NgeBAse('0b11101')\n  67108864800\n  >>> bin2NgeBAse('0b11101')\n  134217728000\n  >>> bin2NgeBAse('0b11101')\n  268435456000\n  >>> bin2NgeBAse('0b11101')\n  53687091200\n  >>> bin2NgeBAse('0b11101')\n  107374182400\n  >>> bin2NgeBAse('0b11101')\n  2147483648000\n  >>> bin2NgeBAse('0b11101')\n  429496729600\n  >>> bin2NgeBAse('0b11101')\n  858993459200\n  >>> bin2NgeBAse('0b11101')\n  167772168000\n  >>> bin2NgeBAse('0b11101')\n  335544320800\n  >>> bin2NgeBAse('0b11101')\n  67108864800\n  >>> bin2NgeBAse('0b11101')\n  134217728000\n  >>> bin2NgeBAse('0b11101')\n  268435456000\n  >>> bin2NgeBAse('0b11101')\n  53687091200\n  >>> bin2NgeBAse('0b11101')\n  107374182400\n  >>> bin2NgeBAse('0b11101')\n  2147483648000\n  >>> bin2NgeBAse('0b11101')\n  429496729600\n  >>> bin2NgeBAse('0b11101')\n  858993459200\n  >>> bin2NgeBAse('0b11101')\n  167772168000\n  >>> bin2NgeBAse('0b11101')\n  335544320800\n  >>> bin2NgeBAse('0b11101')\n  67108864800\n  >>> bin2NgeBAse('0b11101')\n  134217728000\n  >>> bin2NgeBAse('0b11101')\n  268435456000\n  >>> bin2NgeBAse('0b11101')\n  53687091200\n  >>> bin2NgeBAse('0b11101')\n  107374182400\n  >>> bin2NgeBAse('0b11101')\n  2147483648000\n  >>> bin2NgeBAse('0b11101')\n  4294967", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and high return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  7.5\n  */\nconst triAnglEArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triAnglEArea", "gc": "<|endoftext|>/*Given length of a side and high return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  7.5\n  */\nconst triAnglEArea = (a, h) => {\n  const area = (h / 2) * (a / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)\n  3.5\n  */\nconst triAnglEArea = (l, w) => {\n  const area = (w / 2) * (l / 2);\n  return area;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triAnglEArea(5, 3)", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "gc": "<|endoftext|>/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  >>> fib2(5)\n  1\n  >>> fib2(6)\n  2\n  >>> fib2(7)\n  3\n  >>> fib2(8)\n  5\n  >>> fib2(9)\n  8\n  >>> fib2(10)\n  13\n  */\nconst fib2 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib2(n - 1) + fib2(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  >>> fib3(5)\n  1\n  >>> fib3(6)\n  2\n  >>> fib3(7)\n  3\n  >>> fib3(8)\n  5\n  >>> fib3(9)\n  8\n  >>> fib3(10)\n  13\n  */\nconst fib3 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib3(n - 1) + fib3(n - 2) + fib3(n - 3) + fib3(n - 4);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  >>> fib4(5)\n  1\n  >>> fib4(6)\n  2\n  >>> fib4(7)\n  3\n  >>> fib4(8)\n  5\n  >>> fib4(9)\n  8\n  >>> fib4(10)\n  13\n  */\nconst fib4 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  >>> fib5(5)\n  1\n  >>> fib5(6)\n  2\n  >>> fib5(7)\n  3\n  >>> fib5(8)\n  5\n  >>> fib5(9)\n  8\n  >>> fib5(10)\n  13\n  */\nconst fib5 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib5(n - 1) + fib5(n - 2) + fib5(n - 3) + fib5(n - 4) + fib5(n - 5);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  >>> fib6(5)\n  1\n  >>> fib6(6)\n  2\n  >>> fib6(7)\n  3\n  >>> fib6(8)\n  5\n  >>> fib6(9)\n  8\n  >>> fib6(10)\n  13\n  */\nconst fib6 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib6(n - 1) + fib6(n - 2) + fib6(n - 3) + fib6(n - 4) + fib6(n - 5) + fib6(n - 6);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  >>> fib7(5)\n  1\n  >>> fib7(6)\n  2\n  >>> fib7(7)\n  3\n  >>> fib7(8)\n  5\n  >>> fib7(9)\n  8\n  >>> fib7(10)\n  13\n  */\nconst fib7 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib7(n - 1) + fib7(n - 2) + fib7(n - 3) + fib7(n - 4) + fib7(n - 5) + fib7(n - 6) + fib7(n - 7);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  >>> fib8(5)\n  1\n  >>> fib8(6)\n  2\n  >>> fib8(7)\n  3\n  >>> fib8(8)\n  5\n  >>> fib8(9)\n  8\n  >>> fib8(10)\n  13\n  */\nconst fib8 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib8(n - 1) + fib8(n - 2) + fib8(n - 3) + fib8(n - 4) + fib8(n - 5) + fib8(n - 6) + fib8(n - 7) + fib8(n - 8);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  >>> fib9(5)\n  1\n  >>> fib9(6)\n  2\n  >>> fib9(7)\n  3\n  >>> fib9(8)\n  5\n  >>> fib9(9)\n  8\n  >>> fib9(10)\n  13\n  */\nconst fib9 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib9(n - 1) + fib9(n - 2) + fib9(n - 3) + fib9(n - 4) + fib9(n - 5) + fib9(n - 6) + fib9(n - 7) + fib9(n - 8) + fib9(n - 9);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  >>> fib10(5)\n  1\n  >>> fib10(6)\n  2\n  >>> fib10(7)\n  3\n  >>> fib10(8)\n  5\n  >>> fib10(9)\n  8\n  >>> fib10(10)\n  13\n  */\nconst fib10 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib10(n - 1) + fib10(n - 2) + fib10(n - 3) + fib10(n - 4) + fib10(n - 5) + fib10(n - 6) + fib10(n - 7) + fib10(n - 8) + fib10(n - 9) + fib10(n - 10);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  >>> fib11(5)\n  1\n  >>> fib11(6)\n  2\n  >>> fib11(7)\n  3\n  >>> fib11(8)\n  5\n  >>> fib11(9)\n  8\n  >>> fib11(10)\n  13\n  */\nconst fib11 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib11(n - 1) + fib11(n - 2) + fib11(n - 3) + fib11(n - 4) + fib11(n - 5) + fib11(n - 6) + fib11(n - 7) + fib11(n - 8) + fib11", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/47", "prompt": "/*Return medIan of elements in the list l.\n  >>> medIan([3, 1, 2, 4, 5])\n  3\n  >>> medIan([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medIan = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "medIan", "gc": "<|endoftext|>/*Return medIan of elements in the list l.\n  >>> medIan([3, 1, 2, 4, 5])\n  3\n  >>> medIan([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medIan = (l) => {\n  let sum = 0;\n  let max = 0;\n  let min = 0;\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sum2 = 0;\n  let sum3 = 0;\n  let sum4 = 0;\n  let sum5 = 0;\n  let sum6 = 0;\n  let sum7 = 0;\n  let sum8 = 0;\n  let sum9 = 0;\n  let sum10 = 0;\n  let sum11 = 0;\n  let sum12 = 0;\n  let sum13 = 0;\n  let sum14 = 0;\n  let sum15 = 0;\n  let sum16 = 0;\n  let sum17 = 0;\n  let sum18 = 0;\n  let sum19 = 0;\n  let sum20 = 0;\n  let sum21 = 0;\n  let sum22 = 0;\n  let sum23 = 0;\n  let sum24 = 0;\n  let sum25 = 0;\n  let sum26 = 0;\n  let sum27 = 0;\n  let sum28 = 0;\n  let sum29 = 0;\n  let sum30 = 0;\n  let sum31 = 0;\n  let sum32 = 0;\n  let sum33 = 0;\n  let sum34 = 0;\n  let sum35 = 0;\n  let sum36 = 0;\n  let sum37 = 0;\n  let sum38 = 0;\n  let sum39 = 0;\n  let sum40 = 0;\n  let sum41 = 0;\n  let sum42 = 0;\n  let sum43 = 0;\n  let sum44 = 0;\n  let sum45 = 0;\n  let sum46 = 0;\n  let sum47 = 0;\n  let sum48 = 0;\n  let sum49 = 0;\n  let sum50 = 0;\n  let sum51 = 0;\n  let sum52 = 0;\n  let sum53 = 0;\n  let sum54 = 0;\n  let sum55 = 0;\n  let sum56 = 0;\n  let sum57 = 0;\n  let sum58 = 0;\n  let sum59 = 0;\n  let sum60 = 0;\n  let sum61 = 0;\n  let sum62 = 0;\n  let sum63 = 0;\n  let sum64 = 0;\n  let sum65 = 0;\n  let sum66 = 0;\n  let sum67 = 0;\n  let sum68 = 0;\n  let sum69 = 0;\n  let sum70 = 0;\n  let sum71 = 0;\n  let sum72 = 0;\n  let sum73 = 0;\n  let sum74 = 0;\n  let sum75 = 0;\n  let sum76 = 0;\n  let sum77 = 0;\n  let sum78 = 0;\n  let sum79 = 0;\n  let sum80 = 0;\n  let sum81 = 0;\n  let sum82 = 0;\n  let sum83 = 0;\n  let sum84 = 0;\n  let sum85 = 0;\n  let sum86 = 0;\n  let sum87 = 0;\n  let sum88 = 0;\n  let sum89 = 0;\n  let sum90 = 0;\n  let sum91 = 0;\n  let sum92 = 0;\n  let sum93 = 0;\n  let sum94 = 0;\n  let sum95 = 0;\n  let sum96 = 0;\n  let sum97 = 0;\n  let sum98 = 0;\n  let sum99 = 0;\n  let sum100 = 0;\n  let sum101 = 0;\n  let sum102 = 0;\n  let sum103 = 0;\n  let sum104 = 0;\n  let sum105 = 0;\n  let sum106 = 0;\n  let sum107 = 0;\n  let sum108 = 0;\n  let sum109 = 0;\n  let sum110 = 0;\n  let sum111 = 0;\n  let sum112 = 0;\n  let sum113 = 0;\n  let sum114 = 0;\n  let sum115 = 0;\n  let sum116 = 0;\n  let sum117 = 0;\n  let sum118 = 0;\n  let sum119 = 0;\n  let sum120 = 0;\n  let sum121 = 0;\n  let sum122 = 0;\n  let sum123 = 0;\n  let sum124 = 0;\n  let sum125 = 0;\n  let sum126 = 0;\n  let sum127 = 0;\n  let sum128 = 0;\n  let sum129 = 0;\n  let sum130 = 0;\n  let sum131 = 0;\n  let sum132 = 0;\n  let sum133 = 0;\n  let sum134 = 0;\n  let sum135 = 0;\n  let sum136 = 0;\n  let sum137 = 0;\n  let sum138 = 0;\n  let sum139 = 0;\n  let sum140 = 0;\n  let sum141 = 0;\n  let sum142 = 0;\n  let sum143 = 0;\n  let sum144 = 0;\n  let sum145 = 0;\n  let sum146 = 0;\n  let sum147 = 0;\n  let sum148 = 0;\n  let sum149 = 0;\n  let sum150 = 0;\n  let sum151 = 0;\n  let sum152 = 0;\n  let sum153 = 0;\n  let sum154 = 0;\n  let sum155 = 0;\n  let sum156 = 0;\n  let sum157 = 0;\n  let sum158 = 0;\n  let sum159 = 0;\n  let sum160 = 0;\n  let sum161 = 0;\n  let sum162 = 0;\n  let sum163 = 0;\n  let sum164 = 0;\n  let sum165 = 0;\n  let sum166 = 0;\n  let sum167 = 0;\n  let sum168 = 0;\n  let sum169 = 0;\n  let sum170 = 0;\n  let sum171 = 0;\n  let sum172 = 0;\n  let sum173 = 0;\n  let sum174 = 0;\n  let sum175 = 0;\n  let sum176 = 0;\n  let sum177 = 0;\n  let sum178 = 0;\n  let sum179 = 0;\n  let sum180 = 0;\n  let sum181 = 0;\n  let sum182 = 0;\n  let sum183 = 0;\n  let sum184 = 0;\n  let sum185 = 0;\n  let sum186 = 0;\n  let sum187 = 0;\n  let sum188 = 0;\n  let sum189 = 0;\n  let sum190 = 0;\n  let sum191 = 0;\n  let sum192 = 0;\n  let sum193 = 0;\n  let sum194 = 0;\n  let sum195 = 0;\n  let sum196 = 0;\n  let sum197 = 0;\n  let sum198 = 0;\n  let sum199 = 0;\n  let sum200 = 0;\n  let sum201 = 0;\n  let sum202 = 0;\n  let sum203 = 0;\n  let sum204 = 0;\n  let sum205 = 0;\n  let sum206 = 0;\n  let sum207 = 0;\n  let sum208 = 0;\n  let sum209 = 0;\n  let sum210 = 0;\n  let sum211 = 0;\n  let sum212 = 0;\n  let sum213 = 0;\n  let sum214 = 0;\n  let sum215 = 0;\n  let sum216 = 0;\n  let sum217 = 0;\n  let sum218 = 0;\n  let sum219 = 0;\n  let sum220 = 0;\n  let sum221 = 0;\n  let sum222 = 0;\n  let sum223 = 0;\n  let sum224 = 0;\n  let sum225 = 0;\n  let sum226 = 0;\n  let sum227 = 0;\n  let sum228 = 0;\n  let sum229 = 0;\n  let sum230 = 0;\n  let sum231 = 0;\n  let sum232 = 0;\n  let sum233 = 0;\n  let sum234 = 0;\n  let sum235 = 0;\n  let sum236 = 0;\n  let sum237 = 0;\n  let sum238 = 0;\n  let sum239 = 0;\n  let sum240 = 0;\n  let sum241 = 0;\n  let sum242 = 0;\n  let sum243 = 0;\n  let sum244 = 0;\n  let sum245 = 0;\n  let sum246 = 0;\n  let sum247 = 0;\n  let sum248 = 0;\n  let sum249 = 0;\n  let sum250 = 0;\n  let sum251 = 0;\n  let sum252 = 0;\n  let sum253 = 0;\n  let sum254 = 0;\n  let sum255 = 0;\n  let sum256 = 0;\n  let sum257 = 0;\n  let sum258 = 0;\n  let sum259 = 0;\n  let sum260 = 0;\n  let sum261 = 0;\n  let sum262 = 0;\n  let sum263 = 0;\n  let sum264 = 0;\n  let sum265 = 0;\n  let sum266 = 0;\n  let sum267 = 0;\n  let sum268 = 0;\n  let sum269 = 0;\n  let sum270 = 0;\n  let sum271 = 0;\n  let sum272 = 0;\n  let sum273 = 0;\n  let sum274 = 0;\n  let sum275 = 0;\n  let sum276 = 0;\n  let sum277 = 0;\n  let sum278 = 0;\n  let sum279 = 0;\n  let sum280 = 0;\n  let sum281 = 0;\n  let sum282 = 0;\n  let sum283 = 0;\n  let sum284 = 0;\n  let sum285 = 0;\n  let sum286 = 0;\n  let sum287 = 0;\n  let sum288 = 0;\n  let sum289 = 0;\n  let sum290 = 0;\n  let sum291 = 0;\n  let sum292 = 0;\n  let sum", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a palindrome\n  >>> isPAlinDrome('')\n  true\n  >>> isPAlinDrome('aba')\n  true\n  >>> isPAlinDrome('aaaaa')\n  true\n  >>> isPAlinDrome('zbcd')\n  false\n  */\nconst isPAlinDrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPAlinDrome", "gc": "<|endoftext|>/*\n  Checks if given string is a palindrome\n  >>> isPAlinDrome('')\n  true\n  >>> isPAlinDrome('aba')\n  true\n  >>> isPAlinDrome('aaaaa')\n  true\n  >>> isPAlinDrome('zbcd')\n  false\n  */\nconst isPAlinDrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPAlinDrome('aba')\n  true\n  >>> isPAlinDrome('aaaaa')\n  true\n  >>> isPAlinDrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeReverse = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeReverse('aba')\n  true\n  >>> isPalindromeReverse('aaaaa')\n  true\n  >>> isPalindromeReverse('zbcd')\n  false\n  */\nconst isPalindromeReversed = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeReversed('aba')\n  true\n  >>> isPalindromeReversed('aaaaa')\n  true\n  >>> isPalindromeReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReverse = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeReversedReverse('aba')\n  true\n  >>> isPalindromeReversedReverse('aaaaa')\n  true\n  >>> isPalindromeReversedReverse('zbcd')\n  false\n  */\nconst isPalindromeReversedReversed = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReverse = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeReversedReversedReverse('aba')\n  true\n  >>> isPalindromeReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversed = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReverse = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeReversedReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReversedReverse = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeReversedReversedReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReversedReversedReverse = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeReversedReversedReversedReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReversedReversedReversedReverse = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeReversedReversedReversedReversedReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversedReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReversedReversedReversedReversedReverse = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindromeReversedReversedReversedReverse", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modP(3, 5)\n  3\n  >>> modP(1101, 101)\n  2\n  >>> modP(0, 101)\n  1\n  >>> modP(3, 11)\n  8\n  >>> modP(100, 101)\n  1\n  */\nconst modP = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modP", "gc": "<|endoftext|>/*Return 2^n modulo p (be aware of numerics).\n  >>> modP(3, 5)\n  3\n  >>> modP(1101, 101)\n  2\n  >>> modP(0, 101)\n  1\n  >>> modP(3, 11)\n  8\n  >>> modP(100, 101)\n  1\n  */\nconst modP = (n, p) => {\n  if (n < 0 || p <= 0) return 0;\n  if (p === 1) return 1;\n  if (p === 2) return 2;\n  if (p === 3) return 3;\n  if (p === 4) return 4;\n  if (p === 5) return 5;\n  if (p === 6) return 6;\n  if (p === 7) return 7;\n  if (p === 8) return 8;\n  if (p === 9) return 9;\n  if (p === 10) return 10;\n  if (p === 11) return 11;\n  if (p === 12) return 12;\n  if (p === 13) return 13;\n  if (p === 14) return 14;\n  if (p === 15) return 15;\n  if (p === 16) return 16;\n  if (p === 17) return 17;\n  if (p === 18) return 18;\n  if (p === 19) return 19;\n  if (p === 20) return 20;\n  if (p === 21) return 21;\n  if (p === 22) return 22;\n  if (p === 23) return 23;\n  if (p === 24) return 24;\n  if (p === 25) return 25;\n  if (p === 26) return 26;\n  if (p === 27) return 27;\n  if (p === 28) return 28;\n  if (p === 29) return 29;\n  if (p === 30) return 30;\n  if (p === 31) return 31;\n  if (p === 32) return 32;\n  if (p === 33) return 33;\n  if (p === 34) return 34;\n  if (p === 35) return 35;\n  if (p === 36) return 36;\n  if (p === 37) return 37;\n  if (p === 38) return 38;\n  if (p === 39) return 39;\n  if (p === 40) return 40;\n  if (p === 41) return 41;\n  if (p === 42) return 42;\n  if (p === 43) return 43;\n  if (p === 44) return 44;\n  if (p === 45) return 45;\n  if (p === 46) return 46;\n  if (p === 47) return 47;\n  if (p === 48) return 48;\n  if (p === 49) return 49;\n  if (p === 50) return 50;\n  if (p === 51) return 51;\n  if (p === 52) return 52;\n  if (p === 53) return 53;\n  if (p === 54) return 54;\n  if (p === 55) return 55;\n  if (p === 56) return 56;\n  if (p === 57) return 57;\n  if (p === 58) return 58;\n  if (p === 59) return 59;\n  if (p === 60) return 60;\n  if (p === 61) return 61;\n  if (p === 62) return 62;\n  if (p === 63) return 63;\n  if (p === 64) return 64;\n  if (p === 65) return 65;\n  if (p === 66) return 66;\n  if (p === 67) return 67;\n  if (p === 68) return 68;\n  if (p === 69) return 69;\n  if (p === 70) return 70;\n  if (p === 71) return 71;\n  if (p === 72) return 72;\n  if (p === 73) return 73;\n  if (p === 74) return 74;\n  if (p === 75) return 75;\n  if (p === 76) return 76;\n  if (p === 77) return 77;\n  if (p === 78) return 78;\n  if (p === 79) return 79;\n  if (p === 80) return 80;\n  if (p === 81) return 81;\n  if (p === 82) return 82;\n  if (p === 83) return 83;\n  if (p === 84) return 84;\n  if (p === 85) return 85;\n  if (p === 86) return 86;\n  if (p === 87) return 87;\n  if (p === 88) return 88;\n  if (p === 89) return 89;\n  if (p === 90) return 90;\n  if (p === 91) return 91;\n  if (p === 92) return 92;\n  if (p === 93) return 93;\n  if (p === 94) return 94;\n  if (p === 95) return 95;\n  if (p === 96) return 96;\n  if (p === 97) return 97;\n  if (p === 98) return 98;\n  if (p === 99) return 99;\n  if (p === 100) return 100;\n  if (p === 101) return 101;\n  if (p === 102) return 102;\n  if (p === 103) return 103;\n  if (p === 104) return 104;\n  if (p === 105) return 105;\n  if (p === 106) return 106;\n  if (p === 107) return 107;\n  if (p === 108) return 108;\n  if (p === 109) return 109;\n  if (p === 110) return 110;\n  if (p === 111) return 111;\n  if (p === 112) return 112;\n  if (p === 113) return 113;\n  if (p === 114) return 114;\n  if (p === 115) return 115;\n  if (p === 116) return 116;\n  if (p === 117) return 117;\n  if (p === 118) return 118;\n  if (p === 119) return 119;\n  if (p === 120) return 120;\n  if (p === 121) return 121;\n  if (p === 122) return 122;\n  if (p === 123) return 123;\n  if (p === 124) return 124;\n  if (p === 125) return 125;\n  if (p === 126) return 126;\n  if (p === 127) return 127;\n  if (p === 128) return 128;\n  if (p === 129) return 129;\n  if (p === 130) return 130;\n  if (p === 131) return 131;\n  if (p === 132) return 132;\n  if (p === 133) return 133;\n  if (p === 134) return 134;\n  if (p === 135) return 135;\n  if (p === 136) return 136;\n  if (p === 137) return 137;\n  if (p === 138) return 138;\n  if (p === 139) return 139;\n  if (p === 140) return 140;\n  if (p === 141) return 141;\n  if (p === 142) return 142;\n  if (p === 143) return 143;\n  if (p === 144) return 144;\n  if (p === 145) return 145;\n  if (p === 146) return 146;\n  if (p === 147) return 147;\n  if (p === 148) return 148;\n  if (p === 149) return 149;\n  if (p === 150) return 150;\n  if (p === 151) return 151;\n  if (p === 152) return 152;\n  if (p === 153) return 153;\n  if (p === 154) return 154;\n  if (p === 155) return 155;\n  if (p === 156) return 156;\n  if (p === 157) return 157;\n  if (p === 158) return 158;\n  if (p === 159) return 159;\n  if (p === 160) return 160;\n  if (p === 161) return 161;\n  if (p === 162) return 162;\n  if (p === 163) return 163;\n  if (p === 164) return 164;\n  if (p === 165) return 165;\n  if (p === 166) return 166;\n  if (p === 167) return 167;\n  if (p === 168) return 168;\n  if (p === 169) return 169;\n  if (p === 170) return 170;\n  if (p === 171) return 171;\n  if (p === 172) return 172;\n  if (p === 173) return 173;\n  if (p === 174) return 174;\n  if (p === 175) return 175;\n  if (p === 176) return 176;\n  if (p === 177) return 177;\n  if (p === 178) return 178;\n  if (p === 179) return 179;\n  if (p === 180) return 18", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intErspErse([], 4)\n  []\n  >>> intErspErse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intErspErse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intErspErse", "gc": "<|endoftext|>/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intErspErse([], 4)\n  []\n  >>> intErspErse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intErspErse = (numbers, delimeter) => {\n  const result = [];\n  let index = 0;\n  while (index < numbers.length) {\n    const number = numbers[index];\n    const nextIndex = index + 1;\n    if (nextIndex < numbers.length) {\n      const nextNumber = numbers[nextIndex];\n      if (number < nextNumber) {\n        result.push(number);\n        index++;\n      } else {\n        result.push(nextNumber);\n        index++;\n      }\n    } else {\n      result.push(number);\n      index++;\n    }\n  }\n  return result;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * >>> removeAll([1,2,3,4,5], 2)\n  [1, 3]\n  >>> removeAll([1,2,3,4,5], 3)\n  [3, 4]\n  >>> removeAll([1,2,3,4,5], 4)\n  []\n  */\nconst removeAll = (numbers, element) => {\n  const result = [];\n  let index = 0;\n  while (index < numbers.length) {\n    if (numbers[index] === element) {\n      result.push(numbers[index]);\n      index++;\n    } else {\n      result.push(numbers[index]);\n      index++;\n    }\n  }\n  return result;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * >>> removeAll([1,2,3,4,5], 2)\n  [1, 3]\n  >>> removeAll([1,2,3,4,5], 3)\n  [3, 4]\n  >>> removeAll([1,2,3,4,5], 4)\n  []\n  */\nconst removeAll = (numbers, element) => {\n  const result = [];\n  let index = 0;\n  while (index < numbers.length) {\n    if (numbers[index] === element) {\n      result.push(numbers[index]);\n      index++;\n    } else {\n      result.push(numbers[index]);\n      index++;\n    }\n  }\n  return result;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * >>> removeAll([1,2,3,4,5], 2)\n  [1, 3]\n  >>> removeAll([1,2,3,4,5], 3)\n  [3, 4]\n  >>> removeAll([1,2,3,4,5], 4)\n  []\n  */\nconst removeAll = (numbers, element) => {\n  const result = [];\n  let index = 0;\n  while (index < numbers.length) {\n    if (numbers[index] === element) {\n      result.push(numbers[index]);\n      index++;\n    } else {\n      result.push(numbers[index]);\n      index++;\n    }\n  }\n  return result;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * >>> removeAll([1,2,3,4,5], 2)\n  [1, 3]\n  >>> removeAll([1,2,3,4,5], 3)\n  [3, 4]\n  >>> removeAll([1,2,3,4,5], 4)\n  []\n  */\nconst removeAll = (numbers, element) => {\n  const result = [];\n  let index = 0;\n  while (index < numbers.length) {\n    if (numbers[index] === element) {\n      result.push(numbers[index]);\n      index++;\n    } else {\n      result.push(numbers[index]);\n      index++;\n    }\n  }\n  return result;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * >>> removeAll([1,2,3,4,5], 2)\n  [1, 3]\n  >>> removeAll([1,2,3,4,5], 3)\n  [3, 4]\n  >>> removeAll([1,2,3,4,5], 4)\n  []\n  */\nconst removeAll = (numbers, element) => {\n  const result = [];\n  let index = 0;\n  while (index < numbers.length) {\n    if (numbers[index] === element) {\n      result.push(numbers[index]);\n      index++;\n    } else {\n      result.push(numbers[index]);\n      index++;\n    }\n  }\n  return result;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * >>> removeAll([1,2,3,4,5], 2)\n  [1, 3]\n  >>> removeAll([1,2,3,4,5], 3)\n  [3, 4]\n  >>> removeAll([1,2,3,4,5], 4)\n  []\n  */\nconst removeAll = (numbers, element) => {\n  const result = [];\n  let index = 0;\n  while (index < numbers.length) {\n    if (numbers[index] === element) {\n      result.push(numbers[index]);\n      index++;\n    } else {\n      result.push(numbers[index]);\n      index++;\n    }\n  }\n  return result;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * >>> removeAll([1,2,3,4,5], 2)\n  [1, 3]\n  >>> removeAll([1,2,3,4,5], 3)\n  [3, 4]\n  >>> removeAll([1,2,3,4,5], 4)\n  []\n  */\nconst removeAll = (numbers, element) => {\n  const result = [];\n  let index = 0;\n  while (index < numbers.length) {\n    if (numbers[index] === element) {\n      result.push(numbers[index]);\n      index++;\n    } else {\n      result.push(numbers[index]);\n      index++;\n    }\n  }\n  return result;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * >>> removeAll([1,2,3,4,5], 2)\n  [1, 3]\n  >>> removeAll([1,2,3,4,5], 3)\n  [3, 4]\n  >>> removeAll([1,2,3,4,5], 4)\n  []\n  */\nconst removeAll = (numbers, element) => {\n  const result = [];\n  let index = 0;\n  while (index < numbers.length) {\n    if (numbers[index] === element) {\n      result.push(numbers[index]);\n      index++;\n    } else {\n      result.push(numbers[index]);\n      index++;\n    }\n  }\n  return result;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * >>> removeAll([1,2,3,4,5], 2)\n  [1, 3]\n  >>> removeAll([1,2,3,4,5], 3)\n  [3, 4]\n  >>> removeAll([1,2,3,4,5], 4)\n  []\n  */\nconst removeAll = (numbers, element) => {\n  const result = [];\n  let index = 0;\n  while (index < numbers.length) {\n    if (numbers[index] === element) {\n      result.push(numbers[index]);\n      index++;\n    } else {\n      result.push(numbers[index]);\n      index++;\n    }\n  }\n  return result;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * >>> removeAll([1,2,3,4,5], 2)\n  [1, 3]\n  >>> removeAll([1,2,3,4,5], 3)\n  [3, 4]\n  >>> removeAll([1,2,3,4,5], 4)\n  []\n  */\nconst removeAll = (numbers, element) => {\n  const result = [];\n  let index = 0;\n  while (index < numbers.length) {\n    if (numbers[index] === element) {\n      result.push(numbers[index]);\n      index++;\n    } else {\n      result.push(numbers[index]);\n      index++;\n    }\n  }\n  return result;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * >>> removeAll([1,2,3,4,5], 2)\n  [1, 3]\n  >>> removeAll([1,2,3,4,5], 3)\n  [3, 4]\n  >>> removeAll([1,2,3,4,5], 4)\n  []\n  */\nconst removeAll = (numbers, element) => {\n  const result = [];\n  let index = 0;\n  while (index < numbers.length) {\n    if (numbers[index] === element) {\n      result.push(numbers[index]);\n      index++;\n    } else {\n      result.push(numbers[index]);\n      index++;\n    }\n  }\n  return result;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * >>> removeAll([1,2,3,4,5], 2)\n  [1, 3]\n  >>> removeAll([1,2,3,4,5], 3)\n  [3, 4]\n  >>> removeAll([1,2,3,4,5], 4)\n  []\n  */\nconst removeAll = (numbers, element) => {\n  const result = [];\n  let index = 0;\n  while (index < numbers.length) {\n    if (numbers[index] === element) {\n      result.push(numbers[index]);\n      index++;\n    } else {\n      result.push(numbers[index]);\n      index++;\n    }\n  }\n  return result;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encOdeSHift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encOdeSHift", "gc": "<|endoftext|>/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encOdeSHift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encOdeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encOdeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encOdeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encOdeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encOdeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encOdeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encOdeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encOdeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encOdeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encOdeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encOdeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/51", "prompt": "/*\n  remOveVOwels is a function that takes string and returns string without vowels.\n  >>> remOveVOwels('')\n  ''\n  >>> remOveVOwels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> remOveVOwels('abcdef')\n  'bcdf'\n  >>> remOveVOwels('aaaaa')\n  ''\n  >>> remOveVOwels('aaBAA')\n  'B'\n  >>> remOveVOwels('zbcd')\n  'zbcd'\n  */\nconst remOveVOwels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "remOveVOwels", "gc": "<|endoftext|>/*\n  remOveVOwels is a function that takes string and returns string without vowels.\n  >>> remOveVOwels('')\n  ''\n  >>> remOveVOwels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> remOveVOwels('abcdef')\n  'bcdf'\n  >>> remOveVOwels('aaaaa')\n  ''\n  >>> remOveVOwels('aaBAA')\n  'B'\n  >>> remOveVOwels('zbcd')\n  'zbcd'\n  */\nconst remOveVOwels = (text) => {\n  let vowels = 'aeiouAEIOU'\n  let vowelsLength = vowels.length\n  let vowelsIndex = 0\n  let vowelsIndex2 = 0\n  let vowelsIndex3 = 0\n  let vowelsIndex4 = 0\n  let vowelsIndex5 = 0\n  let vowelsIndex6 = 0\n  let vowelsIndex7 = 0\n  let vowelsIndex8 = 0\n  let vowelsIndex9 = 0\n  let vowelsIndex10 = 0\n  let vowelsIndex11 = 0\n  let vowelsIndex12 = 0\n  let vowelsIndex13 = 0\n  let vowelsIndex14 = 0\n  let vowelsIndex15 = 0\n  let vowelsIndex16 = 0\n  let vowelsIndex17 = 0\n  let vowelsIndex18 = 0\n  let vowelsIndex19 = 0\n  let vowelsIndex20 = 0\n  let vowelsIndex21 = 0\n  let vowelsIndex22 = 0\n  let vowelsIndex23 = 0\n  let vowelsIndex24 = 0\n  let vowelsIndex25 = 0\n  let vowelsIndex26 = 0\n  let vowelsIndex27 = 0\n  let vowelsIndex28 = 0\n  let vowelsIndex29 = 0\n  let vowelsIndex30 = 0\n  let vowelsIndex31 = 0\n  let vowelsIndex32 = 0\n  let vowelsIndex33 = 0\n  let vowelsIndex34 = 0\n  let vowelsIndex35 = 0\n  let vowelsIndex36 = 0\n  let vowelsIndex37 = 0\n  let vowelsIndex38 = 0\n  let vowelsIndex39 = 0\n  let vowelsIndex40 = 0\n  let vowelsIndex41 = 0\n  let vowelsIndex42 = 0\n  let vowelsIndex43 = 0\n  let vowelsIndex44 = 0\n  let vowelsIndex45 = 0\n  let vowelsIndex46 = 0\n  let vowelsIndex47 = 0\n  let vowelsIndex48 = 0\n  let vowelsIndex49 = 0\n  let vowelsIndex50 = 0\n  let vowelsIndex51 = 0\n  let vowelsIndex52 = 0\n  let vowelsIndex53 = 0\n  let vowelsIndex54 = 0\n  let vowelsIndex55 = 0\n  let vowelsIndex56 = 0\n  let vowelsIndex57 = 0\n  let vowelsIndex58 = 0\n  let vowelsIndex59 = 0\n  let vowelsIndex60 = 0\n  let vowelsIndex61 = 0\n  let vowelsIndex62 = 0\n  let vowelsIndex63 = 0\n  let vowelsIndex64 = 0\n  let vowelsIndex65 = 0\n  let vowelsIndex66 = 0\n  let vowelsIndex67 = 0\n  let vowelsIndex68 = 0\n  let vowelsIndex69 = 0\n  let vowelsIndex70 = 0\n  let vowelsIndex71 = 0\n  let vowelsIndex72 = 0\n  let vowelsIndex73 = 0\n  let vowelsIndex74 = 0\n  let vowelsIndex75 = 0\n  let vowelsIndex76 = 0\n  let vowelsIndex77 = 0\n  let vowelsIndex78 = 0\n  let vowelsIndex79 = 0\n  let vowelsIndex80 = 0\n  let vowelsIndex81 = 0\n  let vowelsIndex82 = 0\n  let vowelsIndex83 = 0\n  let vowelsIndex84 = 0\n  let vowelsIndex85 = 0\n  let vowelsIndex86 = 0\n  let vowelsIndex87 = 0\n  let vowelsIndex88 = 0\n  let vowelsIndex89 = 0\n  let vowelsIndex90 = 0\n  let vowelsIndex91 = 0\n  let vowelsIndex92 = 0\n  let vowelsIndex93 = 0\n  let vowelsIndex94 = 0\n  let vowelsIndex95 = 0\n  let vowelsIndex96 = 0\n  let vowelsIndex97 = 0\n  let vowelsIndex98 = 0\n  let vowelsIndex99 = 0\n  let vowelsIndex100 = 0\n  let vowelsIndex101 = 0\n  let vowelsIndex102 = 0\n  let vowelsIndex103 = 0\n  let vowelsIndex104 = 0\n  let vowelsIndex105 = 0\n  let vowelsIndex106 = 0\n  let vowelsIndex107 = 0\n  let vowelsIndex108 = 0\n  let vowelsIndex109 = 0\n  let vowelsIndex110 = 0\n  let vowelsIndex111 = 0\n  let vowelsIndex112 = 0\n  let vowelsIndex113 = 0\n  let vowelsIndex114 = 0\n  let vowelsIndex115 = 0\n  let vowelsIndex116 = 0\n  let vowelsIndex117 = 0\n  let vowelsIndex118 = 0\n  let vowelsIndex119 = 0\n  let vowelsIndex120 = 0\n  let vowelsIndex121 = 0\n  let vowelsIndex122 = 0\n  let vowelsIndex123 = 0\n  let vowelsIndex124 = 0\n  let vowelsIndex125 = 0\n  let vowelsIndex126 = 0\n  let vowelsIndex127 = 0\n  let vowelsIndex128 = 0\n  let vowelsIndex129 = 0\n  let vowelsIndex130 = 0\n  let vowelsIndex131 = 0\n  let vowelsIndex132 = 0\n  let vowelsIndex133 = 0\n  let vowelsIndex134 = 0\n  let vowelsIndex135 = 0\n  let vowelsIndex136 = 0\n  let vowelsIndex137 = 0\n  let vowelsIndex138 = 0\n  let vowelsIndex139 = 0\n  let vowelsIndex140 = 0\n  let vowelsIndex141 = 0\n  let vowelsIndex142 = 0\n  let vowelsIndex143 = 0\n  let vowelsIndex144 = 0\n  let vowelsIndex145 = 0\n  let vowelsIndex146 = 0\n  let vowelsIndex147 = 0\n  let vowelsIndex148 = 0\n  let vowelsIndex149 = 0\n  let vowelsIndex150 = 0\n  let vowelsIndex151 = 0\n  let vowelsIndex152 = 0\n  let vowelsIndex153 = 0\n  let vowelsIndex154 = 0\n  let vowelsIndex155 = 0\n  let vowelsIndex156 = 0\n  let vowelsIndex157 = 0\n  let vowelsIndex158 = 0\n  let vowelsIndex159 = 0\n  let vowelsIndex160 = 0\n  let vowelsIndex161 = 0\n  let vowelsIndex162 = 0\n  let vowelsIndex163 = 0\n  let vowelsIndex164 = 0\n  let vowelsIndex165 = 0\n  let vowelsIndex166 = 0\n  let vowelsIndex167 = 0\n  let vowelsIndex168 = 0\n  let vowelsIndex169 = 0\n  let vowelsIndex170 = 0\n  let vowelsIndex171 = 0\n  let vowelsIndex172 = 0\n  let vowelsIndex173 = 0\n  let vowelsIndex174 = 0\n  let vowelsIndex175 = 0\n  let vowelsIndex176 = 0\n  let vowelsIndex177 = 0\n  let vowelsIndex178 = 0\n  let vowelsIndex179 = 0\n  let vowelsIndex180 = 0\n  let vowelsIndex181 = 0\n  let vowelsIndex182 = 0\n  let vowelsIndex183 = 0\n  let vowelsIndex184 = 0\n  let vowelsIndex185 = 0\n  let vowelsIndex186 = 0\n  let vowelsIndex187 = 0\n  let vowelsIndex188 = 0\n  let vowelsIndex189 = 0\n  let vowelsIndex190 = 0\n  let vowelsIndex191 = 0\n  let vowelsIndex192 = 0\n  let vowelsIndex193 = 0\n  let vowelsIndex194 = 0\n  let vowelsIndex195 = 0\n  let vowels", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belOwThReshoLd([1, 2, 4, 10], 100)\n  true\n  >>> belOwThReshoLd([1, 20, 4, 10], 5)\n  false\n  */\nconst belOwThReshoLd = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belOwThReshoLd", "gc": "<|endoftext|>/*Return true if all numbers in the list l are below threshold t.\n  >>> belOwThReshoLd([1, 2, 4, 10], 100)\n  true\n  >>> belOwThReshoLd([1, 20, 4, 10], 5)\n  false\n  */\nconst belOwThReshoLd = (l, t) => {\n  return l.every(n => n <= t);\n};\n\n/*Return true if all numbers in the list l are above threshold t.\n  >>> belOwThReshoLd([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoLd([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoLg = (l, t) => {\n  return l.every(n => n > t);\n};\n\n/*Return true if all numbers in the list l are equal or above threshold t.\n  >>> belOwThReshoLg([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoLg([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoEq = (l, t) => {\n  return l.every(n => n === t);\n};\n\n/*Return true if all numbers in the list l are equal or below threshold t.\n  >>> belOwThReshoEq([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoEq([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoNe = (l, t) => {\n  return l.every(n => n >= t);\n};\n\n/*Return true if all numbers in the list l are equal or equal above threshold t.\n  >>> belOwThReshoEq([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoEq([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoEqg = (l, t) => {\n  return l.every(n => n === t);\n};\n\n/*Return true if all numbers in the list l are equal or equal below threshold t.\n  >>> belOwThReshoEqg([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoEqg([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoEqLg = (l, t) => {\n  return l.every(n => n >= t);\n};\n\n/*Return true if all numbers in the list l are equal or equal above threshold t.\n  >>> belOwThReshoEqLg([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoEqLg([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoEqEq = (l, t) => {\n  return l.every(n => n === t);\n};\n\n/*Return true if all numbers in the list l are equal or equal below threshold t.\n  >>> belOwThReshoEqEq([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoEqEq([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoEqNe = (l, t) => {\n  return l.every(n => n <= t);\n};\n\n/*Return true if all numbers in the list l are equal or equal above threshold t.\n  >>> belOwThReshoEqEq([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoEqEq([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoEqEqg = (l, t) => {\n  return l.every(n => n === t);\n};\n\n/*Return true if all numbers in the list l are equal or equal below threshold t.\n  >>> belOwThReshoEqEqLg([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoEqEqLg([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoEqEqLg = (l, t) => {\n  return l.every(n => n <= t);\n};\n\n/*Return true if all numbers in the list l are equal or equal above threshold t.\n  >>> belOwThReshoEqEqEq([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoEqEqEq([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoEqEqEq = (l, t) => {\n  return l.every(n => n === t);\n};\n\n/*Return true if all numbers in the list l are equal or equal below threshold t.\n  >>> belOwThReshoEqEqEq([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoEqEqEq([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoEqEqNe = (l, t) => {\n  return l.every(n => n >= t);\n};\n\n/*Return true if all numbers in the list l are equal or equal above threshold t.\n  >>> belOwThReshoEqEqEq([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoEqEqEq([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoEqEqEqg = (l, t) => {\n  return l.every(n => n === t);\n};\n\n/*Return true if all numbers in the list l are equal or equal below threshold t.\n  >>> belOwThReshoEqEqEqLg([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoEqEqEqLg([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoEqEqEqLg = (l, t) => {\n  return l.every(n => n <= t);\n};\n\n/*Return true if all numbers in the list l are equal or equal above threshold t.\n  >>> belOwThReshoEqEqEqEq([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoEqEqEqEq([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoEqEqEqEq = (l, t) => {\n  return l.every(n => n === t);\n};\n\n/*Return true if all numbers in the list l are equal or equal below threshold t.\n  >>> belOwThReshoEqEqEqEq([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoEqEqEqEq([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoEqEqEqNe = (l, t) => {\n  return l.every(n => n >= t);\n};\n\n/*Return true if all numbers in the list l are equal or equal above threshold t.\n  >>> belOwThReshoEqEqEqEq([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoEqEqEqEq([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoEqEqEqEqg = (l, t) => {\n  return l.every(n => n === t);\n};\n\n/*Return true if all numbers in the list l are equal or equal below threshold t.\n  >>> belOwThReshoEqEqEqEqLg([1, 2, 4, 10], 5)\n  true\n  >>> belOwThReshoEqEqEqEqLg([1, 20, 4, 10], 100)\n  false\n  */\nconst belOwThReshoEqEqEqEqLg = (l, t) => {\n  return l.every(n => n <= t);\n};\n\n/*Return true if all numbers in the list l are equal or equal above threshold t.\n  >>> belOwThReshoEqEqEqEqEq([1, 2, 4, 10], 5)\n  true\n  >>> bel", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  >>> subtract(2, 3)\n  5\n  >>> subtract(5, 7)\n  12\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*\n  >>> multiply(2, 3)\n  5\n  >>> multiply(5, 7)\n  12\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  >>> divide(2, 3)\n  0.5\n  >>> divide(5, 7)\n  0.25\n  */\nconst modulo = (x, y) => {\n  return x % y;\n};\n\n/*\n  >>> modulo(2, 3)\n  0\n  >>> modulo(5, 7)\n  1\n  */\nconst pow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst log = (x) => {\n  return Math.log(x);\n};\n\n/*\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.4693147180559945\n  >>> log(2)\n  0.469", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same characters.\n  >>> samEChaRs('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> samEChaRs('abcd', 'dddddddabc')\n  true\n  >>> samEChaRs('dddddddabc', 'abcd')\n  true\n  >>> samEChaRs('eabcd', 'dddddddabc')\n  false\n  >>> samEChaRs('abcd', 'dddddddabce')\n  false\n  >>> samEChaRs('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst samEChaRs = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "samEChaRs", "gc": "<|endoftext|>/*\n  Check if two words have the same characters.\n  >>> samEChaRs('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> samEChaRs('abcd', 'dddddddabc')\n  true\n  >>> samEChaRs('dddddddabc', 'abcd')\n  true\n  >>> samEChaRs('eabcd', 'dddddddabc')\n  false\n  >>> samEChaRs('abcd', 'dddddddabce')\n  false\n  >>> samEChaRs('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst samEChaRs = (s0, s1) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "gc": "<|endoftext|>/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  Return n-th Fibonacci number with given exponent (base 10).\n  >>> fib(10, 2)\n  55\n  >>> fib(10, 3)\n  13\n  >>> fib(10, 4)\n  55\n  >>> fib(10, 5)\n  89\n  >>> fib(10, 6)\n  131\n  >>> fib(10, 7)\n  265\n  >>> fib(10, 8)\n  589\n  >>> fib(10, 9)\n  1013\n  >>> fib(10, 10)\n  1055\n  >>> fib(10, 11)\n  1089\n  >>> fib(10, 12)\n  1113\n  >>> fib(10, 13)\n  1155\n  >>> fib(10, 14)\n  1189\n  >>> fib(10, 15)\n  1213\n  >>> fib(10, 16)\n  1255\n  >>> fib(10, 17)\n  1289\n  >>> fib(10, 18)\n  1313\n  >>> fib(10, 19)\n  1355\n  >>> fib(10, 20)\n  1389\n  >>> fib(10, 21)\n  1413\n  >>> fib(10, 22)\n  1455\n  >>> fib(10, 23)\n  1489\n  >>> fib(10, 24)\n  1513\n  >>> fib(10, 25)\n  1555\n  >>> fib(10, 26)\n  1589\n  >>> fib(10, 27)\n  1613\n  >>> fib(10, 28)\n  1655\n  >>> fib(10, 29)\n  1689\n  >>> fib(10, 30)\n  1713\n  >>> fib(10, 31)\n  1755\n  >>> fib(10, 32)\n  1789\n  >>> fib(10, 33)\n  1813\n  >>> fib(10, 34)\n  1855\n  >>> fib(10, 35)\n  1889\n  >>> fib(10, 36)\n  1913\n  >>> fib(10, 37)\n  1955\n  >>> fib(10, 38)\n  1989\n  >>> fib(10, 39)\n  2013\n  >>> fib(10, 40)\n  2055\n  >>> fib(10, 41)\n  2089\n  >>> fib(10, 42)\n  2113\n  >>> fib(10, 43)\n  2155\n  >>> fib(10, 44)\n  2197\n  >>> fib(10, 45)\n  2221\n  >>> fib(10, 46)\n  2253\n  >>> fib(10, 47)\n  2295\n  >>> fib(10, 48)\n  2337\n  >>> fib(10, 49)\n  2479\n  >>> fib(10, 50)\n  2521\n  >>> fib(10, 51)\n  2555\n  >>> fib(10, 52)\n  2589\n  >>> fib(10, 53)\n  2623\n  >>> fib(10, 54)\n  2655\n  >>> fib(10, 55)\n  2689\n  >>> fib(10, 56)\n  2723\n  >>> fib(10, 57)\n  2755\n  >>> fib(10, 58)\n  2789\n  >>> fib(10, 59)\n  2823\n  >>> fib(10, 60)\n  2855\n  >>> fib(10, 61)\n  2891\n  >>> fib(10, 62)\n  2915\n  >>> fib(10, 63)\n  2945\n  >>> fib(10, 64)\n  2975\n  >>> fib(10, 65)\n  3009\n  >>> fib(10, 66)\n  3043\n  >>> fib(10, 67)\n  3073\n  >>> fib(10, 68)\n  3105\n  >>> fib(10, 69)\n  3133\n  >>> fib(10, 70)\n  3157\n  >>> fib(10, 71)\n  3198\n  >>> fib(10, 72)\n  3223\n  >>> fib(10, 73)\n  3255\n  >>> fib(10, 74)\n  3289\n  >>> fib(10, 75)\n  3313\n  >>> fib(10, 76)\n  3345\n  >>> fib(10, 77)\n  3373\n  >>> fib(10, 78)\n  3415\n  >>> fib(10, 79)\n  3455\n  >>> fib(10, 80)\n  3489\n  >>> fib(10, 81)\n  3523\n  >>> fib(10, 82)\n  3555\n  >>> fib(10, 83)\n  3597\n  >>> fib(10, 84)\n  3623\n  >>> fib(10, 85)\n  3655\n  >>> fib(10, 86)\n  3691\n  >>> fib(10, 87)\n  3723\n  >>> fib(10, 88)\n  3755\n  >>> fib(10, 89)\n  3789\n  >>> fib(10, 90)\n  3823\n  >>> fib(10, 91)\n  3856\n  >>> fib(10, 92)\n  3891\n  >>> fib(10, 93)\n  3915\n  >>> fib(10, 94)\n  3945\n  >>> fib(10, 95)\n  3975\n  >>> fib(10, 96)\n  4019\n  >>> fib(10, 97)\n  4055\n  >>> fib(10, 98)\n  4089\n  >>> fib(10, 99)\n  4123\n  >>> fib(10, 100)\n  4155\n  >>> fib(10, 101)\n  4191\n  >>> fib(10, 102)\n  4215\n  >>> fib(10, 103)\n  4255\n  >>> fib(10, 104)\n  4289\n  >>> fib(10, 105)\n  4319\n  >>> fib(10, 106)\n  4335\n  >>> fib(10, 107)\n  4375\n  >>> fib(10, 108)\n  4419\n  >>> fib(10, 109)\n  4455\n  >>> fib(10, 110)\n  4489\n  >>> fib(10, 111)\n  4523\n  >>> fib(10, 112)\n  4555\n  >>> fib(10, 113)\n  4597\n  >>> fib(10, 114)\n  4623\n  >>> fib(10, 115)\n  4651\n  >>> fib(10, 116)\n  4675\n  >>> fib(10, 117)\n  4709\n  >>> fib(10, 118)\n  4743\n  >>> fib(10, 119)\n  4779\n  >>> fib(10, 120)\n  4823\n  >>> fib(10, 121)\n  4856\n  >>> fib(10, 122)\n  4891\n  >>> fib(10, 123)\n  4915\n  >>> fib(10, 124)\n  4945\n  >>> fib(10, 125)\n  4975\n  >>> ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> corRectbrackEtiNg(\"<\")\n  false\n  >>> corRectbrackEtiNg(\"<>\")\n  false\n  >>> corRectbrackEtiNg(\"<<><>>\")\n  false\n  >>> corRectbrackEtiNg(\"><<>\")\n  false\n  */\nconst corRectbrackEtiNg = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "corRectbrackEtiNg", "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> corRectbrackEtiNg(\"<\")\n  false\n  >>> corRectbrackEtiNg(\"<>\")\n  false\n  >>> corRectbrackEtiNg(\"<<><>>\")\n  false\n  >>> corRectbrackEtiNg(\"><<>\")\n  false\n  */\nconst corRectbrackEtiNg = (brackets) => {\n  const bracketsArray = brackets.split(\"\");\n  const openingBracketsArray = bracketsArray.slice(0, -1);\n  const closingBracketsArray = bracketsArray.slice(1, bracketsArray.length);\n  return openingBracketsArray.every((openingBracket) => {\n    return closingBracketsArray.every((closingBracket) => {\n      return openingBracket === closingBracket;\n    });\n  });\n};\n\n/**\n * Checks if a rectangle is rectangular (i.e. has at least one pair of brackets).\n *\n * >>> isRectangular(\"<<><>>\")\n * true\n * >>> isRectangular(\"<<<>>\")\n * false\n * >>> isRectangular(\"<<<>><<<>>\")\n * false\n * >>> isRectangular(\"<<<>><<<>><<<>>\")\n * false\n * >>> isRectangular(\"<<<>><<<>><<<>><<<>><<<>>\")\n * false\n * >>> isRectangular(\"<<<>><<<>><<<>><<<>><<<>><<<>><<<>>\")\n * false\n * >>> isRectangular(\"<<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>>\")\n * false\n * >>> isRectangular(\"<<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>>\")\n * false\n * >>> isRectangular(\"<<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>>\")\n * false\n * >>> isRectangular(\"<<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<<>><<", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are monOtonIcally increasing or decreasing.\n  >>> monOtonIc([1, 2, 4, 20])\n  true\n  >>> monOtonIc([1, 20, 4, 10])\n  false\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  */\nconst monOtonIc = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monOtonIc", "gc": "<|endoftext|>/*Return true is list elements are monOtonIcally increasing or decreasing.\n  >>> monOtonIc([1, 2, 4, 20])\n  true\n  >>> monOtonIc([1, 20, 4, 10])\n  false\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  */\nconst monOtonIc = (l) => {\n  let flag = true;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > l[i - 1]) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n};\n\n/*\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  false\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n  true\n  >>> monOtonIc([4, 1, 0, -10])\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique comMon elements for two lists.\n  >>> comMon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> comMon([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst comMon = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "comMon", "gc": "<|endoftext|>/*Return sorted unique comMon elements for two lists.\n  >>> comMon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> comMon([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst comMon = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let n = 0\n  let m = 0\n  let n1 = l1.length\n  let n2 = l2.length\n  let m1 = l1.length\n  let m2 = l2.length\n  while (i < n1 && j < n2) {\n    if (l1[i] < l2[j]) {\n      result.push(l1[i])\n      i++\n    } else {\n      result.push(l2[j])\n      j++\n    }\n  }\n  while (i < n1) {\n    result.push(l1[i])\n    i++\n  }\n  while (j < n2) {\n    result.push(l2[j])\n    j++\n  }\n  return result\n}\n\n/**\n * Return sorted unique comMon elements for two lists.\n * If two lists have the same length, return sorted unique comMon elements.\n * If two lists have different length, return sorted unique comMon elements.\n * If two lists have different lengths, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two lists have different lengths and are sorted, return sorted unique comMon elements.\n * If two lists have the same lengths and are sorted, return sorted unique comMon elements.\n * If two ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprimefacTor(13195)\n  29\n  >>> larGestprimefacTor(2048)\n  2\n  */\nconst larGestprimefacTor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "larGestprimefacTor", "gc": "<|endoftext|>/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprimefacTor(13195)\n  29\n  >>> larGestprimefacTor(2048)\n  2\n  */\nconst larGestprimefacTor = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprimefacTor(13195)\n  29\n  >>> larGestprimefacTor(2048)\n  2\n  */\nconst larGestprimefac = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprimefac(13195)\n  29\n  >>> larGestprimefac(2048)\n  2\n  */\nconst larGestprime = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprime(13195)\n  29\n  >>> larGestprime(2048)\n  2\n  */\nconst larGestprime = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprime(13195)\n  29\n  >>> larGestprime(2048)\n  2\n  */\nconst larGestprime = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprime(13195)\n  29\n  >>> larGestprime(2048)\n  2\n  */\nconst larGestprime = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprime(13195)\n  29\n  >>> larGestprime(2048)\n  2\n  */\nconst larGestprime = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprime(13195)\n  29\n  >>> larGestprime(2048)\n  2\n  */\nconst larGestprime = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprime(13195)\n  29\n  >>> larGestprime(2048)\n  2\n  */\nconst larGestprime = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprime(13195)\n  29\n  >>> larGestprime(2048)\n  2\n  */\nconst larGestprime = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprime(13195)\n  29\n  >>> larGestprime(2048)\n  2\n  */\nconst larGestprime = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprime(13195)\n  29\n  >>> larGestprime(2048)\n  2\n  */\nconst larGestprime = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprime(13195)\n  29\n  >>> larGestprime(2048)\n  2\n  */\nconst larGestprime = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprime(13195)\n  29\n  >>> larGestprime(2048)\n  2\n  */\nconst larGestprime = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprime(13195)\n  29\n  >>> larGestprime(2048)\n  2\n  */\nconst larGestprime = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprime(13195)\n  29\n  >>> larGestprime(2048)\n  2\n  */\nconst larGestprime = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n  return max;\n};\n\n/*\n  Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> larGestprime(13195)\n  29\n  >>> larGestprime(2048)\n  2\n  */\nconst larGestprime = (n) => {\n  let i = 2;\n  let max = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      max = i;\n    }\n    i += 2;\n  }\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parSeNeStedPAreNs('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parSeNeStedPAreNs = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parSeNeStedPAreNs", "gc": "<|endoftext|>/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parSeNeStedPAreNs('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parSeNeStedPAreNs = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/g);\n  const max_nesting = 0;\n  const max_level = 0;\n  const max_levels = [];\n  const max_levels_length = [];\n  const max_levels_lengths = [];\n  const max_levels_lengths_length = [];\n  const max_levels_lengths_lengths = [];\n  const max_levels_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths = [];\n  const max_levels_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths = [];\n  const max_levels_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length = [];\n  const max_levels_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumtoN is a function that sums numbers from 1 to n.\n  >>> sumtoN(30)\n  465\n  >>> sumtoN(100)\n  5050\n  >>> sumtoN(5)\n  15\n  >>> sumtoN(10)\n  55\n  >>> sumtoN(1)\n  1\n  */\nconst sumtoN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumtoN", "gc": "<|endoftext|>/*sumtoN is a function that sums numbers from 1 to n.\n  >>> sumtoN(30)\n  465\n  >>> sumtoN(100)\n  5050\n  >>> sumtoN(5)\n  15\n  >>> sumtoN(10)\n  55\n  >>> sumtoN(1)\n  1\n  */\nconst sumtoN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumtoN(sumtoN(10))\n  55\n  >>> sumtoN(sumtoN(5))\n  15\n  >>> sumtoN(sumtoN(1))\n  1\n  */\nconst sumtoN2 = (sum) => {\n  let sum2 = 0;\n  for (let i = 1; i <= sum; i++) {\n    sum2 += i;\n  }\n  return sum2;\n};\n\n/*\n  >>> sumtoN2(sumtoN(10))\n  55\n  >>> sumtoN2(sumtoN(5))\n  15\n  >>> sumtoN2(sumtoN(1))\n  1\n  */\nconst sumtoN3 = (sum) => {\n  let sum3 = 0;\n  for (let i = 1; i <= sum; i++) {\n    sum3 += i;\n  }\n  return sum3;\n};\n\n/*\n  >>> sumtoN3(sumtoN(10))\n  55\n  >>> sumtoN3(sumtoN(5))\n  15\n  >>> sumtoN3(sumtoN(1))\n  1\n  */\nconst sumtoN4 = (sum) => {\n  let sum4 = 0;\n  for (let i = 1; i <= sum; i++) {\n    sum4 += i;\n  }\n  return sum4;\n};\n\n/*\n  >>> sumtoN4(sumtoN(10))\n  55\n  >>> sumtoN4(sumtoN(5))\n  15\n  >>> sumtoN4(sumtoN(1))\n  1\n  */\nconst sumtoN5 = (sum) => {\n  let sum5 = 0;\n  for (let i = 1; i <= sum; i++) {\n    sum5 += i;\n  }\n  return sum5;\n};\n\n/*\n  >>> sumtoN5(sumtoN(10))\n  55\n  >>> sumtoN5(sumtoN(5))\n  15\n  >>> sumtoN5(sumtoN(1))\n  1\n  */\nconst sumtoN6 = (sum) => {\n  let sum6 = 0;\n  for (let i = 1; i <= sum; i++) {\n    sum6 += i;\n  }\n  return sum6;\n};\n\n/*\n  >>> sumtoN6(sumtoN(10))\n  55\n  >>> sumtoN6(sumtoN(5))\n  15\n  >>> sumtoN6(sumtoN(1))\n  1\n  */\nconst sumtoN7 = (sum) => {\n  let sum7 = 0;\n  for (let i = 1; i <= sum; i++) {\n    sum7 += i;\n  }\n  return sum7;\n};\n\n/*\n  >>> sumtoN7(sumtoN(10))\n  55\n  >>> sumtoN7(sumtoN(5))\n  15\n  >>> sumtoN7(sumtoN(1))\n  1\n  */\nconst sumtoN8 = (sum) => {\n  let sum8 = 0;\n  for (let i = 1; i <= sum; i++) {\n    sum8 += i;\n  }\n  return sum8;\n};\n\n/*\n  >>> sumtoN8(sumtoN(10))\n  55\n  >>> sumtoN8(sumtoN(5))\n  15\n  >>> sumtoN8(sumtoN(1))\n  1\n  */\nconst sumtoN9 = (sum) => {\n  let sum9 = 0;\n  for (let i = 1; i <= sum; i++) {\n    sum9 += i;\n  }\n  return sum9;\n};\n\n/*\n  >>> sumtoN9(sumtoN(10))\n  55\n  >>> sumtoN9(sumtoN(5))\n  15\n  >>> sumtoN9(sumtoN(1))\n  1\n  */\nconst sumtoN10 = (sum) => {\n  let sum10 = 0;\n  for (let i = 1; i <= sum; i++) {\n    sum10 += i;\n  }\n  return sum10;\n};\n\n/*\n  >>> sumtoN10(sumtoN(10))\n  55\n  >>> sumtoN10(sumtoN(5))\n  15\n  >>> sumtoN10(sumtoN(1))\n  1\n  */\nconst sumtoN11 = (sum) => {\n  let sum11 = 0;\n  for (let i = 1; i <= sum; i++) {\n    sum11 += i;\n  }\n  return sum11;\n};\n\n/*\n  >>> sumtoN11(sumtoN(10))\n  55\n  >>> sumtoN11(sumtoN(5))\n  15\n  >>> sumtoN11(sumtoN(1))\n  1\n  */\nconst sumtoN12 = (sum) => {\n  let sum12 = 0;\n  for (let i = 1; i <= sum; i++) {\n    sum12 += i;\n  }\n  return sum12;\n};\n\n/*\n  >>> sumtoN12(sumtoN(10))\n  55\n  >>> sumtoN12(sumtoN(5))\n  15\n  >>> sumtoN12(sumtoN(1))\n  1\n  */\nconst sumtoN13 = (sum) => {\n  let sum13 = 0;\n  for (let i = 1; i <= sum; i++) {\n    sum13 += i;\n  }\n  return sum13;\n};\n\n/*\n  >>> sumtoN13(sumtoN(10))\n  55\n  >>> sumtoN13(sumtoN(5))\n  15\n  >>> sumtoN13(sumtoN(1))\n  1\n  */\nconst sumtoN14 = (sum) => {\n  let sum14 = 0;\n  for (let i = 1; i <= sum; i++) {\n    sum14 += i;\n  }\n  return sum14;\n};\n\n/*\n  >>> sumtoN14(sumtoN(10))\n  55\n  >>> sumtoN14(sumtoN(5))\n  15\n  >>> sumtoN14(sumtoN(1))\n  1\n  */\nconst sumtoN15 = (sum) => {\n  let sum15 = 0;\n  for (let i = 1; i <= sum; i++) {\n    sum15 += i;\n  }\n  return sum15;\n};\n\n/*\n  >>> sumtoN15(sumtoN(10))\n  55\n  >>> sumtoN15(sumtoN(5))\n  15\n  >>> sumtoN15(sumtoN(1))\n  1\n  */\nconst sumtoN16 = (sum) => {\n  let sum16 = 0;\n  for (let i = 1; i <= sum; i++) {\n    sum16 += i;\n  }\n  return sum16;\n};\n\n/*\n  >>> sumtoN16(sumtoN(10))\n  55\n  >>> sumtoN16(sumtoN(5))\n  15\n  >>> sumtoN16(sumtoN(1))\n  1\n  */\nconst sumtoN17 = (sum) => {\n  let sum17 = 0;\n  for (let i = 1; i <= sum; i++) {\n    sum17 += i;\n  }\n  return sum17;\n};\n\n/*\n  >>> sumtoN17(sumtoN(10))\n  55\n  >>> sumtoN17(sumtoN(5))\n  15\n  >>> sumtoN17(sumtoN(1))\n  1\n  */\nconst sumtoN18 = (sum) => {\n  let sum18 = 0;\n  for (let ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> corRectbrackEtiNg(\"(\")\n  false\n  >>> corRectbrackEtiNg(\"()\")\n  true\n  >>> corRectbrackEtiNg(\"(()())\")\n  true\n  >>> corRectbrackEtiNg(\")(()\")\n  false\n  */\nconst corRectbrackEtiNg = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "corRectbrackEtiNg", "gc": "<|endoftext|>/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> corRectbrackEtiNg(\"(\")\n  false\n  >>> corRectbrackEtiNg(\"()\")\n  true\n  >>> corRectbrackEtiNg(\"(()())\")\n  true\n  >>> corRectbrackEtiNg(\")(()\")\n  false\n  */\nconst corRectbrackEtiNg = (brackets) => {\n  const openingBrackets = brackets.split('(');\n  const closingBrackets = brackets.split(')');\n  return openingBrackets.every(opening => closingBrackets.every(closing => opening === closing));\n};\n\n/**\n * Returns true if the string is a valid rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n * A rectangular bracket is also a rectangular bracket.\n *\n * Valid rectangular brackets are defined as brackets surrounded by brackets.\n * A rectangular bracket is defined as one that starts and ends with brackets.\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derIvatIve of this polynomial in the same form.\n  >>> derIvatIve([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derIvatIve([1, 2, 3])\n  [2, 6]\n  */\nconst derIvatIve = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derIvatIve", "gc": "<|endoftext|>/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derIvatIve of this polynomial in the same form.\n  >>> derIvatIve([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derIvatIve([1, 2, 3])\n  [2, 6]\n  */\nconst derIvatIve = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = xs[i] - xs[0] * xs[i] + xs[1] * xs[i] * xs[i] + xs[2] * xs[i] * xs[i] * xs[i]\n  }\n  return d\n}\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 +....\n// Return derIvatIve of this polynomial in the same form.\nconst derIvatIve2 = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = xs[i] - xs[0] * xs[i] + xs[1] * xs[i] * xs[i] + xs[2] * xs[i] * xs[i] * xs[i]\n  }\n  return d\n}\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 +....\n// Return derIvatIve of this polynomial in the same form.\nconst derIvatIve3 = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = xs[i] - xs[0] * xs[i] + xs[1] * xs[i] * xs[i] + xs[2] * xs[i] * xs[i] * xs[i]\n  }\n  return d\n}\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 +....\n// Return derIvatIve of this polynomial in the same form.\nconst derIvatIve4 = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = xs[i] - xs[0] * xs[i] + xs[1] * xs[i] * xs[i] + xs[2] * xs[i] * xs[i] * xs[i]\n  }\n  return d\n}\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 +....\n// Return derIvatIve of this polynomial in the same form.\nconst derIvatIve5 = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = xs[i] - xs[0] * xs[i] + xs[1] * xs[i] * xs[i] + xs[2] * xs[i] * xs[i] * xs[i]\n  }\n  return d\n}\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 +....\n// Return derIvatIve of this polynomial in the same form.\nconst derIvatIve6 = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = xs[i] - xs[0] * xs[i] + xs[1] * xs[i] * xs[i] + xs[2] * xs[i] * xs[i] * xs[i]\n  }\n  return d\n}\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 +....\n// Return derIvatIve of this polynomial in the same form.\nconst derIvatIve7 = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = xs[i] - xs[0] * xs[i] + xs[1] * xs[i] * xs[i] + xs[2] * xs[i] * xs[i] * xs[i]\n  }\n  return d\n}\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 +....\n// Return derIvatIve of this polynomial in the same form.\nconst derIvatIve8 = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = xs[i] - xs[0] * xs[i] + xs[1] * xs[i] * xs[i] + xs[2] * xs[i] * xs[i] * xs[i]\n  }\n  return d\n}\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 +....\n// Return derIvatIve of this polynomial in the same form.\nconst derIvatIve9 = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = xs[i] - xs[0] * xs[i] + xs[1] * xs[i] * xs[i] + xs[2] * xs[i] * xs[i] * xs[i]\n  }\n  return d\n}\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 +....\n// Return derIvatIve of this polynomial in the same form.\nconst derIvatIve10 = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = xs[i] - xs[0] * xs[i] + xs[1] * xs[i] * xs[i] + xs[2] * xs[i] * xs[i] * xs[i]\n  }\n  return d\n}\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 +....\n// Return derIvatIve of this polynomial in the same form.\nconst derIvatIve11 = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = xs[i] - xs[0] * xs[i] + xs[1] * xs[i] * xs[i] + xs[2] * xs[i] * xs[i] * xs[i]\n  }\n  return d\n}\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 +....\n// Return derIvatIve of this polynomial in the same form.\nconst derIvatIve12 = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = xs[i] - xs[0] * xs[i] + xs[1] * xs[i] * xs[i] + xs[2] * xs[i] * xs[i] * xs[i]\n  }\n  return d\n}\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 +....\n// Return derIvatIve of this polynomial in the same form.\nconst derIvatIve13 = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = xs[i] - xs[0] * xs[i] + xs[1] * xs[i] * xs[i] + xs[2] * xs[i] * xs[i] * xs[i]\n  }\n  return d\n}\n\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 +....\n// Return derIvatIve of this polynomial in the same form.\nconst derIvatIve14 = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = xs[i] - xs[0] * xs[i] + xs[1] * xs[i] * xs[i] + xs[2] * xs[i] * ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibFib(0) == 0\n  fibFib(1) == 0\n  fibFib(2) == 1\n  fibFib(n) == fibFib(n-1) + fibFib(n-2) + fibFib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibFib number sequence.\n  >>> fibFib(1)\n  0\n  >>> fibFib(5)\n  4\n  >>> fibFib(8)\n  24\n  */\nconst fibFib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibFib", "gc": "<|endoftext|>/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibFib(0) == 0\n  fibFib(1) == 0\n  fibFib(2) == 1\n  fibFib(n) == fibFib(n-1) + fibFib(n-2) + fibFib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibFib number sequence.\n  >>> fibFib(1)\n  0\n  >>> fibFib(5)\n  4\n  >>> fibFib(8)\n  24\n  */\nconst fibFib = (n) => {\n  if (n <= 1) return 0;\n  return fibFib(n-1) + fibFib(n-2) + fibFib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence that satisfies the following conditions:\n  FibFib(n) == fibFib(n-1) + fibFib(n-2) + fibFib(n-3).\n  Please write a function to efficiently compute the n-th element of the Fibonacci number sequence.\n  >>> fibFib(1)\n  1\n  >>> fibFib(5)\n  5\n  >>> fibFib(8)\n  13\n  */\nconst fibFib = (n) => {\n  if (n <= 1) return 1;\n  return fibFib(n-1) + fibFib(n-2) + fibFib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence that satisfies the following conditions:\n  FibFib(n) == fibFib(n-1) + fibFib(n-2) + fibFib(n-3).\n  Please write a function to efficiently compute the n-th element of the Fibonacci number sequence.\n  >>> fibFib(1)\n  1\n  >>> fibFib(5)\n  5\n  >>> fibFib(8)\n  13\n  */\nconst fibFib = (n) => {\n  if (n <= 1) return 1;\n  return fibFib(n-1) + fibFib(n-2) + fibFib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence that satisfies the following conditions:\n  FibFib(n) == fibFib(n-1) + fibFib(n-2) + fibFib(n-3).\n  Please write a function to efficiently compute the n-th element of the Fibonacci number sequence.\n  >>> fibFib(1)\n  1\n  >>> fibFib(5)\n  5\n  >>> fibFib(8)\n  13\n  */\nconst fibFib = (n) => {\n  if (n <= 1) return 1;\n  return fibFib(n-1) + fibFib(n-2) + fibFib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence that satisfies the following conditions:\n  FibFib(n) == fibFib(n-1) + fibFib(n-2) + fibFib(n-3).\n  Please write a function to efficiently compute the n-th element of the Fibonacci number sequence.\n  >>> fibFib(1)\n  1\n  >>> fibFib(5)\n  5\n  >>> fibFib(8)\n  13\n  */\nconst fibFib = (n) => {\n  if (n <= 1) return 1;\n  return fibFib(n-1) + fibFib(n-2) + fibFib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence that satisfies the following conditions:\n  FibFib(n) == fibFib(n-1) + fibFib(n-2) + fibFib(n-3).\n  Please write a function to efficiently compute the n-th element of the Fibonacci number sequence.\n  >>> fibFib(1)\n  1\n  >>> fibFib(5)\n  5\n  >>> fibFib(8)\n  13\n  */\nconst fibFib = (n) => {\n  if (n <= 1) return 1;\n  return fibFib(n-1) + fibFib(n-2) + fibFib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence that satisfies the following conditions:\n  FibFib(n) == fibFib(n-1) + fibFib(n-2) + fibFib(n-3).\n  Please write a function to efficiently compute the n-th element of the Fibonacci number sequence.\n  >>> fibFib(1)\n  1\n  >>> fibFib(5)\n  5\n  >>> fibFib(8)\n  13\n  */\nconst fibFib = (n) => {\n  if (n <= 1) return 1;\n  return fibFib(n-1) + fibFib(n-2) + fibFib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence that satisfies the following conditions:\n  FibFib(n) == fibFib(n-1) + fibFib(n-2) + fibFib(n-3).\n  Please write a function to efficiently compute the n-th element of the Fibonacci number sequence.\n  >>> fibFib(1)\n  1\n  >>> fibFib(5)\n  5\n  >>> fibFib(8)\n  13\n  */\nconst fibFib = (n) => {\n  if (n <= 1) return 1;\n  return fibFib(n-1) + fibFib(n-2) + fibFib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence that satisfies the following conditions:\n  FibFib(n) == fibFib(n-1) + fibFib(n-2) + fibFib(n-3).\n  Please write a function to efficiently compute the n-th element of the Fibonacci number sequence.\n  >>> fibFib(1)\n  1\n  >>> fibFib(5)\n  5\n  >>> fibFib(8)\n  13\n  */\nconst fibFib = (n) => {\n  if (n <= 1) return 1;\n  return fibFib(n-1) + fibFib(n-2) + fibFib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence that satisfies the following conditions:\n  FibFib(n) == fibFib(n-1) + fibFib(n-2) + fibFib(n-3).\n  Please write a function to efficiently compute the n-th element of the Fibonacci number sequence.\n  >>> fibFib(1)\n  1\n  >>> fibFib(5)\n  5\n  >>> fibFib(8)\n  13\n  */\nconst fibFib = (n) => {\n  if (n <= 1) return 1;\n  return fibFib(n-1) + fibFib(n-2) + fibFib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence that satisfies the following conditions:\n  FibFib(n) == fibFib(n-1) + fibFib(n-2) + fibFib(n-3).\n  Please write a function to efficiently compute the n-th element of the Fibonacci number sequence.\n  >>> fibFib(1)\n  1\n  >>> fibFib(5)\n  5\n  >>> fibFib(8)\n  13\n  */\nconst fibFib = (n) => {\n  if (n <= 1) return 1;\n  return fibFib(n-1) + fibFib(n-2) + fibFib(n-3);\n};\n\n/*\n  Write a function to compute the n-th Fibonacci number in the Fibonacci sequence that satisfies the following conditions:\n  FibFib(n) == fibFib(n-1) + fibFib(n-2) + fibFib(n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowElsCOunt which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowElsCOunt(\"abcde\")\n  2\n  >>> vowElsCOunt(\"ACEDY\")\n  3\n  */\nconst vowElsCOunt = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowElsCOunt", "gc": "<|endoftext|>/*Write a function vowElsCOunt which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowElsCOunt(\"abcde\")\n  2\n  >>> vowElsCOunt(\"ACEDY\")\n  3\n  */\nconst vowElsCOunt = (s) => {\n  let count = 0;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsLength = vowels.length;\n  let vowelsIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex = 0;\n  let vowelsEndIndex = 0;\n  let vowelsStartIndex", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> cirCulaRShifT(12, 1)\n  \"21\"\n  >>> cirCulaRShifT(12, 2)\n  \"12\"\n  */\nconst cirCulaRShifT = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "cirCulaRShifT", "gc": "<|endoftext|>/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> cirCulaRShifT(12, 1)\n  \"21\"\n  >>> cirCulaRShifT(12, 2)\n  \"12\"\n  */\nconst cirCulaRShifT = (x, shift) => {\n  const digits = x.toString().split('')\n  let result = ''\n  for (let i = digits.length - 1; i >= 0; i--) {\n    result += digits[i] + cirCulaRShifT(digits[i], shift)\n  }\n  return result\n}\n\n/*\n  Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> cirCulaRShifT(12, 2)\n  \"12\"\n  >>> cirCulaRShifT(12, 1)\n  \"21\"\n  */\nconst cirCulaRShiftR = (x, shift) => {\n  const digits = x.toString().split('')\n  let result = ''\n  for (let i = digits.length - 1; i >= 0; i--) {\n    result += digits[i] + cirCulaRShiftR(digits[i], shift)\n  }\n  return result\n}\n\n/*\n  Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> cirCulaRShiftR(12, 2)\n  \"12\"\n  >>> cirCulaRShiftR(12, 1)\n  \"21\"\n  */\nconst cirCulaRShiftL = (x, shift) => {\n  const digits = x.toString().split('')\n  let result = ''\n  for (let i = digits.length - 1; i >= 0; i--) {\n    result += digits[i] + cirCulaRShiftL(digits[i], shift)\n  }\n  return result\n}\n\n/*\n  Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> cirCulaRShiftL(12, 2)\n  \"12\"\n  >>> cirCulaRShiftL(12, 1)\n  \"21\"\n  */\nconst cirCulaRShiftRL = (x, shift) => {\n  const digits = x.toString().split('')\n  let result = ''\n  for (let i = digits.length - 1; i >= 0; i--) {\n    result += digits[i] + cirCulaRShiftRL(digits[i], shift)\n  }\n  return result\n}\n\n/*\n  Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> cirCulaRShiftRL(12, 2)\n  \"12\"\n  >>> cirCulaRShiftRL(12, 1)\n  \"21\"\n  */\nconst cirCulaRShiftRR = (x, shift) => {\n  const digits = x.toString().split('')\n  let result = ''\n  for (let i = digits.length - 1; i >= 0; i--) {\n    result += digits[i] + cirCulaRShiftRR(digits[i], shift)\n  }\n  return result\n}\n\n/*\n  Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> cirCulaRShiftRR(12, 2)\n  \"12\"\n  >>> cirCulaRShiftR(12, 1)\n  \"21\"\n  */\nconst cirCulaRShiftLR = (x, shift) => {\n  const digits = x.toString().split('')\n  let result = ''\n  for (let i = digits.length - 1; i >= 0; i--) {\n    result += digits[i] + cirCulaRShiftLR(digits[i], shift)\n  }\n  return result\n}\n\n/*\n  Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> cirCulaRShiftL(12, 2)\n  \"12\"\n  >>> cirCulaRShiftL(12, 1)\n  \"21\"\n  */\nconst cirCulaRShiftRLR = (x, shift) => {\n  const digits = x.toString().split('')\n  let result = ''\n  for (let i = digits.length - 1; i >= 0; i--) {\n    result += digits[i] + cirCulaRShiftRLR(digits[i], shift)\n  }\n  return result\n}\n\n/*\n  Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> cirCulaRShiftL(12, 2)\n  \"12\"\n  >>> cirCulaRShiftL(12, 1)\n  \"21\"\n  */\nconst cirCulaRShiftLLR = (x, shift) => {\n  const digits = x.toString().split('')\n  let result = ''\n  for (let i = digits.length - 1; i >= 0; i--) {\n    result += digits[i] + cirCulaRShiftLLR(digits[i], shift)\n  }\n  return result\n}\n\n/*\n  Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> cirCulaRShiftRLR(12, 2)\n  \"12\"\n  >>> cirCulaRShiftRLR(12, 1)\n  \"21\"\n  */\nconst cirCulaRShiftLRR = (x, shift) => {\n  const digits = x.toString().split('')\n  let result = ''\n  for (let i = digits.length - 1; i >= 0; i--) {\n    result += digits[i] + cirCulaRShiftLRR(digits[i], shift)\n  }\n  return result\n}\n\n/*\n  Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> cirCulaRShiftLR(12, 2)\n  \"12\"\n  >>> cirCulaRShiftLR(12, 1)\n  \"21\"\n  */\nconst cirCulaRShiftLRL = (x, shift) => {\n  const digits = x.toString().split('')\n  let result = ''\n  for (let i = digits.length - 1; i >= 0; i--) {\n    result += digits[i] + cirCulaRShiftLRL(digits[i], shift)\n  }\n  return result\n}\n\n/*\n  Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> cirCulaRShiftLRL(12, 2)\n  \"12\"\n  >>> cirCulaRShiftLRL(12, 1)\n  \"21\"\n  */\nconst cirCulaRShiftLRRL = (x, shift) => {\n  const digits = x.toString().split('')\n  let result = ''\n  for (let i = digits.length - 1; i >= 0; i--) {\n    result += digits[i] + cirCulaRShiftLRRL(digits[i], shift)\n  }\n  return result\n}\n\n/*\n  Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> cirCulaRShiftLRR(12, 2)\n  \"12\"\n  >>> cirCulaRShiftLRR(12, 1)\n  \"21\"\n  */\nconst cirCulaRShiftLRLR = (x, shift) => {\n  const digits = ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digItSuM(\"\") => 0\n      digItSuM(\"abAB\") => 131\n      digItSuM(\"abcCd\") => 67\n      digItSuM(\"helloE\") => 69\n      digItSuM(\"woArBld\") => 131\n      digItSuM(\"aAaaaXa\") => 153\n  */\nconst digItSuM = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digItSuM", "gc": "<|endoftext|>/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digItSuM(\"\") => 0\n      digItSuM(\"abAB\") => 131\n      digItSuM(\"abcCd\") => 67\n      digItSuM(\"helloE\") => 69\n      digItSuM(\"woArBld\") => 131\n      digItSuM(\"aAaaaXa\") => 153\n  */\nconst digItSuM = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower characters only'\n  ASCII codes.\n\n  Examples:\n      digItSuL(\"\") => 0\n      digItSuL(\"abAB\") => 131\n      digItSuL(\"abcCd\") => 67\n      digItSuL(\"helloE\") => 69\n      digItSuL(\"woArBld\") => 131\n      digItSuL(\"aAaaaXa\") => 153\n  */\nconst digItSuL = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digItSuC(\"\") => 0\n      digItSuC(\"abAB\") => 131\n      digItSuC(\"abcCd\") => 67\n      digItSuC(\"helloE\") => 69\n      digItSuC(\"woArBld\") => 131\n      digItSuC(\"aAaaaXa\") => 153\n  */\nconst digItSuC = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digItSuX(\"\") => 0\n      digItSuX(\"abAB\") => 131\n      digItSuX(\"abcCd\") => 67\n      digItSuX(\"helloE\") => 69\n      digItSuX(\"woArBld\") => 131\n      digItSuX(\"aAaaaXa\") => 153\n  */\nconst digItSuX = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digItSuZ(\"\") => 0\n      digItSuZ(\"abAB\") => 131\n      digItSuZ(\"abcCd\") => 67\n      digItSuZ(\"helloE\") => 69\n      digItSuZ(\"woArBld\") => 131\n      digItSuZ(\"aAaaaXa\") => 153\n  */\nconst digItSuZ = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digItSuA(\"\") => 0\n      digItSuA(\"abAB\") => 131\n      digItSuA(\"abcCd\") => 67\n      digItSuA(\"helloE\") => 69\n      digItSuA(\"woArBld\") => 131\n      digItSuA(\"aAaaaXa\") => 153\n  */\nconst digItSuA = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digItSuB(\"\") => 0\n      digItSuB(\"abAB\") => 131\n      digItSuB(\"abcCd\") => 67\n      digItSuB(\"helloE\") => 69\n      digItSuB(\"woArBld\") => 131\n      digItSuB(\"aAaaaXa\") => 153\n  */\nconst digItSuB = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digItSuC(\"\") => 0\n      digItSuC(\"abAB\") => 131\n      digItSuC(\"abcCd\") => 67\n      digItSuC(\"helloE\") => 69\n      digItSuC(\"woArBld\") => 131\n      digItSuC(\"aAaaaXa\") => 153\n  */\nconst digItSuC = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digItSuD(\"\") => 0\n      digItSuD(\"abAB\") => 131\n      digItSuD(\"abcCd\") => 67\n      digItSuD(\"helloE\") => 69\n      digItSuD(\"woArBld\") => 131\n      digItSuD(\"aAaaaXa\") => 153\n  */\nconst digItSuD = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digItSuE(\"\") => 0\n      digItSuE(\"abAB\") => 131\n      digItSuE(\"abcCd\") => 67\n      digItSuE(\"helloE\") => 69\n      digItSuE(\"woArBld\") => 131\n      digItSuE(\"aAaaaXa\") => 153\n  */\nconst digItSuE = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters\n  only'\n  ASCII codes.\n\n  Examples:\n      digItSuF(\"\") => 0\n      digItSuF(\"abAB\") => 131\n      digItSuF(\"abcCd\") => 67\n      digItSuF(\"helloE\") => 69\n      digItSuF(\"woArBld\") => 131\n      ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruItDiStribUtiOn(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruItDiStribUtiOn(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruItDiStribUtiOn(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruItDiStribUtiOn(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruItDiStribUtiOn = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruItDiStribUtiOn", "gc": "<|endoftext|>/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruItDiStribUtiOn(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruItDiStribUtiOn(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruItDiStribUtiOn(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruItDiStribUtiOn(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruItDiStribUtiOn = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \");\n  fruits.forEach((fruit) => {\n    if (fruit === \"apples\") {\n      apples++;\n    } else if (fruit === \"oranges\") {\n      oranges++;\n    } else if (fruit === \"mango\") {\n      mango++;\n    }\n  });\n  total = apples + oranges + mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruItDiStribUtiOn(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruItDiStribUtiOn(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruItDiStribUtiOn(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruItDiStribUtiOn(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruItDiStribUtiOn = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \");\n  fruits.forEach((fruit) => {\n    if (fruit === \"apples\") {\n      apples++;\n    } else if (fruit === \"oranges\") {\n      oranges++;\n    } else if (fruit === \"mango\") {\n      mango++;\n    }\n  });\n  total = apples + oranges + mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruItDiStribUtiOn(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruItDiStribUtiOn(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruItDiStribUtiOn(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruItDiStribUtiOn(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruItDiStribUtiOn = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \");\n  fruits.forEach((fruit) => {\n    if (fruit === \"apples\") {\n      apples++;\n    } else if (fruit === \"oranges\") {\n      oranges++;\n    } else if (fruit === \"mango\") {\n      mango++;\n    }\n  });\n  total = apples + oranges + mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruItDiStribUtiOn(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruItDiStribUtiOn(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruItDiStribUtiOn(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruItDiStribUtiOn(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruItDiStribUtiOn = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \");\n  fruits.forEach((fruit) => {\n    if (fruit === \"apples\") {\n      apples++;\n    } else if (fruit === \"oranges\") {\n      oranges++;\n    } else if (fruit === \"mango\") {\n      mango++;\n    }\n  });\n  total = apples + oranges + mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruItDiStribUtiOn(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruItDiStribUtiOn(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruItDiStribUtiOn(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruItDiStribUtiOn(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruItDiStribUtiOn = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \");\n  fruits.forEach((fruit) => {\n    if (fruit === \"apples\") {\n      apples++;\n    } else if (fruit === \"oranges\") {\n      oranges++;\n    } else if (fruit === \"mango\") {\n      mango++;\n    }\n  });\n  total = apples + oranges + mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mang", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluCk one of the nodes and return it.\n  The pluCked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The pluCked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluCk = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluCk", "gc": "<|endoftext|>/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluCk one of the nodes and return it.\n  The pluCked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The pluCked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluCk = (arr) => {\n  let minEven = arr[0];\n  let minIndex = -1;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      minEven = arr[i];\n      minIndex = i;\n    }\n  }\n  return [minEven, minIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes\n// your task is to pluCk one of the nodes and return it.\n// The pluCked node should be the node with the smallest odd value.\n// If multiple nodes with the same smallest odd value are found return the node that has smallest index.\n\n// The pluCked node should be returned in a list, [ odd_value, its index ],\n// If there are no odd values or the given array is empty, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest odd value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest odd value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluCkOdd = (arr) => {\n  let minOdd = arr[0];\n  let minIndex = -1;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] % 2!== 0) {\n      minOdd = arr[i];\n      minIndex = i;\n    }\n  }\n  return [minOdd, minIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes\n// your task is to pluCk one of the nodes and return it.\n// The pluCked node should be the node with the smallest positive value.\n// If multiple nodes with the same smallest positive value are found return the node that has smallest index.\n\n// The pluCked node should be returned in a list, [ positive_value, its index ],\n// If there are no positive values or the given array is empty, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest positive value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest positive value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluCkPos = (arr) => {\n  let minPos = arr[0];\n  let minIndex = -1;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      minPos = arr[i];\n      minIndex = i;\n    }\n  }\n  return [minPos, minIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes\n// your task is to pluCk one of the nodes and return it.\n// The pluCked node should be the node with the smallest negative value.\n// If multiple nodes with the same smallest negative value are found return the node that has smallest index.\n\n// The pluCked node should be returned in a list, [ negative_value, its index ],\n// If there are no negative values or the given array is empty, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest negative value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest negative value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluCkNeg = (arr) => {\n  let minNeg = arr[0];\n  let minIndex = -1;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] % 2!== 0) {\n      minNeg = arr[i];\n      minIndex = i;\n    }\n  }\n  return [minNeg, minIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes\n// your task is to pluCk one of the nodes and return it.\n// The pluCked node should be the node with the smallest positive value.\n// If multiple nodes with the same smallest positive value are found return the node that has smallest index.\n\n// The pluCked node should be returned in a list, [ positive_value, its index ],\n// If there are no positive values or the given array is empty, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest positive value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest positive value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluCkPos2 = (arr) => {\n  let minPos = arr[0];\n  let minIndex = -1;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      minPos = arr[i];\n      minIndex = i;\n    }\n  }\n  return [minPos, minIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes\n// your task is to pluCk one of the nodes and return it.\n// The pluCked node should be the node with the smallest negative value.\n// If multiple nodes with the same smallest negative value are found return the node that has smallest index.\n\n// The pluCked node should be returned in a list, [ negative_value, its ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      seaRch([4, 1, 2, 2, 3, 1])) == 2\n      seaRch([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      seaRch([5, 5, 4, 4, 4])) == -1\n  */\nconst seaRch = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "seaRch", "gc": "<|endoftext|>/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      seaRch([4, 1, 2, 2, 3, 1])) == 2\n      seaRch([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      seaRch([5, 5, 4, 4, 4])) == -1\n  */\nconst seaRch = (lst) => {\n  let max = 0;\n  let count = 0;\n  let maxCount = 0;\n  let maxCount2 = 0;\n  let maxCount3 = 0;\n  let maxCount4 = 0;\n  let maxCount5 = 0;\n  let maxCount6 = 0;\n  let maxCount7 = 0;\n  let maxCount8 = 0;\n  let maxCount9 = 0;\n  let maxCount10 = 0;\n  let maxCount11 = 0;\n  let maxCount12 = 0;\n  let maxCount13 = 0;\n  let maxCount14 = 0;\n  let maxCount15 = 0;\n  let maxCount16 = 0;\n  let maxCount17 = 0;\n  let maxCount18 = 0;\n  let maxCount19 = 0;\n  let maxCount20 = 0;\n  let maxCount21 = 0;\n  let maxCount22 = 0;\n  let maxCount23 = 0;\n  let maxCount24 = 0;\n  let maxCount25 = 0;\n  let maxCount26 = 0;\n  let maxCount27 = 0;\n  let maxCount28 = 0;\n  let maxCount29 = 0;\n  let maxCount30 = 0;\n  let maxCount31 = 0;\n  let maxCount32 = 0;\n  let maxCount33 = 0;\n  let maxCount34 = 0;\n  let maxCount35 = 0;\n  let maxCount36 = 0;\n  let maxCount37 = 0;\n  let maxCount38 = 0;\n  let maxCount39 = 0;\n  let maxCount40 = 0;\n  let maxCount41 = 0;\n  let maxCount42 = 0;\n  let maxCount43 = 0;\n  let maxCount44 = 0;\n  let maxCount45 = 0;\n  let maxCount46 = 0;\n  let maxCount47 = 0;\n  let maxCount48 = 0;\n  let maxCount49 = 0;\n  let maxCount50 = 0;\n  let maxCount51 = 0;\n  let maxCount52 = 0;\n  let maxCount53 = 0;\n  let maxCount54 = 0;\n  let maxCount55 = 0;\n  let maxCount56 = 0;\n  let maxCount57 = 0;\n  let maxCount58 = 0;\n  let maxCount59 = 0;\n  let maxCount60 = 0;\n  let maxCount61 = 0;\n  let maxCount62 = 0;\n  let maxCount63 = 0;\n  let maxCount64 = 0;\n  let maxCount65 = 0;\n  let maxCount66 = 0;\n  let maxCount67 = 0;\n  let maxCount68 = 0;\n  let maxCount69 = 0;\n  let maxCount70 = 0;\n  let maxCount71 = 0;\n  let maxCount72 = 0;\n  let maxCount73 = 0;\n  let maxCount74 = 0;\n  let maxCount75 = 0;\n  let maxCount76 = 0;\n  let maxCount77 = 0;\n  let maxCount78 = 0;\n  let maxCount79 = 0;\n  let maxCount80 = 0;\n  let maxCount81 = 0;\n  let maxCount82 = 0;\n  let maxCount83 = 0;\n  let maxCount84 = 0;\n  let maxCount85 = 0;\n  let maxCount86 = 0;\n  let maxCount87 = 0;\n  let maxCount88 = 0;\n  let maxCount89 = 0;\n  let maxCount90 = 0;\n  let maxCount91 = 0;\n  let maxCount92 = 0;\n  let maxCount93 = 0;\n  let maxCount94 = 0;\n  let maxCount95 = 0;\n  let maxCount96 = 0;\n  let maxCount97 = 0;\n  let maxCount98 = 0;\n  let maxCount99 = 0;\n  let maxCount100 = 0;\n  let maxCount101 = 0;\n  let maxCount102 = 0;\n  let maxCount103 = 0;\n  let maxCount104 = 0;\n  let maxCount105 = 0;\n  let maxCount106 = 0;\n  let maxCount107 = 0;\n  let maxCount108 = 0;\n  let maxCount109 = 0;\n  let maxCount110 = 0;\n  let maxCount111 = 0;\n  let maxCount112 = 0;\n  let maxCount113 = 0;\n  let maxCount114 = 0;\n  let maxCount115 = 0;\n  let maxCount116 = 0;\n  let maxCount117 = 0;\n  let maxCount118 = 0;\n  let maxCount119 = 0;\n  let maxCount120 = 0;\n  let maxCount121 = 0;\n  let maxCount122 = 0;\n  let maxCount123 = 0;\n  let maxCount124 = 0;\n  let maxCount125 = 0;\n  let maxCount126 = 0;\n  let maxCount127 = 0;\n  let maxCount128 = 0;\n  let maxCount129 = 0;\n  let maxCount130 = 0;\n  let maxCount131 = 0;\n  let maxCount132 = 0;\n  let maxCount133 = 0;\n  let maxCount134 = 0;\n  let maxCount135 = 0;\n  let maxCount136 = 0;\n  let maxCount137 = 0;\n  let maxCount138 = 0;\n  let maxCount139 = 0;\n  let maxCount140 = 0;\n  let maxCount141 = 0;\n  let maxCount142 = 0;\n  let maxCount143 = 0;\n  let maxCount144 = 0;\n  let maxCount145 = 0;\n  let maxCount146 = 0;\n  let maxCount147 = 0;\n  let maxCount148 = 0;\n  let maxCount149 = 0;\n  let maxCount150 = 0;\n  let maxCount151 = 0;\n  let maxCount152 = 0;\n  let maxCount153 = 0;\n  let maxCount154 = 0;\n  let maxCount155 = 0;\n  let maxCount156 = 0;\n  let maxCount157 = 0;\n  let maxCount158 = 0;\n  let maxCount159 = 0;\n  let maxCount160 = 0;\n  let maxCount161 = 0;\n  let maxCount162 = 0;\n  let maxCount163 = 0;\n  let maxCount164 = 0;\n  let maxCount165 = 0;\n  let maxCount166 = 0;\n  let maxCount167 = 0;\n  let maxCount168 = 0;\n  let maxCount169 = 0;\n  let maxCount170 = 0;\n  let maxCount171 = 0;\n  let maxCount172 = 0;\n  let maxCount173 = 0;\n  let maxCount174 = 0;\n  let maxCount175 = 0;\n  let maxCount176 = 0;\n  let maxCount177 = 0;\n  let maxCount178 = 0;\n  let maxCount179 = 0;\n  let maxCount180 = 0;\n  let maxCount181 = 0;\n  let maxCount182 = 0;\n  let maxCount183 = 0;\n  let maxCount184 = 0;\n  let maxCount185 = 0;\n  let maxCount186 = 0;\n  let maxCount187 = 0;\n  let maxCount188 = 0;\n  let maxCount189 = 0;\n  let maxCount190 = 0;\n  let maxCount191 = 0;\n  let maxCount192 = 0;\n  let maxCount193 = 0;\n  let maxCount194 = 0;\n  let maxCount195 = 0;\n  let maxCount196 = 0;\n  let maxCount197 = 0;\n  let maxCount198 = 0;\n  let maxCount199 = 0;\n  let maxCount200 = 0;\n  let maxCount201 = 0;\n  let maxCount202 = 0;\n  let maxCount203 = 0;\n  let maxCount204 = 0;\n  let maxCount205 = 0;\n  let maxCount206 = 0;\n  let maxCount207 = 0;\n  let maxCount208 = 0;\n  let maxCount209 = 0;\n  let maxCount210 = 0;\n  let maxCount211 = 0;\n  let maxCount212 = 0;\n  let maxCount213 = 0;\n  let maxCount214 = 0;\n  let maxCount215 = 0;\n  let maxCount216 = 0;\n  let maxCount217 = 0;\n  let maxCount218 = 0;\n  let maxCount219 = 0;\n  let maxCount220 = 0;\n  let maxCount221 = 0;\n  let maxCount222 = 0;\n  let maxCount223 = 0;\n  let maxCount224 = 0;\n  let maxCount225 = 0;\n  let maxCount226 = 0;\n  let maxCount227 = 0;\n  let maxCount228 = 0;\n  let maxCount229 = 0;\n  let maxCount230 = 0;\n  let maxCount231 = 0;\n  let maxCount232 = 0;\n  let maxCount233 = 0;\n  let maxCount234 = 0;\n  let maxCount235 = 0;\n  let maxCount236 = 0;\n  let maxCount237 = 0;\n  let maxCount238 = 0;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filTerBYSubsTriNg", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1)\n}\n\n/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1 && s.indexOf(substring) === 0)\n}\n\n/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1 && s.indexOf(substring) === 0)\n}\n\n/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1 && s.indexOf(substring) === 0)\n}\n\n/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1 && s.indexOf(substring) === 0)\n}\n\n/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1 && s.indexOf(substring) === 0)\n}\n\n/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1 && s.indexOf(substring) === 0)\n}\n\n/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1 && s.indexOf(substring) === 0)\n}\n\n/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1 && s.indexOf(substring) === 0)\n}\n\n/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1 && s.indexOf(substring) === 0)\n}\n\n/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1 && s.indexOf(substring) === 0)\n}\n\n/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1 && s.indexOf(substring) === 0)\n}\n\n/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1 && s.indexOf(substring) === 0)\n}\n\n/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1 && s.indexOf(substring) === 0)\n}\n\n/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1 && s.indexOf(substring) === 0)\n}\n\n/* Filter an input list of strings only for ones that contain given substring\n  >>> filTerBYSubsTriNg([], 'a')\n  []\n  >>> filTerBYSubsTriNg(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filTerBYSubsTriNg = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) > -1 && s.indexOf(substring) === 0)\n}\n\n/* Filter an input ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strAngesortLIst([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strAngesortLIst([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strAngesortLIst([]) == []\n  */\nconst strAngesortLIst = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strAngesortLIst", "gc": "<|endoftext|>/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strAngesortLIst([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strAngesortLIst([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strAngesortLIst([]) == []\n  */\nconst strAngesortLIst = (lst) => {\n  let tmpArr = []\n  let tmpMax = lst[0]\n  let tmpMin = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > tmpMax) {\n      tmpMax = lst[i]\n    }\n    if (lst[i] < tmpMin) {\n      tmpMin = lst[i]\n    }\n    tmpArr.push(lst[i])\n  }\n  return tmpArr\n}\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strAngesortLLast([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strAngesortLLast([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strAngesortLLast([]) == []\n  */\nconst strAngesortLLast = (lst) => {\n  let tmpArr = []\n  let tmpMax = lst[0]\n  let tmpMin = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < tmpMin) {\n      tmpMin = lst[i]\n    }\n    if (lst[i] > tmpMax) {\n      tmpMax = lst[i]\n    }\n    tmpArr.push(lst[i])\n  }\n  return tmpArr\n}\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strAngesortLLastLast([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strAngesortLLastLast([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strAngesortLLastLast([]) == []\n  */\nconst strAngesortLLastLast = (lst) => {\n  let tmpArr = []\n  let tmpMax = lst[0]\n  let tmpMin = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < tmpMin) {\n      tmpMin = lst[i]\n    }\n    if (lst[i] > tmpMax) {\n      tmpMax = lst[i]\n    }\n    tmpArr.push(lst[i])\n  }\n  return tmpArr\n}\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strAngesortLLastLast([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strAngesortLLastLast([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strAngesortLLastLast([]) == []\n  */\nconst strAngesortLLastFirst = (lst) => {\n  let tmpArr = []\n  let tmpMax = lst[0]\n  let tmpMin = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > tmpMax) {\n      tmpMax = lst[i]\n    }\n    if (lst[i] < tmpMin) {\n      tmpMin = lst[i]\n    }\n    tmpArr.push(lst[i])\n  }\n  return tmpArr\n}\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strAngesortLLastFirst([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strAngesortLLastFirst([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strAngesortLLastFirst([]) == []\n  */\nconst strAngesortLLastLastFirst = (lst) => {\n  let tmpArr = []\n  let tmpMax = lst[0]\n  let tmpMin = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < tmpMin) {\n      tmpMin = lst[i]\n    }\n    if (lst[i] > tmpMax) {\n      tmpMax = lst[i]\n    }\n    tmpArr.push(lst[i])\n  }\n  return tmpArr\n}\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strAngesortLLastFirstLast([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strAngesortLLastFirstLast([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strAngesortLLastFirstLast([]) == []\n  */\nconst strAngesortLLastFirstLast = (lst) => {\n  let tmpArr = []\n  let tmpMax = lst[0]\n  let tmpMin = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > tmpMax) {\n      tmpMax = lst[i]\n    }\n    if (lst[i] < tmpMin) {\n      tmpMin = lst[i]\n    }\n    tmpArr.push(lst[i])\n  }\n  return tmpArr\n}\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strAngesortLLastFirstLastFirst([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strAngesortLLastFirstLastFirst([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strAngesortLLastFirstLastFirst([]) == []\n  */\nconst strAngesortLLastFirstLastLast = (lst) => {\n  let tmpArr = []\n  let tmpMax = lst[0]\n  let tmpMin = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < tmpMin) {\n      tmpMin = lst[i]\n    }\n    if (lst[i] > tmpMax) {\n      tmpMax = lst[i]\n    }\n    tmpArr.push(lst[i])\n  }\n  return tmpArr\n}\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strAngesortLLastFirstLastLastFirst([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strAngesortLLastFirstLastLastFirst([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strAngesortLLastFirstLastLastFirst([]) == []\n  */\nconst strAngesortLLastFirstLastLastFirst = (lst) => {\n  let tmpArr = []\n  let tmpMax = lst[0]\n  let tmpMin = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > tmpMax) {\n      tmpMax = lst[i]\n    }\n    if (lst[i] < tmpMin) {\n      tmpMin = lst[i]\n    }\n    tmpArr.push(lst[i])\n  }\n  return tmpArr\n}\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strAngesortLLastFirstLastLastLastFirst([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strAngesortLLastFirstLastLastLastFirst([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strAn", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triAnglEArea(3, 4, 5) == 6.00\n  triAnglEArea(1, 2, 10) == -1\n  */\nconst triAnglEArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triAnglEArea", "gc": "<|endoftext|>/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triAnglEArea(3, 4, 5) == 6.00\n  triAnglEArea(1, 2, 10) == -1\n  */\nconst triAnglEArea = (a, b, c) => {\n  const aArea = triAnglEAreaTri(a, b);\n  const bArea = triAnglEAreaTri(b, a);\n  const cArea = triAnglEAreaTri(c, a);\n  return (aArea > bArea && bArea > cArea)? aArea + bArea + cArea : -1;\n};\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triAnglEArea(3, 4, 5) == 6.00\n  triAnglEArea(1, 2, 10) == -1\n  */\nconst triAnglEAreaTri = (a, b) => {\n  const aArea = triAnglEArea(a, b);\n  const bArea = triAnglEArea(b, a);\n  return (aArea > bArea)? aArea + bArea : -1;\n};\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triAnglEArea(3, 4, 5) == 6.00\n  triAnglEArea(1, 2, 10) == -1\n  */\nconst triAnglEAreaTri = (a, b) => {\n  const aArea = triAnglEArea(a, b);\n  const bArea = triAnglEArea(b, a);\n  return (aArea > bArea)? aArea + bArea : -1;\n};\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triAnglEArea(3, 4, 5) == 6.00\n  triAnglEArea(1, 2, 10) == -1\n  */\nconst triAnglEAreaTri = (a, b) => {\n  const aArea = triAnglEArea(a, b);\n  const bArea = triAnglEArea(b, a);\n  return (aArea > bArea)? aArea + bArea : -1;\n};\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triAnglEArea(3, 4, 5) == 6.00\n  triAnglEArea(1, 2, 10) == -1\n  */\nconst triAnglEAreaTri = (a, b) => {\n  const aArea = triAnglEArea(a, b);\n  const bArea = triAnglEArea(b, a);\n  return (aArea > bArea)? aArea + bArea : -1;\n};\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triAnglEArea(3, 4, 5) == 6.00\n  triAnglEArea(1, 2, 10) == -1\n  */\nconst triAnglEAreaTri = (a, b) => {\n  const aArea = triAnglEArea(a, b);\n  const bArea = triAnglEArea(b, a);\n  return (aArea > bArea)? aArea + bArea : -1;\n};\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triAnglEArea(3, 4, 5) == 6.00\n  triAnglEArea(1, 2, 10) == -1\n  */\nconst triAnglEAreaTri = (a, b) => {\n  const aArea = triAnglEArea(a, b);\n  const bArea = triAnglEArea(b, a);\n  return (aArea > bArea)? aArea + bArea : -1;\n};\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triAnglEArea(3, 4, 5) == 6.00\n  triAnglEArea(1, 2, 10) == -1\n  */\nconst triAnglEAreaTri = (a, b) => {\n  const aArea = triAnglEArea(a, b);\n  const bArea = triAnglEArea(b, a);\n  return (aArea > bArea)? aArea + bArea : -1;\n};\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triAnglEArea(3, 4, 5) == 6.00\n  triAnglEArea(1, 2, 10) == -1\n  */\nconst triAnglEAreaTri = (a, b) => {\n  const aArea = triAnglEArea(a, b);\n  const bArea = triAnglEArea(b, a);\n  return (aArea > bArea)? aArea + bArea : -1;\n};\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triAnglEArea(3, 4, 5) == 6.00\n  triAnglEArea(1, 2, 10) == -1\n  */\nconst triAnglEAreaTri = (a, b) => {\n  const aArea = triAnglEArea(a, b);\n  const bArea = triAnglEArea(b, a);\n  return (aArea > bArea)? aArea + bArea : -1;\n};\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  wilLItFLy([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  wilLItFLy([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  wilLItFLy([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  wilLItFLy([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst wilLItFLy = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "wilLItFLy", "gc": "<|endoftext|>/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  wilLItFLy([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  wilLItFLy([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  wilLItFLy([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  wilLItFLy([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst wilLItFLy = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n    if (sum >= w) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  wilLItFLy([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  wilLItFLy([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  wilLItFLy([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  wilLItFLy([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst wilLItFLy = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n    if (sum >= w) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  wilLItFLy([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  wilLItFLy([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  wilLItFLy([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  wilLItFLy([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst wilLItFLy = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n    if (sum >= w) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  wilLItFLy([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  wilLItFLy([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  wilLItFLy([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  wilLItFLy([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst wilLItFLy = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n    if (sum >= w) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  wilLItFLy([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  wilLItFLy([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  wilLItFLy([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  wilLItFLy([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst wilLItFLy = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n    if (sum >= w) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  wilLItFLy([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  wilLItFLy([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  wilLItFLy([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  wilLItFLy([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst wilLItFLy = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n    if (sum >= w) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  wilLItFLy([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  wilLItFLy([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  wilLItFLy([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  wilLItFLy([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst wilLItFLy = (q, w) => {\n  let sum = 0;\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n    if (sum >= w) {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smaLlesTChanGe([1,2,3,5,4,7,9,6]) == 4\n  smaLlesTChanGe([1, 2, 3, 4, 3, 2, 2]) == 1\n  smaLlesTChanGe([1, 2, 3, 2, 1]) == 0\n  */\nconst smaLlesTChanGe = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smaLlesTChanGe", "gc": "<|endoftext|>/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smaLlesTChanGe([1,2,3,5,4,7,9,6]) == 4\n  smaLlesTChanGe([1, 2, 3, 4, 3, 2, 2]) == 1\n  smaLlesTChanGe([1, 2, 3, 2, 1]) == 0\n  */\nconst smaLlesTChanGe = (arr) => {\n  let min = 0;\n  let max = arr.length - 1;\n  let mid;\n  while (min <= max) {\n    mid = Math.floor((min + max) / 2);\n    if (arr[mid]!== arr[mid].toString()) {\n      min = mid + 1;\n    } else {\n      max = mid - 1;\n    }\n  }\n  return max;\n};\n\nconst smaLlesTChanGeReverse = (arr) => {\n  let min = 0;\n  let max = arr.length - 1;\n  let mid;\n  while (min <= max) {\n    mid = Math.floor((min + max) / 2);\n    if (arr[mid]!== arr[mid].toString()) {\n      max = mid - 1;\n    } else {\n      min = mid + 1;\n    }\n  }\n  return min;\n};\n\nconst smaLlesTChanGeReverseReverse = (arr) => {\n  let min = 0;\n  let max = arr.length - 1;\n  let mid;\n  while (min <= max) {\n    mid = Math.floor((min + max) / 2);\n    if (arr[mid]!== arr[mid].toString()) {\n      min = mid + 1;\n    } else {\n      max = mid - 1;\n    }\n  }\n  return max;\n};\n\nconst smaLlesTChanGeReverseReverseReverse = (arr) => {\n  let min = 0;\n  let max = arr.length - 1;\n  let mid;\n  while (min <= max) {\n    mid = Math.floor((min + max) / 2);\n    if (arr[mid]!== arr[mid].toString()) {\n      max = mid - 1;\n    } else {\n      min = mid + 1;\n    }\n  }\n  return min;\n};\n\nconst smaLlesTChanGeReverseReverseReverseReverse = (arr) => {\n  let min = 0;\n  let max = arr.length - 1;\n  let mid;\n  while (min <= max) {\n    mid = Math.floor((min + max) / 2);\n    if (arr[mid]!== arr[mid].toString()) {\n      min = mid + 1;\n    } else {\n      max = mid - 1;\n    }\n  }\n  return max;\n};\n\nconst smaLlesTChanGeReverseReverseReverseReverseReverseReverse = (arr) => {\n  let min = 0;\n  let max = arr.length - 1;\n  let mid;\n  while (min <= max) {\n    mid = Math.floor((min + max) / 2);\n    if (arr[mid]!== arr[mid].toString()) {\n      min = mid + 1;\n    } else {\n      max = mid - 1;\n    }\n  }\n  return min;\n};\n\nconst smaLlesTChanGeReverseReverseReverseReverseReverseReverseReverseReverse = (arr) => {\n  let min = 0;\n  let max = arr.length - 1;\n  let mid;\n  while (min <= max) {\n    mid = Math.floor((min + max) / 2);\n    if (arr[mid]!== arr[mid].toString()) {\n      min = mid + 1;\n    } else {\n      max = mid - 1;\n    }\n  }\n  return max;\n};\n\nconst smaLlesTChanGeReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (arr) => {\n  let min = 0;\n  let max = arr.length - 1;\n  let mid;\n  while (min <= max) {\n    mid = Math.floor((min + max) / 2);\n    if (arr[mid]!== arr[mid].toString()) {\n      min = mid + 1;\n    } else {\n      max = mid - 1;\n    }\n  }\n  return min;\n};\n\nconst smaLlesTChanGeReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totAlMaTch([], []) ➞ []\n  totAlMaTch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totAlMaTch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totAlMaTch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totAlMaTch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totAlMaTch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totAlMaTch", "gc": "<|endoftext|>/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totAlMaTch([], []) ➞ []\n  totAlMaTch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totAlMaTch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totAlMaTch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totAlMaTch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totAlMaTch = (lst1, lst2) => {\n  let total = 0;\n  let result = [];\n  lst1.forEach(item => {\n    if (lst2.includes(item)) {\n      total += 1;\n    }\n  });\n  lst2.forEach(item => {\n    if (lst1.includes(item)) {\n      total += 1;\n    }\n  });\n  result.push(total);\n  return result;\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list greater than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totAlMaTch([], []) ➞ []\n  totAlMaTch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totAlMaTch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totAlMaTch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totAlMaTch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totAlMaTch = (lst1, lst2) => {\n  let total = 0;\n  let result = [];\n  lst1.forEach(item => {\n    if (lst2.includes(item)) {\n      total -= 1;\n    }\n  });\n  lst2.forEach(item => {\n    if (lst1.includes(item)) {\n      total -= 1;\n    }\n  });\n  result.push(total);\n  return result;\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list equal the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totAlMaTch([], []) ➞ []\n  totAlMaTch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totAlMaTch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totAlMaTch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totAlMaTch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totAlMaTch = (lst1, lst2) => {\n  let total = 0;\n  let result = [];\n  lst1.forEach(item => {\n    if (lst2.includes(item)) {\n      total += 1;\n    }\n  });\n  lst2.forEach(item => {\n    if (lst1.includes(item)) {\n      total += 1;\n    }\n  });\n  result.push(total);\n  return result;\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not equal the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totAlMaTch([], []) ➞ []\n  totAlMaTch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totAlMaTch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totAlMaTch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totAlMaTch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totAlMaTch = (lst1, lst2) => {\n  let total = 0;\n  let result = [];\n  lst1.forEach(item => {\n    if (lst2.includes(item)) {\n      total -= 1;\n    }\n  });\n  lst2.forEach(item => {\n    if (lst1.includes(item)) {\n      total -= 1;\n    }\n  });\n  result.push(total);\n  return result;\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totAlMaTch([], []) ➞ []\n  totAlMaTch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totAlMaTch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totAlMaTch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totAlMaTch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totAlMaTch = (lst1, lst2) => {\n  let total = 0;\n  let result = [];\n  lst1.forEach(item => {\n    if (lst2.includes(item)) {\n      total += 1;\n    }\n  });\n  lst2.forEach(item => {\n    if (lst1.includes(item)) {\n      total -= 1;\n    }\n  });\n  result.push(total);\n  return result;\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not greater than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totAlMaTch([], []) ➞ []\n  totAlMaTch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totAlMaTch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totAlMaTch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totAlMaTch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totAlMaTch = (lst1, lst2) => {\n  let total = 0;\n  let result = [];\n  lst1.forEach(item => {\n    if (lst2.includes(item)) {\n      total -= 1;\n    }\n  });\n  lst2.forEach(item => {\n    if (lst1.includes(item)) {\n      total += 1;\n    }\n  });\n  result.push(total);\n  return result;\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMUltiPlyPrIme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMUltiPlyPrIme = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMUltiPlyPrIme", "gc": "<|endoftext|>/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMUltiPlyPrIme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMUltiPlyPrIme = (a) => {\n  let isMUltiPlyPrIme = true;\n  let isPrime = true;\n  let isPrime2 = true;\n  let isPrime3 = true;\n  let isPrime4 = true;\n  let isPrime5 = true;\n  let isPrime6 = true;\n  let isPrime7 = true;\n  let isPrime8 = true;\n  let isPrime9 = true;\n  let isPrime10 = true;\n  let isPrime11 = true;\n  let isPrime12 = true;\n  let isPrime13 = true;\n  let isPrime14 = true;\n  let isPrime15 = true;\n  let isPrime16 = true;\n  let isPrime17 = true;\n  let isPrime18 = true;\n  let isPrime19 = true;\n  let isPrime20 = true;\n  let isPrime21 = true;\n  let isPrime22 = true;\n  let isPrime23 = true;\n  let isPrime24 = true;\n  let isPrime25 = true;\n  let isPrime26 = true;\n  let isPrime27 = true;\n  let isPrime28 = true;\n  let isPrime29 = true;\n  let isPrime30 = true;\n  let isPrime31 = true;\n  let isPrime32 = true;\n  let isPrime33 = true;\n  let isPrime34 = true;\n  let isPrime35 = true;\n  let isPrime36 = true;\n  let isPrime37 = true;\n  let isPrime38 = true;\n  let isPrime39 = true;\n  let isPrime40 = true;\n  let isPrime41 = true;\n  let isPrime42 = true;\n  let isPrime43 = true;\n  let isPrime44 = true;\n  let isPrime45 = true;\n  let isPrime46 = true;\n  let isPrime47 = true;\n  let isPrime48 = true;\n  let isPrime49 = true;\n  let isPrime50 = true;\n  let isPrime51 = true;\n  let isPrime52 = true;\n  let isPrime53 = true;\n  let isPrime54 = true;\n  let isPrime55 = true;\n  let isPrime56 = true;\n  let isPrime57 = true;\n  let isPrime58 = true;\n  let isPrime59 = true;\n  let isPrime60 = true;\n  let isPrime61 = true;\n  let isPrime62 = true;\n  let isPrime63 = true;\n  let isPrime64 = true;\n  let isPrime65 = true;\n  let isPrime66 = true;\n  let isPrime67 = true;\n  let isPrime68 = true;\n  let isPrime69 = true;\n  let isPrime70 = true;\n  let isPrime71 = true;\n  let isPrime72 = true;\n  let isPrime73 = true;\n  let isPrime74 = true;\n  let isPrime75 = true;\n  let isPrime76 = true;\n  let isPrime77 = true;\n  let isPrime78 = true;\n  let isPrime79 = true;\n  let isPrime80 = true;\n  let isPrime81 = true;\n  let isPrime82 = true;\n  let isPrime83 = true;\n  let isPrime84 = true;\n  let isPrime85 = true;\n  let isPrime86 = true;\n  let isPrime87 = true;\n  let isPrime88 = true;\n  let isPrime89 = true;\n  let isPrime90 = true;\n  let isPrime91 = true;\n  let isPrime92 = true;\n  let isPrime93 = true;\n  let isPrime94 = true;\n  let isPrime95 = true;\n  let isPrime96 = true;\n  let isPrime97 = true;\n  let isPrime98 = true;\n  let isPrime99 = true;\n  let isPrime100 = true;\n  let isPrime101 = true;\n  let isPrime102 = true;\n  let isPrime103 = true;\n  let isPrime104 = true;\n  let isPrime105 = true;\n  let isPrime106 = true;\n  let isPrime107 = true;\n  let isPrime108 = true;\n  let isPrime109 = true;\n  let isPrime110 = true;\n  let isPrime111 = true;\n  let isPrime112 = true;\n  let isPrime113 = true;\n  let isPrime114 = true;\n  let isPrime115 = true;\n  let isPrime116 = true;\n  let isPrime117 = true;\n  let isPrime118 = true;\n  let isPrime119 = true;\n  let isPrime120 = true;\n  let isPrime121 = true;\n  let isPrime122 = true;\n  let isPrime123 = true;\n  let isPrime124 = true;\n  let isPrime125 = true;\n  let isPrime126 = true;\n  let isPrime127 = true;\n  let isPrime128 = true;\n  let isPrime129 = true;\n  let isPrime130 = true;\n  let isPrime131 = true;\n  let isPrime132 = true;\n  let isPrime133 = true;\n  let isPrime134 = true;\n  let isPrime135 = true;\n  let isPrime136 = true;\n  let isPrime137 = true;\n  let isPrime138 = true;\n  let isPrime139 = true;\n  let isPrime140 = true;\n  let isPrime141 = true;\n  let isPrime142 = true;\n  let isPrime143 = true;\n  let isPrime144 = true;\n  let isPrime145 = true;\n  let isPrime146 = true;\n  let isPrime147 = true;\n  let isPrime148 = true;\n  let isPrime149 = true;\n  let isPrime150 = true;\n  let isPrime151 = true;\n  let isPrime152 = true;\n  let isPrime153 = true;\n  let isPrime154 = true;\n  let isPrime155 = true;\n  let isPrime156 = true;\n  let isPrime157 = true;\n  let isPrime158 = true;\n  let isPrime159 = true;\n  let isPrime160 = true;\n  let isPrime161 = true;\n  let isPrime162 = true;\n  let isPrime163 = true;\n  let isPrime164 = true;\n  let isPrime165 = true;\n  let isPrime166 = true;\n  let isPrime167 = true;\n  let isPrime168 = true;\n  let isPrime169 = true;\n  let isPrime170 = true;\n  let isPrime171 = true;\n  let isPrime172 = true;\n  let isPrime173 = true;\n  let isPrime174 = true;\n  let isPrime175 = true;\n  let isPrime176 = true;\n  let isPrime177 = true;\n  let isPrime178 = true;\n  let isPrime179 = true;\n  let isPrime180 = true;\n  let isPrime181 = true;\n  let isPrime182 = true;\n  let isPrime183 = true;\n  let isPrime184 = true;\n  let isPrime185 = true;\n  let isPrime186 = true;\n  let isPrime187 = true;\n  let isPrime188 = true;\n  let isPrime189 = true;\n  let isPrime190 = true;\n  let isPrime191 = true;\n  let isPrime192 = true;\n  let isPrime193 = true;\n  let isPrime194 = true;\n  let isPrime195 = true;\n  let isPrime196 = ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSImplEPoweR(1, 4) => true\n  isSImplEPoweR(2, 2) => true\n  isSImplEPoweR(8, 2) => true\n  isSImplEPoweR(3, 2) => false\n  isSImplEPoweR(3, 1) => false\n  isSImplEPoweR(5, 3) => false\n  */\nconst isSImplEPoweR = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSImplEPoweR", "gc": "<|endoftext|>/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSImplEPoweR(1, 4) => true\n  isSImplEPoweR(2, 2) => true\n  isSImplEPoweR(8, 2) => true\n  isSImplEPoweR(3, 2) => false\n  isSImplEPoweR(3, 1) => false\n  isSImplEPoweR(5, 3) => false\n  */\nconst isSImplEPoweR = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  return true;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSImplEPoweR(1, 4) => true\n  isSImplEPoweR(2, 2) => true\n  isSImplEPoweR(8, 2) => true\n  isSImplEPoweR(3, 2) => false\n  isSImplEPoweR(3, 1) => false\n  isSImplEPoweR(5, 3) => false\n  */\nconst isSImplEPoweR = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  return true;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSImplEPoweR(1, 4) => true\n  isSImplEPoweR(2, 2) => true\n  isSImplEPoweR(8, 2) => true\n  isSImplEPoweR(3, 2) => false\n  isSImplEPoweR(3, 1) => false\n  isSImplEPoweR(5, 3) => false\n  */\nconst isSImplEPoweR = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  return true;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSImplEPoweR(1, 4) => true\n  isSImplEPoweR(2, 2) => true\n  isSImplEPoweR(8, 2) => true\n  isSImplEPoweR(3, 2) => false\n  isSImplEPoweR(3, 1) => false\n  isSImplEPoweR(5, 3) => false\n  */\nconst isSImplEPoweR = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  return true;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSImplEPoweR(1, 4) => true\n  isSImplEPoweR(2, 2) => true\n  isSImplEPoweR(8, 2) => true\n  isSImplEPoweR(3, 2) => false\n  isSImplEPoweR(3, 1) => false\n  isSImplEPoweR(5, 3) => false\n  */\nconst isSImplEPoweR = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  return true;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSImplEPoweR(1, 4) => true\n  isSImplEPoweR(2, 2) => true\n  isSImplEPoweR(8, 2) => true\n  isSImplEPoweR(3, 2) => false\n  isSImplEPoweR(3, 1) => false\n  isSImplEPoweR(5, 3) => false\n  */\nconst isSImplEPoweR = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  return true;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSImplEPoweR(1, 4) => true\n  isSImplEPoweR(2, 2) => true\n  isSImplEPoweR(8, 2) => true\n  isSImplEPoweR(3, 2) => false\n  isSImplEPoweR(3, 1) => false\n  isSImplEPoweR(5, 3) => false\n  */\nconst isSImplEPoweR = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  return true;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSImplEPoweR(1, 4) => true\n  isSImplEPoweR(2, 2) => true\n  isSImplEPoweR(8, 2) => true\n  isSImplEPoweR(3, 2) => false\n  isSImplEPoweR(3, 1) => false\n  isSImplEPoweR(5, 3) => false\n  */\nconst isSImplEPoweR = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  return true;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSImplEPoweR(1, 4) => true\n  isSImplEPoweR(2, 2) => true\n  isSImplEPoweR(8, 2) => true\n  isSImplEPoweR(3, 2) => false\n  isSImplEPoweR(3, 1) => false\n  isSImplEPoweR(5, 3) => false\n  */\nconst isSImplEPoweR = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  return true;\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscUbe(1) ==> true\n  iscUbe(2) ==> false\n  iscUbe(-1) ==> true\n  iscUbe(64) ==> true\n  iscUbe(0) ==> true\n  iscUbe(180) ==> false\n  */\nconst iscUbe = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscUbe", "gc": "<|endoftext|>/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscUbe(1) ==> true\n  iscUbe(2) ==> false\n  iscUbe(-1) ==> true\n  iscUbe(64) ==> true\n  iscUbe(0) ==> true\n  iscUbe(180) ==> false\n  */\nconst iscUbe = (a) => {\n  if (a < 1) return false;\n  if (a === 1) return true;\n  if (a % 2 === 0) return false;\n  if (a % 3 === 0) return true;\n  if (a % 4 === 0) return false;\n  if (a % 5 === 0) return true;\n  if (a % 6 === 0) return false;\n  if (a % 7 === 0) return true;\n  if (a % 8 === 0) return false;\n  if (a % 9 === 0) return true;\n  if (a % 10 === 0) return false;\n  if (a % 11 === 0) return true;\n  if (a % 12 === 0) return false;\n  if (a % 13 === 0) return true;\n  if (a % 14 === 0) return false;\n  if (a % 15 === 0) return true;\n  if (a % 16 === 0) return false;\n  if (a % 17 === 0) return true;\n  if (a % 18 === 0) return false;\n  if (a % 19 === 0) return true;\n  if (a % 20 === 0) return false;\n  if (a % 21 === 0) return true;\n  if (a % 22 === 0) return false;\n  if (a % 23 === 0) return true;\n  if (a % 24 === 0) return false;\n  if (a % 25 === 0) return true;\n  if (a % 26 === 0) return false;\n  if (a % 27 === 0) return true;\n  if (a % 28 === 0) return false;\n  if (a % 29 === 0) return true;\n  if (a % 30 === 0) return false;\n  if (a % 31 === 0) return true;\n  if (a % 32 === 0) return false;\n  if (a % 33 === 0) return true;\n  if (a % 34 === 0) return false;\n  if (a % 35 === 0) return true;\n  if (a % 36 === 0) return false;\n  if (a % 37 === 0) return true;\n  if (a % 38 === 0) return false;\n  if (a % 39 === 0) return true;\n  if (a % 40 === 0) return false;\n  if (a % 41 === 0) return true;\n  if (a % 42 === 0) return false;\n  if (a % 43 === 0) return true;\n  if (a % 44 === 0) return false;\n  if (a % 45 === 0) return true;\n  if (a % 46 === 0) return false;\n  if (a % 47 === 0) return true;\n  if (a % 48 === 0) return false;\n  if (a % 49 === 0) return true;\n  if (a % 50 === 0) return false;\n  if (a % 51 === 0) return true;\n  if (a % 52 === 0) return false;\n  if (a % 53 === 0) return true;\n  if (a % 54 === 0) return false;\n  if (a % 55 === 0) return true;\n  if (a % 56 === 0) return false;\n  if (a % 57 === 0) return true;\n  if (a % 58 === 0) return false;\n  if (a % 59 === 0) return true;\n  if (a % 60 === 0) return false;\n  if (a % 61 === 0) return true;\n  if (a % 62 === 0) return false;\n  if (a % 63 === 0) return true;\n  if (a % 64 === 0) return false;\n  if (a % 65 === 0) return true;\n  if (a % 66 === 0) return false;\n  if (a % 67 === 0) return true;\n  if (a % 68 === 0) return false;\n  if (a % 69 === 0) return true;\n  if (a % 70 === 0) return false;\n  if (a % 71 === 0) return true;\n  if (a % 72 === 0) return false;\n  if (a % 73 === 0) return true;\n  if (a % 74 === 0) return false;\n  if (a % 75 === 0) return true;\n  if (a % 76 === 0) return false;\n  if (a % 77 === 0) return true;\n  if (a % 78 === 0) return false;\n  if (a % 79 === 0) return true;\n  if (a % 80 === 0) return false;\n  if (a % 81 === 0) return true;\n  if (a % 82 === 0) return false;\n  if (a % 83 === 0) return true;\n  if (a % 84 === 0) return false;\n  if (a % 85 === 0) return true;\n  if (a % 86 === 0) return false;\n  if (a % 87 === 0) return true;\n  if (a % 88 === 0) return false;\n  if (a % 89 === 0) return true;\n  if (a % 90 === 0) return false;\n  if (a % 91 === 0) return true;\n  if (a % 92 === 0) return false;\n  if (a % 93 === 0) return true;\n  if (a % 94 === 0) return false;\n  if (a % 95 === 0) return true;\n  if (a % 96 === 0) return false;\n  if (a % 97 === 0) return true;\n  if (a % 98 === 0) return false;\n  if (a % 99 === 0) return true;\n  if (a % 100 === 0) return false;\n  if (a % 101 === 0) return true;\n  if (a % 102 === 0) return false;\n  if (a % 103 === 0) return true;\n  if (a % 104 === 0) return false;\n  if (a % 105 === 0) return true;\n  if (a % 106 === 0) return false;\n  if (a % 107 === 0) return true;\n  if (a % 108 === 0) return false;\n  if (a % 109 === 0) return true;\n  if (a % 110 === 0) return false;\n  if (a % 111 === 0) return true;\n  if (a % 112 === 0) return false;\n  if (a % 113 === 0) return true;\n  if (a % 114 === 0) return false;\n  if (a % 115 === 0) return true;\n  if (a % 116 === 0) return false;\n  if (a % 117 === 0) return true;\n  if (a % 118 === 0) return false;\n  if (a % 119 === 0) return true;\n  if (a % 120 === 0) return false;\n  if (a % 121 === 0) return true;\n  if (a % 122 === 0) return false;\n  if (a % 123 === 0) return true;\n  if (a % 124 === 0) return false;\n  if (a % 125 === 0) return true;\n  if (a % 126 === 0) return false;\n  if (a % 127 === 0) return true;\n  if (a % 128 === 0) return false;\n  if (a % 129 === 0) return true;\n  if (a % 130 === 0) return false;\n  if (a % 131 === 0) return true;\n  if (a % 132 === 0) return false;\n  if (a % 133 === 0) return true;\n  if (a % 134 === 0) return false;\n  if (a % 135 === 0) return true;\n  if (a % 136 === 0) return false;\n  if (a % 137 === 0) return true;\n  if (a % 138 === 0) return false;\n  if (a % 139 === 0) return true;\n  if (a % 140 === 0) return false;\n  if (a % 141 === 0) return true;\n  if (a % 142 === 0) return false;\n  if (a % 143 === 0) return true;\n  if (a % 144 === 0) return false;\n  if (a % 145 === 0) return true;\n  if (a % 146 === 0) return false;\n  if (a % 147 === 0) return true;\n  if (a % 148 === 0) return false;\n  if (a % 149 === 0) return true;\n  if (a % 150 === 0) return false;\n  if (a % 151 === 0) return true;\n  if (a % 152 === 0) return false;\n  if (a % ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexkey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexkey", "gc": "<|endoftext|>/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexkey = (num) => {\n  let count = 0;\n  let numArray = num.split('');\n  for (let i = 0; i < numArray.length; i++) {\n    if (numArray[i].length === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You have been tasked to write a function that receives a string and counts\n  the number of letters that are uppercase letters (A===a===Z===z===A===Z===a===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===z===A===Z===", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decImaltoBinAry(15)   # returns \"db1111db\"\n  decImaltoBinAry(32)   # returns \"db100000db\"\n  */\nconst decImaltoBinAry = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decImaltoBinAry", "gc": "<|endoftext|>/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decImaltoBinAry(15)   # returns \"db1111db\"\n  decImaltoBinAry(32)   # returns \"db100000db\"\n  */\nconst decImaltoBinAry = (decimal) => {\n  let binary = '';\n  let binaryString = '';\n  let binaryStringLength = 0;\n  let binaryStringLengthLength = 0;\n  let binaryStringLengthLength2 = 0;\n  let binaryStringLengthLength3 = 0;\n  let binaryStringLengthLength4 = 0;\n  let binaryStringLengthLength5 = 0;\n  let binaryStringLengthLength6 = 0;\n  let binaryStringLengthLength7 = 0;\n  let binaryStringLengthLength8 = 0;\n  let binaryStringLengthLength9 = 0;\n  let binaryStringLengthLength10 = 0;\n  let binaryStringLengthLength11 = 0;\n  let binaryStringLengthLength12 = 0;\n  let binaryStringLengthLength13 = 0;\n  let binaryStringLengthLength14 = 0;\n  let binaryStringLengthLength15 = 0;\n  let binaryStringLengthLength16 = 0;\n  let binaryStringLengthLength17 = 0;\n  let binaryStringLengthLength18 = 0;\n  let binaryStringLengthLength19 = 0;\n  let binaryStringLengthLength20 = 0;\n  let binaryStringLengthLength21 = 0;\n  let binaryStringLengthLength22 = 0;\n  let binaryStringLengthLength23 = 0;\n  let binaryStringLengthLength24 = 0;\n  let binaryStringLengthLength25 = 0;\n  let binaryStringLengthLength26 = 0;\n  let binaryStringLengthLength27 = 0;\n  let binaryStringLengthLength28 = 0;\n  let binaryStringLengthLength29 = 0;\n  let binaryStringLengthLength30 = 0;\n  let binaryStringLengthLength31 = 0;\n  let binaryStringLengthLength32 = 0;\n  let binaryStringLengthLength33 = 0;\n  let binaryStringLengthLength34 = 0;\n  let binaryStringLengthLength35 = 0;\n  let binaryStringLengthLength36 = 0;\n  let binaryStringLengthLength37 = 0;\n  let binaryStringLengthLength38 = 0;\n  let binaryStringLengthLength39 = 0;\n  let binaryStringLengthLength40 = 0;\n  let binaryStringLengthLength41 = 0;\n  let binaryStringLengthLength42 = 0;\n  let binaryStringLengthLength43 = 0;\n  let binaryStringLengthLength44 = 0;\n  let binaryStringLengthLength45 = 0;\n  let binaryStringLengthLength46 = 0;\n  let binaryStringLengthLength47 = 0;\n  let binaryStringLengthLength48 = 0;\n  let binaryStringLengthLength49 = 0;\n  let binaryStringLengthLength50 = 0;\n  let binaryStringLengthLength51 = 0;\n  let binaryStringLengthLength52 = 0;\n  let binaryStringLengthLength53 = 0;\n  let binaryStringLengthLength54 = 0;\n  let binaryStringLengthLength55 = 0;\n  let binaryStringLengthLength56 = 0;\n  let binaryStringLengthLength57 = 0;\n  let binaryStringLengthLength58 = 0;\n  let binaryStringLengthLength59 = 0;\n  let binaryStringLengthLength60 = 0;\n  let binaryStringLengthLength61 = 0;\n  let binaryStringLengthLength62 = 0;\n  let binaryStringLengthLength63 = 0;\n  let binaryStringLengthLength64 = 0;\n  let binaryStringLengthLength65 = 0;\n  let binaryStringLengthLength66 = 0;\n  let binaryStringLengthLength67 = 0;\n  let binaryStringLengthLength68 = 0;\n  let binaryStringLengthLength69 = 0;\n  let binaryStringLengthLength70 = 0;\n  let binaryStringLengthLength71 = 0;\n  let binaryStringLengthLength72 = 0;\n  let binaryStringLengthLength73 = 0;\n  let binaryStringLengthLength74 = 0;\n  let binaryStringLengthLength75 = 0;\n  let binaryStringLengthLength76 = 0;\n  let binaryStringLengthLength77 = 0;\n  let binaryStringLengthLength78 = 0;\n  let binaryStringLengthLength79 = 0;\n  let binaryStringLengthLength80 = 0;\n  let binaryStringLengthLength81 = 0;\n  let binaryStringLengthLength82 = 0;\n  let binaryStringLengthLength83 = 0;\n  let binaryStringLengthLength84 = 0;\n  let binaryStringLengthLength85 = 0;\n  let binaryStringLengthLength86 = 0;\n  let binaryStringLengthLength87 = 0;\n  let binaryStringLengthLength88 = 0;\n  let binaryStringLengthLength89 = 0;\n  let binaryStringLengthLength90 = 0;\n  let binaryStringLengthLength91 = 0;\n  let binaryStringLengthLength92 = 0;\n  let binaryStringLengthLength93 = 0;\n  let binaryStringLengthLength94 = 0;\n  let binaryStringLengthLength95 = 0;\n  let binaryStringLengthLength96 = 0;\n  let binaryStringLengthLength97 = 0;\n  let binaryStringLengthLength98 = 0;\n  let binaryStringLengthLength99 = 0;\n  let binaryStringLengthLength100 = 0;\n  let binaryStringLengthLength101 = 0;\n  let binaryStringLengthLength102 = 0;\n  let binaryStringLengthLength103 = 0;\n  let binaryStringLengthLength104 = 0;\n  let binaryStringLengthLength105 = 0;\n  let binaryStringLengthLength106 = 0;\n  let binaryStringLengthLength107 = 0;\n  let binaryStringLengthLength108 = 0;\n  let binaryStringLengthLength109 = 0;\n  let binaryStringLengthLength110 = 0;\n  let binaryStringLengthLength111 = 0;\n  let binaryStringLengthLength112 = 0;\n  let binaryStringLengthLength113 = 0;\n  let binaryStringLengthLength114 = 0;\n  let binaryStringLengthLength115 = 0;\n  let binaryStringLengthLength116 = 0;\n  let binaryStringLengthLength117 = 0;\n  let binaryStringLengthLength118 = 0;\n  let binaryStringLengthLength119 = 0;\n  let binaryStringLengthLength120 = 0;\n  let binaryStringLengthLength121 = 0;\n  let binaryStringLengthLength122 = 0;\n  let binaryStringLengthLength123 = 0;\n  let binaryStringLengthLength124 = 0;\n  let binaryStringLengthLength125 = 0;\n  let binaryStringLengthLength126 = 0;\n  let binaryStringLengthLength127 = 0;\n  let binaryStringLengthLength128 = 0;\n  let binaryStringLengthLength129 = 0;\n  let binaryStringLengthLength130 = 0;\n  let binaryStringLengthLength131 = 0;\n  let binaryStringLengthLength132 = 0;\n  let binaryStringLengthLength133 = 0;\n  let binaryStringLengthLength134 = 0;\n  let binaryStringLengthLength135 = 0;\n  let binaryStringLengthLength136 = 0;\n  let binaryStringLengthLength137 = 0;\n  let binaryStringLengthLength138 = 0;\n  let binaryStringLengthLength139 = 0;\n  let binaryStringLengthLength140 = 0;\n  let binaryStringLengthLength141 = 0;\n  let binaryStringLengthLength142 = 0;\n  let binaryStringLengthLength143 = 0;\n  let binaryStringLengthLength144 = 0;\n  let binaryStringLengthLength145 = 0;\n  let binaryStringLengthLength146 = 0;\n  let binaryStringLengthLength147 = 0;\n  let binaryStringLengthLength148 = 0;\n  let binaryStringLengthLength149 = 0;\n  let binaryStringLengthLength150 = 0;\n  let binaryStringLengthLength151 = 0;\n  let binaryStringLengthLength152 = 0;\n  let binaryStringLengthLength153 = 0;\n  let binaryStringLengthLength154 = 0;\n  let binaryStringLengthLength155 = 0;\n  let binaryStringLengthLength156 = 0;\n  let binaryStringLengthLength157 = 0;\n  let binaryStringLengthLength158 = 0;\n  let binaryStringLengthLength159 = 0;\n  let binaryStringLengthLength160 = 0;\n  let binaryStringLengthLength161 = 0;\n  let binaryStringLengthLength162 = 0;\n  let binaryStringLengthLength163 = 0;\n  let binaryStringLengthLength164 = 0;\n  let binaryStringLengthLength165 = 0;\n  let binaryStringLengthLength166 = 0;\n  let binaryStringLengthLength167 = 0;\n  let binaryStringLengthLength168 = 0;\n  let binaryStringLengthLength169 = 0;\n  let binaryStringLengthLength170 = 0;\n  let binaryStringLengthLength171 = 0;\n  let binaryStringLengthLength172 = 0;\n  let binaryStringLengthLength173 = 0;\n  let binaryStringLengthLength174 = 0;\n  let binaryStringLengthLength175 = 0;\n  let binaryStringLength", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumprodUct([])\n  (0, 1)\n  >>> sumprodUct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumprodUct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumprodUct", "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumprodUct([])\n  (0, 1)\n  >>> sumprodUct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumprodUct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the one at index.\n  >>> listOdds([0, 1, 2, 3, 4])\n  [2, 4]\n  */\nconst listOdds = (numbers, index) => {\n  let odds = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i!== index) {\n      odds.push(numbers[i]);\n    }\n  }\n  return odds;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the one at index but one less than the one at index.\n  >>> listEvens([0, 1, 2, 3, 4])\n  [3, 4]\n  */\nconst listEvens = (numbers, index) => {\n  let evens = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i!== index) {\n      evens.push(numbers[i]);\n    }\n  }\n  return evens;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the one at index but one less than the one at index plus one.\n  >>> listOddsPlusOne([0, 1, 2, 3, 4])\n  [2, 3, 4]\n  */\nconst listOddsPlusOne = (numbers, index) => {\n  let odds = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i!== index) {\n      odds.push(numbers[i]);\n    }\n  }\n  return odds;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the one at index but one less than the one at index plus one.\n  >>> listEvensPlusOne([0, 1, 2, 3, 4])\n  [3, 4]\n  */\nconst listEvensPlusOne = (numbers, index) => {\n  let evens = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i!== index) {\n      evens.push(numbers[i]);\n    }\n  }\n  return evens;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the one at index but one less than the one at index minus one.\n  >>> listOddsMinusOne([0, 1, 2, 3, 4])\n  [1, 2, 3, 4]\n  */\nconst listOddsMinusOne = (numbers, index) => {\n  let odds = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i!== index) {\n      odds.push(numbers[i]);\n    }\n  }\n  return odds;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the one at index but one less than the one at index minus one.\n  >>> listEvensMinusOne([0, 1, 2, 3, 4])\n  [3, 4]\n  */\nconst listEvensMinusOne = (numbers, index) => {\n  let evens = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i!== index) {\n      evens.push(numbers[i]);\n    }\n  }\n  return evens;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the one at index plus one.\n  >>> listOddsPlusOnePlusOne([0, 1, 2, 3, 4])\n  [2, 3, 4]\n  */\nconst listOddsPlusOnePlusOne = (numbers, index) => {\n  let odds = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i!== index) {\n      odds.push(numbers[i]);\n    }\n  }\n  return odds;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the one at index plus one.\n  >>> listEvensPlusOnePlusOne([0, 1, 2, 3, 4])\n  [3, 4]\n  */\nconst listEvensPlusOnePlusOne = (numbers, index) => {\n  let evens = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i!== index) {\n      evens.push(numbers[i]);\n    }\n  }\n  return evens;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the one at index minus one.\n  >>> listOddsMinusOneMinusOne([0, 1, 2, 3, 4])\n  [1, 2, 3, 4]\n  */\nconst listOddsMinusOneMinusOne = (numbers, index) => {\n  let odds = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i!== index) {\n      odds.push(numbers[i]);\n    }\n  }\n  return odds;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the one at index minus one.\n  >>> listEvensMinusOneMinusOne([0, 1, 2, 3, 4])\n  [3, 4]\n  */\nconst listEvensMinusOneMinusOne = (numbers, index) => {\n  let evens = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i!== index) {\n      evens.push(numbers[i]);\n    }\n  }\n  return evens;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the one at index minus one.\n  >>> listOddsMinusOneMinusOnePlusOne([0, 1, 2, 3, 4])\n  [2, 3, 4]\n  */\nconst listOddsMinusOneMinusOnePlusOne = (numbers, index) => {\n  let odds = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i!== index) {\n      odds.push(numbers[i]);\n    }\n  }\n  return odds;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the one at index minus one.\n  >>> listEvensMinusOneMinusOnePlusOne([0, 1, 2, 3, 4])\n  [3, 4]\n  */\nconst listEvensMinusOneMinusOnePlusOne = (numbers, index) => {\n  let evens = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i!== index) {\n      evens.push(numbers[i]);\n    }\n  }\n  return evens;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the one at index minus one.\n  >>> listOddsMinusOneMinusOneMinusOnePlusOne([0, 1, 2, 3, 4])\n  [2, 3, 4]\n  */\nconst listOddsMinusOneMinusOneMinusOnePlusOne = (numbers, index) => {\n  let odds = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i!== index) {\n      odds.push(numbers[i]);\n    }\n  }\n  return odds;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the one at index minus one.\n  >>> listOddsMinusOneMinusOneMinusOneMinusOnePlusOne([0, 1, 2, 3, 4])\n  [2, 3, 4]\n  */\nconst listOddsMinusOneMinusOneMinusOneMinusOnePlusOne = (numbers, index) => {\n  let odds = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i!== index) {\n      odds.push(numbers[i]);\n    }\n  }\n  return odds;\n};\n\n/* Given a list of integers, return a list of integers containing all the integers except the one at index minus one.\n  >>> listOddsMinusOneMinusOneMinusOneMinusOneMinusOneMinusOnePlusOne([0, 1, 2, 3, 4])\n  [2, 3, 4]\n  */\nconst listOddsMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOnePlusOne = (numbers, index) => {\n  let odds = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i!== index) {\n      odds.push(numbers[i]);\n    }\n  }\n  return odds;\n};\n\n/* Given a list of integers, return a list of ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isHAppy(a) => false\n  isHAppy(aa) => false\n  isHAppy(abcd) => true\n  isHAppy(aabb) => false\n  isHAppy(adb) => true\n  isHAppy(xyy) => false\n  */\nconst isHAppy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHAppy", "gc": "<|endoftext|>/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isHAppy(a) => false\n  isHAppy(aa) => false\n  isHAppy(abcd) => true\n  isHAppy(aabb) => false\n  isHAppy(adb) => true\n  isHAppy(xyy) => false\n  */\nconst isHAppy = (s) => {\n  let isHappy = true;\n  let isHappyLength = 3;\n  let isHappyLettersDistinct = true;\n  let isHappyLettersCount = 0;\n  let isHappyLettersCount2 = 0;\n  let isHappyLettersCount3 = 0;\n  let isHappyLettersCount4 = 0;\n  let isHappyLettersCount5 = 0;\n  let isHappyLettersCount6 = 0;\n  let isHappyLettersCount7 = 0;\n  let isHappyLettersCount8 = 0;\n  let isHappyLettersCount9 = 0;\n  let isHappyLettersCount10 = 0;\n  let isHappyLettersCount11 = 0;\n  let isHappyLettersCount12 = 0;\n  let isHappyLettersCount13 = 0;\n  let isHappyLettersCount14 = 0;\n  let isHappyLettersCount15 = 0;\n  let isHappyLettersCount16 = 0;\n  let isHappyLettersCount17 = 0;\n  let isHappyLettersCount18 = 0;\n  let isHappyLettersCount19 = 0;\n  let isHappyLettersCount20 = 0;\n  let isHappyLettersCount21 = 0;\n  let isHappyLettersCount22 = 0;\n  let isHappyLettersCount23 = 0;\n  let isHappyLettersCount24 = 0;\n  let isHappyLettersCount25 = 0;\n  let isHappyLettersCount26 = 0;\n  let isHappyLettersCount27 = 0;\n  let isHappyLettersCount28 = 0;\n  let isHappyLettersCount29 = 0;\n  let isHappyLettersCount30 = 0;\n  let isHappyLettersCount31 = 0;\n  let isHappyLettersCount32 = 0;\n  let isHappyLettersCount33 = 0;\n  let isHappyLettersCount34 = 0;\n  let isHappyLettersCount35 = 0;\n  let isHappyLettersCount36 = 0;\n  let isHappyLettersCount37 = 0;\n  let isHappyLettersCount38 = 0;\n  let isHappyLettersCount39 = 0;\n  let isHappyLettersCount40 = 0;\n  let isHappyLettersCount41 = 0;\n  let isHappyLettersCount42 = 0;\n  let isHappyLettersCount43 = 0;\n  let isHappyLettersCount44 = 0;\n  let isHappyLettersCount45 = 0;\n  let isHappyLettersCount46 = 0;\n  let isHappyLettersCount47 = 0;\n  let isHappyLettersCount48 = 0;\n  let isHappyLettersCount49 = 0;\n  let isHappyLettersCount50 = 0;\n  let isHappyLettersCount51 = 0;\n  let isHappyLettersCount52 = 0;\n  let isHappyLettersCount53 = 0;\n  let isHappyLettersCount54 = 0;\n  let isHappyLettersCount55 = 0;\n  let isHappyLettersCount56 = 0;\n  let isHappyLettersCount57 = 0;\n  let isHappyLettersCount58 = 0;\n  let isHappyLettersCount59 = 0;\n  let isHappyLettersCount60 = 0;\n  let isHappyLettersCount61 = 0;\n  let isHappyLettersCount62 = 0;\n  let isHappyLettersCount63 = 0;\n  let isHappyLettersCount64 = 0;\n  let isHappyLettersCount65 = 0;\n  let isHappyLettersCount66 = 0;\n  let isHappyLettersCount67 = 0;\n  let isHappyLettersCount68 = 0;\n  let isHappyLettersCount69 = 0;\n  let isHappyLettersCount70 = 0;\n  let isHappyLettersCount71 = 0;\n  let isHappyLettersCount72 = 0;\n  let isHappyLettersCount73 = 0;\n  let isHappyLettersCount74 = 0;\n  let isHappyLettersCount75 = 0;\n  let isHappyLettersCount76 = 0;\n  let isHappyLettersCount77 = 0;\n  let isHappyLettersCount78 = 0;\n  let isHappyLettersCount79 = 0;\n  let isHappyLettersCount80 = 0;\n  let isHappyLettersCount81 = 0;\n  let isHappyLettersCount82 = 0;\n  let isHappyLettersCount83 = 0;\n  let isHappyLettersCount84 = 0;\n  let isHappyLettersCount85 = 0;\n  let isHappyLettersCount86 = 0;\n  let isHappyLettersCount87 = 0;\n  let isHappyLettersCount88 = 0;\n  let isHappyLettersCount89 = 0;\n  let isHappyLettersCount90 = 0;\n  let isHappyLettersCount91 = 0;\n  let isHappyLettersCount92 = 0;\n  let isHappyLettersCount93 = 0;\n  let isHappyLettersCount94 = 0;\n  let isHappyLettersCount95 = 0;\n  let isHappyLettersCount96 = 0;\n  let isHappyLettersCount97 = 0;\n  let isHappyLettersCount98 = 0;\n  let isHappyLettersCount99 = 0;\n  let isHappyLettersCount100 = 0;\n  let isHappyLettersCount101 = 0;\n  let isHappyLettersCount102 = 0;\n  let isHappyLettersCount103 = 0;\n  let isHappyLettersCount104 = 0;\n  let isHappyLettersCount105 = 0;\n  let isHappyLettersCount106 = 0;\n  let isHappyLettersCount107 = 0;\n  let isHappyLettersCount108 = 0;\n  let isHappyLettersCount109 = 0;\n  let isHappyLettersCount110 = 0;\n  let isHappyLettersCount111 = 0;\n  let isHappyLettersCount112 = 0;\n  let isHappyLettersCount113 = 0;\n  let isHappyLettersCount114 = 0;\n  let isHappyLettersCount115 = 0;\n  let isHappyLettersCount116 = 0;\n  let isHappyLettersCount117 = 0;\n  let isHappyLettersCount118 = 0;\n  let isHappyLettersCount119 = 0;\n  let isHappyLettersCount120 = 0;\n  let isHappyLettersCount121 = 0;\n  let isHappyLettersCount122 = 0;\n  let isHappyLettersCount123 = 0;\n  let isHappyLettersCount124 = 0;\n  let isHappyLettersCount125 = 0;\n  let isHappyLettersCount126 = 0;\n  let isHappyLettersCount127 = 0;\n  let isHappyLettersCount128 = 0;\n  let is", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numEricAlLetTergrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numEricAlLetTergrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numEricAlLetTergrade", "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numEricAlLetTergrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numEricAlLetTergrade = (grades) => {\n  let letterGrades = [];\n  let numEric = grades.reduce((acc, cur) => {\n    if (cur >= 3.0 && cur <= 3.7) {\n      acc.push('A');\n    } else if (cur >= 3.3 && cur <= 3.7) {\n      acc.push('A-');\n    } else if (cur >= 3.0 && cur <= 3.3) {\n      acc.push('B+');\n    } else if (cur >= 2.7 && cur <= 3.3) {\n      acc.push('B');\n    } else if (cur >= 2.3 && cur <= 2.7) {\n      acc.push('B-');\n    } else if (cur >= 2.0 && cur <= 2.3) {\n      acc.push('C+');\n    } else if (cur >= 1.7 && cur <= 2.3) {\n      acc.push('C');\n    } else if (cur >= 1.3 && cur <= 2.7) {\n      acc.push('C-');\n    } else if (cur >= 1.0 && cur <= 2.7) {\n      acc.push('D+');\n    } else if (cur >= 0.7 && cur <= 2.7) {\n      acc.push('D');\n    } else if (cur >= 0.0 && cur <= 2.3) {\n      acc.push('D-');\n    } else {\n      acc.push('E');\n    }\n    return acc;\n  }, []);\n  numEric.forEach((letter) => {\n    letterGrades.push(letter);\n  });\n  return letterGrades;\n};\n\n/*\n  Write a function that takes an array of grades and a semester number and\n  returns the list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numEricAlLetTergrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numEricAlLetTergradeGrades = (grades, semester) => {\n  let letterGrades = [];\n  let numEric = grades.reduce((acc, cur) => {\n    if (cur >= 3.0 && cur <= 3.7) {\n      acc.push('A');\n    } else if (cur >= 3.3 && cur <= 3.7) {\n      acc.push('A-');\n    } else if (cur >= 3.0 && cur <= 3.3) {\n      acc.push('B+');\n    } else if (cur >= 2.7 && cur <= 3.3) {\n      acc.push('B');\n    } else if (cur >= 2.3 && cur <= 2.7) {\n      acc.push('B-');\n    } else if (cur >= 2.0 && cur <= 2.3) {\n      acc.push('C+');\n    } else if (cur >= 1.7 && cur <= 2.3) {\n      acc.push('C');\n    } else if (cur >= 1.3 && cur <= 2.7) {\n      acc.push('C-');\n    } else if (cur >= 1.0 && cur <= 2.7) {\n      acc.push('D+');\n    } else if (cur >= 0.7 && cur <= 2.7) {\n      acc.push('D');\n    } else if (cur >= 0.0 && cur <= 2.3) {\n      acc.push('D-');\n    } else {\n      acc.push('E');\n    }\n    return acc;\n  }, []);\n  numEric.forEach((letter) => {\n    letterGrades.push(letter);\n  });\n  return letterGrades;\n};\n\n/*\n  Write a function that takes an array of grades and a semester number and\n  returns the list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numEricAlLetTergradeGrades([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numEricAlLetTergradeGradesGrades = (grades, semester) => {\n  let letterGrades = [];\n  let numEric = grades.reduce((acc, cur) => {\n    if (cur >= 3.0 && cur <= 3.7) {\n      acc.push('A');\n    } else if (cur >= 3.3 && cur <= 3.7) {\n      acc.push('A-');\n    } else if (cur >= 3.0 && cur <= 3.3) {\n      acc.push('B+');\n    } else if (cur >= 2.7 && cur <= 3.3) {\n      acc.push('B');\n    } else if (cur >= 2.3 && cur <= 2.7) {\n      acc.push('B-');\n    } else if (cur >= 2.0 && cur <= 2.3) {\n      acc.push('C+');\n    } else if (cur >= 1.7 && cur <= 2.3) {\n      acc.push('C');\n    } else if (cur >= 1.3 && cur <= 2.7) {\n      acc.push('C-');\n    } else if (cur >= 1.0 && cur <= 2.7) {\n      acc.push('D+');\n    } else if (cur >= 0.7 && cur <= 2.7) {\n      acc.push('D');\n    } else if (cur >= 0.0 && cur <= 2.3) {\n      acc.push('D-');\n    } else {\n      acc.push('E');\n    }\n    return acc;\n  }, []);\n  numEric.forEach((letter) => {\n    letterGrades.push(letter);\n  });\n  return letterGrades;\n};\n\n/*\n  Write a function that takes an array of grades and a semester number and\n  returns the list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numEricAlLetTergradeGradesGrades([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numEricAlLet", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  priMeLeNgth('Hello') == true\n  priMeLeNgth('abcdcba') == true\n  priMeLeNgth('kittens') == true\n  priMeLeNgth('orange') == false\n  */\nconst priMeLeNgth = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "priMeLeNgth", "gc": "<|endoftext|>/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  priMeLeNgth('Hello') == true\n  priMeLeNgth('abcdcba') == true\n  priMeLeNgth('kittens') == true\n  priMeLeNgth('orange') == false\n  */\nconst priMeLeNgth = (string) => {\n  let isPrime = true;\n  let length = string.length;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst staRtsONeEndS = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "staRtsONeEndS", "gc": "<|endoftext|>/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst staRtsONeEndS = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      if (n % 100 === 0) {\n        if (n % 100 === 1) {\n          count++;\n        }\n      }\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst staRtsONeStartS = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      if (n % 100 === 0) {\n        if (n % 100 === 1) {\n          count++;\n        }\n      }\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst staRtsONeStart0S = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      if (n % 100 === 0) {\n        if (n % 100 === 1) {\n          count++;\n        }\n      }\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst staRtsONeStart1S = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      if (n % 100 === 0) {\n        if (n % 100 === 1) {\n          count++;\n        }\n      }\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst staRtsONeEnd0S = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      if (n % 100 === 0) {\n        if (n % 100 === 1) {\n          count++;\n        }\n      }\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst staRtsONeEnd1S = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      if (n % 100 === 0) {\n        if (n % 100 === 1) {\n          count++;\n        }\n      }\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst staRtsONeStart0 = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      if (n % 100 === 0) {\n        if (n % 100 === 1) {\n          count++;\n        }\n      }\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst staRtsONeStart1 = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      if (n % 100 === 0) {\n        if (n % 100 === 1) {\n          count++;\n        }\n      }\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst staRtsONeEnd0 = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      if (n % 100 === 0) {\n        if (n % 100 === 1) {\n          count++;\n        }\n      }\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst staRtsONeEnd1 = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      if (n % 100 === 0) {\n        if (n % 100 === 1) {\n          count++;\n        }\n      }\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst staRtsONeStart0n = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      if (n % 100 === 0) {\n        if (n % 100 === 1) {\n          count++;\n        }\n      }\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst staRtsONeStart1n = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      if (n % 100 === 0) {\n        if (n % 100 === 1) {\n          count++;\n        }\n      }\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst staRtsONeEnd0n = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      if (n % 100 === 0) {\n        if (n % 100 === 1) {\n          count++;\n        }\n      }\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst staRtsONeEnd1n = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      if (n % 100 === 0) {\n        if (n % 100 === 1) {\n          count++;\n        }\n      }\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst staRtsONeStart0nS = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      if (n % 100 === 0) {\n        if (n % 100 === 1) {\n          count++;\n        }\n      }\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst staRtsONeStart1nS = (n) => {\n  let count = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      if (n % 100 === 0) {\n        if (n % 100 === 1) {\n          count++;\n        }\n      }\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solVe = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solVe", "gc": "<|endoftext|>/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solVe = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i).toString(2);\n    sum = sum + parseInt(binary.charAt(0), 2);\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst solDe = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i).toString(2);\n    sum = sum + parseInt(binary.charAt(0), 2);\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst solHex = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i).toString(16);\n    sum = sum + parseInt(binary.charAt(0), 16);\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in octal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of octal number\n  */\nconst solOct = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i).toString(8);\n    sum = sum + parseInt(binary.charAt(0), 8);\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal and decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal and decimal number\n  */\nconst solHexDec = () => {\n  let sum = 0;\n  let binary = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i).toString(16);\n    sum = sum + parseInt(binary.charAt(0), 16);\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal and decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal and decimal number\n  */\nconst solHexDecDec = () => {\n  let sum = 0;\n  let binary = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i).toString(16);\n    sum = sum + parseInt(binary.charAt(0), 16);\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal and decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal and decimal number\n  */\nconst solHexDecDecHex = () => {\n  let sum = 0;\n  let binary = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i).toString(16);\n    sum = sum + parseInt(binary.charAt(0), 16);\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal and decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal and decimal number\n  */\nconst solHexDecDecHexDec = () => {\n  let sum = 0;\n  let binary = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i).toString(16);\n    sum = sum + parseInt(binary.charAt(0), 16);\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal and decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal and decimal number\n  */\nconst solHexDecDecHexDecHex = () => {\n  let sum = 0;\n  let binary = \"\";\n  \n  for (let i = 0; i <= N; i++) {\n    binary = binary + binary(i).toString(16);\n    sum = sum + parseInt(binary.charAt(0), 16);\n  }\n  \n  return sum;\n};\n\n/*Given a ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "gc": "<|endoftext|>/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd > 0 && even++ < lst.length) {\n    if (lst[odd] % 2 === 0) {\n      lst[odd] = lst[odd] + 1;\n    } else {\n      lst[odd] = lst[odd] - 1;\n    }\n    odd = (odd + 1) % lst.length;\n  }\n  return lst;\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst remove = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd > 0 && even++ < lst.length) {\n    if (lst[odd] % 2 === 0) {\n      lst[odd] = lst[odd] - 1;\n    } else {\n      lst[odd] = lst[odd] + 1;\n    }\n    odd = (odd + 1) % lst.length;\n  }\n  return lst;\n};\n\n/*Given a non-empty list of integers lst. return the sum of the even elements that are at odd indices..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 7\n  */\nconst sum = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd > 0 && even++ < lst.length) {\n    if (lst[odd] % 2 === 0) {\n      lst[odd] = lst[odd] + 1;\n    } else {\n      lst[odd] = lst[odd] - 1;\n    }\n    odd = (odd + 1) % lst.length;\n  }\n  return lst;\n};\n\n/*Given a non-empty list of integers lst. return the product of the even elements that are at odd indices..\n\n\n  Examples:\n      product([4, 2, 6, 7]) ==> 24\n  */\nconst product = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd > 0 && even++ < lst.length) {\n    if (lst[odd] % 2 === 0) {\n      lst[odd] = lst[odd] * 1;\n    } else {\n      lst[odd] = lst[odd] * -1;\n    }\n    odd = (odd + 1) % lst.length;\n  }\n  return lst;\n};\n\n/*Given a non-empty list of integers lst. return the product of the odd elements that are at even indices..\n\n\n  Examples:\n      product([4, 2, 6, 7]) ==> 4\n  */\nconst productOdd = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (even < odd && odd - even > 1) {\n    if (lst[even] % 2 === 0) {\n      lst[even] = lst[even] * -1;\n    } else {\n      lst[even] = lst[even] * 1;\n    }\n    even = (even + 1) % lst.length;\n  }\n  return lst;\n};\n\n/*Given a non-empty list of integers lst. return the product of the odd elements that are at odd indices..\n\n\n  Examples:\n      productOdd([4, 2, 6, 7]) ==> 8\n  */\nconst productOddEven = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (even < odd && odd - even > 1) {\n    if (lst[even] % 2 === 0) {\n      lst[even] = lst[even] * -1;\n    } else {\n      lst[even] = lst[even] * 1;\n    }\n    even = (even + 1) % lst.length;\n  }\n  return lst;\n};\n\n/*Given a non-empty list of integers lst. return the product of the even elements that are at even indices..\n\n\n  Examples:\n      productEven([4, 2, 6, 7]) ==> 2\n  */\nconst productEven = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (even < odd && odd - even > 1) {\n    if (lst[even] % 2 === 0) {\n      lst[even] = lst[even] * 1;\n    } else {\n      lst[even] = lst[even] * -1;\n    }\n    even = (even + 1) % lst.length;\n  }\n  return lst;\n};\n\n/*Given a non-empty list of integers lst. return the product of the odd elements that are at odd indices..\n\n\n  Examples:\n      productOddEven([4, 2, 6, 7]) ==> 6\n  */\nconst productOddEvenOdd = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (even < odd && odd - even > 1) {\n    if (lst[even] % 2 === 0) {\n      lst[even] = lst[even] * -1;\n    } else {\n      lst[even] = lst[even] * 1;\n    }\n    even = (even + 1) % lst.length;\n  }\n  return lst;\n};\n\n/*Given a non-empty list of integers lst. return the product of the even elements that are at odd indices..\n\n\n  Examples:\n      productOddEvenOdd([4, 2, 6, 7]) ==> 12\n  */\nconst productOddEvenOddOddEven = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (even < odd && odd - even > 1) {\n    if (lst[even] % 2 === 0) {\n      lst[even] = lst[even] * -1;\n    } else {\n      lst[even] = lst[even] * 1;\n    }\n    even = (even + 1) % lst.length;\n  }\n  return lst;\n};\n\n/*Given a non-empty list of integers lst. return the product of the odd elements that are at odd indices..\n\n\n  Examples:\n      productOddEvenOddOddEvenOdd([4, 2, 6, 7]) ==> 24\n  */\nconst productOddEvenOddOddEvenOddOddEvenOdd = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (even < odd && odd - even > 1) {\n    if (lst[even] % 2 === 0) {\n      lst[even] = lst[even] * -1;\n    } else {\n      lst[even] = lst[even] * 1;\n    }\n    even = (even + 1) % lst.length;\n  }\n  return lst;\n};\n\n/*Given a non-empty list of integers lst. return the product of the even elements that are at odd indices..\n\n\n  Examples:\n      productOddEvenOddOddEvenOddOddEvenOdd([4, 2, 6, 7]) ==> 120\n  */\nconst productOddEvenOddOddEvenOddOddEvenOddOddEvenOdd = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (even < odd && odd - even > 1) {\n    if (lst[even] % 2 === 0) {\n      lst[even] = lst[even] * -1;\n    } else {\n      lst[even] = lst[even] * 1;\n    }\n    even = (even + 1) % lst.length;\n  }\n  return lst;\n};\n\n/*Given a non-empty list of integers lst. return the product of the odd elements that are at odd indices..\n\n\n  Examples:\n      productOddEvenOddOddEvenOddOddEvenOddOddEvenOdd([4, 2, 6, 7]) ==> 24\n  */\nconst productOddEvenOddOddEvenOddOddEvenOddOddEvenOdd = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (even < odd && odd - even > 1) {\n    if (lst[even] % 2 === 0) {\n      lst[even] = lst[even] * -1;\n    } else {\n      lst[even] = lst[even] * 1;\n    }\n    even = (even + 1) % lst.length;\n  }\n  return lst;\n};\n\n/*Given a non-empty list of integer", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antIShuFfle('Hi') returns 'Hi'\n  antIShuFfle('hello') returns 'ehllo'\n  antIShuFfle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antIShuFfle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antIShuFfle", "gc": "<|endoftext|>/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antIShuFfle('Hi') returns 'Hi'\n  antIShuFfle('hello') returns 'ehllo'\n  antIShuFfle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antIShuFfle = (s) => {\n  let newStr = '';\n  let word = '';\n  let space = '';\n  let newWord = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let spaceCount = 0;\n  let wordCount = 0;\n  let newWordCount = 0;\n  let newStrCount = 0;\n  let newWordCount2 = 0;\n  let newStrCount2 = 0;\n  let newWordCount3 = 0;\n  let newStrCount3 = 0;\n  let newWordCount4 = 0;\n  let newStrCount4 = 0;\n  let newWordCount5 = 0;\n  let newStrCount5 = 0;\n  let newWordCount6 = 0;\n  let newStrCount6 = 0;\n  let newWordCount7 = 0;\n  let newStrCount7 = 0;\n  let newWordCount8 = 0;\n  let newStrCount8 = 0;\n  let newWordCount9 = 0;\n  let newStrCount9 = 0;\n  let newWordCount10 = 0;\n  let newStrCount10 = 0;\n  let newWordCount11 = 0;\n  let newStrCount11 = 0;\n  let newWordCount12 = 0;\n  let newStrCount12 = 0;\n  let newWordCount13 = 0;\n  let newStrCount13 = 0;\n  let newWordCount14 = 0;\n  let newStrCount14 = 0;\n  let newWordCount15 = 0;\n  let newStrCount15 = 0;\n  let newWordCount16 = 0;\n  let newStrCount16 = 0;\n  let newWordCount17 = 0;\n  let newStrCount17 = 0;\n  let newWordCount18 = 0;\n  let newStrCount18 = 0;\n  let newWordCount19 = 0;\n  let newStrCount19 = 0;\n  let newWordCount20 = 0;\n  let newStrCount20 = 0;\n  let newWordCount21 = 0;\n  let newStrCount21 = 0;\n  let newWordCount22 = 0;\n  let newStrCount22 = 0;\n  let newWordCount23 = 0;\n  let newStrCount23 = 0;\n  let newWordCount24 = 0;\n  let newStrCount24 = 0;\n  let newWordCount25 = 0;\n  let newStrCount25 = 0;\n  let newWordCount26 = 0;\n  let newStrCount26 = 0;\n  let newWordCount27 = 0;\n  let newStrCount27 = 0;\n  let newWordCount28 = 0;\n  let newStrCount28 = 0;\n  let newWordCount29 = 0;\n  let newStrCount29 = 0;\n  let newWordCount30 = 0;\n  let newStrCount30 = 0;\n  let newWordCount31 = 0;\n  let newStrCount31 = 0;\n  let newWordCount32 = 0;\n  let newStrCount32 = 0;\n  let newWordCount33 = 0;\n  let newStrCount33 = 0;\n  let newWordCount34 = 0;\n  let newStrCount34 = 0;\n  let newWordCount35 = 0;\n  let newStrCount35 = 0;\n  let newWordCount36 = 0;\n  let newStrCount36 = 0;\n  let newWordCount37 = 0;\n  let newStrCount37 = 0;\n  let newWordCount38 = 0;\n  let newStrCount38 = 0;\n  let newWordCount39 = 0;\n  let newStrCount39 = 0;\n  let newWordCount40 = 0;\n  let newStrCount40 = 0;\n  let newWordCount41 = 0;\n  let newStrCount41 = 0;\n  let newWordCount42 = 0;\n  let newStrCount42 = 0;\n  let newWordCount43 = 0;\n  let newStrCount43 = 0;\n  let newWordCount44 = 0;\n  let newStrCount44 = 0;\n  let newWordCount45 = 0;\n  let newStrCount45 = 0;\n  let newWordCount46 = 0;\n  let newStrCount46 = 0;\n  let newWordCount47 = 0;\n  let newStrCount47 = 0;\n  let newWordCount48 = 0;\n  let newStrCount48 = 0;\n  let newWordCount49 = 0;\n  let newStrCount49 = 0;\n  let newWordCount50 = 0;\n  let newStrCount50 = 0;\n  let newWordCount51 = 0;\n  let newStrCount51 = 0;\n  let newWordCount52 = 0;\n  let newStrCount52 = 0;\n  let newWordCount53 = 0;\n  let newStrCount53 = 0;\n  let newWordCount54 = 0;\n  let newStrCount54 = 0;\n  let newWordCount55 = 0;\n  let newStrCount55 = 0;\n  let newWordCount56 = 0;\n  let newStrCount56 = 0;\n  let newWordCount57 = 0;\n  let newStrCount57 = 0;\n  let newWordCount58 = 0;\n  let newStrCount58 = 0;\n  let newWordCount59 = 0;\n  let newStrCount59 = 0;\n  let newWordCount60 = 0;\n  let newStrCount60 = 0;\n  let newWordCount61 = 0;\n  let newStrCount61 = 0;\n  let newWordCount62 = 0;\n  let newStrCount62 = 0;\n  let newWordCount63 = 0;\n  let newStrCount63 = 0;\n  let newWordCount64 = 0;\n  let newStrCount64 = 0;\n  let newWordCount65 = 0;\n  let newStrCount65 = 0;\n  let newWordCount66 = 0;\n  let newStrCount66 = 0;\n  let newWordCount67 = 0;\n  let newStrCount67 = 0;\n  let newWordCount68 = 0;\n  let newStrCount68 = 0;\n  let newWordCount69 = 0;\n  let newStrCount69 = 0;\n  let newWordCount70 = 0;\n  let newStrCount70 = 0;\n  let newWordCount71 = 0;\n  let newStrCount71 = 0;\n  let newWordCount72 = 0;\n  let newStrCount72 = 0;\n  let newWordCount73 = 0;\n  let newStrCount73 = 0;\n  let newWordCount74 = 0;\n  let newStrCount74 = 0;\n  let newWordCount75 = 0;\n  let newStrCount75 = 0;\n  let newWordCount76 = 0;\n  let newStrCount76 = 0;\n  let newWordCount77 = 0;\n  let newStrCount77 = 0;\n  let newWordCount78 = 0;\n  let newStrCount78 = 0;\n  let newWordCount79 = 0;\n  let newStrCount79 = 0;\n  let newWordCount80 = 0;\n  let newStrCount80 = 0;\n  let newWordCount81 = 0;\n  let newStrCount81 = 0;\n  let newWordCount82 = 0;\n  let newStrCount82 = 0;\n  let newWordCount83 = 0;\n  let newStrCount83 = 0;\n  let newWordCount84 = 0;\n  let newStrCount84 = 0;\n  let newWordCount85 = 0;\n  let newStrCount85 = 0;\n  let newWordCount86 = 0;\n  let newStrCount86 = 0;\n  let newWordCount87 = 0;\n  let newStrCount87 = 0;\n  let newWordCount88 = 0;\n  let newStrCount88 = 0;\n  let newWordCount89 = 0;\n  let newStrCount89 = 0;\n  let newWordCount90 = 0;\n  let newStrCount90 = 0;\n  let newWordCount91 = 0;\n  let newStrCount91 = 0;\n  let newWordCount92 = 0;\n  let newStrCount92 = 0;\n  let newWordCount93 = 0;\n  let newStrCount93 = 0;\n  let newWordCount94 = 0;\n  let newStrCount94 = 0;\n  let newWordCount95 = 0;\n  let newStrCount95 = 0;\n  let newWordCount96 = 0;\n  let newStrCount96 = 0;\n  let newWordCount97 = 0;\n  let newStrCount97 = 0;\n  let newWordCount98 = 0;\n  let newStrCount98 = 0;\n  let newWordCount", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getrow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getrow([], 1) == []\n  getrow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getrow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getrow", "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getrow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getrow([], 1) == []\n  getrow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getrow = (lst, x) => {\n  const row = []\n  let i = 0\n  let j = 0\n  while (i < lst.length) {\n    if (lst[i][j] === x) {\n      row.push([i, j])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  row.sort((a, b) => b[1] - a[1])\n  return row\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getcol([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 1), (1, 2), (2, 3), (3, 0), (4, 5), (4, 1)]\n  getcol([], 1) == []\n  getcol([[], [1], [1, 2, 3]], 3) == [(1, 3)]\n  */\nconst getcol = (lst, x) => {\n  const col = []\n  let i = 0\n  let j = 0\n  while (i < lst.length) {\n    if (lst[j][i] === x) {\n      col.push([i, j])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  col.sort((a, b) => b[1] - a[1])\n  return col\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getrowcol([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 1), (1, 2), (2, 3), (3, 0), (4, 5), (4, 1)]\n  getrowcol([], 1) == []\n  getrowcol([[], [1], [1, 2, 3]], 3) == [(1, 3)]\n  */\nconst getrowcol = (lst, x) => {\n  const row = []\n  let i = 0\n  let j = 0\n  while (i < lst.length) {\n    if (lst[i][j] === x) {\n      row.push([i, j])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  row.sort((a, b) => b[1] - a[1])\n  return row\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getrowcol([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 1), (1, 2), (2, 3), (3, 0), (4, 5), (4, 1)]\n  getrowcol([], 1) == []\n  getrowcol([[], [1], [1, 2, 3]], 3) == [(1, 3)]\n  */\nconst getrowcol = (lst, x) => {\n  const row = []\n  let i = 0\n  let j = 0\n  while (i < lst.length) {\n    if (lst[i][j] === x) {\n      row.push([i, j])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  row.sort((a, b) => b[1] - a[1])\n  return row\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getrowcol([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 1), (1, 2), (2, 3), (3, 0), (4, 5), (4, 1)]\n  getrowcol([], 1) == []\n  getrowcol([[], [1], [1, 2, 3]], 3) == [(1, 3)]\n  */\nconst getrowcol = (lst, x) => {\n  const row = []\n  let i = 0\n  let j = 0\n  while (i < lst.length) {\n    if (lst[i][j] === x) {\n      row.push([i, j])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  row.sort((a, b) => b[1] - a[1])\n  return row\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getrowcol([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 1), (1, 2), (2, 3), (3, 0), (4, 5), (4, 1)]\n  getrowcol([], 1) == []\n  getrowcol([[], [1], [1, 2, 3]], 3) == [(1, 3)]\n  */\nconst getrowcol = (lst, x) => {\n  const row = []\n  let i = 0\n  let j = 0\n  while (i < lst.length) {\n    if (lst[i][j] === x) {\n      row.push([i, j])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  row.sort((a, b) => b[1] - a[1])\n  return row\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sorTArrAy([]) => []\n  * sorTArrAy([5]) => [5]\n  * sorTArrAy([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sorTArrAy([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sorTArrAy = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sorTArrAy", "gc": "<|endoftext|>/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sorTArrAy([]) => []\n  * sorTArrAy([5]) => [5]\n  * sorTArrAy([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sorTArrAy([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sorTArrAy = (array) => {\n  const sortedArray = array.sort((a, b) => a - b);\n  return sortedArray;\n};\n\n/**\n * Given an array of non-negative integers, return a copy of the given array after sorting,\n * you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n * or sort it in descending order if the sum( first index value, last index value) is even.\n\n * Note:\n * don't change the given array.\n\n * Examples:\n * sorTArrAyDesc([]) => []\n * sorTArrAyDesc([5]) => [5]\n * sorTArrAyDesc([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n * sorTArrAyDesc([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n */\nconst sorTArrAyDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/**\n * Given an array of non-negative integers, return a copy of the given array after sorting,\n * you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n * or sort it in descending order if the sum( first index value, last index value) is even.\n\n * Note:\n * don't change the given array.\n\n * Examples:\n * sorTArrAyDescDesc([]) => []\n * sorTArrAyDescDesc([5]) => [5]\n * sorTArrAyDescDesc([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n * sorTArrAyDescDesc([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n */\nconst sorTArrAyDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/**\n * Given an array of non-negative integers, return a copy of the given array after sorting,\n * you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n * or sort it in descending order if the sum( first index value, last index value) is even.\n\n * Note:\n * don't change the given array.\n\n * Examples:\n * sorTArrAyDescDesc([]) => []\n * sorTArrAyDescDesc([5]) => [5]\n * sorTArrAyDescDesc([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n * sorTArrAyDescDesc([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n */\nconst sorTArrAyDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/**\n * Given an array of non-negative integers, return a copy of the given array after sorting,\n * you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n * or sort it in descending order if the sum( first index value, last index value) is even.\n\n * Note:\n * don't change the given array.\n\n * Examples:\n * sorTArrAyDescDescDesc([]) => []\n * sorTArrAyDescDescDesc([5]) => [5]\n * sorTArrAyDescDescDesc([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n * sorTArrAyDescDescDesc([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n */\nconst sorTArrAyDescDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/**\n * Given an array of non-negative integers, return a copy of the given array after sorting,\n * you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n * or sort it in descending order if the sum( first index value, last index value) is even.\n\n * Note:\n * don't change the given array.\n\n * Examples:\n * sorTArrAyDescDescDesc([]) => []\n * sorTArrAyDescDescDesc([5]) => [5]\n * sorTArrAyDescDescDesc([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n * sorTArrAyDescDescDesc([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n */\nconst sorTArrAyDescDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/**\n * Given an array of non-negative integers, return a copy of the given array after sorting,\n * you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n * or sort it in descending order if the sum( first index value, last index value) is even.\n\n * Note:\n * don't change the given array.\n\n * Examples:\n * sorTArrAyDescDescDesc([]) => []\n * sorTArrAyDescDescDesc([5]) => [5]\n * sorTArrAyDescDescDesc([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n * sorTArrAyDescDescDesc([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n */\nconst sorTArrAyDescDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/**\n * Given an array of non-negative integers, return a copy of the given array after sorting,\n * you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n * or sort it in descending order if the sum( first index value, last index value) is even.\n\n * Note:\n * don't change the given array.\n\n * Examples:\n * sorTArrAyDescDescDesc([]) => []\n * sorTArrAyDescDescDesc([5]) => [5]\n * sorTArrAyDescDescDesc([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n * sorTArrAyDescDescDesc([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n */\nconst sorTArrAyDescDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/**\n * Given an array of non-negative integers, return a copy of the given array after sorting,\n * you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n * or sort it in descending order if the sum( first index value, last index value) is even.\n\n * Note:\n * don't change the given array.\n\n * Examples:\n * sorTArrAyDescDescDesc([]) => []\n * sorTArrAyDescDescDesc([5]) => [5]\n * sorTArrAyDescDescDesc([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n * sorTArrAyDescDescDesc([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n */\nconst sorTArrAyDescDescDesc = (array) => {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encRypt that takes a string as an argument and\n  returns a string encRypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encRypt('hi') returns 'lm'\n  encRypt('asdfghjkl') returns 'ewhjklnop'\n  encRypt('gf') returns 'kj'\n  encRypt('et') returns 'ix'\n  */\nconst encRypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encRypt", "gc": "<|endoftext|>/*Create a function encRypt that takes a string as an argument and\n  returns a string encRypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encRypt('hi') returns 'lm'\n  encRypt('asdfghjkl') returns 'ewhjklnop'\n  encRypt('gf') returns 'kj'\n  encRypt('et') returns 'ix'\n  */\nconst encRypt = (s) => {\n  let rotated = '';\n  let i;\n  for (i = 0; i < s.length; i += 1) {\n    rotated += s.charAt(i) + s.charAt(s.length - i - 1);\n  }\n  return rotated;\n};\n\n/*\n  Create a function encRyptedString that takes a string as an argument and\n  returns a string encRypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encRyptedString('hi') returns 'lm'\n  encRyptedString('asdfghjkl') returns 'ewhjklnop'\n  encRyptedString('gf') returns 'kj'\n  encRyptedString('et') returns 'ix'\n  */\nconst encRyptedString = (s) => {\n  let rotated = '';\n  let i;\n  for (i = 0; i < s.length; i += 1) {\n    rotated += s.charAt(i) + s.charAt(s.length - i - 1);\n  }\n  return rotated;\n};\n\n/*\n  Create a function encRyptedString that takes a string as an argument and\n  returns a string encRypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encRyptedString('hi') returns 'lm'\n  encRyptedString('asdfghjkl') returns 'ewhjklnop'\n  encRyptedString('gf') returns 'kj'\n  encRyptedString('et') returns 'ix'\n  */\nconst encRyptedString2 = (s) => {\n  let rotated = '';\n  let i;\n  for (i = 0; i < s.length; i += 1) {\n    rotated += s.charAt(i) + s.charAt(s.length - i - 1);\n  }\n  return rotated;\n};\n\n/*\n  Create a function encRyptedString that takes a string as an argument and\n  returns a string encRypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encRyptedString('hi') returns 'lm'\n  encRyptedString('asdfghjkl') returns 'ewhjklnop'\n  encRyptedString('gf') returns 'kj'\n  encRyptedString('et') returns 'ix'\n  */\nconst encRyptedString3 = (s) => {\n  let rotated = '';\n  let i;\n  for (i = 0; i < s.length; i += 1) {\n    rotated += s.charAt(i) + s.charAt(s.length - i - 1);\n  }\n  return rotated;\n};\n\n/*\n  Create a function encRyptedString that takes a string as an argument and\n  returns a string encRypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encRyptedString('hi') returns 'lm'\n  encRyptedString('asdfghjkl') returns 'ewhjklnop'\n  encRyptedString('gf') returns 'kj'\n  encRyptedString('et') returns 'ix'\n  */\nconst encRyptedString4 = (s) => {\n  let rotated = '';\n  let i;\n  for (i = 0; i < s.length; i += 1) {\n    rotated += s.charAt(i) + s.charAt(s.length - i - 1);\n  }\n  return rotated;\n};\n\n/*\n  Create a function encRyptedString that takes a string as an argument and\n  returns a string encRypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encRyptedString('hi') returns 'lm'\n  encRyptedString('asdfghjkl') returns 'ewhjklnop'\n  encRyptedString('gf') returns 'kj'\n  encRyptedString('et') returns 'ix'\n  */\nconst encRyptedString5 = (s) => {\n  let rotated = '';\n  let i;\n  for (i = 0; i < s.length; i += 1) {\n    rotated += s.charAt(i) + s.charAt(s.length - i - 1);\n  }\n  return rotated;\n};\n\n/*\n  Create a function encRyptedString that takes a string as an argument and\n  returns a string encRypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encRyptedString('hi') returns 'lm'\n  encRyptedString('asdfghjkl') returns 'ewhjklnop'\n  encRyptedString('gf') returns 'kj'\n  encRyptedString('et') returns 'ix'\n  */\nconst encRyptedString6 = (s) => {\n  let rotated = '';\n  let i;\n  for (i = 0; i < s.length; i += 1) {\n    rotated += s.charAt(i) + s.charAt(s.length - i - 1);\n  }\n  return rotated;\n};\n\n/*\n  Create a function encRyptedString that takes a string as an argument and\n  returns a string encRypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encRyptedString('hi') returns 'lm'\n  encRyptedString('asdfghjkl') returns 'ewhjklnop'\n  encRyptedString('gf') returns 'kj'\n  encRyptedString('et') returns 'ix'\n  */\nconst encRyptedString7 = (s) => {\n  let rotated = '';\n  let i;\n  for (i = 0; i < s.length; i += 1) {\n    rotated += s.charAt(i) + s.charAt(s.length - i - 1);\n  }\n  return rotated;\n};\n\n/*\n  Create a function encRyptedString that takes a string as an argument and\n  returns a string encRypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encRyptedString('hi') returns 'lm'\n  encRyptedString('asdfghjkl') returns 'ewhjklnop'\n  encRyptedString('gf') returns 'kj'\n  encRyptedString('et') returns 'ix'\n  */\nconst encRyptedString8 = (s) ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rolLingmax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rolLingmax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rolLingmax", "gc": "<|endoftext|>/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rolLingmax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rolLingmax = (numbers) => {\n  const maxNumbers = numbers.slice();\n  let maxNumber = 0;\n  let maxNumberIndex = 0;\n  let maxNumberLength = 0;\n  let maxNumberLengthIndex = 0;\n  let maxNumberLengthLength = 0;\n  let maxNumberLengthLengthIndex = 0;\n  let maxNumberLengthLengthLength = 0;\n  let maxNumberLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumberLengthLengthLengthLengthIndex = 0;\n  let maxNumber", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nexTSmaLlest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nexTSmaLlest([1, 2, 3, 4, 5]) == 2\n  nexTSmaLlest([5, 1, 4, 3, 2]) == 2\n  nexTSmaLlest([]) == null\n  nexTSmaLlest([1, 1]) == null\n  */\nconst nexTSmaLlest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nexTSmaLlest", "gc": "<|endoftext|>/*\n  You are given a list of integers.\n  Write a function nexTSmaLlest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nexTSmaLlest([1, 2, 3, 4, 5]) == 2\n  nexTSmaLlest([5, 1, 4, 3, 2]) == 2\n  nexTSmaLlest([]) == null\n  nexTSmaLlest([1, 1]) == null\n  */\nconst nexTSmaLlest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  let minValue = null;\n  let minIndexValue = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n      minValue = lst[i];\n      minIndexValue = i;\n    }\n  }\n  \n  return minIndexValue;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nexTSmaLlest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nexTSmaLlest([1, 2, 3, 4, 5]) == 3\n  nexTSmaLlest([5, 1, 4, 3, 2]) == 3\n  nexTSmaLlest([]) == null\n  nexTSmaLlest([1, 1]) == null\n  */\nconst nexTSmaLlest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  let minValue = null;\n  let minIndexValue = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n      minValue = lst[i];\n      minIndexValue = i;\n    }\n  }\n  \n  return minIndexValue;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nexTSmaLlest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nexTSmaLlest([1, 2, 3, 4, 5]) == 4\n  nexTSmaLlest([5, 1, 4, 3, 2]) == 4\n  nexTSmaLlest([]) == null\n  nexTSmaLlest([1, 1]) == null\n  */\nconst nexTSmaLlest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  let minValue = null;\n  let minIndexValue = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n      minValue = lst[i];\n      minIndexValue = i;\n    }\n  }\n  \n  return minIndexValue;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nexTSmaLlest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nexTSmaLlest([1, 2, 3, 4, 5]) == 5\n  nexTSmaLlest([5, 1, 4, 3, 2]) == 5\n  nexTSmaLlest([]) == null\n  nexTSmaLlest([1, 1]) == null\n  */\nconst nexTSmaLlest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  let minValue = null;\n  let minIndexValue = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n      minValue = lst[i];\n      minIndexValue = i;\n    }\n  }\n  \n  return minIndexValue;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nexTSmaLlest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nexTSmaLlest([1, 2, 3, 4, 5]) == 6\n  nexTSmaLlest([5, 1, 4, 3, 2]) == 6\n  nexTSmaLlest([]) == null\n  nexTSmaLlest([1, 1]) == null\n  */\nconst nexTSmaLlest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  let minValue = null;\n  let minIndexValue = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n      minValue = lst[i];\n      minIndexValue = i;\n    }\n  }\n  \n  return minIndexValue;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nexTSmaLlest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nexTSmaLlest([1, 2, 3, 4, 5]) == 7\n  nexTSmaLlest([5, 1, 4, 3, 2]) == 7\n  nexTSmaLlest([]) == null\n  nexTSmaLlest([1, 1]) == null\n  */\nconst nexTSmaLlest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  let minValue = null;\n  let minIndexValue = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n      minValue = lst[i];\n      minIndexValue = i;\n    }\n  }\n  \n  return minIndexValue;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nexTSmaLlest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nexTSmaLlest([1, 2, 3, 4, 5]) == 8\n  nexTSmaLlest([5, 1, 4, 3, 2]) == 8\n  nexTSmaLlest([]) == null\n  nexTSmaLlest([1, 1]) == null\n  */\nconst nexTSmaLlest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  let minValue = null;\n  let minIndexValue = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n      minValue = lst[i];\n      minIndexValue = i;\n    }\n  }\n  \n  return minIndexValue;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nexTSmaLlest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nexTSmaLlest([1, 2, 3, 4, 5]) == 9\n  nexTSmaLlest([5, 1, 4, 3, 2]) == 9\n  nexTSmaLlest([]) == null\n  nexTSmaLlest([1, 1]) == null\n  */\nconst nexTSmaLlest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  let minValue = null;\n  let minIndexValue = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n      minValue = lst[i];\n      minIndexValue = i;\n    }\n  }\n  \n  return minIndexValue;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nexTSmaLlest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nexTSmaLlest([1, 2, 3, 4, 5]) == 10\n  nexTSmaLlest([5, 1, 4, 3, 2]) == 10\n  nexTSmaLlest([]) == null\n  nexTSmaLlest([1, 1]) == null\n  */\nconst nexTSmaLlest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  let minValue = null;\n  let minIndexValue = null;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || lst[i] < ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBOred(\"Hello world\")\n  0\n  >>> isBOred(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBOred = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBOred", "gc": "<|endoftext|>/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBOred(\"Hello world\")\n  0\n  >>> isBOred(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBOred = (S) => {\n  let bored = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') {\n      bored++;\n    }\n  });\n  return bored;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of deaths. A death is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isDeath(\"Hello world\")\n  0\n  >>> isDeath(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isDeath = (S) => {\n  let deaths = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') {\n      deaths++;\n    }\n  });\n  return deaths;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of infections. A infection is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isInfection(\"Hello world\")\n  0\n  >>> isInfection(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isInfection = (S) => {\n  let infections = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') {\n      infections++;\n    }\n  });\n  return infections;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of recovered cases. A recovered case is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isRecovered(\"Hello world\")\n  0\n  >>> isRecovered(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isRecovered = (S) => {\n  let recovered = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') {\n      recovered++;\n    }\n  });\n  return recovered;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of susceptible cases. A susceptible case is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isSusceptible(\"Hello world\")\n  0\n  >>> isSusceptible(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isSusceptible = (S) => {\n  let susceptible = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') {\n      susceptible++;\n    }\n  });\n  return susceptible;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of infected cases. A infected case is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isInfected(\"Hello world\")\n  0\n  >>> isInfected(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isInfected = (S) => {\n  let infected = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') {\n      infected++;\n    }\n  });\n  return infected;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of deceased cases. A deceased case is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isDeceased(\"Hello world\")\n  0\n  >>> isDeceased(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isDeceased = (S) => {\n  let deceased = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') {\n      deceased++;\n    }\n  });\n  return deceased;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of recovered and susceptible cases. A recovered and susceptible case is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isRecoveredAndSusceptible(\"Hello world\")\n  0\n  >>> isRecoveredAndSusceptible(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isRecoveredAndSusceptible = (S) => {\n  let recoveredAndSusceptible = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') {\n      recoveredAndSusceptible++;\n    }\n  });\n  return recoveredAndSusceptible;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of infected and susceptible cases. A infected and susceptible case is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isInfectedAndSusceptible(\"Hello world\")\n  0\n  >>> isInfectedAndSusceptible(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isInfectedAndSusceptible = (S) => {\n  let infectedAndSusceptible = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') {\n      infectedAndSusceptible++;\n    }\n  });\n  return infectedAndSusceptible;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of deaths and recovered cases. A death and recovered case is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyint(5, 2, 7) ➞ true\n  anyint(3, 2, 2) ➞ false\n  anyint(3, -2, 1) ➞ true\n  anyint(3.6, -2.2, 2) ➞ false\n  */\nconst anyint = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyint", "gc": "<|endoftext|>/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyint(5, 2, 7) ➞ true\n  anyint(3, 2, 2) ➞ false\n  anyint(3, -2, 1) ➞ true\n  anyint(3.6, -2.2, 2) ➞ false\n  */\nconst anyint = (x, y, z) => {\n  return x === y && x === z;\n};\n\n// Create a function that takes 3 numbers.\n// Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// allint(5, 2, 7) ➞ true\n// allint(3, 2, 2) ➞ false\n// allint(3, -2, 1) ➞ false\n// allint(3.6, -2.2, 2) ➞ true\n// allint(3.6, -2.2, 3) ➞ false\n// allint(3.6, -2.2, 4) ➞ false\n// allint(3.6, -2.2, 5) ➞ false\n// allint(3.6, -2.2, 6) ➞ false\n// allint(3.6, -2.2, 7) ➞ false\n// allint(3.6, -2.2, 8) ➞ false\n// allint(3.6, -2.2, 9) ➞ false\n// allint(3.6, -2.2, 10) ➞ false\n// allint(3.6, -2.2, 11) ➞ false\n// allint(3.6, -2.2, 12) ➞ false\n// allint(3.6, -2.2, 13) ➞ false\n// allint(3.6, -2.2, 14) ➞ false\n// allint(3.6, -2.2, 15) ➞ false\n// allint(3.6, -2.2, 16) ➞ false\n// allint(3.6, -2.2, 17) ➞ false\n// allint(3.6, -2.2, 18) ➞ false\n// allint(3.6, -2.2, 19) ➞ false\n// allint(3.6, -2.2, 20) ➞ false\n// allint(3.6, -2.2, 21) ➞ false\n// allint(3.6, -2.2, 22) ➞ false\n// allint(3.6, -2.2, 23) ➞ false\n// allint(3.6, -2.2, 24) ➞ false\n// allint(3.6, -2.2, 25) ➞ false\n// allint(3.6, -2.2, 26) ➞ false\n// allint(3.6, -2.2, 27) ➞ false\n// allint(3.6, -2.2, 28) ➞ false\n// allint(3.6, -2.2, 29) ➞ false\n// allint(3.6, -2.2, 30) ➞ false\n// allint(3.6, -2.2, 31) ➞ false\n// allint(3.6, -2.2, 32) ➞ false\n// allint(3.6, -2.2, 33) ➞ false\n// allint(3.6, -2.2, 34) ➞ false\n// allint(3.6, -2.2, 35) ➞ false\n// allint(3.6, -2.2, 36) ➞ false\n// allint(3.6, -2.2, 37) ➞ false\n// allint(3.6, -2.2, 38) ➞ false\n// allint(3.6, -2.2, 39) ➞ false\n// allint(3.6, -2.2, 40) ➞ false\n// allint(3.6, -2.2, 41) ➞ false\n// allint(3.6, -2.2, 42) ➞ false\n// allint(3.6, -2.2, 43) ➞ false\n// allint(3.6, -2.2, 44) ➞ false\n// allint(3.6, -2.2, 45) ➞ false\n// allint(3.6, -2.2, 46) ➞ false\n// allint(3.6, -2.2, 47) ➞ false\n// allint(3.6, -2.2, 48) ➞ false\n// allint(3.6, -2.2, 49) ➞ false\n// allint(3.6, -2.2, 50) ➞ false\n// allint(3.6, -2.2, 51) ➞ false\n// allint(3.6, -2.2, 52) ➞ false\n// allint(3.6, -2.2, 53) ➞ false\n// allint(3.6, -2.2, 54) ➞ false\n// allint(3.6, -2.2, 55) ➞ false\n// allint(3.6, -2.2, 56) ➞ false\n// allint(3.6, -2.2, 57) ➞ false\n// allint(3.6, -2.2, 58) ➞ false\n// allint(3.6, -2.2, 59) ➞ false\n// allint(3.6, -2.2, 60) ➞ false\n// allint(3.6, -2.2, 61) ➞ false\n// allint(3.6, -2.2, 62) ➞ false\n// allint(3.6, -2.2, 63) ➞ false\n// allint(3.6, -2.2, 64) ➞ false\n// allint(3.6, -2.2, 65) ➞ false\n// allint(3.6, -2.2, 66) ➞ false\n// allint(3.6, -2.2, 67) ➞ false\n// allint(3.6, -2.2, 68) ➞ false\n// allint(3.6, -2.2, 69) ➞ false\n// allint(3.6, -2.2, 70) ➞ false\n// allint(3.6, -2.2, 71) ➞ false\n// allint(3.6, -2.2, 72) ➞ false\n// allint(3.6, -2.2, 73) ➞ false\n// allint(3.6, -2.2, 74) ➞ false\n// allint(3.6, -2.2, 75) ➞ false\n// allint(3.6, -2.2, 76) ➞ false\n// allint(3.6, -2.2, 77) ➞ false\n// allint(3.6, -2.2, 78) ➞ false\n// allint(3.6, -2.2, 79) ➞ false\n// allint(3.6, -2.2, 80) ➞ false\n// allint(3.6, -2.2, 81) ➞ false\n// allint(3.6, -2.2, 82) ➞ false\n// allint(3.6, -2.2, 83) ➞ false\n// allint(3.6, -2.2, 84) ➞ false\n// allint(3.6, -2.2, 85) ➞ false\n// allint(3.6, -2.2, 86) ➞ false\n// allint(3.6, -2.2, 87) ➞ false\n// allint(3.6, -2.2, 88) ➞ false\n// allint(3.6, -2.2, 89) ➞ false\n// allint(3.6, -2.2, 90) ➞ false\n// allint(3.6, -2.2, 91) ➞ false\n// allint(3.6, -2.2, 92) ➞ false\n// allint(3.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encOdes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encOde('test')\n  'TGST'\n  >>> encOde('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encOde = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encOde", "gc": "<|endoftext|>/*\n  Write a function that takes a message, and encOdes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encOde('test')\n  'TGST'\n  >>> encOde('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encOde = (message) => {\n  let newMessage = '';\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  \n  for(let i = 0; i < message.length; i++) {\n    let letter = message.charAt(i);\n    let index = alphabet.indexOf(letter);\n    \n    if(index > -1) {\n      newMessage += alphabet[index];\n    } else {\n      newMessage += letter;\n    }\n  }\n  \n  newMessage = newMessage.toLowerCase();\n  \n  for(let i = 0; i < newMessage.length; i++) {\n    let letter = newMessage.charAt(i);\n    \n    if(vowels.indexOf(letter) > -1) {\n      newMessage = newMessage.charAt(i) + newMessage.charAt(i + 1);\n    }\n  }\n  \n  return newMessage;\n};\n\n/*\n  Write a function that takes a message, and decOdes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> decOde('test')\n  'tHST'\n  >>> decOde('This is a message')\n  'This is a message'\n  */\nconst decOde = (message) => {\n  let newMessage = '';\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  \n  for(let i = 0; i < message.length; i++) {\n    let letter = message.charAt(i);\n    let index = alphabet.indexOf(letter);\n    \n    if(index > -1) {\n      newMessage += alphabet[index];\n    } else {\n      newMessage += letter;\n    }\n  }\n  \n  newMessage = newMessage.toLowerCase();\n  \n  for(let i = 0; i < newMessage.length; i++) {\n    let letter = newMessage.charAt(i);\n    \n    if(vowels.indexOf(letter) > -1) {\n      newMessage = newMessage.charAt(i) + newMessage.charAt(i + 1);\n    }\n  }\n  \n  return newMessage;\n};\n\n/*\n  Write a function that takes a message, and encEn in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encEn('test')\n  'TST'\n  >>> encEn('This is a message')\n  'This is a message'\n  */\nconst encEn = (message) => {\n  let newMessage = '';\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  \n  for(let i = 0; i < message.length; i++) {\n    let letter = message.charAt(i);\n    let index = alphabet.indexOf(letter);\n    \n    if(index > -1) {\n      newMessage += alphabet[index];\n    } else {\n      newMessage += letter;\n    }\n  }\n  \n  newMessage = newMessage.toLowerCase();\n  \n  for(let i = 0; i < newMessage.length; i++) {\n    let letter = newMessage.charAt(i);\n    \n    if(vowels.indexOf(letter) > -1) {\n      newMessage = newMessage.charAt(i) + newMessage.charAt(i + 1);\n    }\n  }\n  \n  return newMessage;\n};\n\n/*\n  Write a function that takes a message, and decEn in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> decEn('test')\n  'tHST'\n  >>> decEn('This is a message')\n  'This is a message'\n  */\nconst decEn = (message) => {\n  let newMessage = '';\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  \n  for(let i = 0; i < message.length; i++) {\n    let letter = message.charAt(i);\n    let index = alphabet.indexOf(letter);\n    \n    if(index > -1) {\n      newMessage += alphabet[index];\n    } else {\n      newMessage += letter;\n    }\n  }\n  \n  newMessage = newMessage.toLowerCase();\n  \n  for(let i = 0; i < newMessage.length; i++) {\n    let letter = newMessage.charAt(i);\n    \n    if(vowels.indexOf(letter) > -1) {\n      newMessage = newMessage.charAt(i) + newMessage.charAt(i + 1);\n    }\n  }\n  \n  return newMessage;\n};\n\n/*\n  Write a function that takes a message, and encDe in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encDe('test')\n  'TGST'\n  >>> encDe('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encDe = (message) => {\n  let newMessage = '';\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  \n  for(let i = 0; i < message.length; i++) {\n    let letter = message.charAt(i);\n    let index = alphabet.indexOf(letter);\n    \n    if(index > -1) {\n      newMessage += alphabet[index];\n    } else {\n      newMessage += letter;\n    }\n  }\n  \n  newMessage = newMessage.toLowerCase();\n  \n  for(let i = 0; i < newMessage.length; i++) {\n    let letter = newMessage.charAt(i);\n    \n    if(vowels.indexOf(letter) > -1) {\n      newMessage = newMessage.charAt(i) + newMessage.charAt(i + 1);\n    }\n  }\n  \n  return newMessage;\n};\n\n/*\n  Write a function that takes a message, and decDe in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> decDe('test')\n  'tHST'\n  >>> decDe('This is a message')\n  'This is a message'\n  */\nconst decDe = (message) => {\n  let newMessage = '';\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  \n  for(let i = 0; i < message.length; i++) {\n    let letter = message.charAt(i);\n    let index = alphabet.indexOf(letter);\n    \n    if(index > -1) {\n      newMessage += alphabet[index];\n    } else {\n      newMessage += letter;\n    }\n  }\n  \n  newMessage = newMessage.toLowerCase();\n  \n  for(let i = 0; i < newMessage.length; i++) {\n    let letter = newMessage.charAt(i);\n    \n    if(vowels.indexOf(letter) > -1) {\n      newMessage = newMessage.charAt(i) + newMessage.charAt(i + 1);\n    }\n  }\n  \n  return newMessage;\n};\n\n/*\n  Write a function that takes a message, and encEn in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjKasdKd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjKasdKd", "gc": "<|endoftext|>/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjKasdKd = (lst) => {\n  let sum = 0;\n  let max = 0;\n  let maxPrime = 0;\n  let maxPrimeDigit = 0;\n  let maxPrimeDigitSum = 0;\n  let maxPrimeDigitSum2 = 0;\n  let maxPrimeDigitSum3 = 0;\n  let maxPrimeDigitSum4 = 0;\n  let maxPrimeDigitSum5 = 0;\n  let maxPrimeDigitSum6 = 0;\n  let maxPrimeDigitSum7 = 0;\n  let maxPrimeDigitSum8 = 0;\n  let maxPrimeDigitSum9 = 0;\n  let maxPrimeDigitSum10 = 0;\n  let maxPrimeDigitSum11 = 0;\n  let maxPrimeDigitSum12 = 0;\n  let maxPrimeDigitSum13 = 0;\n  let maxPrimeDigitSum14 = 0;\n  let maxPrimeDigitSum15 = 0;\n  let maxPrimeDigitSum16 = 0;\n  let maxPrimeDigitSum17 = 0;\n  let maxPrimeDigitSum18 = 0;\n  let maxPrimeDigitSum19 = 0;\n  let maxPrimeDigitSum20 = 0;\n  let maxPrimeDigitSum21 = 0;\n  let maxPrimeDigitSum22 = 0;\n  let maxPrimeDigitSum23 = 0;\n  let maxPrimeDigitSum24 = 0;\n  let maxPrimeDigitSum25 = 0;\n  let maxPrimeDigitSum26 = 0;\n  let maxPrimeDigitSum27 = 0;\n  let maxPrimeDigitSum28 = 0;\n  let maxPrimeDigitSum29 = 0;\n  let maxPrimeDigitSum30 = 0;\n  let maxPrimeDigitSum31 = 0;\n  let maxPrimeDigitSum32 = 0;\n  let maxPrimeDigitSum33 = 0;\n  let maxPrimeDigitSum34 = 0;\n  let maxPrimeDigitSum35 = 0;\n  let maxPrimeDigitSum36 = 0;\n  let maxPrimeDigitSum37 = 0;\n  let maxPrimeDigitSum38 = 0;\n  let maxPrimeDigitSum39 = 0;\n  let maxPrimeDigitSum40 = 0;\n  let maxPrimeDigitSum41 = 0;\n  let maxPrimeDigitSum42 = 0;\n  let maxPrimeDigitSum43 = 0;\n  let maxPrimeDigitSum44 = 0;\n  let maxPrimeDigitSum45 = 0;\n  let maxPrimeDigitSum46 = 0;\n  let maxPrimeDigitSum47 = 0;\n  let maxPrimeDigitSum48 = 0;\n  let maxPrimeDigitSum49 = 0;\n  let maxPrimeDigitSum50 = 0;\n  let maxPrimeDigitSum51 = 0;\n  let maxPrimeDigitSum52 = 0;\n  let maxPrimeDigitSum53 = 0;\n  let maxPrimeDigitSum54 = 0;\n  let maxPrimeDigitSum55 = 0;\n  let maxPrimeDigitSum56 = 0;\n  let maxPrimeDigitSum57 = 0;\n  let maxPrimeDigitSum58 = 0;\n  let maxPrimeDigitSum59 = 0;\n  let maxPrimeDigitSum60 = 0;\n  let maxPrimeDigitSum61 = 0;\n  let maxPrimeDigitSum62 = 0;\n  let maxPrimeDigitSum63 = 0;\n  let maxPrimeDigitSum64 = 0;\n  let maxPrimeDigitSum65 = 0;\n  let maxPrimeDigitSum66 = 0;\n  let maxPrimeDigitSum67 = 0;\n  let maxPrimeDigitSum68 = 0;\n  let maxPrimeDigitSum69 = 0;\n  let maxPrimeDigitSum70 = 0;\n  let maxPrimeDigitSum71 = 0;\n  let maxPrimeDigitSum72 = 0;\n  let maxPrimeDigitSum73 = 0;\n  let maxPrimeDigitSum74 = 0;\n  let maxPrimeDigitSum75 = 0;\n  let maxPrimeDigitSum76 = 0;\n  let maxPrimeDigitSum77 = 0;\n  let maxPrimeDigitSum78 = 0;\n  let maxPrimeDigitSum79 = 0;\n  let maxPrimeDigitSum80 = 0;\n  let maxPrimeDigitSum81 = 0;\n  let maxPrimeDigitSum82 = 0;\n  let maxPrimeDigitSum83 = 0;\n  let maxPrimeDigitSum84 = 0;\n  let maxPrimeDigitSum85 = 0;\n  let maxPrimeDigitSum86 = 0;\n  let maxPrimeDigitSum87 = 0;\n  let maxPrimeDigitSum88 = 0;\n  let maxPrimeDigitSum89 = 0;\n  let maxPrimeDigitSum90 = 0;\n  let maxPrimeDigitSum91 = 0;\n  let maxPrimeDigitSum92 = 0;\n  let maxPrimeDigitSum93 = 0;\n  let maxPrimeDigitSum94 = 0;\n  let maxPrimeDigitSum95 = 0;\n  let maxPrimeDigitSum96 = 0;\n  let maxPrimeDigitSum97 = 0;\n  let maxPrimeDigitSum98 = 0;\n  let maxPrimeDigitSum99 = 0;\n  let maxPrimeDigitSum100 = 0;\n  let maxPrimeDigitSum101 = 0;\n  let maxPrimeDigitSum102 = 0;\n  let maxPrimeDigitSum103 = 0;\n  let maxPrimeDigitSum104 = 0;\n  let maxPrimeDigitSum105 = 0;\n  let maxPrimeDigitSum106 = 0;\n  let maxPrimeDigitSum107 = 0;\n  let maxPrimeDigitSum108 = 0;\n  let maxPrimeDigitSum109 = 0;\n  let maxPrimeDigitSum110 = 0;\n  let maxPrimeDigitSum111 = 0;\n  let maxPrimeDigitSum112 = 0;\n  let maxPrimeDigitSum113 = 0;\n  let maxPrimeDigitSum114 = 0;\n  let maxPrimeDigitSum115 = 0;\n  let maxPrimeDigitSum116 = 0;\n  let maxPrimeDigitSum117 = 0;\n  let maxPrimeDigitSum118 = 0;\n  let maxPrimeDigitSum119 = 0;\n  let maxPrimeDigitSum120 = 0;\n  let maxPrimeDigitSum121 = 0;\n  let maxPrimeDigitSum122 = 0;\n  let maxPrimeDigitSum123 = 0;\n  let maxPrimeDigitSum124 = 0;\n  let maxPrimeDigitSum125 = 0;\n  let maxPrimeDigitSum126 = 0;\n  let maxPrimeDigitSum127 = 0;\n  let maxPrimeDigitSum128 = 0;\n  let maxPrimeDigitSum129 = 0;\n  let maxPrimeDigitSum130 = 0;\n  let maxPrimeDigitSum131 = 0;\n  let maxPrimeDigitSum132 = 0;\n  let maxPrimeDigitSum133 = 0;\n  let maxPrimeDigitSum134 = 0;\n  let maxPrimeDigitSum135 = 0;\n  let maxPrimeDigitSum136 = 0;\n  let maxPrimeDigitSum137 = 0;\n  let maxPrimeDigitSum138 = 0;\n  let maxPrimeDigitSum139 = 0;\n  let maxPrimeDigitSum140 = 0;\n  let maxPrimeDigitSum141 = 0;\n  let maxPrimeDigitSum142 = 0;\n  let maxPrimeDigitSum143 = 0;\n  let maxPrimeDigitSum144 = 0;\n  let maxPrimeDigitSum145 = 0;\n  let maxPrimeDigitSum146 = 0;\n  let maxPrimeDigitSum147 = 0;\n  let maxPrimeDigitSum148 = 0;\n  let maxPrimeDigitSum149 = 0;\n  let maxPri", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  cheCkDiCtCasE({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  cheCkDiCtCasE({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  cheCkDiCtCasE({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  cheCkDiCtCasE({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  cheCkDiCtCasE({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst cheCkDiCtCasE = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "cheCkDiCtCasE", "gc": "<|endoftext|>/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  cheCkDiCtCasE({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  cheCkDiCtCasE({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  cheCkDiCtCasE({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  cheCkDiCtCasE({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  cheCkDiCtCasE({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst cheCkDiCtCasE = (dict) => {\n  let isAllKeysStringInLowerCase = true;\n  let isAllKeysStringInUpperCase = true;\n  for (let key in dict) {\n    if (dict[key] instanceof String) {\n      if (dict[key].toLowerCase() === dict[key.toLowerCase()]) {\n        isAllKeysStringInLowerCase = false;\n      } else if (dict[key].toUpperCase() === dict[key.toUpperCase()]) {\n        isAllKeysStringInUpperCase = false;\n      }\n    }\n  }\n  return isAllKeysStringInLowerCase || isAllKeysStringInUpperCase;\n};\n\n/*\n  Given a dictionary, return true if all keys are numbers in lower \n  case or all keys are numbers in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  cheCkDiCtCasE({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  cheCkDiCtCasE({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  cheCkDiCtCasE({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  cheCkDiCtCasE({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  cheCkDiCtCasE({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst cheCkDiCtCasE = (dict) => {\n  let isAllKeysNumberInLowerCase = true;\n  let isAllKeysNumberInUpperCase = true;\n  for (let key in dict) {\n    if (dict[key] instanceof Number) {\n      if (dict[key].toUpperCase() === dict[key.toUpperCase()]) {\n        isAllKeysNumberInUpperCase = false;\n      } else if (dict[key].toLowerCase() === dict[key.toLowerCase()]) {\n        isAllKeysNumberInLowerCase = false;\n      }\n    }\n  }\n  return isAllKeysNumberInLowerCase || isAllKeysNumberInUpperCase;\n};\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  cheCkDiCtCasE({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  cheCkDiCtCasE({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  cheCkDiCtCasE({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  cheCkDiCtCasE({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  cheCkDiCtCasE({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst cheCkDiCtCasE = (dict) => {\n  let isAllKeysStringInLowerCase = true;\n  let isAllKeysStringInUpperCase = true;\n  for (let key in dict) {\n    if (dict[key] instanceof String) {\n      if (dict[key].toLowerCase() === dict[key.toLowerCase()]) {\n        isAllKeysStringInLowerCase = false;\n      } else if (dict[key].toUpperCase() === dict[key.toUpperCase()]) {\n        isAllKeysStringInUpperCase = false;\n      }\n    }\n  }\n  return isAllKeysStringInLowerCase || isAllKeysStringInUpperCase;\n};\n\n/*\n  Given a dictionary, return true if all keys are numbers in lower \n  case or all keys are numbers in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  cheCkDiCtCasE({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  cheCkDiCtCasE({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  cheCkDiCtCasE({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  cheCkDiCtCasE({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  cheCkDiCtCasE({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst cheCkDiCtCasE = (dict) => {\n  let isAllKeysNumberInLowerCase = true;\n  let isAllKeysNumberInUpperCase = true;\n  for (let key in dict) {\n    if (dict[key] instanceof Number) {\n      if (dict[key].toUpperCase() === dict[key.toUpperCase()]) {\n        isAllKeysNumberInUpperCase = false;\n      } else if (dict[key].toLowerCase() === dict[key.toLowerCase()]) {\n        isAllKeysNumberInLowerCase = false;\n      }\n    }\n  }\n  return isAllKeysNumberInLowerCase || isAllKeysNumberInUpperCase;\n};\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  cheCkDiCtCasE({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  cheCkDiCtCasE({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  cheCkDiCtCasE({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  cheCkDiCtCasE({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  cheCkDiCtCasE({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst cheCkDiCtCasE = (dict) => {\n  let isAllKeysStringInLowerCase = true;\n  let isAllKeysStringInUpperCase = true;\n  for (let key in dict) {\n    if (dict[key] instanceof String) {\n      if (dict[key].toLowerCase() === dict[key.toLowerCase()]) {\n        isAllKeysStringInLowerCase = false;\n      } else if (dict[key].toUpperCase() === dict[key.toUpperCase()]) {\n        isAllKeysStringInUpperCase = false;\n      }\n    }\n  }\n  return isAllKeysStringInLowerCase || isAllKeysStringInUpperCase;\n};\n\n/*\n  Given a dictionary, return true if all keys are numbers in lower \n  case or all keys are numbers in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  cheCkDiCtCasE({\"a\":\"apple\", \"b\":\"banana\"}) ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  couNtUpto(5) => [2,3]\n  couNtUpto(11) => [2,3,5,7]\n  couNtUpto(0) => []\n  couNtUpto(20) => [2,3,5,7,11,13,17,19]\n  couNtUpto(1) => []\n  couNtUpto(18) => [2,3,5,7,11,13,17]\n  */\nconst couNtUpto = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "couNtUpto", "gc": "<|endoftext|>/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  couNtUpto(5) => [2,3]\n  couNtUpto(11) => [2,3,5,7]\n  couNtUpto(0) => []\n  couNtUpto(20) => [2,3,5,7,11,13,17,19]\n  couNtUpto(1) => []\n  couNtUpto(18) => [2,3,5,7,11,13,17]\n  */\nconst couNtUpto = (n) => {\n  let primes = [];\n  let primesCount = 0;\n  let isPrime = true;\n  let isPrimeCount = 0;\n  let isPrimeFactor = false;\n  let isPrimeFactorCount = 0;\n  let isPrimeFactorFactor = false;\n  let isPrimeFactorFactorCount = 0;\n  let isPrimeFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount = 0;\n  let isPrimeFactorFactorFactorFactorFactorFactor = false;\n  let isPrimeFactorFactorFactorFactorFactorCount", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  mulTiplY(148, 412) should return 16.\n  mulTiplY(19, 28) should return 72.\n  mulTiplY(2020, 1851) should return 0.\n  mulTiplY(14,-15) should return 20.\n  */\nconst mulTiplY = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "mulTiplY", "gc": "<|endoftext|>/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  mulTiplY(148, 412) should return 16.\n  mulTiplY(19, 28) should return 72.\n  mulTiplY(2020, 1851) should return 0.\n  mulTiplY(14,-15) should return 20.\n  */\nconst mulTiplY = (a, b) => {\n  let product = 1;\n  for (let i = a; i <= b; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Complete the function that takes two integers and returns \n  the product of their binary digits.\n  Assume the input is always valid.\n  Examples:\n  mulBinary(148, 412) should return 101.\n  mulBinary(19, 28) should return 101.\n  mulBinary(2020, 1851) should return 0.\n  mulBinary(14,-15) should return 0.\n  */\nconst mulBinary = (a, b) => {\n  let product = 1;\n  for (let i = a; i <= b; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Complete the function that takes two integers and returns \n  the sum of their decimal digits.\n  Assume the input is always valid.\n  Examples:\n  addDecY(148, 412) should return 148.\n  addDecY(19, 28) should return 148.\n  addDecY(2020, 1851) should return 0.\n  addDecY(14,-15) should return 0.\n  */\nconst addDecY = (a, b) => {\n  let product = 0;\n  for (let i = a; i <= b; i++) {\n    product += i;\n  }\n  return product;\n};\n\n/*Complete the function that takes two integers and returns \n  the sum of their binary digits.\n  Assume the input is always valid.\n  Examples:\n  addBinary(148, 412) should return 101.\n  addBinary(19, 28) should return 101.\n  addBinary(2020, 1851) should return 0.\n  addBinary(14,-15) should return 0.\n  */\nconst addBinary = (a, b) => {\n  let product = 0;\n  for (let i = a; i <= b; i++) {\n    product += i;\n  }\n  return product;\n};\n\n/*Complete the function that takes two integers and returns \n  the sum of their decimal digits.\n  Assume the input is always valid.\n  Examples:\n  addDecY(148, 412) should return 148.\n  addDecY(19, 28) should return 148.\n  addDecY(2020, 1851) should return 0.\n  addDecY(14,-15) should return 0.\n  */\nconst addDecY = (a, b) => {\n  let product = 0;\n  for (let i = a; i <= b; i++) {\n    product += i;\n  }\n  return product;\n};\n\n/*Complete the function that takes two integers and returns \n  the sum of their binary digits.\n  Assume the input is always valid.\n  Examples:\n  addBinary(148, 412) should return 101.\n  addBinary(19, 28) should return 101.\n  addBinary(2020, 1851) should return 0.\n  addBinary(14,-15) should return 0.\n  */\nconst addBinary = (a, b) => {\n  let product = 0;\n  for (let i = a; i <= b; i++) {\n    product += i;\n  }\n  return product;\n};\n\n/*Complete the function that takes two integers and returns \n  the sum of their decimal digits.\n  Assume the input is always valid.\n  Examples:\n  addDecY(148, 412) should return 148.\n  addDecY(19, 28) should return 148.\n  addDecY(2020, 1851) should return 0.\n  addDecY(14,-15) should return 0.\n  */\nconst addDecY = (a, b) => {\n  let product = 0;\n  for (let i = a; i <= b; i++) {\n    product += i;\n  }\n  return product;\n};\n\n/*Complete the function that takes two integers and returns \n  the sum of their binary digits.\n  Assume the input is always valid.\n  Examples:\n  addBinary(148, 412) should return 101.\n  addBinary(19, 28) should return 101.\n  addBinary(2020, 1851) should return 0.\n  addBinary(14,-15) should return 0.\n  */\nconst addBinary = (a, b) => {\n  let product = 0;\n  for (let i = a; i <= b; i++) {\n    product += i;\n  }\n  return product;\n};\n\n/*Complete the function that takes two integers and returns \n  the sum of their decimal digits.\n  Assume the input is always valid.\n  Examples:\n  addDecY(148, 412) should return 148.\n  addDecY(19, 28) should return 148.\n  addDecY(2020, 1851) should return 0.\n  addDecY(14,-15) should return 0.\n  */\nconst addDecY = (a, b) => {\n  let product = 0;\n  for (let i = a; i <= b; i++) {\n    product += i;\n  }\n  return product;\n};\n\n/*Complete the function that takes two integers and returns \n  the sum of their binary digits.\n  Assume the input is always valid.\n  Examples:\n  addBinary(148, 412) should return 101.\n  addBinary(19, 28) should return 101.\n  addBinary(2020, 1851) should return 0.\n  addBinary(14,-15) should return 0.\n  */\nconst addBinary = (a, b) => {\n  let product = 0;\n  for (let i = a; i <= b; i++) {\n    product += i;\n  }\n  return product;\n};\n\n/*Complete the function that takes two integers and returns \n  the sum of their decimal digits.\n  Assume the input is always valid.\n  Examples:\n  addDecY(148, 412) should return 148.\n  addDecY(19, 28) should return 148.\n  addDecY(2020, 1851) should return 0.\n  addDecY(14,-15) should return 0.\n  */\nconst addDecY = (a, b) => {\n  let product = 0;\n  for (let i = a; i <= b; i++) {\n    product += i;\n  }\n  return product;\n};\n\n/*Complete the function that takes two integers and returns \n  the sum of their binary digits.\n  Assume the input is always valid.\n  Examples:\n  addBinary(148, 412) should return 101.\n  addBinary(19, 28) should return 101.\n  addBinary(2020, 1851) should return 0.\n  addBinary(14,-15) should return 0.\n  */\nconst addBinary = (a, b) => {\n  let product = 0;\n  for (let i = a; i <= b; i++) {\n    product += i;\n  }\n  return product;\n};\n\n/*Complete the function that takes two integers and returns \n  the sum of their decimal digits.\n  Assume the input is always valid.\n  Examples:\n  addDecY(148, 412) should return 148.\n  addDecY(19, 28) should return 148.\n  addDecY(2020, 1851) should return 0.\n  addDecY(14,-15) should return 0.\n  */\nconst addDecY = (a, b) => {\n  let product = 0;\n  for (let i = a; i <= b; i++) {\n    product += i;\n  }\n  return product;\n};\n\n/*Complete the function that takes two integers and returns \n  the sum of their binary digits.\n  Assume the input is always valid.\n  Examples:\n  addBinary(148, 412) should return 101.\n  addBinary(19, 28) should return 101.\n  addBinary(2020, 1851) should return 0.\n  addBinary(14,-15) should return 0.\n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  couNtUpPer('aBCdEf') returns 1\n  couNtUpPer('abcdefg') returns 0\n  couNtUpPer('dBBE') returns 0\n  */\nconst couNtUpPer = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "couNtUpPer", "gc": "<|endoftext|>/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  couNtUpPer('aBCdEf') returns 1\n  couNtUpPer('abcdefg') returns 0\n  couNtUpPer('dBBE') returns 0\n  */\nconst couNtUpPer = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsLength = vowels.length;\n  let vowelsIndex = 0;\n  let vowelsIndex2 = 0;\n  let vowelsIndex3 = 0;\n  let vowelsIndex4 = 0;\n  let vowelsIndex5 = 0;\n  let vowelsIndex6 = 0;\n  let vowelsIndex7 = 0;\n  let vowelsIndex8 = 0;\n  let vowelsIndex9 = 0;\n  let vowelsIndex10 = 0;\n  let vowelsIndex11 = 0;\n  let vowelsIndex12 = 0;\n  let vowelsIndex13 = 0;\n  let vowelsIndex14 = 0;\n  let vowelsIndex15 = 0;\n  let vowelsIndex16 = 0;\n  let vowelsIndex17 = 0;\n  let vowelsIndex18 = 0;\n  let vowelsIndex19 = 0;\n  let vowelsIndex20 = 0;\n  let vowelsIndex21 = 0;\n  let vowelsIndex22 = 0;\n  let vowelsIndex23 = 0;\n  let vowelsIndex24 = 0;\n  let vowelsIndex25 = 0;\n  let vowelsIndex26 = 0;\n  let vowelsIndex27 = 0;\n  let vowelsIndex28 = 0;\n  let vowelsIndex29 = 0;\n  let vowelsIndex30 = 0;\n  let vowelsIndex31 = 0;\n  let vowelsIndex32 = 0;\n  let vowelsIndex33 = 0;\n  let vowelsIndex34 = 0;\n  let vowelsIndex35 = 0;\n  let vowelsIndex36 = 0;\n  let vowelsIndex37 = 0;\n  let vowelsIndex38 = 0;\n  let vowelsIndex39 = 0;\n  let vowelsIndex40 = 0;\n  let vowelsIndex41 = 0;\n  let vowelsIndex42 = 0;\n  let vowelsIndex43 = 0;\n  let vowelsIndex44 = 0;\n  let vowelsIndex45 = 0;\n  let vowelsIndex46 = 0;\n  let vowelsIndex47 = 0;\n  let vowelsIndex48 = 0;\n  let vowelsIndex49 = 0;\n  let vowelsIndex50 = 0;\n  let vowelsIndex51 = 0;\n  let vowelsIndex52 = 0;\n  let vowelsIndex53 = 0;\n  let vowelsIndex54 = 0;\n  let vowelsIndex55 = 0;\n  let vowelsIndex56 = 0;\n  let vowelsIndex57 = 0;\n  let vowelsIndex58 = 0;\n  let vowelsIndex59 = 0;\n  let vowelsIndex60 = 0;\n  let vowelsIndex61 = 0;\n  let vowelsIndex62 = 0;\n  let vowelsIndex63 = 0;\n  let vowelsIndex64 = 0;\n  let vowelsIndex65 = 0;\n  let vowelsIndex66 = 0;\n  let vowelsIndex67 = 0;\n  let vowelsIndex68 = 0;\n  let vowelsIndex69 = 0;\n  let vowelsIndex70 = 0;\n  let vowelsIndex71 = 0;\n  let vowelsIndex72 = 0;\n  let vowelsIndex73 = 0;\n  let vowelsIndex74 = 0;\n  let vowelsIndex75 = 0;\n  let vowelsIndex76 = 0;\n  let vowelsIndex77 = 0;\n  let vowelsIndex78 = 0;\n  let vowelsIndex79 = 0;\n  let vowelsIndex80 = 0;\n  let vowelsIndex81 = 0;\n  let vowelsIndex82 = 0;\n  let vowelsIndex83 = 0;\n  let vowelsIndex84 = 0;\n  let vowelsIndex85 = 0;\n  let vowelsIndex86 = 0;\n  let vowelsIndex87 = 0;\n  let vowelsIndex88 = 0;\n  let vowelsIndex89 = 0;\n  let vowelsIndex90 = 0;\n  let vowelsIndex91 = 0;\n  let vowelsIndex92 = 0;\n  let vowelsIndex93 = 0;\n  let vowelsIndex94 = 0;\n  let vowelsIndex95 = 0;\n  let vowelsIndex96 = 0;\n  let vowelsIndex97 = 0;\n  let vowelsIndex98 = 0;\n  let vowelsIndex99 = 0;\n  let vowelsIndex100 = 0;\n  let vowelsIndex101 = 0;\n  let vowelsIndex102 = 0;\n  let vowelsIndex103 = 0;\n  let vowelsIndex104 = 0;\n  let vowelsIndex105 = 0;\n  let vowelsIndex106 = 0;\n  let vowelsIndex107 = 0;\n  let vowelsIndex108 = 0;\n  let vowelsIndex109 = 0;\n  let vowelsIndex110 = 0;\n  let vowelsIndex111 = 0;\n  let vowelsIndex112 = 0;\n  let vowelsIndex113 = 0;\n  let vowelsIndex114 = 0;\n  let vowelsIndex115 = 0;\n  let vowelsIndex116 = 0;\n  let vowelsIndex117 = 0;\n  let vowelsIndex118 = 0;\n  let vowelsIndex119 = 0;\n  let vowelsIndex120 = 0;\n  let vowelsIndex121 = 0;\n  let vowelsIndex122 = 0;\n  let vowelsIndex123 = 0;\n  let vowelsIndex124 = 0;\n  let vowelsIndex125 = 0;\n  let vowelsIndex126 = 0;\n  let vowelsIndex127 = 0;\n  let vowelsIndex128 = 0;\n  let vowelsIndex129 = 0;\n  let vowelsIndex130 = 0;\n  let vowelsIndex131 = 0;\n  let vowelsIndex132 = 0;\n  let vowelsIndex133 = 0;\n  let vowelsIndex134 = 0;\n  let vowelsIndex135 = 0;\n  let vowelsIndex136 = 0;\n  let vowelsIndex137 = 0;\n  let vowelsIndex138 = 0;\n  let vowelsIndex139 = 0;\n  let vowelsIndex140 = 0;\n  let vowelsIndex141 = 0;\n  let vowelsIndex142 = 0;\n  let vowelsIndex143 = 0;\n  let vowelsIndex144 = 0;\n  let vowelsIndex145 = 0;\n  let vowelsIndex146 = 0;\n  let vowelsIndex147 = 0;\n  let vowelsIndex148 = 0;\n  let vowelsIndex149 = 0;\n  let vowelsIndex150 = 0;\n  let vowelsIndex151 = 0;\n  let vowelsIndex152 = 0;\n  let vowelsIndex153 = 0;\n  let vowelsIndex154 = 0;\n  let vowelsIndex155 = 0;\n  let vowelsIndex156 = 0;\n  let vowelsIndex157 = 0;\n  let vowelsIndex158 = 0;\n  let vowelsIndex159 = 0;\n  let vowelsIndex160 = 0;\n  let vowelsIndex161 = 0;\n  let vowelsIndex162 = 0;\n  let vowelsIndex163 = 0;\n  let vowelsIndex164 = 0;\n  let vowelsIndex165 = 0;\n  let vowelsIndex166 = 0;\n  let vowelsIndex167 = 0;\n  let vowelsIndex168 = 0;\n  let vowelsIndex169 = 0;\n  let vowelsIndex170 = 0;\n  let vowelsIndex171 = 0;\n  let vowelsIndex172 = 0;\n  let vowelsIndex173 = 0;\n  let vowelsIndex174 = 0;\n  let vowelsIndex175 = 0;\n  let vowelsIndex176 = 0;\n  let vowelsIndex177 = 0;\n  let vowelsIndex178 = 0;\n  let vowelsIndex179 = 0;\n  let vowelsIndex180 = 0;\n  let vowelsIndex181 = 0;\n  let vowelsIndex182 = 0;\n  let vowelsIndex183 = 0;\n  let vowelsIndex184 = 0;\n  let vowelsIndex185 = 0;\n  let vowelsIndex186 = 0;\n  let vowelsIndex187 = 0;\n  let vowelsIndex188 = 0;\n  let vowelsIndex189 = 0;\n  let vowelsIndex190 = 0;\n  let vowelsIndex191 = 0;\n  let vowelsIndex192 = 0;\n  let vowelsIndex193 = 0;\n  let vowelsIndex194 = 0;\n  let vowelsIndex195 = 0;\n  let vowelsIndex196 = 0;\n  let vowelsIndex197 = 0;\n  let vowelsIndex198 = 0;\n  let vowelsIndex199 = 0;\n  let vowelsIndex200 = 0;\n  let vowelsIndex201 = 0;\n  let vowelsIndex202 = 0;\n  let vowelsIndex203 = 0;\n  let vowelsIndex204 = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> cloSestintegEr(\"10\")\n  10\n  >>> cloSestintegEr(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example cloSestintegEr(\"14.5\") should\n  return 15 and cloSestintegEr(\"-14.5\") should return -15.\n  */\nconst cloSestintegEr = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "cloSestintegEr", "gc": "<|endoftext|>/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> cloSestintegEr(\"10\")\n  10\n  >>> cloSestintegEr(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example cloSestintegEr(\"14.5\") should\n  return 15 and cloSestintegEr(\"-14.5\") should return -15.\n  */\nconst cloSestintegEr = (value) => {\n  let num;\n  let num2;\n  let num3;\n  let num4;\n  let num5;\n  let num6;\n  let num7;\n  let num8;\n  let num9;\n  let num10;\n  let num11;\n  let num12;\n  let num13;\n  let num14;\n  let num15;\n  let num16;\n  let num17;\n  let num18;\n  let num19;\n  let num20;\n  let num21;\n  let num22;\n  let num23;\n  let num24;\n  let num25;\n  let num26;\n  let num27;\n  let num28;\n  let num29;\n  let num30;\n  let num31;\n  let num32;\n  let num33;\n  let num34;\n  let num35;\n  let num36;\n  let num37;\n  let num38;\n  let num39;\n  let num40;\n  let num41;\n  let num42;\n  let num43;\n  let num44;\n  let num45;\n  let num46;\n  let num47;\n  let num48;\n  let num49;\n  let num50;\n  let num51;\n  let num52;\n  let num53;\n  let num54;\n  let num55;\n  let num56;\n  let num57;\n  let num58;\n  let num59;\n  let num60;\n  let num61;\n  let num62;\n  let num63;\n  let num64;\n  let num65;\n  let num66;\n  let num67;\n  let num68;\n  let num69;\n  let num70;\n  let num71;\n  let num72;\n  let num73;\n  let num74;\n  let num75;\n  let num76;\n  let num77;\n  let num78;\n  let num79;\n  let num80;\n  let num81;\n  let num82;\n  let num83;\n  let num84;\n  let num85;\n  let num86;\n  let num87;\n  let num88;\n  let num89;\n  let num90;\n  let num91;\n  let num92;\n  let num93;\n  let num94;\n  let num95;\n  let num96;\n  let num97;\n  let num98;\n  let num99;\n  let num100;\n  let num101;\n  let num102;\n  let num103;\n  let num104;\n  let num105;\n  let num106;\n  let num107;\n  let num108;\n  let num109;\n  let num110;\n  let num111;\n  let num112;\n  let num113;\n  let num114;\n  let num115;\n  let num116;\n  let num117;\n  let num118;\n  let num119;\n  let num120;\n  let num121;\n  let num122;\n  let num123;\n  let num124;\n  let num125;\n  let num126;\n  let num127;\n  let num128;\n  let num129;\n  let num130;\n  let num131;\n  let num132;\n  let num133;\n  let num134;\n  let num135;\n  let num136;\n  let num137;\n  let num138;\n  let num139;\n  let num140;\n  let num141;\n  let num142;\n  let num143;\n  let num144;\n  let num145;\n  let num146;\n  let num147;\n  let num148;\n  let num149;\n  let num150;\n  let num151;\n  let num152;\n  let num153;\n  let num154;\n  let num155;\n  let num156;\n  let num157;\n  let num158;\n  let num159;\n  let num160;\n  let num161;\n  let num162;\n  let num163;\n  let num164;\n  let num165;\n  let num166;\n  let num167;\n  let num168;\n  let num169;\n  let num170;\n  let num171;\n  let num172;\n  let num173;\n  let num174;\n  let num175;\n  let num176;\n  let num177;\n  let num178;\n  let num179;\n  let num180;\n  let num181;\n  let num182;\n  let num183;\n  let num184;\n  let num185;\n  let num186;\n  let num187;\n  let num188;\n  let num189;\n  let num190;\n  let num191;\n  let num192;\n  let num193;\n  let num194;\n  let num195;\n  let num196;\n  let num197;\n  let num198;\n  let num199;\n  let num200;\n  let num201;\n  let num202;\n  let num203;\n  let num204;\n  let num205;\n  let num206;\n  let num207;\n  let num208;\n  let num209;\n  let num210;\n  let num211;\n  let num212;\n  let num213;\n  let num214;\n  let num215;\n  let num216;\n  let num217;\n  let num218;\n  let num219;\n  let num220;\n  let num221;\n  let num222;\n  let num223;\n  let num224;\n  let num225;\n  let num226;\n  let num227;\n  let num228;\n  let num229;\n  let num230;\n  let num231;\n  let num232;\n  let num233;\n  let num234;\n  let num235;\n  let num236;\n  let num237;\n  let num238;\n  let num239;\n  let num240;\n  let num241;\n  let num242;\n  let num243;\n  let num244;\n  let num245;\n  let num246;\n  let num247;\n  let num248;\n  let num249;\n  let num250;\n  let num251;\n  let num252;\n  let num253;\n  let num254;\n  let num255;\n  let num256;\n  let num257;\n  let num258;\n  let num259;\n  let num260;\n  let num261;\n  let num262;\n  let num263;\n  let num264;\n  let num265;\n  let num266;\n  let num267;\n  let num268;\n  let num269;\n  let num270;\n  let num271;\n  let num272;\n  let num273;\n  let num274;\n  let num275;\n  let num276;\n  let num277;\n  let num278;\n  let num279;\n  let num280;\n  let num281;\n  let num282;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
