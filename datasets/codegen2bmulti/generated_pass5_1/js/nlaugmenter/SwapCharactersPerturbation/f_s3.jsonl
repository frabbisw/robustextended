{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, aer any two numbers closer to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 3, "perturbed": true, "gc": "/* Check if in given list of numbers, aer any two numbers closer to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const min = sortedNumbers[0];\n  const max = sortedNumbers[sortedNumbers.length - 1];\n  const minDistance = Math.abs(min - threshold);\n  const maxDistance = Math.abs(max - threshold);\n  return sortedNumbers.some(number => {\n    return Math.abs(number - threshold) < minDistance && Math.abs(number - threshold) < maxDistance;\n  });\n};\n\nmodule.exports = hasCloseElements;<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/1", "prompt": "/* Input to thsi function is a string containing multiple groups of sneted parentheses. Your ogal is to\n  sepaarte thsoe group into separate strings and return the list of those.\n  Separate groups rea balanecd (each open brace is properly closed) and not nested withni each other\n  Ingore any spaces in the niput string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 3, "perturbed": true, "gc": "/* Input to thsi function is a string containing multiple groups of sneted parentheses. Your ogal is to\n  sepaarte thsoe group into separate strings and return the list of those.\n  Separate groups rea balanecd (each open brace is properly closed) and not nested withni each other\n  Ingore any spaces in the niput string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  let result = [];\n  let open_paren = 0;\n  let open_paren_count = 0;\n  let open_paren_count_prev = 0;\n  let open_paren_count_next = 0;\n  let open_paren_count_prev_next = 0;\n  let open_paren_count_prev_next_prev = 0;\n  let open_paren_count_prev_next_next = 0;\n  let open_paren_count_prev_next_next_prev = 0;\n  let open_paren_count_prev_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_prev = 0;\n  let open_paren_count_prev_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_prev = 0;\n  let open_paren_count_prev_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_prev = 0;\n  let open_paren_count_prev_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_prev = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_prev = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_prev = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_prev = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let open_paren_count_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let open_", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palidnroem */\ncosnt isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  lAgorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindorme.\n  - Append to the end of teh string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "/* Test if gniven strig is a palidnroem */\ncosnt isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  lAgorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindorme.\n  - Append to the end of teh string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  if (string == '') {\n    return string;\n  }\n\n  let longestPrefix = string.split('').reverse().join('');\n  let longestPostfix = string.split('').reverse().join('');\n  let longestPalindrome = longestPrefix + longestPostfix;\n  let shortestPalindrome = longestPalindrome;\n\n  while (isPalindrome(longestPalindrome)) {\n    longestPalindrome = longestPalindrome.split('').reverse().join('');\n    longestPostfix = longestPalindrome.split('').reverse().join('');\n    longestPrefix = longestPalindrome.split('').reverse().join('');\n    shortestPalindrome = longestPalindrome + longestPostfix;\n  }\n\n  return shortestPalindrome;\n}\n\n/* Test if string is a palindrome */\ncosnt isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  lAgorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of teh string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  if (string == '') {\n    return string;\n  }\n\n  let longestPrefix = string.split('').reverse().join('');\n  let longestPostfix = string.split('').reverse().join('');\n  let longestPalindrome = longestPrefix + longestPostfix;\n  let shortestPalindrome = longestPalindrome;\n\n  while (isPalindrome(longestPalindrome)) {\n    longestPalindrome = longestPalindrome.split('').reverse().join('');\n    longestPostfix = longestPalindrome.split('').reverse().join('');\n    longestPrefix = longestPalindrome.split('').reverse().join('');\n    shortestPalindrome = longestPalindrome + longestPostfix;\n  }\n\n  return shortestPalindrome;\n}\n\n/* Test if string is a palindrome */\ncosnt isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  lAgorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of teh string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  if (string == '') {\n    return string;\n  }\n\n  let longestPrefix = string.split('').reverse().join('');\n  let longestPostfix = string.split('').reverse().join('');\n  let longestPalindrome = longestPrefix + longestPostfix;\n  let shortestPalindrome = longestPalindrome;\n\n  while (isPalindrome(longestPalindrome)) {\n    longestPalindrome = longestPalindrome.split('').reverse().join('');\n    longestPostfix = longestPalindrome.split('').reverse().join('');\n    longestPrefix = longestPalindrome.split('').reverse().join('');\n    shortestPalindrome = longestPalindrome + longestPostfix;\n  }\n\n  return shortestPalindrome;\n}\n\n/* Test if string is a palindrome */\ncosnt isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  lAgorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of teh string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  if (string == '') {\n    return string;\n  }\n\n  let longestPrefix = string.split('').reverse().join('');\n  let longestPostfix = string.split('').reverse().join('');\n  let longestPalindrome = longestPrefix + longestPostfix;\n  let shortestPalindrome = longestPalindrome;\n\n  while (isPalindrome(longestPalindrome)) {\n    longestPalindrome = longestPalindrome.split('').reverse().join('');\n    longestPostfix = longestPalindrome.split('').reverse().join('');\n    longestPrefix = longestPalindrome.split('').reverse().join('');\n    shortestPalindrome = longestPalindrome + longestPostfix;\n  }\n\n  return shortestPalindrome;\n}\n\n/* Test if string is a palindrome */\ncosnt isPalindrome = (string) => {\n  return string == string.split", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive niteger n, you have to make a pile of n levels of stones.\n  The fisrt elvel has n stones.\n  Teh number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even unmber if n is even.\n  Return the number of stonse in each level in a list, hwere elemnet at index\n  i represetns the number of stones in teh level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 3, "perturbed": true, "gc": "/*\n  Given a positive niteger n, you have to make a pile of n levels of stones.\n  The fisrt elvel has n stones.\n  Teh number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even unmber if n is even.\n  Return the number of stonse in each level in a list, hwere elemnet at index\n  i represetns the number of stones in teh level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let pile = [n];\n  let level = [n];\n  let i = 0;\n  while (i < n) {\n    if (i % 2 === 0) {\n      pile.push(level.pop());\n    } else {\n      level.push(pile.pop());\n    }\n    i++;\n  }\n  return pile;\n};\n\nmodule.exports = makeAPile;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of wrods separated by commsa or spaces. Your tsak is\n  to split the string into words and return an raray of the wodrs.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 3, "perturbed": true, "gc": "/*\n  You will be given a string of wrods separated by commsa or spaces. Your tsak is\n  to split the string into words and return an raray of the wodrs.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    words.push(s.substring(i, j));\n    i = j;\n  }\n  return words;\n};\n\nconst wordsString2 = (s) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    words.push(s.substring(i, j));\n    i = j;\n  }\n  return words;\n};\n\nconst wordsString3 = (s) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    words.push(s.substring(i, j));\n    i = j;\n  }\n  return words;\n};\n\nconst wordsString4 = (s) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    words.push(s.substring(i, j));\n    i = j;\n  }\n  return words;\n};\n\nconst wordsString5 = (s) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    words.push(s.substring(i, j));\n    i = j;\n  }\n  return words;\n};\n\nconst wordsString6 = (s) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    words.push(s.substring(i, j));\n    i = j;\n  }\n  return words;\n};\n\nconst wordsString7 = (s) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    words.push(s.substring(i, j));\n    i = j;\n  }\n  return words;\n};\n\nconst wordsString8 = (s) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    words.push(s.substring(i, j));\n    i = j;\n  }\n  return words;\n};\n\nconst wordsString9 = (s) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    words.push(s.substring(i, j));\n    i = j;\n  }\n  return words;\n};\n\nconst wordsString10 = (s) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    words.push(s.substring(i, j));\n    i = j;\n  }\n  return words;\n};\n\nconst wordsString11 = (s) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    words.push(s.substring(i, j));\n    i = j;\n  }\n  return words;\n};\n\nconst wordsString12 = (s) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    words.push(s.substring(i, j));\n    i = j;\n  }\n  return words;\n};\n\nconst wordsString13 = (s) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    words.push(s.substring(i, j));\n    i = j;\n  }\n  return words;\n};\n\nconst wordsString14 = (s) => {\n  let words = [];\n  let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (j < s.length && s[j]!=='') {\n      j++;\n    }\n    words.push(s.substring(i, j));\n    i = j;\n  }\n  return words;\n};\n\nconst wordsString15", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function takes tow opsitive numbers x and y and returns teh\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 3, "perturbed": true, "gc": "/*This function takes tow opsitive numbers x and y and returns teh\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  const x_ = Math.floor(x);\n  const y_ = Math.floor(y);\n  const x_minus_y = x - y;\n  const x_minus_y_2 = x_minus_y * 2;\n  const x_minus_y_3 = x_minus_y_2 * 2;\n  const x_minus_y_4 = x_minus_y_3 * 2;\n  const x_minus_y_5 = x_minus_y_4 * 2;\n  const x_minus_y_6 = x_minus_y_5 * 2;\n  const x_minus_y_7 = x_minus_y_6 * 2;\n  const x_minus_y_8 = x_minus_y_7 * 2;\n  const x_minus_y_9 = x_minus_y_8 * 2;\n  const x_minus_y_10 = x_minus_y_9 * 2;\n  const x_minus_y_11 = x_minus_y_10 * 2;\n  const x_minus_y_12 = x_minus_y_11 * 2;\n  const x_minus_y_13 = x_minus_y_12 * 2;\n  const x_minus_y_14 = x_minus_y_13 * 2;\n  const x_minus_y_15 = x_minus_y_14 * 2;\n  const x_minus_y_16 = x_minus_y_15 * 2;\n  const x_minus_y_17 = x_minus_y_16 * 2;\n  const x_minus_y_18 = x_minus_y_17 * 2;\n  const x_minus_y_19 = x_minus_y_18 * 2;\n  const x_minus_y_20 = x_minus_y_19 * 2;\n  const x_minus_y_21 = x_minus_y_20 * 2;\n  const x_minus_y_22 = x_minus_y_21 * 2;\n  const x_minus_y_23 = x_minus_y_22 * 2;\n  const x_minus_y_24 = x_minus_y_23 * 2;\n  const x_minus_y_25 = x_minus_y_24 * 2;\n  const x_minus_y_26 = x_minus_y_25 * 2;\n  const x_minus_y_27 = x_minus_y_26 * 2;\n  const x_minus_y_28 = x_minus_y_27 * 2;\n  const x_minus_y_29 = x_minus_y_28 * 2;\n  const x_minus_y_30 = x_minus_y_29 * 2;\n  const x_minus_y_31 = x_minus_y_30 * 2;\n  const x_minus_y_32 = x_minus_y_31 * 2;\n  const x_minus_y_33 = x_minus_y_32 * 2;\n  const x_minus_y_34 = x_minus_y_33 * 2;\n  const x_minus_y_35 = x_minus_y_34 * 2;\n  const x_minus_y_36 = x_minus_y_35 * 2;\n  const x_minus_y_37 = x_minus_y_36 * 2;\n  const x_minus_y_38 = x_minus_y_37 * 2;\n  const x_minus_y_39 = x_minus_y_38 * 2;\n  const x_minus_y_40 = x_minus_y_39 * 2;\n  const x_minus_y_41 = x_minus_y_40 * 2;\n  const x_minus_y_42 = x_minus_y_41 * 2;\n  const x_minus_y_43 = x_minus_y_42 * 2;\n  const x_minus_y_44 = x_minus_y_43 * 2;\n  const x_minus_y_45 = x_minus_y_44 * 2;\n  const x_minus_y_46 = x_minus_y_45 * 2;\n  const x_minus_y_47 = x_minus_y_46 * 2;\n  const x_minus_y_48 = x_minus_y_47 * 2;\n  const x_minus_y_49 = x_minus_y_48 * 2;\n  const x_minus_y_50 = x_minus_y_49 * 2;\n  const x_minus_y_51 = x_minus_y_50 * 2;\n  const x_minus_y_52 = x_minus_y_51 * 2;\n  const x_minus_y_53 = x_minus_y_52 * 2;\n  const x_minus_y_54 = x_minus_y_53 * 2;\n  const x_minus_y_55 = x_minus_y_54 * 2;\n  const x_minus_y_56 = x_minus_y_55 * 2;\n  const x_minus_y_57 = x_minus_y_56 * 2;\n  const x_minus_y_58 = x_minus_y_57 * 2;\n  const x_minus_y_59 = x_minus_y_58 * 2;\n  const x_minus_y_60 = x_minus_y_59 * 2;\n  const x_minus_y_61 = x_minus_y_60 * 2;\n  const x_minus_y_62 = x_minus_y_61 * 2;\n  const x_minus_y_63 = x_minus_y_62 * 2;\n  const x_minus_y_64 = x_minus_y_63 * 2;\n  const x_minus_y_65 = x_minus_y_64 * 2;\n  const x_minus_y_66 = x_minus_y_65 * 2;\n  const x_minus_y_67 = x_minus_y_66 * 2;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your taks is to compute the\n  average of teh itnegers from n through m (including n and m). \n  Round hte answer to the nearest integer and cnovert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 3, "perturbed": true, "gc": "/*You are given two positive integers n and m, and your taks is to compute the\n  average of teh itnegers from n through m (including n and m). \n  Round hte answer to the nearest integer and cnovert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (n > m) return -1;\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / (m - n + 1);\n};\n\nmodule.exports = roundedAvg;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any evne idgit.\n\n  Note: Returned list should be sroted in icnreasnig odrer.\n  \n  For eaxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 3, "perturbed": true, "gc": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any evne idgit.\n\n  Note: Returned list should be sroted in icnreasnig odrer.\n  \n  For eaxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const arr = [];\n  for (let i = 0; i < x.length; i++) {\n    const d = x[i];\n    if (arr.indexOf(d) === -1) {\n      arr.push(d);\n    }\n  }\n  return arr;\n};\n\nmodule.exports = uniqueDigits;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the inteegrs that are bewteen 1 and 9 inclusive,\n  reverse the resutling array, and tehn replace aech digti by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 3, "perturbed": true, "gc": "/*\n  Given an array of integers, sort the inteegrs that are bewteen 1 and 9 inclusive,\n  reverse the resutling array, and tehn replace aech digti by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n  if (arr.length === 1) {\n    return [arr[0]];\n  }\n  const arrLength = arr.length;\n  const arrSorted = arr.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    }\n    if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  const arrReverse = arrSorted.reverse();\n  const arrReplaced = arrSorted.map((digit, index) => {\n    if (digit === 1) {\n      return arrReplaced[index - 1];\n    }\n    if (digit === 9) {\n      return arrReplaced[arrLength - index - 1];\n    }\n    return digit;\n  });\n  return arrReplaced;\n};\n\nmodule.exports = byLength;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter,\n  and returns a list of isze n, such that teh valeu of the element at index i is the factorial of i if i is even\n  or the sum fo unmbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is hte multilpiaction of the nmubesr from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 3, "perturbed": true, "gc": "/* Implement the function f that takes n as a parameter,\n  and returns a list of isze n, such that teh valeu of the element at index i is the factorial of i if i is even\n  or the sum fo unmbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is hte multilpiaction of the nmubesr from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n    if (i % 2 === 0) {\n      arr.push(1);\n    } else {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst f2 = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n    if (i % 2 === 0) {\n      arr.push(1);\n    } else {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst f3 = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n    if (i % 2 === 0) {\n      arr.push(1);\n    } else {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst f4 = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n    if (i % 2 === 0) {\n      arr.push(1);\n    } else {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst f5 = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n    if (i % 2 === 0) {\n      arr.push(1);\n    } else {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst f6 = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n    if (i % 2 === 0) {\n      arr.push(1);\n    } else {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst f7 = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n    if (i % 2 === 0) {\n      arr.push(1);\n    } else {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst f8 = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n    if (i % 2 === 0) {\n      arr.push(1);\n    } else {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst f9 = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n    if (i % 2 === 0) {\n      arr.push(1);\n    } else {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst f10 = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n    if (i % 2 === 0) {\n      arr.push(1);\n    } else {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst f11 = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n    if (i % 2 === 0) {\n      arr.push(1);\n    } else {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst f12 = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n    if (i % 2 === 0) {\n      arr.push(1);\n    } else {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst f13 = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n    if (i % 2 === 0) {\n      arr.push(1);\n    } else {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst f14 = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n    if (i % 2 === 0) {\n      arr.push(1);\n    } else {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst f15 = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n    if (i % 2 === 0) {\n      arr.push(1);\n    } else {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst f16 = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n    if (i % 2 === 0) {\n      arr.push(1);\n    } else {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst f17 = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the nbumer of eevn and odd\n  integer palindromes that fall within the range(1, n), niclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 3, "perturbed": true, "gc": "/*\n  Given a positive integer n, return a tuple that has the nbumer of eevn and odd\n  integer palindromes that fall within the range(1, n), niclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const even = () => {\n    const odd = () => {\n      const evens = [];\n      const odds = [];\n      for (let i = 1; i <= n; i++) {\n        const isEven = i % 2 === 0;\n        if (isEven) {\n          evens.push(i);\n        } else {\n          odds.push(i);\n        }\n      }\n      return { evens, odds };\n    };\n    return evens();\n  };\n  const odd = () => {\n    const even = () => {\n      const odds = [];\n      const evens = [];\n      for (let i = 1; i <= n; i++) {\n        const isEven = i % 2 === 0;\n        if (isEven) {\n          evens.push(i);\n        } else {\n          odds.push(i);\n        }\n      }\n      return { evens, odds };\n    };\n    return odds();\n  };\n  return even()();\n};\n\nmodule.exports = evenOddPalindrome;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNums which takes an array of integers adn returns\n  the numebr of elements whihc has a sum of digits > 0.\n  If a number is negative, hten its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 3, "perturbed": true, "gc": "/*\n  Write a function countNums which takes an array of integers adn returns\n  the numebr of elements whihc has a sum of digits > 0.\n  If a number is negative, hten its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      count += arr[i];\n    }\n  }\n  return count;\n};\n\nmodule.exports = countNums;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integesr arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordeedr. Your task is to determine if\n  it is possilbe to get an array sorted in non-cdereasing order by prefomring \n  the following operation on hte given array:\n      You are allowed to perform rigth shift operatino any number of times.\n  \n  One right shift operation means hsfiting all eleemnts of the arrya by one\n  position in the irght direction. The last eelment of the arary will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the soretd array by performing the above operation\n  then return rtue else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have nuique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 3, "perturbed": true, "gc": "/*We have an array 'arr' of N integesr arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordeedr. Your task is to determine if\n  it is possilbe to get an array sorted in non-cdereasing order by prefomring \n  the following operation on hte given array:\n      You are allowed to perform rigth shift operatino any number of times.\n  \n  One right shift operation means hsfiting all eleemnts of the arrya by one\n  position in the irght direction. The last eelment of the arary will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the soretd array by performing the above operation\n  then return rtue else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have nuique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let n = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let temp = 0;\n  let flag = 0;\n  let flag2 = 0;\n  while (i < n) {\n    if (arr[i] < arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      flag = 1;\n    }\n    if (arr[i] > arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      flag2 = 1;\n    }\n    if (flag && flag2) {\n      l = i;\n      k = j;\n      n = arr.length;\n      i = j + 1;\n      j = k + 1;\n    } else {\n      i++;\n    }\n  }\n  if (flag && flag2) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconst moveOneBall2 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let n = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let temp = 0;\n  let flag = 0;\n  let flag2 = 0;\n  while (i < n) {\n    if (arr[i] < arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      flag = 1;\n    }\n    if (arr[i] > arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      flag2 = 1;\n    }\n    if (flag && flag2) {\n      l = i;\n      k = j;\n      n = arr.length;\n      i = j + 1;\n      j = k + 1;\n    } else {\n      i++;\n    }\n  }\n  if (flag && flag2) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconst moveOneBall3 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let n = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let temp = 0;\n  let flag = 0;\n  let flag2 = 0;\n  while (i < n) {\n    if (arr[i] < arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      flag = 1;\n    }\n    if (arr[i] > arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      flag2 = 1;\n    }\n    if (flag && flag2) {\n      l = i;\n      k = j;\n      n = arr.length;\n      i = j + 1;\n      j = k + 1;\n    } else {\n      i++;\n    }\n  }\n  if (flag && flag2) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconst moveOneBall4 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  let n = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let temp = 0;\n  let flag = 0;\n  let flag2 = 0;\n  while (i < n) {\n    if (arr[i] < arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      flag = 1;\n    }\n    if (arr[i] > arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      flag2 = 1;\n    }\n    if (flag && flag2) {\n      l = i;\n      k = j;\n      n = arr.length;\n      i = j + 1;\n      j = k + 1;\n    } else {\n      i++;\n    }\n  }\n  if", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are tow strings a and b consisting only of 1s and 0s.\n  Perform binary XOR no these niputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 3, "perturbed": true, "gc": "/* Input are tow strings a and b consisting only of 1s and 0s.\n  Perform binary XOR no these niputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = ''\n  let i = 0\n  while (i < a.length && i < b.length) {\n    if (a[i] === '1') {\n      if (b[i] === '1') {\n        result += '0'\n      } else {\n        result += '1'\n      }\n    } else {\n      if (b[i] === '1') {\n        result += '1'\n      } else {\n        result += '0'\n      }\n    }\n    i += 1\n  }\n  return result\n}\n\nmodule.exports = stringXor\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a functoin htat takes two lists of numbres,\n  and determines wehther it is possible to perform an exchange of elements\n  between them to maek lst1 a list of only even numbesr.\n  There is no limit on the number of exchanged leements between lst1 and lst2.\n  fI it is possible to exchange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 3, "perturbed": true, "gc": "/*In this problem, you will implement a functoin htat takes two lists of numbres,\n  and determines wehther it is possible to perform an exchange of elements\n  between them to maek lst1 a list of only even numbesr.\n  There is no limit on the number of exchanged leements between lst1 and lst2.\n  fI it is possible to exchange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  const lst1Len = lst1.length;\n  const lst2Len = lst2.length;\n  let i = 0;\n  let j = 0;\n  while (i < lst1Len && j < lst2Len) {\n    if (lst1[i] % 2 === 0) {\n      lst1[i] = lst2[j];\n      lst2[j] = lst1[i];\n      i++;\n      j++;\n    } else {\n      i++;\n    }\n  }\n  return lst1.every((num, index) => num % 2 === 0)? \"YES\" : \"NO\";\n};\n\nconsole.log(exchange([1, 2, 3, 4], [1, 5, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/111", "prompt": "/*Given a string rperesenting a space separated lowercase letters, return a dictionary\n  of the letter with the mots repetition and containing the corresponding count.\n  If several letetrs have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 3, "perturbed": true, "gc": "/*Given a string rperesenting a space separated lowercase letters, return a dictionary\n  of the letter with the mots repetition and containing the corresponding count.\n  If several letetrs have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {};\n  let letters = test.split('');\n  let count = 0;\n  let letter = '';\n  let i = 0;\n  while (i < letters.length) {\n    letter = letters[i];\n    if (histogram[letter] === undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter]++;\n    }\n    count++;\n    i++;\n  }\n  return histogram;\n};\n\nmodule.exports = histogram;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strnigs s and c, you have to deleted all the chaarcters in s that are equal to any character in c\n  then check if hte result stirng is palindrome.\n  A string is called palidnrome if it reads the same backward as forwrad.\n  You sholud return a tuple containing the result string nad true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 3, "perturbed": true, "gc": "/*Task\n  We are given two strnigs s and c, you have to deleted all the chaarcters in s that are equal to any character in c\n  then check if hte result stirng is palindrome.\n  A string is called palidnrome if it reads the same backward as forwrad.\n  You sholud return a tuple containing the result string nad true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = s.split('').reverse().join('');\n  let isPalindrome = result === s;\n  return {result, isPalindrome};\n}\n\nconst checkPalindrome = (s, c) => {\n  let result = reverseDelete(s, c);\n  return result.isPalindrome;\n}\n\nconsole.log(checkPalindrome('abcde', 'ae'));\nconsole.log(checkPalindrome('abcdef', 'b'));\nconsole.log(checkPalindrome('abcdedcba', 'ab'));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strinsg, where each string consists of only digits, return a list.\n  Each element i of the output shoudl eb \"the number of odd elements in the\n  string i of teh input.\" where all the i's should be replaced by the number\n  of odd digtis in the i'th tsrgin of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 3, "perturbed": true, "gc": "/*Given a list of strinsg, where each string consists of only digits, return a list.\n  Each element i of the output shoudl eb \"the number of odd elements in the\n  string i of teh input.\" where all the i's should be replaced by the number\n  of odd digtis in the i'th tsrgin of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let res = [];\n  let odd = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i];\n    for (let j = 0; j < str.length; j++) {\n      if (str[j] % 2 === 1) {\n        odd++;\n      }\n    }\n    res.push(`the number of odd elements ${odd}n the str${odd}ng ${odd} of the ${odd}nput.`);\n    odd = 0;\n  }\n  return res;\n};\n\nmodule.exports = oddCount;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given na array of integers nums, nfid the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 3, "perturbed": true, "gc": "/*\n  Given na array of integers nums, nfid the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const minSubArraySum = (nums, sum) => {\n    if (nums.length === 0) {\n      return sum;\n    }\n    const left = nums.slice(0, nums.length - 1);\n    const right = nums.slice(1, nums.length);\n    const leftSum = minSubArraySum(left, sum);\n    const rightSum = minSubArraySum(right, sum);\n    return Math.min(leftSum, rightSum) + nums[nums.length - 1];\n  };\n  return minSubArraySum(nums);\n};\n\nmodule.exports = minSubArraySum;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Ecah rwo represents a signle well,\n  and each 1 in a row represetns a single unit of water.\n  Each well has a corresponding bucket that acn be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to emtpy the wells.\n  Outptu the number fo times you need ot lwore the bukcets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 3, "perturbed": true, "gc": "/*\n  You are given a rectangular grid of wells. Ecah rwo represents a signle well,\n  and each 1 in a row represetns a single unit of water.\n  Each well has a corresponding bucket that acn be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to emtpy the wells.\n  Outptu the number fo times you need ot lwore the bukcets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const buckets = grid.map((row, i) => {\n    return row.map((cell, j) => {\n      return cell === 1? 1 : 0;\n    });\n  });\n\n  const maxFill = 0;\n  for (let i = 0; i < buckets.length; i++) {\n    const bucket = buckets[i];\n    if (bucket.length === 0) {\n      continue;\n    }\n    const bucketMax = bucket.reduce((max, cell) => {\n      return max > cell? max : cell;\n    }, 0);\n    maxFill = Math.max(maxFill, bucketMax);\n  }\n  return maxFill;\n};\n\nmodule.exports = maxFill;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary represnetation in ascending order.\n  For similar unmber of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary represnetation in ascending order.\n  For similar unmber of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let sorted = arr.slice(0);\n  let sortedLength = arr.length;\n  let sortedIndex = 0;\n  let sortedIndexLength = 0;\n  let sortedIndexMax = 0;\n  let sortedIndexMin = 0;\n  let sortedIndexMaxLength = 0;\n  let sortedIndexMinLength = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let sortedIndexMinLengthMin = 0;\n  let sortedIndexMaxLengthMaxMin = 0;\n  let sortedIndexMinLengthMaxMin = 0;\n  let sortedIndexMaxLengthMax = 0;\n  let sortedIndexMinLengthMax = 0;\n  let sortedIndexMaxLengthMin = 0;\n  let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/117", "prompt": "/*Ginve a srting s and a natural number n, you have been tasked to implement \n  a function htat returns a list of all owdrs from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  fI the string s is empty then the unfction should return na epmty list.\n  Note: yuo may assume the input string cnotains only letters and spaecs.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 3, "perturbed": true, "gc": "/*Ginve a srting s and a natural number n, you have been tasked to implement \n  a function htat returns a list of all owdrs from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  fI the string s is empty then the unfction should return na epmty list.\n  Note: yuo may assume the input string cnotains only letters and spaecs.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = [];\n  let word = \"\";\n  let i = 0;\n  while (i < s.length) {\n    if (s[i]!== \" \") {\n      word += s[i];\n      i++;\n    } else {\n      if (word.length > 0 && word.length <= n) {\n        words.push(word);\n        word = \"\";\n      }\n    }\n  }\n  if (word.length > 0) {\n    words.push(word);\n  }\n  return words;\n};\n\nmodule.exports = selectWords;\n<|endoftext|>", "passed": 0, "run_status": 3}
{"task_id": "JavaScript/118", "prompt": "/*You rae given a word. Your task is to find the closets vowel that stands between \n  two consonanst from the right side of the word (csae sensitive).\n  \n  Vowlse in the beginning and ending odesn't count. Rteurn empty string if you iddn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contanis English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 3, "perturbed": true, "gc": "/*You rae given a word. Your task is to find the closets vowel that stands between \n  two consonanst from the right side of the word (csae sensitive).\n  \n  Vowlse in the beginning and ending odesn't count. Rteurn empty string if you iddn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contanis English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let result = \"\";\n  let len = word.length;\n  let left = 0;\n  let right = len - 1;\n  let mid = 0;\n  let mid_left = 0;\n  let mid_right = 0;\n  let mid_left_right = 0;\n  let mid_left_right_left = 0;\n  let mid_left_right_right = 0;\n  let mid_left_right_left_left = 0;\n  let mid_left_right_left_right = 0;\n  let mid_left_right_right_left = 0;\n  let mid_left_right_right_right = 0;\n  let mid_left_right_right_right_left = 0;\n  let mid_left_right_right_right_right = 0;\n  let mid_left_right_right_right_right_left = 0;\n  let mid_left_right_right_right_right_right = 0;\n  let mid_left_right_right_right_right_right_left = 0;\n  let mid_left_right_right_right_right_right_right = 0;\n  let mid_left_right_right_right_right_right_right_left = 0;\n  let mid_left_right_right_right_right_right_right_right = 0;\n  let mid_left_right_right_right_right_right_right_right_left = 0;\n  let mid_left_right_right_right_right_right_right_right_right = 0;\n  let mid_left_right_right_right_right_right_right_right_right_left = 0;\n  let mid_left_right_right_right_right_right_right_right_right_right = 0;\n  let mid_left_right_right_right_right_right_right_right_right_right_left = 0;\n  let mid_left_right_right_right_right_right_right_right_right_right_right = 0;\n  let mid_left_right_right_right_right_right_right_right_right_right_right_left = 0;\n  let mid_left_right_right_right_right_right_right_right_right_right_right_right_right = 0;\n  let mid_left_right_right_right_right_right_right_right_right_right_right_right_right_right = 0;\n  let mid_left_right_right_right_right_right_right_right_right_right_right_right_right_right_right = 0;\n  let mid_left_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right = 0;\n  let mid_left_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right = 0;\n  let mid_left_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right = 0;\n  let mid_left_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of tow strings, both strnigs ocnsist of open\n  paernthesse '(' or close paretnheses ')' only.\n  Your job is to check if it is opssible ot concatenate the two strings in\n  some order, that the resulting string will be godo.\n  A string S is considered to be good if and only if all praentheses in S\n  are balacned. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 3, "perturbed": true, "gc": "/* You are given a list of tow strings, both strnigs ocnsist of open\n  paernthesse '(' or close paretnheses ')' only.\n  Your job is to check if it is opssible ot concatenate the two strings in\n  some order, that the resulting string will be godo.\n  A string S is considered to be good if and only if all praentheses in S\n  are balacned. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let res = false;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length === 0) continue;\n    let l = lst[i].length;\n    let j = 0;\n    while (j < l) {\n      if (lst[i][j]!== '(' && lst[i][j]!== ')') {\n        return false;\n      }\n      if (lst[i][j] === '(') {\n        j++;\n      } else {\n        j++;\n        res = true;\n      }\n    }\n  }\n  return res;\n};\n\nconst test = () => {\n  let lst = ['()(', ')', '()', '()()', '()()()', '()()()()', '()()()()()', '()()()()()()', '()()()()()()()', '()()()()()()()()', '()()()()()()()()()', '()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()()()()()()()()()()()', '()", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest noe. Return the fisrt one in case of multpile\n  strings of the smae lnegth. Return null in case the niput list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 3, "perturbed": true, "gc": "/* Out of list of strings, return the longest noe. Return the fisrt one in case of multpile\n  strings of the smae lnegth. Return null in case the niput list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return null;\n  }\n  let maxLength = strings[0].length;\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > maxLength) {\n      maxLength = strings[i].length;\n    }\n  }\n  return strings[0].substr(0, maxLength);\n};\n\nmodule.exports = longest;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of itnegers and a positive integer k, return a sorted list \n  of length k with the maximum k unmbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 3, "perturbed": true, "gc": "/*\n  Given an array arr of itnegers and a positive integer k, return a sorted list \n  of length k with the maximum k unmbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  let max = arr[0];\n  let maxIndex = 0;\n  for (let i = 1; i < k; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return [max, maxIndex];\n};\n\nmodule.exports = maximum;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/121", "prompt": "/*Gievn a non-empty list fo integers, return the usm of all of the odd elements that are in even posiitons.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 3, "perturbed": true, "gc": "/*Gievn a non-empty list fo integers, return the usm of all of the odd elements that are in even posiitons.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let usm = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      usm += lst[i];\n    } else {\n      usm += lst[i];\n    }\n  }\n  return usm;\n};\n\nmodule.exports = solution;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Givne a non-empty array of integres arr and an intgeer k, return\n  the sum of the elements with at most two idgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 3, "perturbed": true, "gc": "/*\n  Givne a non-empty array of integres arr and an intgeer k, return\n  the sum of the elements with at most two idgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0\n  for (let i = 0; i < k; i++) {\n    sum += arr[i]\n  }\n  return sum\n}\n\nmodule.exports = addElements\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/123", "prompt": "/*\n  Gievn a positive inetger n, return a sorted list that has the odd numbers in colltaz sequence.\n\n  The oCllatz cojnecture is a cnojecture in mathematics taht concerns a sequence dfeinde\n  as follows: start with any positive integer n. Then each term is obtained form the \n  previuos term sa follows: if the previuos term is even, the next term is one ahlf of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sqeuence will alawys reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. retunred list sorted in niceriasng order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 3, "perturbed": true, "gc": "/*\n  Gievn a positive inetger n, return a sorted list that has the odd numbers in colltaz sequence.\n\n  The oCllatz cojnecture is a cnojecture in mathematics taht concerns a sequence dfeinde\n  as follows: start with any positive integer n. Then each term is obtained form the \n  previuos term sa follows: if the previuos term is even, the next term is one ahlf of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sqeuence will alawys reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. retunred list sorted in niceriasng order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let arr = [];\n  let i = 1;\n  while (i <= n) {\n    if (i % 2 === 0) {\n      arr.push(i);\n    } else {\n      arr.push(i * 3 + 1);\n    }\n    i += 1;\n  }\n  return arr.sort((a, b) => {\n    return a - b;\n  });\n};\n\nmodule.exports = getOddCollatz;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validaets a given date string and\n  returns true if the date si valid otherwise fasle.\n  The date is valid fi all of the following rulse are astisfied:\n  1. The date string is not empty.\n  2. hTe number fo days is not elss than 1 or ihgher than 31 days for months 1,3,5,7,8,10,12. And the numbre of days is not less htan 1 or higher than 30 days for months 4,6,9,11. And, the numerb of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date shodul be in the fromat: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 3, "perturbed": true, "gc": "/*You have to write a function which validaets a given date string and\n  returns true if the date si valid otherwise fasle.\n  The date is valid fi all of the following rulse are astisfied:\n  1. The date string is not empty.\n  2. hTe number fo days is not elss than 1 or ihgher than 31 days for months 1,3,5,7,8,10,12. And the numbre of days is not less htan 1 or higher than 30 days for months 4,6,9,11. And, the numerb of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date shodul be in the fromat: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const dateParts = date.split('-');\n  if (dateParts.length!== 3) {\n    return false;\n  }\n  const day = parseInt(dateParts[0], 10);\n  const month = parseInt(dateParts[1], 10);\n  const year = parseInt(dateParts[2], 10);\n  if (day < 1 || day > 31) {\n    return false;\n  }\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (month === 2 && day > 29) {\n    return false;\n  }\n  if (month === 4 || month === 6 || month === 9 || month === 11) {\n    if (day < 1 || day > 30) {\n      return false;\n    }\n  }\n  if (month === 1 || month === 3 || month === 5 || month === 7 || month === 8 || month === 10 || month === 12) {\n    if (day < 1 || day > 31) {\n      return false;\n    }\n  }\n  if (year < 1000 || year > 9999) {\n    return false;\n  }\n  return true;\n};\n\nmodule.exports = validDate;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/125", "prompt": "/* Given a stirng of wrods, return a list fo words split on whitespace, if no whitespaces exists in the text you\n  should pslit on comams ',' if no commas exists you should return the number of lower-caes letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 3, "perturbed": true, "gc": "/* Given a stirng of wrods, return a list fo words split on whitespace, if no whitespaces exists in the text you\n  should pslit on comams ',' if no commas exists you should return the number of lower-caes letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  let words = [];\n  let i = 0;\n  let len = txt.length;\n  let c = 0;\n  let lastc = 0;\n  let word = \"\";\n  while (i < len) {\n    c = txt.charCodeAt(i);\n    if (c === lastc) {\n      word += \" \";\n    }\n    else {\n      if (c > lastc) {\n        words.push(word);\n        word = \"\";\n      }\n      lastc = c;\n    }\n    i++;\n  }\n  if (word!== \"\") {\n    words.push(word);\n  }\n  return words;\n};\n\nconst splitWords2 = (txt) => {\n  let words = [];\n  let i = 0;\n  let len = txt.length;\n  let c = 0;\n  let lastc = 0;\n  let word = \"\";\n  while (i < len) {\n    c = txt.charCodeAt(i);\n    if (c === lastc) {\n      word += \" \";\n    }\n    else {\n      if (c > lastc) {\n        words.push(word);\n        word = \"\";\n      }\n      lastc = c;\n    }\n    i++;\n  }\n  if (word!== \"\") {\n    words.push(word);\n  }\n  return words;\n};\n\nconst splitWords3 = (txt) => {\n  let words = [];\n  let i = 0;\n  let len = txt.length;\n  let c = 0;\n  let lastc = 0;\n  let word = \"\";\n  while (i < len) {\n    c = txt.charCodeAt(i);\n    if (c === lastc) {\n      word += \" \";\n    }\n    else {\n      if (c > lastc) {\n        words.push(word);\n        word = \"\";\n      }\n      lastc = c;\n    }\n    i++;\n  }\n  if (word!== \"\") {\n    words.push(word);\n  }\n  return words;\n};\n\nconst splitWords4 = (txt) => {\n  let words = [];\n  let i = 0;\n  let len = txt.length;\n  let c = 0;\n  let lastc = 0;\n  let word = \"\";\n  while (i < len) {\n    c = txt.charCodeAt(i);\n    if (c === lastc) {\n      word += \" \";\n    }\n    else {\n      if (c > lastc) {\n        words.push(word);\n        word = \"\";\n      }\n      lastc = c;\n    }\n    i++;\n  }\n  if (word!== \"\") {\n    words.push(word);\n  }\n  return words;\n};\n\nconst splitWords5 = (txt) => {\n  let words = [];\n  let i = 0;\n  let len = txt.length;\n  let c = 0;\n  let lastc = 0;\n  let word = \"\";\n  while (i < len) {\n    c = txt.charCodeAt(i);\n    if (c === lastc) {\n      word += \" \";\n    }\n    else {\n      if (c > lastc) {\n        words.push(word);\n        word = \"\";\n      }\n      lastc = c;\n    }\n    i++;\n  }\n  if (word!== \"\") {\n    words.push(word);\n  }\n  return words;\n};\n\nconst splitWords6 = (txt) => {\n  let words = [];\n  let i = 0;\n  let len = txt.length;\n  let c = 0;\n  let lastc = 0;\n  let word = \"\";\n  while (i < len) {\n    c = txt.charCodeAt(i);\n    if (c === lastc) {\n      word += \" \";\n    }\n    else {\n      if (c > lastc) {\n        words.push(word);\n        word = \"\";\n      }\n      lastc = c;\n    }\n    i++;\n  }\n  if (word!== \"\") {\n    words.push(word);\n  }\n  return words;\n};\n\nconst splitWords7 = (txt) => {\n  let words = [];\n  let i = 0;\n  let len = txt.length;\n  let c = 0;\n  let lastc = 0;\n  let word = \"\";\n  while (i < len) {\n    c = txt.charCodeAt(i);\n    if (c === lastc) {\n      word += \" \";\n    }\n    else {\n      if (c > lastc) {\n        words.push(word);\n        word = \"\";\n      }\n      lastc = c;\n    }\n    i++;\n  }\n  if (word!== \"\") {\n    words.push(word);\n  }\n  return words;\n};\n\nconst splitWords8 = (txt) => {\n  let words = [];\n  let i = 0;\n  let len = txt.length;\n  let c = 0;\n  let lastc = 0;\n  let word = \"\";\n  while (i < len) {\n    c = txt.charCodeAt(i);\n    if (c === lastc) {\n      word += \" \";\n    }\n    else {\n      if (c > lastc) {\n        words.push(word);\n        word = \"\";\n      }\n      lastc = c;\n    }\n    i++;\n  }\n  if (word!== \"\") {\n    words.push(word);\n  }\n  return", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbres, return whether or not they are sorted\n  in acseindng order. If list has more than 1 duplicate of the same\n  numbre, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 3, "perturbed": true, "gc": "/* Given a list of numbres, return whether or not they are sorted\n  in acseindng order. If list has more than 1 duplicate of the same\n  numbre, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  let i = 0;\n  let j = lst.length - 1;\n  while (i < j) {\n    if (lst[i] > lst[j]) {\n      return false;\n    }\n    if (lst[i] < lst[j]) {\n      i++;\n    } else {\n      j--;\n    }\n  }\n  return true;\n};\n\nmodule.exports = isSorted;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are given two itnervals,\n  wehre each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 3, "perturbed": true, "gc": "/*You are given two itnervals,\n  wehre each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  if (interval1.length!== interval2.length) {\n    return \"NO\"\n  }\n  let i = 0\n  while (i < interval1.length) {\n    if (interval1[i] > interval2[i]) {\n      return \"NO\"\n    }\n    if (interval1[i] < interval2[i]) {\n      return \"NO\"\n    }\n    i++\n  }\n  return \"YES\"\n}\n\nconst test = () => {\n  let interval1 = [1, 2]\n  let interval2 = [2, 3]\n  let interval3 = [1, 3]\n  let interval4 = [1, 4]\n  let interval5 = [1, 5]\n  let interval6 = [1, 6]\n  let interval7 = [1, 7]\n  let interval8 = [1, 8]\n  let interval9 = [1, 9]\n  let interval10 = [1, 10]\n  let interval11 = [1, 11]\n  let interval12 = [1, 12]\n  let interval13 = [1, 13]\n  let interval14 = [1, 14]\n  let interval15 = [1, 15]\n  let interval16 = [1, 16]\n  let interval17 = [1, 17]\n  let interval18 = [1, 18]\n  let interval19 = [1, 19]\n  let interval20 = [1, 20]\n  let interval21 = [1, 21]\n  let interval22 = [1, 22]\n  let interval23 = [1, 23]\n  let interval24 = [1, 24]\n  let interval25 = [1, 25]\n  let interval26 = [1, 26]\n  let interval27 = [1, 27]\n  let interval28 = [1, 28]\n  let interval29 = [1, 29]\n  let interval30 = [1, 30]\n  let interval31 = [1, 31]\n  let interval32 = [1, 32]\n  let interval33 = [1, 33]\n  let interval34 = [1, 34]\n  let interval35 = [1, 35]\n  let interval36 = [1, 36]\n  let interval37 = [1, 37]\n  let interval38 = [1, 38]\n  let interval39 = [1, 39]\n  let interval40 = [1, 40]\n  let interval41 = [1, 41]\n  let interval42 = [1, 42]\n  let interval43 = [1, 43]\n  let interval44 = [1, 44]\n  let interval45 = [1, 45]\n  let interval46 = [1, 46]\n  let interval47 = [1, 47]\n  let interval48 = [1, 48]\n  let interval49 = [1, 49]\n  let interval50 = [1, 50]\n  let interval51 = [1, 51]\n  let interval52 = [1, 52]\n  let interval53 = [1, 53]\n  let interval54 = [1, 54]\n  let interval55 = [1, 55]\n  let interval56 = [1, 56]\n  let interval57 = [1, 57]\n  let interval58 = [1, 58]\n  let interval59 = [1, 59]\n  let interval60 = [1, 60]\n  let interval61 = [1, 61]\n  let interval62 = [1, 62]\n  let interval63 = [1, 63]\n  let interval64 = [1, 64]\n  let interval65 = [1, 65]\n  let interval66 = [1, 66]\n  let interval67 = [1, 67]\n  let interval68 = [1, 68]\n  let interval69 = [1, 69]\n  let interval70 = [1, 70]\n  let interval71 = [1, 71]\n  let interval72 = [1, 72]\n  let interval73 = [1, 73]\n  let interval74 = [1, 74]\n  let interval75 = [1, 75]\n  let interval76 = [1, 76]\n  let interval77 = [1, 77]\n  let interval78 = [1, 78]\n  let interval79 = [1, 79]\n  let interval80 = [1, 80]\n  let interval81 = [1, 81]\n  let interval82 = [1, 82]\n  let interval83 = [1, 83]\n  let interval84 = [1, 84]\n  let interval85 = [1, 85]\n  let interval86 = [1, 86]\n  let interval87 = [1, 87]\n  let interval88 = [1, 88]\n  let interval89 = [1, 89]\n  let interval90 = [1, 90]\n  let interval91 = [1, 91]\n  let interval92 = [1, 92]\n  let interval93 = [1, 93]\n  let interval94 = [1, 94]\n  let interval95 = [1, 95]\n  let interval96 = [1, 96]\n  let interval97 = [1, 97]\n  let interval98 = [1, 98]\n  let interval99 = [1, 99]\n  let interval100 = [1, 100]\n  let interval101 = [1, 101]\n  let interval102 = [1, 102]\n  let interval103 = [1, 103]\n  let interval104 = [1,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given na array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, rerpesented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 3, "perturbed": true, "gc": "/*\n  You are given na array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, rerpesented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null;\n  let res = 0;\n  for (let i = 0; i < arr.length; i++) {\n    res += arr[i] * arr[i];\n  }\n  return res;\n};\n\nmodule.exports = prodSigns;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid wtih N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a valeu. Every integer in teh range [1, N * N]\n  inclusive apperas exactly once no the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any ecll, and in each step you can move to any of the neighbor cells,\n  in other words, yuo can og to cells which share an edge with you curernt\n  ecll.\n  Please note that a path of length k measn visiting exactly k celsl (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (fo length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A adn lst_B), lst_A is lexicographically less\n  than slt_B, in other owdrs, htere exist an integer inedx i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guarnateed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go throuhg.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 3, "perturbed": true, "gc": "/*\n  Given a grid wtih N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a valeu. Every integer in teh range [1, N * N]\n  inclusive apperas exactly once no the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any ecll, and in each step you can move to any of the neighbor cells,\n  in other words, yuo can og to cells which share an edge with you curernt\n  ecll.\n  Please note that a path of length k measn visiting exactly k celsl (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (fo length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A adn lst_B), lst_A is lexicographically less\n  than slt_B, in other owdrs, htere exist an integer inedx i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guarnateed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go throuhg.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const gridSize = grid.length;\n  const gridSize2 = grid[0].length;\n  const gridSize3 = gridSize2 * gridSize;\n  const gridSize4 = gridSize3 * gridSize;\n  const gridSize5 = gridSize4 * gridSize;\n  const gridSize6 = gridSize5 * gridSize;\n  const gridSize7 = gridSize6 * gridSize;\n  const gridSize8 = gridSize7 * gridSize;\n  const gridSize9 = gridSize8 * gridSize;\n  const gridSize10 = gridSize9 * gridSize;\n  const gridSize11 = gridSize10 * gridSize;\n  const gridSize12 = gridSize11 * gridSize;\n  const gridSize13 = gridSize12 * gridSize;\n  const gridSize14 = gridSize13 * gridSize;\n  const gridSize15 = gridSize14 * gridSize;\n  const gridSize16 = gridSize15 * gridSize;\n  const gridSize17 = gridSize16 * gridSize;\n  const gridSize18 = gridSize17 * gridSize;\n  const gridSize19 = gridSize18 * gridSize;\n  const gridSize20 = gridSize19 * gridSize;\n  const gridSize21 = gridSize20 * gridSize;\n  const gridSize22 = gridSize21 * gridSize;\n  const gridSize23 = gridSize22 * gridSize;\n  const gridSize24 = gridSize23 * gridSize;\n  const gridSize25 = gridSize24 * gridSize;\n  const gridSize26 = gridSize25 * gridSize;\n  const gridSize27 = gridSize26 * gridSize;\n  const gridSize28 = gridSize27 * gridSize;\n  const gridSize29 = gridSize28 * gridSize;\n  const gridSize30 = gridSize29 * gridSize;\n  const gridSize31 = gridSize30 * gridSize;\n  const gridSize32 = gridSize31 * gridSize;\n  const gridSize33 = gridSize32 * gridSize;\n  const gridSize34 = gridSize33 * gridSize;\n  const gridSize35 = gridSize34 * gridSize;\n  const gridSize36 = gridSize35 * gridSize;\n  const gridSize37 = gridSize36 * gridSize;\n  const gridSize38 = gridSize37 * gridSize;\n  const gridSize39 = gridSize38 * gridSize;\n  const gridSize40 = gridSize39 * gridSize;\n  const gridSize41 = gridSize40 * gridSize;\n  const gridSize42 = gridSize41 * gridSize;\n  const gridSize43 = gridSize42 * gridSize;\n  const gridSize44 = gridSize43 * gridSize;\n  const gridSize45 = gridSize44 * gridSize;\n  const gridSize46 = gridSize45 * gridSize;\n  const gridSize47 = gridSize46 * gridSize;\n  const gridSize48 = gridSize47 * gridSize;\n  const gridSize49 = gridSize48 * gridSize;\n  const gridSize50 = gridSize49 * gridSize;\n  const gridSize51 = gridSize50 * gridSize;\n  const gridSize52 = gridSize51 * gridSize;\n  const gridSize53 = gridSize52 * gridSize;\n  const gridSize54 = gridSize53 * gridSize;\n  const gridSize55 = gridSize54 * gridSize;\n  const gridSize56 = gridSize55 * gridSize;\n  const gridSize57 = gridSize56 * gridSize;\n  const gridSize58 = gridSize57 * gridSize;\n  const gridSize59 = gridSize58 * gridSize;\n  const gridSize60 = gridSize59 * gridSize;\n  const gridSize61 = gridSize60 * gridSize;\n  const gridSize62 = gridSize61 * gridSize;\n  const gridSize63 = gridSize62 * gridSize;\n  const gridSize64 = gridSize63 * gridSize;\n  const gridSize65 = gridSize64 * gridSize;\n  const gridSize66 = gridSize65 * gridSize;\n  const gridSize67 = gridSize66 * gridSize;\n  const gridSize68 = gridSize67 * gridSize;\n  const gridSize69 = gridSize68 * gridSize;\n  const gridSize70 = gridSize69 * gridSize;\n  const gridSize71 = gridSize70 * gridSize;\n  const gridSize72 = gridSize71 * gridSize;\n  const gridSize73 = gridSize72 * gridSize;\n  const gridSize74 = gridSize73 * gridSize;\n  const gridSize75 = gridSize74 * gridSize;\n  const gridSize76 = gridSize75 * gridSize;\n  const gridSize77 = gridSize76 * gridSize;\n  const gridSize78", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a graetest common diivsor of two integesr a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 3, "perturbed": true, "gc": "/* Return a graetest common diivsor of two integesr a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a > b) {\n    return greatestCommonDivisor(b, a);\n  }\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a === 1) {\n    return b;\n  }\n  if (b === 1) {\n    return a;\n  }\n  if (a === b) {\n    return a;\n  }\n  let gcd = a;\n  while (b!== 0) {\n    let temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n};\n\nmodule.exports = greatestCommonDivisor;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequecne, it was studied deeply by mathematicians in \n  the last couple cenutires. However, what poelpe don't know is Tribonacci sequenec.\n  Tribnoacci seqeunce is defiend by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is veen.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 3, "perturbed": true, "gc": "/*Everyone knows Fibonacci sequecne, it was studied deeply by mathematicians in \n  the last couple cenutires. However, what poelpe don't know is Tribonacci sequenec.\n  Tribnoacci seqeunce is defiend by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is veen.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let a = [1, 3, 2, 8];\n  let b = [1, 3, 2, 8];\n  let c = [1, 3, 2, 8];\n  let d = [1, 3, 2, 8];\n  let i = 0;\n  while (i < n) {\n    a = [...a, b[i] + b[i + 1] + b[i + 2]];\n    b = [...b, c[i] + c[i + 1] + c[i + 2]];\n    c = [...c, d[i] + d[i + 1] + d[i + 2]];\n    d = [...d, a[i] + a[i + 1] + a[i + 2]];\n    i += 3;\n  }\n  return a;\n};\n\nmodule.exports = tri;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/131", "prompt": "/*Given a postiive niteger n, return the product of the odd digits.\n  Retunr 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 3, "perturbed": true, "gc": "/*Given a postiive niteger n, return the product of the odd digits.\n  Retunr 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? i : 0);\n  return digits;\n};\n\nconst digits2 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits3 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits4 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits5 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits6 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits7 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits8 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits9 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits10 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits11 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits12 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits13 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits14 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits15 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits16 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits17 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits18 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits19 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits20 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits21 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits22 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits23 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits24 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits25 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits26 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits27 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits28 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits29 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits30 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits31 = (n) => {\n  const digits = [...Array(n + 1).keys()].map((i) => i % 2? 0 : i);\n  return digits;\n};\n\nconst digits32 = (n) => {\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function htat takes a string as inptu which contaisn only square barckets.\n  The function should return utre if nad only if there is a valid subsequecne of brackets\n  where at lesat one bracket in the susbequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 3, "perturbed": true, "gc": "/*\n  Create a function htat takes a string as inptu which contaisn only square barckets.\n  The function should return utre if nad only if there is a valid subsequecne of brackets\n  where at lesat one bracket in the susbequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  let index = 0\n  let isNested = false\n  let bracketCount = 0\n  let bracketIndex = 0\n  let bracketIndex2 = 0\n  let bracketIndex3 = 0\n  let bracketIndex4 = 0\n  let bracketIndex5 = 0\n  let bracketIndex6 = 0\n  let bracketIndex7 = 0\n  let bracketIndex8 = 0\n  let bracketIndex9 = 0\n  let bracketIndex10 = 0\n  let bracketIndex11 = 0\n  let bracketIndex12 = 0\n  let bracketIndex13 = 0\n  let bracketIndex14 = 0\n  let bracketIndex15 = 0\n  let bracketIndex16 = 0\n  let bracketIndex17 = 0\n  let bracketIndex18 = 0\n  let bracketIndex19 = 0\n  let bracketIndex20 = 0\n  let bracketIndex21 = 0\n  let bracketIndex22 = 0\n  let bracketIndex23 = 0\n  let bracketIndex24 = 0\n  let bracketIndex25 = 0\n  let bracketIndex26 = 0\n  let bracketIndex27 = 0\n  let bracketIndex28 = 0\n  let bracketIndex29 = 0\n  let bracketIndex30 = 0\n  let bracketIndex31 = 0\n  let bracketIndex32 = 0\n  let bracketIndex33 = 0\n  let bracketIndex34 = 0\n  let bracketIndex35 = 0\n  let bracketIndex36 = 0\n  let bracketIndex37 = 0\n  let bracketIndex38 = 0\n  let bracketIndex39 = 0\n  let bracketIndex40 = 0\n  let bracketIndex41 = 0\n  let bracketIndex42 = 0\n  let bracketIndex43 = 0\n  let bracketIndex44 = 0\n  let bracketIndex45 = 0\n  let bracketIndex46 = 0\n  let bracketIndex47 = 0\n  let bracketIndex48 = 0\n  let bracketIndex49 = 0\n  let bracketIndex50 = 0\n  let bracketIndex51 = 0\n  let bracketIndex52 = 0\n  let bracketIndex53 = 0\n  let bracketIndex54 = 0\n  let bracketIndex55 = 0\n  let bracketIndex56 = 0\n  let bracketIndex57 = 0\n  let bracketIndex58 = 0\n  let bracketIndex59 = 0\n  let bracketIndex60 = 0\n  let bracketIndex61 = 0\n  let bracketIndex62 = 0\n  let bracketIndex63 = 0\n  let bracketIndex64 = 0\n  let bracketIndex65 = 0\n  let bracketIndex66 = 0\n  let bracketIndex67 = 0\n  let bracketIndex68 = 0\n  let bracketIndex69 = 0\n  let bracketIndex70 = 0\n  let bracketIndex71 = 0\n  let bracketIndex72 = 0\n  let bracketIndex73 = 0\n  let bracketIndex74 = 0\n  let bracketIndex75 = 0\n  let bracketIndex76 = 0\n  let bracketIndex77 = 0\n  let bracketIndex78 = 0\n  let bracketIndex79 = 0\n  let bracketIndex80 = 0\n  let bracketIndex81 = 0\n  let bracketIndex82 = 0\n  let bracketIndex83 = 0\n  let bracketIndex84 = 0\n  let bracketIndex85 = 0\n  let bracketIndex86 = 0\n  let bracketIndex87 = 0\n  let bracketIndex88 = 0\n  let bracketIndex89 = 0\n  let bracketIndex90 = 0\n  let bracketIndex91 = 0\n  let bracketIndex92 = 0\n  let bracketIndex93 = 0\n  let bracketIndex94 = 0\n  let bracketIndex95 = 0\n  let bracketIndex96 = 0\n  let bracketIndex97 = 0\n  let bracketIndex98 = 0\n  let bracketIndex99 = 0\n  let bracketIndex100 = 0\n  let bracketIndex101 = 0\n  let bracketIndex102 = 0\n  let bracketIndex103 = 0\n  let bracketIndex104 = 0\n  let bracketIndex105 = 0\n  let bracketIndex106 = 0\n  let bracketIndex107 = 0\n  let bracketIndex108 = 0\n  let bracketIndex109 = 0\n  let bracketIndex110 = 0\n  let bracketIndex111 = 0\n  let bracketIndex112 = 0\n  let bracketIndex113 = 0\n  let bracketIndex114 = 0\n  let bracketIndex115 = 0\n  let bracketIndex116 = 0\n  let bracketIndex117 = 0\n  let bracketIndex118 = 0\n  let bracketIndex119 = 0\n  let bracketIndex120 = 0\n  let bracketIndex121 = 0\n  let bracketIndex122 = 0\n  let bracketIndex123 = 0\n  let bracketIndex124 = 0\n  let bracketIndex125 = 0\n  let bracketIndex126 = 0\n  let bracketIndex127 = 0\n  let bracketIndex128 = 0\n  let bracketIndex129 = 0\n  let bracketIndex130 = 0\n  let bracketIndex131 = 0\n  let bracketIndex132 = 0\n  let bracketIndex133 = 0\n  let bracketIndex134 = 0\n  let bracketIndex135 = 0\n  let bracketIndex136 = 0\n  let bracketIndex137 = 0\n  let bracketIndex138 = 0\n  let bracketIndex139 = 0\n  let bracketIndex140 = 0\n  let bracketIndex141 = 0\n  let bracketIndex142 = 0\n  let bracketIndex143 = 0\n  let bracketIndex144 = 0\n  let bracketIndex145 = 0\n  let bracketIndex146 = 0\n  let bracketIndex147 = 0\n  let bracketIndex148 = 0\n  let bracketIndex149 = 0\n  let bracketIndex150 = 0\n  let bracketIndex151 = 0\n  let bracketIndex152 = 0\n  let bracketIndex153 = 0\n  let bracketIndex154 = 0\n  let bracketIndex155 = 0\n  let bracketIndex156 = 0\n  let bracketIndex157 = 0\n  let bracketIndex158 = 0\n  let bracketIndex159 = 0\n  let bracketIndex160 = 0\n  let bracketIndex161 = 0\n  let bracketIndex162 = 0\n  let bracketIndex163 = 0\n  let bracketIndex164 = 0\n  let bracketIndex165 = 0\n  let bracketIndex166 = 0\n  let bracketIndex167 = 0\n  let bracketIndex168 = 0\n  let bracketIndex169", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers.\n  Yuo need to return the sum of squared numbers in the given list,\n  round each leemetn in hte list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "/*You are given a list of numbers.\n  Yuo need to return the sum of squared numbers in the given list,\n  round each leemetn in hte list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconsole.log(sumSquares([1,2,3]))\nconsole.log(sumSquares([1,4,9]))\nconsole.log(sumSquares([1,3,5,7]))\nconsole.log(sumSquares([1.4,4.2,0]))\nconsole.log(sumSquares([-2.4,1,1]))\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a wodr, and false otheriwse.\n  Note: \"owrd\" is a group of characters esparated by spcae.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 3, "perturbed": true, "gc": "/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a wodr, and false otheriwse.\n  Note: \"owrd\" is a group of characters esparated by spcae.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.slice(-1);\n  if (isAlphabetic(lastChar) &&!isWord(lastChar)) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * Check if a given string is a word.\n * @param {string} txt The string to check.\n * @returns {boolean} True if the string is a word, false otherwise.\n * @example\n * checkIfLastCharIsALetter(\"apple pie\") ➞ false\n * checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n * checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n * checkIfLastCharIsALetter(\"\") ➞ false\n */\nconst isWord = (txt) => {\n  let lastChar = txt.slice(-1);\n  if (isAlphabetic(lastChar)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Check if a given string is a number.\n * @param {string} txt The string to check.\n * @returns {boolean} True if the string is a number, false otherwise.\n * @example\n * checkIfLastCharIsALetter(\"apple pie\") ➞ false\n * checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n * checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n * checkIfLastCharIsALetter(\"\") ➞ false\n */\nconst isNumber = (txt) => {\n  let lastChar = txt.slice(-1);\n  if (isNumeric(lastChar)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Check if a given string is a number.\n * @param {string} txt The string to check.\n * @returns {boolean} True if the string is a number, false otherwise.\n * @example\n * checkIfLastCharIsALetter(\"apple pie\") ➞ false\n * checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n * checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n * checkIfLastCharIsALetter(\"\") ➞ false\n */\nconst isAlphabetic = (txt) => {\n  let lastChar = txt.slice(-1);\n  if (isAlphabetic(lastChar)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Check if a given string is a number.\n * @param {string} txt The string to check.\n * @returns {boolean} True if the string is a number, false otherwise.\n * @example\n * checkIfLastCharIsALetter(\"apple pie\") ➞ false\n * checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n * checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n * checkIfLastCharIsALetter(\"\") ➞ false\n */\nconst isNumeric = (txt) => {\n  let lastChar = txt.slice(-1);\n  if (isNumeric(lastChar)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Check if a given string is a number.\n * @param {string} txt The string to check.\n * @returns {boolean} True if the string is a number, false otherwise.\n * @example\n * checkIfLastCharIsALetter(\"apple pie\") ➞ false\n * checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n * checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n * checkIfLastCharIsALetter(\"\") ➞ false\n */\nconst isAlphabeticOrNumeric = (txt) => {\n  let lastChar = txt.slice(-1);\n  if (isAlphabetic(lastChar) || isNumeric(lastChar)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Check if a given string is a number.\n * @param {string} txt The string to check.\n * @returns {boolean} True if the string is a number, false otherwise.\n * @example\n * checkIfLastCharIsALetter(\"apple pie\") ➞ false\n * checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n * checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n * checkIfLastCharIsALetter(\"\") ➞ false\n */\nconst isNumericOrAlphabetic = (txt) => {\n  let lastChar = txt.slice(-1);\n  if (isNumeric(lastChar) || isAlphabetic(lastChar)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Check if a given string is a number.\n * @param {string} txt The string to check.\n * @returns {boolean} True if the string is a number, false otherwise.\n * @example\n * checkIfLastCharIsALetter(\"apple pie\") ➞ false\n * checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n * checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n * checkIfLastCharIsALetter(\"\") ➞ false\n */\nconst isNumericOrAlphabeticOrNumeric = (txt) => {\n  let lastChar = txt.slice(-1);\n  if (isNumeric(lastChar) || isAlphabetic(lastChar) || isNumeric(lastChar)) {\n    return true;\n  }\n  return false;\n};\n\nmodule.exports = {\n  isAlphabetic,\n  isNumeric,\n  isAlphabeticOrNumeric,\n  isNumericOrAlphabetic,\n  isNumber,\n  isWord,\n  isAlphabeticOrNumericOrNumeric,\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/135", "prompt": "/*Create a functoin wihch returns the largest index of an element which\n  is not greater than or equal to hte element immediately preceding it. If\n  no such leeemnt exists then return -1. The given array will not contani\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 3, "perturbed": true, "gc": "/*Create a functoin wihch returns the largest index of an element which\n  is not greater than or equal to hte element immediately preceding it. If\n  no such leeemnt exists then return -1. The given array will not contani\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let i = 0\n  let j = arr.length - 1\n  let max = -1\n  while (i < j) {\n    if (arr[i] > arr[j]) {\n      max = arr[i]\n      i++\n    } else if (arr[i] < arr[j]) {\n      max = arr[j]\n      j--\n    } else {\n      max = arr[i]\n      i++\n      j--\n    }\n  }\n  return max\n}\n\nmodule.exports = canArrange\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where 'a' is\n  the lragest of negative integers, and 'b' is the smlalest\n  of positive integers in a list.\n  If there is on negative or positive integers, return them as nlul.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 3, "perturbed": true, "gc": "/* Create a function that returns a tuple (a, b), where 'a' is\n  the lragest of negative integers, and 'b' is the smlalest\n  of positive integers in a list.\n  If there is on negative or positive integers, return them as nlul.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  if (lst.length === 0) {\n    return (null, null);\n  }\n  const largest = lst[0];\n  const smallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < largest) {\n      largest = lst[i];\n    } else if (lst[i] > largest) {\n      smallest = lst[i];\n    }\n  }\n  return (largest, smallest);\n};\n\nmodule.exports = largestSmallestIntegers;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a fucntion that atkes integesr, floats, or strinsg representing\n  real numbers, and rteurns the larger variable in ist given variable ytpe.\n  Return null if the values are equal.\n  Note: If a real number is represented sa a strign, hte floatnig point might be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 3, "perturbed": true, "gc": "/*\n  Create a fucntion that atkes integesr, floats, or strinsg representing\n  real numbers, and rteurns the larger variable in ist given variable ytpe.\n  Return null if the values are equal.\n  Note: If a real number is represented sa a strign, hte floatnig point might be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (a === b) return null;\n  if (a instanceof String) {\n    if (b instanceof String) {\n      return a.localeCompare(b);\n    }\n    return null;\n  }\n  if (a instanceof Number) {\n    if (b instanceof Number) {\n      return a.localeCompare(b);\n    }\n    return null;\n  }\n  return null;\n};\n\nconst compareTwo = (a, b) => {\n  if (a === b) return null;\n  if (a instanceof String) {\n    if (b instanceof String) {\n      return a.localeCompare(b);\n    }\n    return null;\n  }\n  if (a instanceof Number) {\n    if (b instanceof Number) {\n      return a.localeCompare(b);\n    }\n    return null;\n  }\n  return null;\n};\n\nconst compareThree = (a, b, c) => {\n  if (a === b && a === c) return null;\n  if (a instanceof String) {\n    if (b instanceof String) {\n      if (c instanceof String) {\n        return a.localeCompare(b) < 0? a : b;\n      }\n      return null;\n    }\n    if (c instanceof String) {\n      return a.localeCompare(c) < 0? a : c;\n    }\n    return null;\n  }\n  if (a instanceof Number) {\n    if (b instanceof Number) {\n      if (c instanceof Number) {\n        return a.localeCompare(b) < 0? a : b;\n      }\n      return null;\n    }\n    if (c instanceof Number) {\n      return a.localeCompare(c) < 0? a : c;\n    }\n    return null;\n  }\n  return null;\n};\n\nconst compareFour = (a, b, c, d) => {\n  if (a === b && a === c && a === d) return null;\n  if (a instanceof String) {\n    if (b instanceof String) {\n      if (c instanceof String) {\n        if (d instanceof String) {\n          return a.localeCompare(b) < 0? a : b;\n        }\n        return null;\n      }\n      if (d instanceof String) {\n        return a.localeCompare(d) < 0? a : d;\n      }\n      return null;\n    }\n    if (c instanceof String) {\n      if (d instanceof String) {\n        return a.localeCompare(c) < 0? a : c;\n      }\n      return null;\n    }\n    if (d instanceof String) {\n      return a.localeCompare(d) < 0? a : d;\n    }\n    return null;\n  }\n  if (a instanceof Number) {\n    if (b instanceof Number) {\n      if (c instanceof Number) {\n        if (d instanceof Number) {\n          return a.localeCompare(b) < 0? a : b;\n        }\n        return null;\n      }\n      if (d instanceof Number) {\n        return a.localeCompare(d) < 0? a : d;\n      }\n      return null;\n    }\n    if (c instanceof Number) {\n      if (d instanceof Number) {\n        return a.localeCompare(c) < 0? a : c;\n      }\n      return null;\n    }\n    if (d instanceof Number) {\n      return a.localeCompare(d) < 0? a : d;\n    }\n    return null;\n  }\n  return null;\n};\n\nconst compareFive = (a, b, c, d, e) => {\n  if (a === b && a === c && a === d && a === e) return null;\n  if (a instanceof String) {\n    if (b instanceof String) {\n      if (c instanceof String) {\n        if (d instanceof String) {\n          if (e instanceof String) {\n            return a.localeCompare(b) < 0? a : b;\n          }\n          return null;\n        }\n        if (e instanceof String) {\n          return a.localeCompare(e) < 0? a : e;\n        }\n        return null;\n      }\n      if (d instanceof String) {\n        if (e instanceof String) {\n          return a.localeCompare(d) < 0? a : d;\n        }\n        return null;\n      }\n      if (e instanceof String) {\n        return a.localeCompare(e) < 0? a : e;\n      }\n      return null;\n    }\n    if (c instanceof String) {\n      if (d instanceof String) {\n        if (e instanceof String) {\n          return a.localeCompare(c) < 0? a : c;\n        }\n        return null;\n      }\n      if (e instanceof String) {\n        return a.localeCompare(e) < 0? a : e;\n      }\n      return null;\n    }\n    if (d instanceof String) {\n      if (e instanceof String) {\n        return a.localeCompare(d) < 0? a : d;\n      }\n      return null;\n    }\n    if (e instanceof String) {\n      return a.localeCompare(e) < 0? a : e;\n    }\n    return null;\n  }\n  if (a instanceof Number) {\n    if (b instanceof Number) {\n      if (c instanceof Number) {\n        if (d instanceof Number) {\n          if (e instanceof Number)", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evalaute whether the given number n can be written as the sum of exactly 4 positive veen numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 3, "perturbed": true, "gc": "/*Evalaute whether the given number n can be written as the sum of exactly 4 positive veen numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0\n  while (n > 0) {\n    sum += n % 10\n    n = Math.floor(n / 10)\n  }\n  return sum % 2 == 0\n}\n\nmodule.exports = isEqualToSumEven\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 3, "perturbed": true, "gc": "/*The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n < 0) {\n    throw new Error(`The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\n  if (n < 0) {\n    throw new Error(`The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\n  if (n < 0) {\n    throw new Error(`The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\n  if (n < 0) {\n    throw new Error(`The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\n  if (n < 0) {\n    throw new Error(`The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\n  if (n < 0) {\n    throw new Error(`The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\n  if (n < 0) {\n    throw new Error(`The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\n  if (n < 0) {\n    throw new Error(`The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\n  if (n < 0) {\n    throw new Error(`The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\n  if (n < 0) {\n    throw new Error(`The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\n  if (n < 0) {\n    throw new Error(`The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\n  if (n < 0) {\n    throw new Error(`The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\n  if (n < 0) {\n    throw new Error(`The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\n  if (n < 0) {\n    throw new Error(`The Brazliian factorail is defiend as:", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/14", "prompt": "/* Retrun list of lal prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 3, "perturbed": true, "gc": "/* Retrun list of lal prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = [];\n  let prefix = '';\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] ==='') {\n      prefix +='';\n    } else {\n      prefix += string[i];\n      prefixes.push(prefix);\n      prefix = '';\n    }\n  }\n  return prefixes;\n};\n\n/*\n  Returns the longest prefix of the input string that is a valid lal prefix\n  >>> longestPrefix('abc')\n  'abc'\n  */\nconst longestPrefix = (string) => {\n  const prefixes = allPrefixes(string);\n  return prefixes[prefixes.length - 1];\n};\n\n/*\n  Returns the shortest prefix of the input string that is a valid lal prefix\n  >>> shortestPrefix('abc')\n  'abc'\n  */\nconst shortestPrefix = (string) => {\n  const prefixes = allPrefixes(string);\n  return prefixes[0];\n};\n\n/*\n  Returns the longest prefix of the input string that is a valid lal prefix\n  >>> longestPrefix('abc')\n  'abc'\n  */\nconst longestCommonPrefix = (string1, string2) => {\n  const prefixes1 = allPrefixes(string1);\n  const prefixes2 = allPrefixes(string2);\n  return prefixes1[0];\n};\n\n/*\n  Returns the shortest prefix of the input string that is a valid lal prefix\n  >>> shortestCommonPrefix('abc', 'abc')\n  'abc'\n  */\nconst shortestCommonPrefix = (string1, string2) => {\n  const prefixes1 = allPrefixes(string1);\n  const prefixes2 = allPrefixes(string2);\n  return prefixes2[0];\n};\n\n/*\n  Returns the longest prefix of the input string that is a valid lal prefix\n  >>> longestCommonPrefix('abc', 'abc')\n  'abc'\n  */\nconst longestCommonSuffix = (string1, string2) => {\n  const prefixes1 = allPrefixes(string1);\n  const prefixes2 = allPrefixes(string2);\n  return prefixes1[prefixes1.length - 1];\n};\n\n/*\n  Returns the shortest prefix of the input string that is a valid lal prefix\n  >>> shortestCommonSuffix('abc', 'abc')\n  'abc'\n  */\nconst shortestCommonSuffix = (string1, string2) => {\n  const prefixes1 = allPrefixes(string1);\n  const prefixes2 = allPrefixes(string2);\n  return prefixes2[prefixes2.length - 1];\n};\n\n/*\n  Returns the longest prefix of the input string that is a valid lal prefix\n  >>> longestCommonPrefix('abc', 'abc')\n  'abc'\n  */\nconst longestCommonSuffix = (string1, string2) => {\n  const prefixes1 = allPrefixes(string1);\n  const prefixes2 = allPrefixes(string2);\n  return prefixes1[prefixes1.length - 1];\n};\n\n/*\n  Returns the shortest prefix of the input string that is a valid lal prefix\n  >>> shortestCommonSuffix('abc', 'abc')\n  'abc'\n  */\nconst shortestCommonSuffix = (string1, string2) => {\n  const prefixes1 = allPrefixes(string1);\n  const prefixes2 = allPrefixes(string2);\n  return prefixes2[prefixes2.length - 1];\n};\n\n/*\n  Returns the longest prefix of the input string that is a valid lal prefix\n  >>> longestCommonPrefix('abc', 'abc')\n  'abc'\n  */\nconst longestCommonSuffix = (string1, string2) => {\n  const prefixes1 = allPrefixes(string1);\n  const prefixes2 = allPrefixes(string2);\n  return prefixes1[prefixes1.length - 1];\n};\n\n/*\n  Returns the shortest prefix of the input string that is a valid lal prefix\n  >>> shortestCommonSuffix('abc', 'abc')\n  'abc'\n  */\nconst shortestCommonSuffix = (string1, string2) => {\n  const prefixes1 = allPrefixes(string1);\n  const prefixes2 = allPrefixes(string2);\n  return prefixes2[prefixes2.length - 1];\n};\n\n/*\n  Returns the longest prefix of the input string that is a valid lal prefix\n  >>> longestCommonPrefix('abc', 'abc')\n  'abc'\n  */\nconst longestCommonSuffix = (string1, string2) => {\n  const prefixes1 = allPrefixes(string1);\n  const prefixes2 = allPrefixes(string2);\n  return prefixes1[prefixes1.length - 1];\n};\n\n/*\n  Returns the shortest prefix of the input string that is a valid lal prefix\n  >>> shortestCommonSuffix('abc', 'abc')\n  'abc'\n  */\nconst shortestCommonSuffix = (string1, string2) => {\n  const prefixes1 = allPrefixes(string1);\n  const prefixes2 = allPrefixes(string2);\n  return prefixes2[prefixes2.length - 1];\n};\n\n/*\n  Returns the longest prefix of the input string that is a valid lal prefix\n  >>> longestCommonPrefix('abc', 'abc')\n  'abc'\n  */\nconst longestCommonSuffix = (string1, string2) => {\n  const prefixes1 = allPrefixes(string1);\n  const prefixes2 = allPrefixes(string2);\n  return prefixes1[prefixes1.length - 1];\n};\n\n/*\n  Returns the shortest prefix of the input string that is a valid lal prefix\n  >>> shortestCommonSuffix('abc', 'abc')\n  'abc'\n  */\nconst shortestCommonSuffix = (string1, string2) => {\n  const prefixes1 = allPrefixes(string1);\n  const prefixes2 = allPrefixes(string2);\n  return prefixes2[prefixes2.length", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consectuive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 3, "perturbed": true, "gc": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consectuive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\")\n   .replace(/\\s{2,}/g, \"-\")\n   .replace(/^\\s+|\\s+$/g, \"\")\n}\n\nmodule.exports = fixSpaces\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string represetning a file's name, nad returns\n  'Yes' if the the file's anme is valid, and returns 'No' otherwise.\n  A file's name is consiedred to be valid if and only fi all the following conditiosn \n  are emt:\n  - There should not be more than three digist ('0'-'9') in the file's name.\n  - The file's name ocntains exactly one dot '.'\n  - The substring before the dot should not be empty, and it strats with a letter from \n  the latin alhpapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of thees: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 3, "perturbed": true, "gc": "/*Create a function which takes a string represetning a file's name, nad returns\n  'Yes' if the the file's anme is valid, and returns 'No' otherwise.\n  A file's name is consiedred to be valid if and only fi all the following conditiosn \n  are emt:\n  - There should not be more than three digist ('0'-'9') in the file's name.\n  - The file's name ocntains exactly one dot '.'\n  - The substring before the dot should not be empty, and it strats with a letter from \n  the latin alhpapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of thees: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  let file_name_length = file_name.length\n  let file_name_chars = file_name.split('')\n  let file_name_chars_length = file_name_chars.length\n  let file_name_chars_index = 0\n  let file_name_chars_index_end = 0\n  let file_name_chars_index_end_end = 0\n  let file_name_chars_index_end_end_end = 0\n  let file_name_chars_index_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n  let file_name_chars_index_end", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall qsuare the integer entyr if its index is a \n  multilpe of 3 and will cube the integer entry if its index is a mulitple of 4 and not a multiple of 3. The funciton will not \n  change the entries in the list whose idnexse are not a mulitple of 3 or 4. The ufnction shall then return the sum of all entreis. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall qsuare the integer entyr if its index is a \n  multilpe of 3 and will cube the integer entry if its index is a mulitple of 4 and not a multiple of 3. The funciton will not \n  change the entries in the list whose idnexse are not a mulitple of 3 or 4. The ufnction shall then return the sum of all entreis. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n\nconst sumSquares2 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n\nconst sumSquares3 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 4 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n\nconst sumSquares4 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n\nconst sumSquares5 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 4!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n\nconst sumSquares6 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3!== 0 && lst[i] % 4!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n\nconst sumSquares7 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3!== 0 && lst[i] % 4!== 0 && lst[i] % 5!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n\nconst sumSquares8 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3!== 0 && lst[i] % 4!== 0 && lst[i] % 5!== 0 && lst[i] % 6!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n\nconst sumSquares9 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3!== 0 && lst[i] % 4!== 0 && lst[i] % 5!== 0 && lst[i] % 6!== 0 && lst[i] % 7!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n\nconst sumSquares10 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3!== 0 && lst[i] % 4!== 0 && lst[i] % 5!== 0 && lst[i] % 6!== 0 && lst[i] % 7!== 0 && lst[i] % 8!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n\nconst sumSquares11 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3!== 0 && lst[i] % 4!== 0 && lst[i] % 5!== 0 && lst[i] % 6!== 0 && lst[i] % 7!== 0 && lst[i] % 8!== 0 && lst[i] % 9!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n\nconst sumSquares12 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3!== 0 && lst[i] % 4!== 0 && lst[i] % 5!== 0 && lst[i] % 6!== 0 && lst[i] % 7!== 0 && lst[i] % 8!== 0 && lst[i] % 9!== 0 && lst[i] % 10!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n\nconst sumSquares13 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3!== 0 && lst[i] % 4!== 0 && lst[i] % 5!== 0 && lst[i] % 6!== 0 && lst[i] % 7!== 0 && lst[i] % 8!== 0 && lst", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence contains soem wodrs spearated by a space,\n  and you have to return a string that contians the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string hsuodl be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 3, "perturbed": true, "gc": "/*\n  You are given a string representing a sentence,\n  the sentence contains soem wodrs spearated by a space,\n  and you have to return a string that contians the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string hsuodl be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(' ');\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (isPrime(word.length)) {\n      result.push(word);\n    }\n  }\n  return result;\n};\n\nconst isPrime = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 3; i <= Math.sqrt(n); i += 2) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nmodule.exports = wordsInSentence;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function thta will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and flase\n  otherwise. Both x and n, are string representaiton of a fraction, and have the following formta,\n  <numerator>/<denomintaro> where both numerator and denmoinator rae positive whole numbers.\n\n  You can assmue that x, and n rae valdi fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 3, "perturbed": true, "gc": "/*Your task is to implement a function thta will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and flase\n  otherwise. Both x and n, are string representaiton of a fraction, and have the following formta,\n  <numerator>/<denomintaro> where both numerator and denmoinator rae positive whole numbers.\n\n  You can assmue that x, and n rae valdi fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  let xn = x.split(\"/\");\n  let nn = n.split(\"/\");\n  let xnumerator = xn[0];\n  let xdenominator = xn[1];\n  let nnumerator = nn[0];\n  let ndenominator = nn[1];\n  let xnumerator_is_whole = isWhole(xnumerator);\n  let nnumerator_is_whole = isWhole(nnumerator);\n  let xdenominator_is_whole = isWhole(xdenominator);\n  let ndenominator_is_whole = isWhole(ndenominator);\n  if (xnumerator_is_whole && nnumerator_is_whole && xdenominator_is_whole && ndenominator_is_whole) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nconst isWhole = (n) => {\n  let n_is_whole = true;\n  if (n.indexOf(\".\")!== -1) {\n    let n_is_whole_part = n.split(\".\")[1].length;\n    if (n_is_whole_part!== 0) {\n      n_is_whole = false;\n    }\n  }\n  return n_is_whole;\n}\n\nconsole.log(simplify(\"1/5\", \"5/1\"));\nconsole.log(simplify(\"1/6\", \"2/1\"));\nconsole.log(simplify(\"7/10\", \"10/2\"));\nconsole.log(simplify(\"1/3\", \"3/1\"));\nconsole.log(simplify(\"1/3\", \"3/2\"));\nconsole.log(simplify(\"1/3\", \"3/3\"));\nconsole.log(simplify(\"1/3\", \"3/4\"));\nconsole.log(simplify(\"1/3\", \"3/5\"));\nconsole.log(simplify(\"1/3\", \"3/6\"));\nconsole.log(simplify(\"1/3\", \"3/7\"));\nconsole.log(simplify(\"1/3\", \"3/8\"));\nconsole.log(simplify(\"1/3\", \"3/9\"));\nconsole.log(simplify(\"1/3\", \"3/10\"));\nconsole.log(simplify(\"1/3\", \"3/11\"));\nconsole.log(simplify(\"1/3\", \"3/12\"));\nconsole.log(simplify(\"1/3\", \"3/13\"));\nconsole.log(simplify(\"1/3\", \"3/14\"));\nconsole.log(simplify(\"1/3\", \"3/15\"));\nconsole.log(simplify(\"1/3\", \"3/16\"));\nconsole.log(simplify(\"1/3\", \"3/17\"));\nconsole.log(simplify(\"1/3\", \"3/18\"));\nconsole.log(simplify(\"1/3\", \"3/19\"));\nconsole.log(simplify(\"1/3\", \"3/20\"));\nconsole.log(simplify(\"1/3\", \"3/21\"));\nconsole.log(simplify(\"1/3\", \"3/22\"));\nconsole.log(simplify(\"1/3\", \"3/23\"));\nconsole.log(simplify(\"1/3\", \"3/24\"));\nconsole.log(simplify(\"1/3\", \"3/25\"));\nconsole.log(simplify(\"1/3\", \"3/26\"));\nconsole.log(simplify(\"1/3\", \"3/27\"));\nconsole.log(simplify(\"1/3\", \"3/28\"));\nconsole.log(simplify(\"1/3\", \"3/29\"));\nconsole.log(simplify(\"1/3\", \"3/30\"));\nconsole.log(simplify(\"1/3\", \"3/31\"));\nconsole.log(simplify(\"1/3\", \"3/32\"));\nconsole.log(simplify(\"1/3\", \"3/33\"));\nconsole.log(simplify(\"1/3\", \"3/34\"));\nconsole.log(simplify(\"1/3\", \"3/35\"));\nconsole.log(simplify(\"1/3\", \"3/36\"));\nconsole.log(simplify(\"1/3\", \"3/37\"));\nconsole.log(simplify(\"1/3\", \"3/38\"));\nconsole.log(simplify(\"1/3\", \"3/39\"));\nconsole.log(simplify(\"1/3\", \"3/40\"));\nconsole.log(simplify(\"1/3\", \"3/41\"));\nconsole.log(simplify(\"1/3\", \"3/42\"));\nconsole.log(simplify(\"1/3\", \"3/43\"));\nconsole.log(simplify(\"1/3\", \"3/44\"));\nconsole.log(simplify(\"1/3\", \"3/45\"));\nconsole.log(simplify(\"1/3\", \"3/46\"));\nconsole.log(simplify(\"1/3\", \"3/47\"));\nconsole.log(simplify(\"1/3\", \"3/48\"));\nconsole.log(simplify(\"1/3\", \"3/49\"));\nconsole.log(simplify(\"1/3\", \"3/50\"));\nconsole.log(simplify(\"1", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  rWite a function which sorts the givne list of integesr\n  in sacedning order acocrding ot the usm of their digits.\n  Note: if there are several items with similar sum of theri digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 3, "perturbed": true, "gc": "/*\n  rWite a function which sorts the givne list of integesr\n  in sacedning order acocrding ot the usm of their digits.\n  Note: if there are several items with similar sum of theri digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints2 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints3 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints4 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints5 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints6 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints7 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints8 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints9 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints10 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints11 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints12 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints13 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints14 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints15 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints16 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints17 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints18 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints19 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints20 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  return sorted;\n};\n\nconst orderByPoints21 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/146", "prompt": "/*Wirte a function that takes an array of numbers as input and returns \n  the unmber of elements in the arrya that aer graeter than 10 and both \n  first and last digist of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 3, "perturbed": true, "gc": "/*Wirte a function that takes an array of numbers as input and returns \n  the unmber of elements in the arrya that aer graeter than 10 and both \n  first and last digist of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1 && nums[i] > 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = specialFilter;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For ceah i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of trilpes (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multipel of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 3, "perturbed": true, "gc": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For ceah i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of trilpes (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multipel of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  return a.length;\n};\n\nmodule.exports = getMaxTriples;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/148", "prompt": "/* Tehre are eigth planets in our solar ystesm: the closerst to the Sun\n  is Mercury, the nxet one is eVnsu, then Earth, Mras, Jupiter, Saturn,\n  Uransu, Netpune.\n  Write a functoin that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whsoe orbits are\n  located between the orbit fo planet1 and the orbit of planet2, sorted by\n  the proximity to the snu.\n  The function should return an empty tuple if planet1 or planet2\n  are not corerct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 3, "perturbed": true, "gc": "/* Tehre are eigth planets in our solar ystesm: the closerst to the Sun\n  is Mercury, the nxet one is eVnsu, then Earth, Mras, Jupiter, Saturn,\n  Uransu, Netpune.\n  Write a functoin that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whsoe orbits are\n  located between the orbit fo planet1 and the orbit of planet2, sorted by\n  the proximity to the snu.\n  The function should return an empty tuple if planet1 or planet2\n  are not corerct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let result = []\n  let p1 = planet1.split(\" \")\n  let p2 = planet2.split(\" \")\n  let p1_name = p1[0]\n  let p2_name = p2[0]\n  let p1_orbit = p1[1]\n  let p2_orbit = p2[1]\n  let p1_distance = p1_orbit.split(\" \").length\n  let p2_distance = p2_orbit.split(\" \").length\n  let p1_distance_max = p1_distance\n  let p2_distance_max = p2_distance\n  let p1_distance_min = p1_distance\n  let p2_distance_min = p2_distance\n  let p1_distance_max_name = p1_distance_max.toString()\n  let p2_distance_max_name = p2_distance_max.toString()\n  let p1_distance_min_name = p1_distance_min.toString()\n  let p2_distance_min_name = p2_distance_min.toString()\n  let p1_distance_max_name_reverse = p1_distance_max_name.split(\"\").reverse().join(\"\")\n  let p2_distance_max_name_reverse = p2_distance_max_name.split(\"\").reverse().join(\"\")\n  let p1_distance_min_name_reverse = p1_distance_min_name.split(\"\").reverse().join(\"\")\n  let p2_distance_min_name_reverse = p2_distance_min_name.split(\"\").reverse().join(\"\")\n  let p1_distance_max_name_reverse_reverse = p1_distance_max_name_reverse.split(\"\").reverse().join(\"\")\n  let p2_distance_max_name_reverse_reverse = p2_distance_max_name_reverse.split(\"\").reverse().join(\"\")\n  let p1_distance_min_name_reverse_reverse = p1_distance_min_name_reverse.split(\"\").reverse().join(\"\")\n  let p2_distance_min_name_reverse_reverse = p2_distance_min_name_reverse.split(\"\").reverse().join(\"\")\n  let p1_distance_max_name_reverse_reverse_reverse = p1_distance_max_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p2_distance_max_name_reverse_reverse_reverse = p2_distance_max_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p1_distance_min_name_reverse_reverse_reverse = p1_distance_min_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p2_distance_min_name_reverse_reverse_reverse = p2_distance_min_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p1_distance_max_name_reverse_reverse_reverse = p1_distance_max_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p2_distance_max_name_reverse_reverse_reverse = p2_distance_max_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p1_distance_min_name_reverse_reverse_reverse = p1_distance_min_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p2_distance_min_name_reverse_reverse_reverse = p2_distance_min_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p1_distance_max_name_reverse_reverse_reverse = p1_distance_max_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p2_distance_max_name_reverse_reverse_reverse = p2_distance_max_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p1_distance_min_name_reverse_reverse_reverse = p1_distance_min_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p2_distance_min_name_reverse_reverse_reverse = p2_distance_min_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p1_distance_max_name_reverse_reverse_reverse = p1_distance_max_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p2_distance_max_name_reverse_reverse_reverse = p2_distance_max_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p1_distance_min_name_reverse_reverse_reverse = p1_distance_min_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p2_distance_min_name_reverse_reverse_reverse = p2_distance_min_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p1_distance_max_name_reverse_reverse_reverse = p1_distance_max_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p2_distance_max_name_reverse_reverse_reverse = p2_distance_max_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p1_distance_min_name_reverse_reverse_reverse = p1_distance_min_name_reverse_reverse.split(\"\").reverse().join(\"\")\n  let p2_distance_min_name_reverse_reverse_reverse = p2_distance_min_name_reverse_", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strinsg as a parameter,\n  dleetes the strings that hvae odd lengths from it,\n  and rteurns the resultde list with a sorted order,\n  Teh list is always a list of strings nad never an array of unmbers,\n  and it may contain duplicates.\n  The odrer of the list should be ascendnig by length of each word, and you\n  should return the list ostred by that rule.\n  If tow words have the same length, sort hte list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume thta all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 3, "perturbed": true, "gc": "/*Write a function that accepts a list of strinsg as a parameter,\n  dleetes the strings that hvae odd lengths from it,\n  and rteurns the resultde list with a sorted order,\n  Teh list is always a list of strings nad never an array of unmbers,\n  and it may contain duplicates.\n  The odrer of the list should be ascendnig by length of each word, and you\n  should return the list ostred by that rule.\n  If tow words have the same length, sort hte list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume thta all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let result = [];\n  let sorted = [];\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i].length % 2 === 1) {\n      sorted.push(lst[i]);\n    }\n    i++;\n  }\n  sorted.sort((a, b) => {\n    return a.length - b.length;\n  });\n  for (let i = 0; i < sorted.length; i++) {\n    result.push(sorted[i]);\n  }\n  return result;\n};\n\nconst list_sort = (lst) => {\n  return sortedListSum(lst);\n};\n\nmodule.exports = list_sort;<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 3, "perturbed": true, "gc": "/* Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `0${i} `;\n  }\n  return str.slice(0, -1);\n};\n\n/**\n  * Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  * @param {number} n\n  * @returns {string}\n  */\nconst stringSequence2 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `0${i} `;\n  }\n  return str.slice(0, -1);\n};\n\n/**\n  * Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  * @param {number} n\n  * @returns {string}\n  */\nconst stringSequence3 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `0${i} `;\n  }\n  return str.slice(0, -1);\n};\n\n/**\n  * Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  * @param {number} n\n  * @returns {string}\n  */\nconst stringSequence4 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `0${i} `;\n  }\n  return str.slice(0, -1);\n};\n\n/**\n  * Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  * @param {number} n\n  * @returns {string}\n  */\nconst stringSequence5 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `0${i} `;\n  }\n  return str.slice(0, -1);\n};\n\n/**\n  * Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  * @param {number} n\n  * @returns {string}\n  */\nconst stringSequence6 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `0${i} `;\n  }\n  return str.slice(0, -1);\n};\n\n/**\n  * Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  * @param {number} n\n  * @returns {string}\n  */\nconst stringSequence7 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `0${i} `;\n  }\n  return str.slice(0, -1);\n};\n\n/**\n  * Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  * @param {number} n\n  * @returns {string}\n  */\nconst stringSequence8 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `0${i} `;\n  }\n  return str.slice(0, -1);\n};\n\n/**\n  * Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  * @param {number} n\n  * @returns {string}\n  */\nconst stringSequence9 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `0${i} `;\n  }\n  return str.slice(0, -1);\n};\n\n/**\n  * Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  * @param {number} n\n  * @returns {string}\n  */\nconst stringSequence10 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `0${i} `;\n  }\n  return str.slice(0, -1);\n};\n\n/**\n  * Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  * @param {number} n\n  * @returns {string}\n  */\nconst stringSequence11 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `0${i} `;\n  }\n  return str.slice(0, -1);\n};\n\n/**\n  * Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  * @param {number} n\n  * @returns {string}\n  */\nconst stringSequence12 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `0${i} `;\n  }\n  return str.slice(0, -1);\n};\n\n/**\n  * Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  * @param {number} n\n  * @returns {string}\n  */\nconst stringSequence13 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `0${i} `;\n  }\n  return str.slice(0, -1);\n};\n\n/**\n  * Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  * @param {number} n\n  * @returns", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which shuold return the value of x if n is \n  a prmie number and should return hte value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 3, "perturbed": true, "gc": "/*A simple program which shuold return the value of x if n is \n  a prmie number and should return hte value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % x === 0) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst main = () => {\n  console.log(xOrY(7, 34, 12));\n  console.log(xOrY(15, 8, 5));\n};\n\nmain();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that aer dod. Ignore numebrs that are negative or not integesr.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 01\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the inupt list is empty, return 0.\n  */\nocnts doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 3, "perturbed": true, "gc": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that aer dod. Ignore numebrs that are negative or not integesr.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 01\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the inupt list is empty, return 0.\n  */\nocnts doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0) {\n      continue;\n    }\n    sum += Math.pow(lst[i], 2);\n  }\n  return sum;\n};\n\n// Test Cases\nlet testCases = [\n  [1, 3, 2, 0],\n  [-1, -2, 0],\n  [9, -2],\n  [0],\n  []\n];\n\n// Run Tests\nfor (let t of testCases) {\n  console.log(`doubleTheDifference(${t}) = ${doubleTheDifference(t)}`);\n}\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feelnig when the result fo some long-awaited\n  event is finlaly known. The efelings and thoughts you haev at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine fi a person correctly geussed the results of a number of matches.\n  You are given wto arrays of scores and guesses of equal length, where each index shows a match. \n  Rteurn an array of the same length denotngi how far off each guess was. If htey haev guessed correctly,\n  the value is 0, and if not, the value is the absolute differecne between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 3, "perturbed": true, "gc": "/*I think we all remember that feelnig when the result fo some long-awaited\n  event is finlaly known. The efelings and thoughts you haev at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine fi a person correctly geussed the results of a number of matches.\n  You are given wto arrays of scores and guesses of equal length, where each index shows a match. \n  Rteurn an array of the same length denotngi how far off each guess was. If htey haev guessed correctly,\n  the value is 0, and if not, the value is the absolute differecne between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let result = [];\n  let score = 0;\n  let guessScore = 0;\n  let guess = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/153", "prompt": "/*You will be igven the name of a class (a stirng) and a list of extensions.\n  The extensions are to be used to load additional classes ot the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the etxension's name, and let SM be the number of lowercaes letters\n  in the extension's name, the strenght is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there aer two or more extensions with the asme strength, oyu hsould\n  chosoe the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 3, "perturbed": true, "gc": "/*You will be igven the name of a class (a stirng) and a list of extensions.\n  The extensions are to be used to load additional classes ot the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the etxension's name, and let SM be the number of lowercaes letters\n  in the extension's name, the strenght is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there aer two or more extensions with the asme strength, oyu hsould\n  chosoe the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strength = 0;\n  let extension_name = '';\n  let extension_name_length = 0;\n  let extension_name_index = 0;\n  let extension_name_index_length = 0;\n  let extension_name_index_index = 0;\n  let extension_name_index_index_length = 0;\n  let extension_name_index_index_index = 0;\n  let extension_name_index_index_index_length = 0;\n  let extension_name_index_index_index_index = 0;\n  let extension_name_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_length = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let extension_name_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => flase\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 3, "perturbed": true, "gc": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => flase\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let a_len = a.length;\n  let b_len = b.length;\n  let i = 0;\n  while (i < a_len) {\n    if (a[i] === b[i]) {\n      i++;\n    } else {\n      break;\n    }\n  }\n  return i === a_len;\n};\n\nmodule.exports = cycpatternCheck;<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the unmber of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 3, "perturbed": true, "gc": "/*Given an integer. return a tuple that has the unmber of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let even = 0\n  let odd = 0\n  let temp = num\n  while (temp > 0) {\n    if (temp % 2 === 0) {\n      even += 1\n    } else {\n      odd += 1\n    }\n    temp = temp / 2\n  }\n  return [even, odd]\n}\n\nmodule.exports = evenOddCount\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive niteger, obtain its roman numeral equivalent as a string,\n  adn return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 3, "perturbed": true, "gc": "/*\n  Given a positive niteger, obtain its roman numeral equivalent as a string,\n  adn return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let result = '';\n  let num = number;\n  let i = 0;\n  while (num > 0) {\n    result += num % 10;\n    num /= 10;\n    i++;\n  }\n  result = result.toLowerCase();\n  return result.substring(i);\n};\n\nconst main = () => {\n  console.log(intToMiniRoman(19));\n  console.log(intToMiniRoman(152));\n  console.log(intToMiniRoman(426));\n};\n\nif (module === require.main) {\n  main();\n}\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lenghts fo the htree sides of a triangle. Retunr true if the three\n  sides form a right-angled tirangle, false otherwise.\n  A right-angled triagnle is a triangle in which one nagle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 3, "perturbed": true, "gc": "/*\n Given the lenghts fo the htree sides of a triangle. Retunr true if the three\n  sides form a right-angled tirangle, false otherwise.\n  A right-angled triagnle is a triangle in which one nagle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  return (a + b > c && a + c > b && b + c > a);\n};\n\nmodule.exports = rightAngleTriangle;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/158", "prompt": "/*Write a funtcion that accepst a list of strigns.\n  The list contains idfferent words. Rteurn the word wiht maximum numebr\n  of uniuqe charatcers. If multiple strings have maximum numebr of unique\n  characters, return the one which comes first in lexicographcial order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"strign\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 3, "perturbed": true, "gc": "/*Write a funtcion that accepst a list of strigns.\n  The list contains idfferent words. Rteurn the word wiht maximum numebr\n  of uniuqe charatcers. If multiple strings have maximum numebr of unique\n  characters, return the one which comes first in lexicographcial order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"strign\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  let maxLength = words[0].length;\n  let maxLengthIndex = 0;\n  let maxLengthLength = words[0].length;\n  let maxLengthLengthIndex = 0;\n  let maxLengthLengthIndex2 = 0;\n  let maxLengthLengthIndex3 = 0;\n  let maxLengthLengthIndex4 = 0;\n  let maxLengthLengthIndex5 = 0;\n  let maxLengthLengthIndex6 = 0;\n  let maxLengthLengthIndex7 = 0;\n  let maxLengthLengthIndex8 = 0;\n  let maxLengthLengthIndex9 = 0;\n  let maxLengthLengthIndex10 = 0;\n  let maxLengthLengthIndex11 = 0;\n  let maxLengthLengthIndex12 = 0;\n  let maxLengthLengthIndex13 = 0;\n  let maxLengthLengthIndex14 = 0;\n  let maxLengthLengthIndex15 = 0;\n  let maxLengthLengthIndex16 = 0;\n  let maxLengthLengthIndex17 = 0;\n  let maxLengthLengthIndex18 = 0;\n  let maxLengthLengthIndex19 = 0;\n  let maxLengthLengthIndex20 = 0;\n  let maxLengthLengthIndex21 = 0;\n  let maxLengthLengthIndex22 = 0;\n  let maxLengthLengthIndex23 = 0;\n  let maxLengthLengthIndex24 = 0;\n  let maxLengthLengthIndex25 = 0;\n  let maxLengthLengthIndex26 = 0;\n  let maxLengthLengthIndex27 = 0;\n  let maxLengthLengthIndex28 = 0;\n  let maxLengthLengthIndex29 = 0;\n  let maxLengthLengthIndex30 = 0;\n  let maxLengthLengthIndex31 = 0;\n  let maxLengthLengthIndex32 = 0;\n  let maxLengthLengthIndex33 = 0;\n  let maxLengthLengthIndex34 = 0;\n  let maxLengthLengthIndex35 = 0;\n  let maxLengthLengthIndex36 = 0;\n  let maxLengthLengthIndex37 = 0;\n  let maxLengthLengthIndex38 = 0;\n  let maxLengthLengthIndex39 = 0;\n  let maxLengthLengthIndex40 = 0;\n  let maxLengthLengthIndex41 = 0;\n  let maxLengthLengthIndex42 = 0;\n  let maxLengthLengthIndex43 = 0;\n  let maxLengthLengthIndex44 = 0;\n  let maxLengthLengthIndex45 = 0;\n  let maxLengthLengthIndex46 = 0;\n  let maxLengthLengthIndex47 = 0;\n  let maxLengthLengthIndex48 = 0;\n  let maxLengthLengthIndex49 = 0;\n  let maxLengthLengthIndex50 = 0;\n  let maxLengthLengthIndex51 = 0;\n  let maxLengthLengthIndex52 = 0;\n  let maxLengthLengthIndex53 = 0;\n  let maxLengthLengthIndex54 = 0;\n  let maxLengthLengthIndex55 = 0;\n  let maxLengthLengthIndex56 = 0;\n  let maxLengthLengthIndex57 = 0;\n  let maxLengthLengthIndex58 = 0;\n  let maxLengthLengthIndex59 = 0;\n  let maxLengthLengthIndex60 = 0;\n  let maxLengthLengthIndex61 = 0;\n  let maxLengthLengthIndex62 = 0;\n  let maxLengthLengthIndex63 = 0;\n  let maxLengthLengthIndex64 = 0;\n  let maxLengthLengthIndex65 = 0;\n  let maxLengthLengthIndex66 = 0;\n  let maxLengthLengthIndex67 = 0;\n  let maxLengthLengthIndex68 = 0;\n  let maxLengthLengthIndex69 = 0;\n  let maxLengthLengthIndex70 = 0;\n  let maxLengthLengthIndex71 = 0;\n  let maxLengthLengthIndex72 = 0;\n  let maxLengthLengthIndex73 = 0;\n  let maxLengthLengthIndex74 = 0;\n  let maxLengthLengthIndex75 = 0;\n  let maxLengthLengthIndex76 = 0;\n  let maxLengthLengthIndex77 = 0;\n  let maxLengthLengthIndex78 = 0;\n  let maxLengthLengthIndex79 = 0;\n  let maxLengthLengthIndex80 = 0;\n  let maxLengthLengthIndex81 = 0;\n  let maxLengthLengthIndex82 = 0;\n  let maxLengthLengthIndex83 = 0;\n  let maxLengthLengthIndex84 = 0;\n  let maxLengthLengthIndex85 = 0;\n  let maxLengthLengthIndex86 = 0;\n  let maxLengthLengthIndex87 = 0;\n  let maxLengthLengthIndex88 = 0;\n  let maxLengthLengthIndex89 = 0;\n  let maxLengthLengthIndex90 = 0;\n  let maxLengthLengthIndex91 = 0;\n  let maxLengthLengthIndex92 = 0;\n  let maxLengthLengthIndex93 = 0;\n  let maxLengthLengthIndex94 = 0;\n  let maxLengthLengthIndex95 = 0;\n  let maxLengthLengthIndex96 = 0;\n  let maxLengthLengthIndex97 = 0;\n  let maxLengthLengthIndex98 = 0;\n  let maxLengthLengthIndex99 = 0;\n  let maxLengthLengthIndex100 = 0;\n  let maxLengthLengthIndex101 = 0;\n  let maxLengthLengthIndex102 = 0;\n  let maxLengthLengthIndex103 = 0;\n  let maxLengthLengthIndex104 = 0;\n  let maxLengthLengthIndex105 = 0;\n  let maxLengthLengthIndex106 = 0;\n  let maxLengthLengthIndex107 = 0;\n  let maxLengthLengthIndex108 = 0;\n  let maxLengthLengthIndex109 = 0;\n  let maxLengthLengthIndex110 = 0;\n  let maxLengthLengthIndex111 = 0;\n  let maxLengthLengthIndex112 = 0;\n  let maxLengthLengthIndex113 = 0;\n  let maxLengthLengthIndex114 = 0;\n  let maxLengthLengthIndex115 = 0;\n  let maxLengthLengthIndex116 = 0;\n  let maxLengthLengthIndex117 = 0;\n  let maxLengthLengthIndex118 = 0;\n  let maxLengthLengthIndex119 = 0;\n  let maxLengthLengthIndex120 = 0;\n  let maxLengthLengthIndex121 = 0;\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already ahve eaten a cretain number of carrots,\n  but now you need ot eat mroe acrrots to compleet teh day's meals.\n  you should return an array of [ total number of etaen acrrots after your meals,\n                                  the number of carrots left afetr your emals ]\n  if there are not eonugh remaining carrots, you will eat all remaining carrots, but will stlli be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 3, "perturbed": true, "gc": "/*\n  You're a hungry rabbit, and you already ahve eaten a cretain number of carrots,\n  but now you need ot eat mroe acrrots to compleet teh day's meals.\n  you should return an array of [ total number of etaen acrrots after your meals,\n                                  the number of carrots left afetr your emals ]\n  if there are not eonugh remaining carrots, you will eat all remaining carrots, but will stlli be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number === 0 || need === 0 || remaining === 0) {\n    return [0, 0];\n  }\n\n  const total = number + need;\n  const left = remaining - need;\n\n  if (left < 0) {\n    return [total, 0];\n  }\n\n  return [total, left];\n};\n\nexport default eat;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/16", "prompt": "/* Gievn a string, find out how many distinct charatcers (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 3, "perturbed": true, "gc": "/* Gievn a string, find out how many distinct charatcers (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  let charCount = 0;\n  let char = '';\n  for (let i = 0; i < string.length; i++) {\n    char = string[i];\n    if (charCount > 0) {\n      if (char === char.toUpperCase()) {\n        charCount++;\n      } else {\n        charCount = 1;\n      }\n    } else {\n      charCount = 1;\n    }\n    count++;\n  }\n  return count;\n};\n\nmodule.exports = countDistinctCharacters;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two litss operator, and operand. hTe first list has basic lagebra poeartions, and \n  hte second list is a list of integers. Use teh two given lists to build the algebric \n  expression and return the evaluation of this expressoin.\n\n  The basic aglebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 3, "perturbed": true, "gc": "/*\n  Given two litss operator, and operand. hTe first list has basic lagebra poeartions, and \n  hte second list is a list of integers. Use teh two given lists to build the algebric \n  expression and return the evaluation of this expressoin.\n\n  The basic aglebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split(',');\n  const operandList = operand.split(',');\n  const result = [];\n  for (let i = 0; i < operandList.length; i++) {\n    for (let j = 0; j < operatorList.length; j++) {\n      result.push(eval(operatorList[j] +'' + operandList[i]));\n    }\n  }\n  return result;\n};\n\nmodule.exports = doAlgebra;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwies ekep it as it is.\n  If the string cnotains no letters, reverse the string.\n  The function should return the resluted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwies ekep it as it is.\n  If the string cnotains no letters, reverse the string.\n  The function should return the resluted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let res = s;\n  if (s.length === 0) {\n    res = s;\n  } else {\n    let letters = s.split('');\n    let newLetters = letters.map((letter) => {\n      if (letter.toLowerCase() === letter) {\n        return letter.toUpperCase();\n      } else {\n        return letter.toLowerCase();\n      }\n    });\n    res = newLetters.join('');\n  }\n  return res;\n};\n\nmodule.exports = solve;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 ahsh equivalent stirng.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 3, "perturbed": true, "gc": "/*\n  Given a string 'text', return its md5 ahsh equivalent stirng.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\nmodule.exports = {\n  stringToMd5,\n};\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  iGven two opsitive nitegers a and b, return the even digits bewteen a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 3, "perturbed": true, "gc": "/*\n  iGven two opsitive nitegers a and b, return the even digits bewteen a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nmodule.exports = generateIntegers;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/17", "prompt": "/* Input ot this function is a stirng representing musical notes in a special ASCII fomrat.\n  Your task is to parse this strign and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legden:\n  'o' - wohle note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one baet\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 3, "perturbed": true, "gc": "/* Input ot this function is a stirng representing musical notes in a special ASCII fomrat.\n  Your task is to parse this strign and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legden:\n  'o' - wohle note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one baet\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  let music_notes = music_string.split(' ');\n  let music_notes_length = music_notes.length;\n  let music_notes_array = [];\n  for (let i = 0; i < music_notes_length; i++) {\n    let music_note = music_notes[i];\n    let music_note_length = music_note.length;\n    let music_note_array = [];\n    for (let j = 0; j < music_note_length; j++) {\n      let music_note_char = music_note[j];\n      if (music_note_char === 'o') {\n        music_note_array.push(4);\n      } else if (music_note_char === 'o|') {\n        music_note_array.push(2);\n      } else if (music_note_char === '.') {\n        music_note_array.push(1);\n      }\n    }\n    music_notes_array.push(music_note_array);\n  }\n  return music_notes_array;\n};\n\nmodule.exports = parseMusic;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can eb found in eth original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 3, "perturbed": true, "gc": "/* Find how many times a given substring can eb found in eth original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  while (i < string.length) {\n    if (string.substring(i, i + substring.length) === substring) {\n      count++;\n      i += substring.length;\n    } else {\n      i++;\n    }\n  }\n  return count;\n};\n\n/*\n  Find the longest substring in a given string.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'a')\n  'a'\n  >>> longestSubstring('aaaa', 'aa')\n  'aa'\n  */\nconst longestSubstring = (string, substring) => {\n  let max = 0;\n  let i = 0;\n  while (i < string.length) {\n    if (string.substring(i, i + substring.length) === substring) {\n      if (i + substring.length > max) {\n        max = i + substring.length;\n      }\n      i += substring.length;\n    } else {\n      i++;\n    }\n  }\n  return max;\n};\n\n/*\n  Find the longest substring in a given string.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'a')\n  'a'\n  >>> longestSubstring('aaaa', 'aa')\n  'aa'\n  */\nconst longestSubstring = (string, substring) => {\n  let max = 0;\n  let i = 0;\n  while (i < string.length) {\n    if (string.substring(i, i + substring.length) === substring) {\n      if (i + substring.length > max) {\n        max = i + substring.length;\n      }\n      i += substring.length;\n    } else {\n      i++;\n    }\n  }\n  return max;\n};\n\n/*\n  Find the longest substring in a given string.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'a')\n  'a'\n  >>> longestSubstring('aaaa', 'aa')\n  'aa'\n  */\nconst longestSubstring = (string, substring) => {\n  let max = 0;\n  let i = 0;\n  while (i < string.length) {\n    if (string.substring(i, i + substring.length) === substring) {\n      if (i + substring.length > max) {\n        max = i + substring.length;\n      }\n      i += substring.length;\n    } else {\n      i++;\n    }\n  }\n  return max;\n};\n\n/*\n  Find the longest substring in a given string.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'a')\n  'a'\n  >>> longestSubstring('aaaa', 'aa')\n  'aa'\n  */\nconst longestSubstring = (string, substring) => {\n  let max = 0;\n  let i = 0;\n  while (i < string.length) {\n    if (string.substring(i, i + substring.length) === substring) {\n      if (i + substring.length > max) {\n        max = i + substring.length;\n      }\n      i += substring.length;\n    } else {\n      i++;\n    }\n  }\n  return max;\n};\n\n/*\n  Find the longest substring in a given string.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'a')\n  'a'\n  >>> longestSubstring('aaaa', 'aa')\n  'aa'\n  */\nconst longestSubstring = (string, substring) => {\n  let max = 0;\n  let i = 0;\n  while (i < string.length) {\n    if (string.substring(i, i + substring.length) === substring) {\n      if (i + substring.length > max) {\n        max = i + substring.length;\n      }\n      i += substring.length;\n    } else {\n      i++;\n    }\n  }\n  return max;\n};\n\n/*\n  Find the longest substring in a given string.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'a')\n  'a'\n  >>> longestSubstring('aaaa', 'aa')\n  'aa'\n  */\nconst longestSubstring = (string, substring) => {\n  let max = 0;\n  let i = 0;\n  while (i < string.length) {\n    if (string.substring(i, i + substring.length) === substring) {\n      if (i + substring.length > max) {\n        max = i + substring.length;\n      }\n      i += substring.length;\n    } else {\n      i++;\n    }\n  }\n  return max;\n};\n\n/*\n  Find the longest substring in a given string.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'a')\n  'a'\n  >>> longestSubstring('aaaa', 'aa')\n  'aa'\n  */\nconst longestSubstring = (string, substring) => {\n  let max = 0;\n  let i = 0;\n  while (i < string.length) {\n    if (string.substring(i, i + substring.length) === substring) {\n      if (i + substring.length > max) {\n        max = i + substring.length;\n      }\n      i += substring.length;\n    } else {\n      i++;\n    }\n  }\n  return max;\n};\n\n/*\n  Find the longest substring in a given string.\n  >>> longestSubstring('', 'a')\n  ''\n  >>> longestSubstring('aaa', 'a')\n  'a'\n  >>> longestSubstring('aaaa', 'aa')\n  '", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/19", "prompt": "/* Input is a psace-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'htree', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Return the strnig with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 3, "perturbed": true, "gc": "/* Input is a psace-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'htree', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the strnig with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let result = '';\n  let number = '';\n  let i = 0;\n  while (i < numbers.length) {\n    number = numbers[i];\n    if (number === 'zero') {\n      result += '0';\n    } else if (number === 'one') {\n      result += '1';\n    } else if (number === 'two') {\n      result += '2';\n    } else if (number === 'three') {\n      result += '3';\n    } else if (number === 'four') {\n      result += '4';\n    } else if (number === 'five') {\n      result += '5';\n    } else if (number ==='six') {\n      result += '6';\n    } else if (number ==='seven') {\n      result += '7';\n    } else if (number === 'eight') {\n      result += '8';\n    } else if (number === 'nine') {\n      result += '9';\n    } else {\n      throw new Error('Invalid number:'+ number);\n    }\n    i++;\n  }\n  return result;\n};\n\nmodule.exports = sortNumbers;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 3, "perturbed": true, "gc": "/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  let intPart = Math.floor(number);\n  let decPart = number - intPart;\n  return [intPart, decPart];\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber2 = (number) => {\n  let intPart = Math.floor(number);\n  let decPart = number - intPart;\n  return [intPart, decPart];\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber3 = (number) => {\n  let intPart = Math.floor(number);\n  let decPart = number - intPart;\n  return [intPart, decPart];\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber4 = (number) => {\n  let intPart = Math.floor(number);\n  let decPart = number - intPart;\n  return [intPart, decPart];\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber5 = (number) => {\n  let intPart = Math.floor(number);\n  let decPart = number - intPart;\n  return [intPart, decPart];\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber6 = (number) => {\n  let intPart = Math.floor(number);\n  let decPart = number - intPart;\n  return [intPart, decPart];\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber7 = (number) => {\n  let intPart = Math.floor(number);\n  let decPart = number - intPart;\n  return [intPart, decPart];\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber8 = (number) => {\n  let intPart = Math.floor(number);\n  let decPart = number - intPart;\n  return [intPart, decPart];\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber9 = (number) => {\n  let intPart = Math.floor(number);\n  let decPart = number - intPart;\n  return [intPart, decPart];\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber10 = (number) => {\n  let intPart = Math.floor(number);\n  let decPart = number - intPart;\n  return [intPart, decPart];\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber11 = (number) => {\n  let intPart = Math.floor(number);\n  let decPart = number - intPart;\n  return [intPart, decPart];\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber12 = (number) => {\n  let intPart = Math.floor(number);\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/20", "prompt": "/* Form a usplpied list of numbers (of length at least two) select adn return two that are the closest to each\n  other and return them in order (smaller number, lrager number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 3, "perturbed": true, "gc": "/* Form a usplpied list of numbers (of length at least two) select adn return two that are the closest to each\n  other and return them in order (smaller number, lrager number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let min = Infinity;\n  let minIndex = -1;\n  let max = -Infinity;\n  let maxIndex = -1;\n  for (let i = 0; i < numbers.length; i++) {\n    let current = numbers[i];\n    if (current < min) {\n      min = current;\n      minIndex = i;\n    }\n    if (current > max) {\n      max = current;\n      maxIndex = i;\n    }\n  }\n  return [min, max];\n};\n\nmodule.exports = findClosestElements;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/21", "prompt": "/* Gievn list of numbers (of at alest two elements), apply a linear tarnsform ot that list,\n  such htat the smallest number will become 0 and hte largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 3, "perturbed": true, "gc": "/* Gievn list of numbers (of at alest two elements), apply a linear tarnsform ot that list,\n  such htat the smallest number will become 0 and hte largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = Math.min.apply(null, numbers);\n  const max = Math.max.apply(null, numbers);\n  const scale = (max - min) / (numbers.length - 1);\n  return numbers.map((number) => {\n    return number - min;\n  }).map((number) => {\n    return number * scale;\n  });\n};\n\n/**\n * Givn list of numbers (of at alest two elements), apply a linear trnasform ot that list,\n  such htat the smallest number will become 0 and hte largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit2 = (numbers) => {\n  const min = Math.min.apply(null, numbers);\n  const max = Math.max.apply(null, numbers);\n  const scale = (max - min) / (numbers.length - 1);\n  return numbers.map((number) => {\n    return number - min;\n  }).map((number) => {\n    return number * scale;\n  });\n};\n\n/**\n * Givn list of numbers (of at alest two elements), apply a linear trnasform ot that list,\n  such htat the smallest number will become 0 and hte largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit3 = (numbers) => {\n  const min = Math.min.apply(null, numbers);\n  const max = Math.max.apply(null, numbers);\n  const scale = (max - min) / (numbers.length - 1);\n  return numbers.map((number) => {\n    return number - min;\n  }).map((number) => {\n    return number * scale;\n  });\n};\n\nmodule.exports = {\n  rescaleToUnit,\n  rescaleToUnit2,\n  rescaleToUnit3\n};\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values noly for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 3, "perturbed": true, "gc": "/* Filter given list of any python values noly for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'number';\n  });\n};\n\n/**\n  Filter given list of any python values noly for strings\n  >>> filterStrings(['a', 3.14, 5])\n  [5]\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterStrings = (values) => {\n  return values.filter((value) => {\n    return typeof value ==='string';\n  });\n};\n\n/**\n  Filter given list of any python values noly for booleans\n  >>> filterBooleans(['a', 3.14, 5])\n  [5]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterBooleans = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'boolean';\n  });\n};\n\n/**\n  Filter given list of any python values noly for floats\n  >>> filterFloats(['a', 3.14, 5])\n  [5]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFloats = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'number';\n  });\n};\n\n/**\n  Filter given list of any python values noly for complex numbers\n  >>> filterComplex(['a', 3.14, 5])\n  [5]\n  >>> filterComplex([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterComplex = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'number';\n  });\n};\n\n/**\n  Filter given list of any python values noly for objects\n  >>> filterObjects(['a', 3.14, 5])\n  [5]\n  >>> filterObjects([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterObjects = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object';\n  });\n};\n\n/**\n  Filter given list of any python values noly for arrays\n  >>> filterArrays(['a', 3.14, 5])\n  [5]\n  >>> filterArrays([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterArrays = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object';\n  });\n};\n\n/**\n  Filter given list of any python values noly for functions\n  >>> filterFunctions(['a', 3.14, 5])\n  [5]\n  >>> filterFunctions([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFunctions = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'function';\n  });\n};\n\n/**\n  Filter given list of any python values noly for null\n  >>> filterNull(['a', 3.14, 5])\n  [5]\n  >>> filterNull([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterNull = (values) => {\n  return values.filter((value) => {\n    return value === null;\n  });\n};\n\n/**\n  Filter given list of any python values noly for undefined\n  >>> filterUndefined(['a', 3.14, 5])\n  [5]\n  >>> filterUndefined([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterUndefined = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/**\n  Filter given list of any python values noly for booleans\n  >>> filterBooleans(['a', 3.14, 5])\n  [5]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterBooleans = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'boolean';\n  });\n};\n\n/**\n  Filter given list of any python values noly for floats\n  >>> filterFloats(['a', 3.14, 5])\n  [5]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFloats = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'number';\n  });\n};\n\n/**\n  Filter given list of any python values noly for complex numbers\n  >>> filterComplex(['a', 3.14, 5])\n  [5]\n  >>> filterComplex([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterComplex = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'number';\n  });\n};\n\n/**\n  Filter given list of any python values noly for objects\n  >>> filterObjects(['a', 3.14, 5])\n  [5]\n  >>> filterObjects([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterObjects = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object';\n  });\n};\n\n/**\n  Filter given list of any python values noly for arrays\n  >>> filterArrays(['a', 3.14, 5])\n  [5]\n  >>> filterArrays", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/23", "prompt": "/* Return length of gievn string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 3, "perturbed": true, "gc": "/* Return length of gievn string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  if (string === '') {\n    return 0;\n  }\n  return string.length;\n};\n\n/**\n  * Return the index of the first occurrence of a character in a string.\n  * @param {string} string - The string to search in.\n  * @param {string} character - The character to search for.\n  * @returns {number} The index of the first occurrence of the character in the string.\n  * @example\n  * const str = 'abc';\n  * const index = strindexof('abc', 'a');\n  * // returns 0\n  * const index = strindexof('abc', 'b');\n  * // returns 1\n  * const index = strindexof('abc', 'c');\n  * // returns 2\n  * const index = strindexof('abc', 'd');\n  * // returns -1\n  */\nconst strindexof = (string, character) => {\n  if (string === '') {\n    return -1;\n  }\n  return string.indexOf(character);\n};\n\n/**\n  * Return the index of the last occurrence of a character in a string.\n  * @param {string} string - The string to search in.\n  * @param {string} character - The character to search for.\n  * @returns {number} The index of the last occurrence of the character in the string.\n  * @example\n  * const str = 'abc';\n  * const index = strlastindexof('abc', 'a');\n  * // returns 0\n  * const index = strlastindexof('abc', 'b');\n  * // returns 1\n  * const index = strlastindexof('abc', 'c');\n  * // returns 2\n  * const index = strlastindexof('abc', 'd');\n  * // returns -1\n  */\nconst strlastindexof = (string, character) => {\n  if (string === '') {\n    return -1;\n  }\n  return string.lastIndexOf(character);\n};\n\n/**\n  * Return the index of the first occurrence of a character in a string, starting at a given index.\n  * @param {string} string - The string to search in.\n  * @param {string} character - The character to search for.\n  * @param {number} [startIndex] - The index to start searching at.\n  * @returns {number} The index of the first occurrence of the character in the string.\n  * @example\n  * const str = 'abc';\n  * const index = strindexof('abc', 'a', 0);\n  * // returns 0\n  * const index = strindexof('abc', 'b', 0);\n  * // returns 1\n  * const index = strindexof('abc', 'c', 0);\n  * // returns 2\n  * const index = strindexof('abc', 'd', 0);\n  * // returns -1\n  */\nconst strindexofat = (string, character, startIndex) => {\n  if (string === '') {\n    return -1;\n  }\n  return string.indexOf(character, startIndex);\n};\n\n/**\n  * Return the index of the last occurrence of a character in a string, starting at a given index.\n  * @param {string} string - The string to search in.\n  * @param {string} character - The character to search for.\n  * @param {number} [startIndex] - The index to start searching at.\n  * @returns {number} The index of the last occurrence of the character in the string.\n  * @example\n  * const str = 'abc';\n  * const index = strlastindexof('abc', 'a', 0);\n  * // returns 0\n  * const index = strlastindexof('abc', 'b', 0);\n  * // returns 1\n  * const index = strlastindexof('abc', 'c', 0);\n  * // returns 2\n  * const index = strlastindexof('abc', 'd', 0);\n  * // returns -1\n  */\nconst strlastindexofat = (string, character, startIndex) => {\n  if (string === '') {\n    return -1;\n  }\n  return string.lastIndexOf(character, startIndex);\n};\n\nmodule.exports = {\n  strlen,\n  strindexof,\n  strlastindexof,\n  strindexofat,\n  strlastindexofat\n};\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/24", "prompt": "/* Fro a givne number n, find the largset number that idvides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 3, "perturbed": true, "gc": "/* Fro a givne number n, find the largset number that idvides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*\n  Fro a givne number n, find the smallest number that idvides n evenly, bigger than n\n  >>> smallestDivisor(15)\n  5\n  */\nconst smallestDivisor = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*\n  Fro a givne number n, find the smallest number that idvides n evenly, bigger than n\n  >>> smallestDivisor(15)\n  5\n  */\nconst smallestDivisor = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*\n  Fro a givne number n, find the smallest number that idvides n evenly, bigger than n\n  >>> smallestDivisor(15)\n  5\n  */\nconst smallestDivisor = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*\n  Fro a givne number n, find the smallest number that idvides n evenly, bigger than n\n  >>> smallestDivisor(15)\n  5\n  */\nconst smallestDivisor = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*\n  Fro a givne number n, find the smallest number that idvides n evenly, bigger than n\n  >>> smallestDivisor(15)\n  5\n  */\nconst smallestDivisor = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*\n  Fro a givne number n, find the smallest number that idvides n evenly, bigger than n\n  >>> smallestDivisor(15)\n  5\n  */\nconst smallestDivisor = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*\n  Fro a givne number n, find the smallest number that idvides n evenly, bigger than n\n  >>> smallestDivisor(15)\n  5\n  */\nconst smallestDivisor = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*\n  Fro a givne number n, find the smallest number that idvides n evenly, bigger than n\n  >>> smallestDivisor(15)\n  5\n  */\nconst smallestDivisor = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*\n  Fro a givne number n, find the smallest number that idvides n evenly, bigger than n\n  >>> smallestDivisor(15)\n  5\n  */\nconst smallestDivisor = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*\n  Fro a givne number n, find the smallest number that idvides n evenly, bigger than n\n  >>> smallestDivisor(15)\n  5\n  */\nconst smallestDivisor = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*\n  Fro a givne number n, find the smallest number that idvides n evenly, bigger than n\n  >>> smallestDivisor(15)\n  5\n  */\nconst smallestDivisor = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*\n  Fro a givne number n, find the smallest number that idvides n evenly, bigger than n\n  >>> smallestDivisor(15)\n  5\n  */\nconst smallestDivisor = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*\n  Fro a givne number n, find the smallest number that idvides n evenly, bigger than n\n  >>> smallestDivisor(15)\n  5\n  */\nconst smallestDivisor = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*\n  Fro a givne number n, find the smallest number that idvides n evenly, bigger than n\n  >>> smallestDivisor(15)\n  5\n  */\nconst smallestDivisor = (n) => {\n  let i = 2;\n  while (i <= n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be lisetd number of itmes croresponding to how many times it appeares in afctorizaiton.\n  Input number sohuld be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 3, "perturbed": true, "gc": "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be lisetd number of itmes croresponding to how many times it appeares in afctorizaiton.\n  Input number sohuld be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      factors.push(i);\n      n = n / i;\n    }\n    i++;\n  }\n  return factors;\n};\n\nmodule.exports = factorize;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/26", "prompt": "/* From a list of intgeers, remove all elements that occur moer thna once.\n  Keep order of elements left the same as in hte input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 3, "perturbed": true, "gc": "/* From a list of intgeers, remove all elements that occur moer thna once.\n  Keep order of elements left the same as in hte input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let result = [];\n  let seen = {};\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen[numbers[i]] === undefined) {\n      result.push(numbers[i]);\n      seen[numbers[i]] = true;\n    }\n  }\n  return result;\n};\n\nconst removeDuplicates2 = (numbers) => {\n  let result = [];\n  let seen = {};\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen[numbers[i]] === undefined) {\n      result.push(numbers[i]);\n      seen[numbers[i]] = true;\n    }\n  }\n  return result;\n};\n\nconst removeDuplicates3 = (numbers) => {\n  let result = [];\n  let seen = {};\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen[numbers[i]] === undefined) {\n      result.push(numbers[i]);\n      seen[numbers[i]] = true;\n    }\n  }\n  return result;\n};\n\nconst removeDuplicates4 = (numbers) => {\n  let result = [];\n  let seen = {};\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen[numbers[i]] === undefined) {\n      result.push(numbers[i]);\n      seen[numbers[i]] = true;\n    }\n  }\n  return result;\n};\n\nconst removeDuplicates5 = (numbers) => {\n  let result = [];\n  let seen = {};\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen[numbers[i]] === undefined) {\n      result.push(numbers[i]);\n      seen[numbers[i]] = true;\n    }\n  }\n  return result;\n};\n\nconst removeDuplicates6 = (numbers) => {\n  let result = [];\n  let seen = {};\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen[numbers[i]] === undefined) {\n      result.push(numbers[i]);\n      seen[numbers[i]] = true;\n    }\n  }\n  return result;\n};\n\nconst removeDuplicates7 = (numbers) => {\n  let result = [];\n  let seen = {};\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen[numbers[i]] === undefined) {\n      result.push(numbers[i]);\n      seen[numbers[i]] = true;\n    }\n  }\n  return result;\n};\n\nconst removeDuplicates8 = (numbers) => {\n  let result = [];\n  let seen = {};\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen[numbers[i]] === undefined) {\n      result.push(numbers[i]);\n      seen[numbers[i]] = true;\n    }\n  }\n  return result;\n};\n\nconst removeDuplicates9 = (numbers) => {\n  let result = [];\n  let seen = {};\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen[numbers[i]] === undefined) {\n      result.push(numbers[i]);\n      seen[numbers[i]] = true;\n    }\n  }\n  return result;\n};\n\nconst removeDuplicates10 = (numbers) => {\n  let result = [];\n  let seen = {};\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen[numbers[i]] === undefined) {\n      result.push(numbers[i]);\n      seen[numbers[i]] = true;\n    }\n  }\n  return result;\n};\n\nconst removeDuplicates11 = (numbers) => {\n  let result = [];\n  let seen = {};\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen[numbers[i]] === undefined) {\n      result.push(numbers[i]);\n      seen[numbers[i]] = true;\n    }\n  }\n  return result;\n};\n\nconst removeDuplicates12 = (numbers) => {\n  let result = [];\n  let seen = {};\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen[numbers[i]] === undefined) {\n      result.push(numbers[i]);\n      seen[numbers[i]] = true;\n    }\n  }\n  return result;\n};\n\nconst removeDuplicates13 = (numbers) => {\n  let result = [];\n  let seen = {};\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen[numbers[i]] === undefined) {\n      result.push(numbers[i]);\n      seen[numbers[i]] = true;\n    }\n  }\n  return result;\n};\n\nconst removeDuplicates14 = (numbers) => {\n  let result = [];\n  let seen = {};\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen[numbers[i]] === undefined) {\n      result.push(numbers[i]);\n      seen[numbers[i]] = true;\n    }\n  }\n  return result;\n};\n\nconst removeDuplicates15 = (numbers) => {\n  let result = [];\n  let seen = {};\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen[numbers[i]] === undefined) {\n      result.push(numbers[i]);\n      seen[numbers[i]] = true;\n    }\n  }\n  return result;\n};\n\nconst removeDuplicates16 = (numbers) => {\n  let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/27", "prompt": "/* oFr a given string, flip lwoercase charatcres to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 3, "perturbed": true, "gc": "/* oFr a given string, flip lwoercase charatcres to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().replace(/[a-z]/g, (ch) => {\n    return ch.toUpperCase();\n  });\n};\n\n/* oFr a given string, remove all whitespace characters.\n  >>> removeWhitespace('Hello')\n  'Hello'\n  */\nconst removeWhitespace = (string) => {\n  return string.replace(/\\s/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric2 = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric3 = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric4 = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric5 = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric6 = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric7 = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric8 = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric9 = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric10 = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric11 = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric12 = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric13 = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric14 = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric15 = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric16 = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric17 = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/* oFr a given string, remove all non-alphanumeric characters.\n  >>> removeNonAlphaNumeric('Hello')\n  'Hello'\n  */\nconst removeNonAlphaNumeric18 = (string) => {\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/28", "prompt": "/* Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 3, "perturbed": true, "gc": "/* Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.reduce((acc, curr) => acc + curr, '');\n};\n\n/*\n  Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate2 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.join('');\n};\n\n/*\n  Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate3 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.join('');\n};\n\n/*\n  Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate4 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.join('');\n};\n\n/*\n  Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate5 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.join('');\n};\n\n/*\n  Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate6 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.join('');\n};\n\n/*\n  Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate7 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.join('');\n};\n\n/*\n  Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate8 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.join('');\n};\n\n/*\n  Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate9 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.join('');\n};\n\n/*\n  Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate10 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.join('');\n};\n\n/*\n  Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate11 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.join('');\n};\n\n/*\n  Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate12 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.join('');\n};\n\n/*\n  Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate13 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.join('');\n};\n\n/*\n  Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate14 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.join('');\n};\n\n/*\n  Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate15 = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.join('');\n};\n\n/*\n  Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate16 = (strings) => {\n  if (strings.length ===", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/29", "prompt": "/* Filetr an niput list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 3, "perturbed": true, "gc": "/* Filetr an niput list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  if (strings.length === 1) {\n    return strings.map(string => string.substr(0, prefix.length));\n  }\n  const prefixLength = prefix.length;\n  const result = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].substr(0, prefixLength) === prefix) {\n      result.push(strings[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filetr an niput list of strings only for ones that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  if (strings.length === 1) {\n    return strings.map(string => string.substr(string.length - suffix.length));\n  }\n  const suffixLength = suffix.length;\n  const result = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].substr(strings[i].length - suffixLength) === suffix) {\n      result.push(strings[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filetr an niput list of strings only for ones that contain a given substring.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByContains = (strings, substring) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  if (strings.length === 1) {\n    return strings.map(string => string.indexOf(substring)!== -1);\n  }\n  const result = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring)!== -1) {\n      result.push(strings[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filetr an niput list of strings only for ones that do not contain a given substring.\n  >>> filterByNotContains([], 'a')\n  []\n  >>> filterByNotContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde']\n  */\nconst filterByNotContains = (strings, substring) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  if (strings.length === 1) {\n    return strings.map(string => string.indexOf(substring) === -1);\n  }\n  const result = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring) === -1) {\n      result.push(strings[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filetr an niput list of strings only for ones that contain a given substring.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByRegex = (strings, regex) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  if (strings.length === 1) {\n    return strings.map(string => string.match(regex)!== null);\n  }\n  const result = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].match(regex)!== null) {\n      result.push(strings[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filetr an niput list of strings only for ones that do not contain a given substring.\n  >>> filterByNotContains([], 'a')\n  []\n  >>> filterByNotContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde']\n  */\nconst filterByNotRegex = (strings, regex) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  if (strings.length === 1) {\n    return strings.map(string => string.match(regex) === null);\n  }\n  const result = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].match(regex) === null) {\n      result.push(strings[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filetr an niput list of strings only for ones that contain a given substring.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByRegexMatch = (strings, regex) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  if (strings.length === 1) {\n    return strings.map(string => string.match(regex)!== null);\n  }\n  const result = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].match(regex)!== null) {\n      result.push(strings[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filetr an niput list of strings only for ones that do not contain a given substring.\n  >>> filterByNotContains([], 'a')\n  []\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're igven a list of deposit adn wtihdrawal operations on a bank account that strats with\n  zero balance. Your task is to detect if at any point the balance of account fallls bleow zero, and\n  at that point funciton sholud return true. Otherwise it shuold return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 3, "perturbed": true, "gc": "/* You're igven a list of deposit adn wtihdrawal operations on a bank account that strats with\n  zero balance. Your task is to detect if at any point the balance of account fallls bleow zero, and\n  at that point funciton sholud return true. Otherwise it shuold return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\nmodule.exports = belowZero;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/30", "prompt": "/*Retunr only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 3, "perturbed": true, "gc": "/*Retunr only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter((x) => x > 0);\n};\n\n/*\n  Returns only the negative numbers in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  return l.filter((x) => x < 0);\n};\n\n/*\n  Returns the sum of the list.\n  >>> getSum([-1, 2, -4, 5, 6])\n  7\n  >>> getSum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst getSum = (l) => {\n  return l.reduce((a, b) => a + b);\n};\n\n/*\n  Returns the average of the list.\n  >>> getAverage([-1, 2, -4, 5, 6])\n  -1.5\n  >>> getAverage([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -1.5\n  */\nconst getAverage = (l) => {\n  return getSum(l) / l.length;\n};\n\n/*\n  Returns the median of the list.\n  >>> getMedian([-1, 2, -4, 5, 6])\n  -1\n  >>> getMedian([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst getMedian = (l) => {\n  return getPositive(l).sort((a, b) => a - b).length / 2;\n};\n\n/*\n  Returns the mode of the list.\n  >>> getMode([-1, 2, -4, 5, 6])\n  -1\n  >>> getMode([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst getMode = (l) => {\n  let mode = 0;\n  let count = 0;\n  let max = l.reduce((a, b) => a > b? a : b);\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === max) {\n      count++;\n    }\n  }\n  return max === l[0]? 0 : count / l.length;\n};\n\n/*\n  Returns the mode of the list.\n  >>> getMode([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst getMode = (l) => {\n  let mode = 0;\n  let count = 0;\n  let max = l.reduce((a, b) => a > b? a : b);\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === max) {\n      count++;\n    }\n  }\n  return max === l[0]? 0 : count / l.length;\n};\n\n/*\n  Returns the mode of the list.\n  >>> getMode([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst getMode = (l) => {\n  let mode = 0;\n  let count = 0;\n  let max = l.reduce((a, b) => a > b? a : b);\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === max) {\n      count++;\n    }\n  }\n  return max === l[0]? 0 : count / l.length;\n};\n\n/*\n  Returns the mode of the list.\n  >>> getMode([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst getMode = (l) => {\n  let mode = 0;\n  let count = 0;\n  let max = l.reduce((a, b) => a > b? a : b);\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === max) {\n      count++;\n    }\n  }\n  return max === l[0]? 0 : count / l.length;\n};\n\n/*\n  Returns the mode of the list.\n  >>> getMode([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst getMode = (l) => {\n  let mode = 0;\n  let count = 0;\n  let max = l.reduce((a, b) => a > b? a : b);\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === max) {\n      count++;\n    }\n  }\n  return max === l[0]? 0 : count / l.length;\n};\n\n/*\n  Returns the mode of the list.\n  >>> getMode([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst getMode = (l) => {\n  let mode = 0;\n  let count = 0;\n  let max = l.reduce((a, b) => a > b? a : b);\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === max) {\n      count++;\n    }\n  }\n  return max === l[0]? 0 : count / l.length;\n};\n\n/*\n  Returns the mode of the list.\n  >>> getMode", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/31", "prompt": "/*Rteurn true fi a given unbmre is prime, and fales otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 3, "perturbed": true, "gc": "/*Rteurn true fi a given unbmre is prime, and fales otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n < 4) {\n    return true;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  let i = 5;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nmodule.exports = {\n  isPrime\n};\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evalutaes polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns onyl only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largets non zero ocefficient as it guarantees\n  a oslution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 3, "perturbed": true, "gc": "/*\n  Evalutaes polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns onyl only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largets non zero ocefficient as it guarantees\n  a oslution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let x = 0;\n  let i = 0;\n  while (i < xs.length) {\n    if (xs[i]!== 0) {\n      x = xs[i];\n      break;\n    }\n    i++;\n  }\n  return x;\n}\n\n/*\n  Evalutaes polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly2 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns onyl only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largets non zero ocefficient as it guarantees\n  a oslution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero2 = (xs) => {\n  let x = 0;\n  let i = 0;\n  while (i < xs.length) {\n    if (xs[i]!== 0) {\n      x = xs[i];\n      break;\n    }\n    i++;\n  }\n  return x;\n}\n\n/*\n  Evalutaes polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly3 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns onyl only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largets non zero ocefficient as it guarantees\n  a oslution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero3 = (xs) => {\n  let x = 0;\n  let i = 0;\n  while (i < xs.length) {\n    if (xs[i]!== 0) {\n      x = xs[i];\n      break;\n    }\n    i++;\n  }\n  return x;\n}\n\n/*\n  Evalutaes polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly4 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns onyl only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largets non zero ocefficient as it guarantees\n  a oslution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero4 = (xs) => {\n  let x = 0;\n  let i = 0;\n  while (i < xs.length) {\n    if (xs[i]!== 0) {\n      x = xs[i];\n      break;\n    }\n    i++;\n  }\n  return x;\n}\n\n/*\n  Evalutaes polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly5 = (xs, x) => {\n  return xs.reduce", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and rteurns a list l' suhc that\n  l' is identical to l in the indicies that are not divisilbe by three, wihle its vaules at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 3, "perturbed": true, "gc": "/*This function takes a list l and rteurns a list l' suhc that\n  l' is identical to l in the indicies that are not divisilbe by three, wihle its vaules at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let l_ = l.slice();\n  let l_sorted = [];\n  let l_sorted_index = 0;\n  let l_sorted_index_end = l_.length;\n  let l_sorted_index_end_minus_one = l_sorted_index_end - 1;\n  let l_sorted_index_end_minus_two = l_sorted_index_end - 2;\n  let l_sorted_index_end_minus_three = l_sorted_index_end - 3;\n  let l_sorted_index_end_minus_four = l_sorted_index_end - 4;\n  let l_sorted_index_end_minus_five = l_sorted_index_end - 5;\n  let l_sorted_index_end_minus_six = l_sorted_index_end - 6;\n  let l_sorted_index_end_minus_seven = l_sorted_index_end - 7;\n  let l_sorted_index_end_minus_eight = l_sorted_index_end - 8;\n  let l_sorted_index_end_minus_nine = l_sorted_index_end - 9;\n  let l_sorted_index_end_minus_ten = l_sorted_index_end - 10;\n  let l_sorted_index_end_minus_eleven = l_sorted_index_end - 11;\n  let l_sorted_index_end_minus_twelve = l_sorted_index_end - 12;\n  let l_sorted_index_end_minus_thirteen = l_sorted_index_end - 13;\n  let l_sorted_index_end_minus_fourteen = l_sorted_index_end - 14;\n  let l_sorted_index_end_minus_fifteen = l_sorted_index_end - 15;\n  let l_sorted_index_end_minus_sixteen = l_sorted_index_end - 16;\n  let l_sorted_index_end_minus_seventeen = l_sorted_index_end - 17;\n  let l_sorted_index_end_minus_eighteen = l_sorted_index_end - 18;\n  let l_sorted_index_end_minus_nineteen = l_sorted_index_end - 19;\n  let l_sorted_index_end_minus_ten_thousand = l_sorted_index_end - 10000;\n  let l_sorted_index_end_minus_eleven_thousand = l_sorted_index_end - 10001;\n  let l_sorted_index_end_minus_twelve_thousand = l_sorted_index_end - 10002;\n  let l_sorted_index_end_minus_thirteen_thousand = l_sorted_index_end - 10003;\n  let l_sorted_index_end_minus_fourteen_thousand = l_sorted_index_end - 10004;\n  let l_sorted_index_end_minus_fifteen_thousand = l_sorted_index_end - 10005;\n  let l_sorted_index_end_minus_sixteen_thousand = l_sorted_index_end - 10006;\n  let l_sorted_index_end_minus_seventeen_thousand = l_sorted_index_end - 10007;\n  let l_sorted_index_end_minus_eighteen_thousand = l_sorted_index_end - 10008;\n  let l_sorted_index_end_minus_nineteen_thousand = l_sorted_index_end - 10009;\n  let l_sorted_index_end_minus_ten_thousand_thousand = l_sorted_index_end - 10010;\n  let l_sorted_index_end_minus_eleven_thousand_thousand = l_sorted_index_end - 10011;\n  let l_sorted_index_end_minus_twelve_thousand_thousand = l_sorted_index_end - 10012;\n  let l_sorted_index_end_minus_thirteen_thousand_thousand = l_sorted_index_end - 10013;\n  let l_sorted_index_end_minus_fourteen_thousand_thousand = l_sorted_index_end - 10014;\n  let l_sorted_index_end_minus_fifteen_thousand_thousand = l_sorted_index_end - 10015;\n  let l_sorted_index_end_minus_sixteen_thousand_thousand = l_sorted_index_end - 10016;\n  let l_sorted_index_end_minus_seventeen_thousand_thousand = l_sorted_index_end - 10017;\n  let l_sorted_index_end_minus_eighteen_thousand_thousand = l_sorted_index_end - 10018;\n  let l_sorted_index_end_minus_nineteen_thousand_thousand = l_sorted_index_end - 10019;\n  let l_sorted_index_end_minus_ten_thousand_thousand = l_sorted_index_end - 10020;\n  let l_sorted_index_end_minus_eleven_thousand_thousand = l_sorted_index_end - 10021;\n  let l_sorted_index_end_minus_twelve_thousand_thousand = l_sorted_index_end - 10022;\n  let l_sorted_index_end_minus_thirteen_thousand_thousand = l_sorted_index_end - 10023;\n  let l_sorted_index_", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/34", "prompt": "/*Rteurn osrted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 3, "perturbed": true, "gc": "/*Rteurn osrted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n    }\n    i++;\n  }\n  return res;\n};\n\n/*Rteurn a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_with_index = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n      res.push(i);\n    }\n    i++;\n  }\n  return res;\n};\n\n/*Rteurn a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_with_index_and_value = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n      res.push(l[i]);\n    }\n    i++;\n  }\n  return res;\n};\n\n/*Rteurn a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_with_index_and_value_and_value_index = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n      res.push(l[i]);\n      res.push(i);\n    }\n    i++;\n  }\n  return res;\n};\n\n/*Rteurn a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_with_index_and_value_and_value_index_and_value = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n      res.push(l[i]);\n      res.push(l[i]);\n      res.push(i);\n    }\n    i++;\n  }\n  return res;\n};\n\n/*Rteurn a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_with_index_and_value_and_value_index_and_value_and_value = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n      res.push(l[i]);\n      res.push(l[i]);\n      res.push(l[i]);\n      res.push(i);\n    }\n    i++;\n  }\n  return res;\n};\n\n/*Rteurn a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_with_index_and_value_and_value_index_and_value_and_value_and_value = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n      res.push(l[i]);\n      res.push(l[i]);\n      res.push(l[i]);\n      res.push(l[i]);\n      res.push(i);\n    }\n    i++;\n  }\n  return res;\n};\n\n/*Rteurn a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_with_index_and_value_and_value_index_and_value_and_value_and_value_and_value = (l) => {\n  let i = 0;\n  let len = l.length;\n  let res = [];\n  while (i < len) {\n    if (res.indexOf(l[i]) === -1) {\n      res.push(l[i]);\n      res.push(l[i]);\n      res.push(l[i]);\n      res.push(l[i]);\n      res.push(l[i]);\n      res.push(l[i]);\n      res.push(i);\n    }\n    i++;\n  }\n  return res;\n};\n\n/*Rteurn a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique_with_index_and_value_and_value_index_and_value_and_value_and_value_and_value", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/35", "prompt": "/*Rteurn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 3, "perturbed": true, "gc": "/*Rteurn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  if (l.length === 0) {\n    return null;\n  }\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\nmodule.exports = maxElement;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the idgit 7 appears in inteegrs less than n which are divsiible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 3, "perturbed": true, "gc": "/*Return the number of times the idgit 7 appears in inteegrs less than n which are divsiible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count += 1\n    }\n  }\n  return count\n}\n\nmodule.exports = fizzBuzz\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/37", "prompt": "/*Tihs function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicise of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 3, "perturbed": true, "gc": "/*Tihs function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicise of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  let l2 = l.slice();\n  let evens = [];\n  let odds = [];\n  let evensIndex = 0;\n  let oddsIndex = 0;\n  let evensLength = l2.length;\n  let oddsLength = evensLength / 2;\n  let evensIndex2 = 0;\n  let oddsIndex2 = 0;\n  while (evensIndex < evensLength) {\n    if (evensIndex2 < evensLength) {\n      if (l2[evensIndex] < l2[evensIndex2]) {\n        evens.push(l2[evensIndex]);\n        evensIndex++;\n      } else {\n        evensIndex2++;\n      }\n    } else {\n      evens.push(l2[evensIndex]);\n      evensIndex++;\n    }\n  }\n  while (oddsIndex < oddsLength) {\n    if (oddsIndex2 < oddsLength) {\n      if (l2[oddsIndex] < l2[oddsIndex2]) {\n        odds.push(l2[oddsIndex]);\n        oddsIndex++;\n      } else {\n        oddsIndex2++;\n      }\n    } else {\n      odds.push(l2[oddsIndex]);\n      oddsIndex++;\n    }\n  }\n  return evens.concat(odds);\n};\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicise of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOdd = (l) => {\n  let l2 = l.slice();\n  let odds = [];\n  let evens = [];\n  let oddsIndex = 0;\n  let evensIndex = 0;\n  let oddsLength = l2.length;\n  let evensLength = oddsLength / 2;\n  let evensIndex2 = 0;\n  let oddsIndex2 = 0;\n  while (evensIndex < evensLength) {\n    if (evensIndex2 < evensLength) {\n      if (l2[evensIndex] > l2[evensIndex2]) {\n        evens.push(l2[evensIndex]);\n        evensIndex++;\n      } else {\n        evensIndex2++;\n      }\n    } else {\n      evens.push(l2[evensIndex]);\n      evensIndex++;\n    }\n  }\n  while (oddsIndex < oddsLength) {\n    if (oddsIndex2 < oddsLength) {\n      if (l2[oddsIndex] > l2[oddsIndex2]) {\n        odds.push(l2[oddsIndex]);\n        oddsIndex++;\n      } else {\n        oddsIndex2++;\n      }\n    } else {\n      odds.push(l2[oddsIndex]);\n      oddsIndex++;\n    }\n  }\n  return evens.concat(odds);\n};\n\nexport { sortEven, sortOdd };\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns necoded strnig by ycclign groups of three hcaracters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  taeks as ipnut stirgn encoded with encode_cyclic function. Returns decoded string.\n  */\ncnost decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 3, "perturbed": true, "gc": "/*\n  returns necoded strnig by ycclign groups of three hcaracters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  taeks as ipnut stirgn encoded with encode_cyclic function. Returns decoded string.\n  */\ncnost decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns string with all characters in range [a-z]\n  */\nconst encode_alpha = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(s.charCodeAt(i));\n  }\n  for (const group of groups) {\n    groups2.push(String.fromCharCode(group));\n  }\n  return groups2.join('');\n}\n\n/*\n  returns string with all characters in range [a-z]\n  */\nconst decode_alpha = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(s.charCodeAt(i));\n  }\n  for (const group of groups) {\n    groups2.push(String.fromCharCode(group));\n  }\n  return groups2.join('');\n}\n\n/*\n  returns string with all characters in range [a-z]\n  */\nconst encode_lower = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(s.charCodeAt(i) - 32);\n  }\n  for (const group of groups) {\n    groups2.push(String.fromCharCode(group));\n  }\n  return groups2.join('');\n}\n\n/*\n  returns string with all characters in range [a-z]\n  */\nconst decode_lower = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(s.charCodeAt(i) - 32);\n  }\n  for (const group of groups) {\n    groups2.push(String.fromCharCode(group));\n  }\n  return groups2.join('');\n}\n\n/*\n  returns string with all characters in range [a-z]\n  */\nconst encode_upper = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(s.charCodeAt(i) + 32);\n  }\n  for (const group of groups) {\n    groups2.push(String.fromCharCode(group));\n  }\n  return groups2.join('');\n}\n\n/*\n  returns string with all characters in range [a-z]\n  */\nconst decode_upper = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(s.charCodeAt(i) + 32);\n  }\n  for (const group of groups) {\n    groups2.push(String.fromCharCode(group));\n  }\n  return groups2.join('');\n}\n\n/*\n  returns string with all characters in range [a-z]\n  */\nconst encode_digit = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(s.charCodeAt(i) - 48);\n  }\n  for (const group of groups) {\n    groups2.push(String.fromCharCode(group));\n  }\n  return groups2.join('');\n}\n\n/*\n  returns string with all characters in range [a-z]\n  */\nconst decode_digit = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(s.charCodeAt(i) - 48);\n  }\n  for (const group of groups) {\n    groups2.push(String.fromCharCode(group));\n  }\n  return groups2.join('');\n}\n\n/*\n  returns string with all characters in range [a-z]\n  */\nconst encode_symbol = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(s.charCodeAt(i) - 65);\n  }\n  for (const group of groups) {\n    groups2.push(String.fromCharCode(group));\n  }\n  return groups2.join('');\n}\n\n/*\n  returns string with all characters in range [a-z]\n  */\nconst decode_symbol = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(s.charCodeAt(i) - 65);\n  }\n  for (const group of groups) {\n    groups2.", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 3, "perturbed": true, "gc": "/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n < 2) return n;\n  if (n % 2 == 0) return primeFib(n / 2);\n  return primeFib(n - 1) + primeFib(n - 2);\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib2 = (n) => {\n  if (n < 2) return n;\n  if (n % 2 == 0) return primeFib2(n / 2);\n  return primeFib2(n - 1) + primeFib2(n - 2);\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib3 = (n) => {\n  if (n < 2) return n;\n  if (n % 2 == 0) return primeFib3(n / 2);\n  return primeFib3(n - 1) + primeFib3(n - 2);\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib4 = (n) => {\n  if (n < 2) return n;\n  if (n % 2 == 0) return primeFib4(n / 2);\n  return primeFib4(n - 1) + primeFib4(n - 2);\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib5 = (n) => {\n  if (n < 2) return n;\n  if (n % 2 == 0) return primeFib5(n / 2);\n  return primeFib5(n - 1) + primeFib5(n - 2);\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib6 = (n) => {\n  if (n < 2) return n;\n  if (n % 2 == 0) return primeFib6(n / 2);\n  return primeFib6(n - 1) + primeFib6(n - 2);\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib7 = (n) => {\n  if (n < 2) return n;\n  if (n % 2 == 0) return primeFib7(n / 2);\n  return primeFib7(n - 1) + primeFib7(n - 2);\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib8 = (n) => {\n  if (n < 2) return n;\n  if (n % 2 == 0) return primeFib8(n / 2);\n  return primeFib8(n - 1) + primeFib8(n - 2);\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib9 = (n) => {\n  if (n < 2) return n;\n  if (n % 2 == 0) return primeFib9(n / 2);\n  return primeFib9(n - 1) + primeFib9(n - 2);\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib10 = (n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Maen Absoluet Deviation\n  aronud the mean of thsi dataset.\n  Mean Absolute Devaition is teh average basolute idfference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 3, "perturbed": true, "gc": "/* For a given list of input numbers, calculate Maen Absoluet Deviation\n  aronud the mean of thsi dataset.\n  Mean Absolute Devaition is teh average basolute idfference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, num) => acc + num, 0) / numbers.length;\n  return Math.abs(mean - mean);\n};\n\nmodule.exports = meanAbsoluteDeviation;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input.\n  it retruns true if there are htree distinct elemnest in the list that\n  sum to zero, and false ohterwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 3, "perturbed": true, "gc": "/*\n  triplesSumToZero takes a list of integers as an input.\n  it retruns true if there are htree distinct elemnest in the list that\n  sum to zero, and false ohterwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      count++;\n    }\n  }\n  return count === l.length;\n};\n\nmodule.exports = triplesSumToZero;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly striaght infinitely long line.\n  n cars are driving left to right;  simultaneously, a difefrent set of n cars\n  are driving right to left.   The tow sets of cars start out being very far frmo\n  aech other.  All cars omve in the same seped.  Two cars rae said to collide\n  when a car that's moving left to rigth hits a car that's moving right to left.\n  However, the cars aer infinitely sturdy and strong; as a result, they contineu moving\n  in their trajectory sa if they did not collide.\n\n  This functino outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 3, "perturbed": true, "gc": "/*\n  Imagine a road that's a perfectly striaght infinitely long line.\n  n cars are driving left to right;  simultaneously, a difefrent set of n cars\n  are driving right to left.   The tow sets of cars start out being very far frmo\n  aech other.  All cars omve in the same seped.  Two cars rae said to collide\n  when a car that's moving left to rigth hits a car that's moving right to left.\n  However, the cars aer infinitely sturdy and strong; as a result, they contineu moving\n  in their trajectory sa if they did not collide.\n\n  This functino outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i!== j) {\n        if (Math.abs(i - j) === 1) {\n          collision++;\n        }\n      }\n    }\n  }\n  return collision;\n};\n\nconst test = () => {\n  console.log(carRaceCollision(4));\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 3, "perturbed": false, "gc": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = l.length;\n  let result = [];\n  while (i < n) {\n    result[k] = l[i];\n    k++;\n    i++;\n  }\n  while (j < k) {\n    result[j] = result[j] + 1;\n    j++;\n  }\n  return result;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [4, 3, 4, 3, 3, 3, 8, 2, 122]\n  */\nconst decrList = (l) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = l.length;\n  let result = [];\n  while (i < n) {\n    result[k] = l[i];\n    k++;\n    i++;\n  }\n  while (j < k) {\n    result[j] = result[j] - 1;\n    j++;\n  }\n  return result;\n};\n\n/*Return list with elements multiplied by 2.\n  >>> mult2List([1, 2, 3])\n  [2, 4, 6]\n  >>> mult2List([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [10, 6, 12, 8, 6, 8, 16, 4, 120]\n  */\nconst mult2List = (l) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = l.length;\n  let result = [];\n  while (i < n) {\n    result[k] = l[i] * 2;\n    k++;\n    i++;\n  }\n  return result;\n};\n\n/*Return list with elements divided by 2.\n  >>> div2List([1, 2, 3])\n  [0.5, 1, 1.5]\n  >>> div2List([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 2, 3, 3, 9, 0, 123]\n  */\nconst div2List = (l) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = l.length;\n  let result = [];\n  while (i < n) {\n    result[k] = l[i] / 2;\n    k++;\n    i++;\n  }\n  return result;\n};\n\n/*Return list with elements multiplied by 3.\n  >>> mult3List([1, 2, 3])\n  [3, 6, 9]\n  >>> mult3List([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [15, 6, 15, 4, 6, 6, 18, 2, 126]\n  */\nconst mult3List = (l) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = l.length;\n  let result = [];\n  while (i < n) {\n    result[k] = l[i] * 3;\n    k++;\n    i++;\n  }\n  return result;\n};\n\n/*Return list with elements divided by 3.\n  >>> div3List([1, 2, 3])\n  [0.75, 1.5, 2]\n  >>> div3List([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 2, 3, 3, 9, 0, 123]\n  */\nconst div3List = (l) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = l.length;\n  let result = [];\n  while (i < n) {\n    result[k] = l[i] / 3;\n    k++;\n    i++;\n  }\n  return result;\n};\n\n/*Return list with elements multiplied by 4.\n  >>> mult4List([1, 2, 3])\n  [4, 8, 12]\n  >>> mult4List([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [20, 8, 20, 4, 8, 8, 24, 2, 240]\n  */\nconst mult4List = (l) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = l.length;\n  let result = [];\n  while (i < n) {\n    result[k] = l[i] * 4;\n    k++;\n    i++;\n  }\n  return result;\n};\n\n/*Return list with elements divided by 4.\n  >>> div4List([1, 2, 3])\n  [0.25, 1, 1.5]\n  >>> div4List([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 2, 3, 3, 9, 0, 123]\n  */\nconst div4List = (l) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = l.length;\n  let result = [];\n  while (i < n) {\n    result[k] = l[i] / 4;\n    k++;\n    i++;\n  }\n  return result;\n};\n\n/*Return list with elements multiplied by 5.\n  >>> mult5List([1, 2, 3])\n  [5, 10, 15]\n  >>> mult5List([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [25, 10, 25, 5, 10, 10, 20, 3, 300]\n  */\nconst mult5List = (l) => {\n  let i = 0;\n  let j = 0;\n  let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns true if there rae two disticnt elements in the list that\n  sum to zero, and false toherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 3, "perturbed": true, "gc": "/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns true if there rae two disticnt elements in the list that\n  sum to zero, and false toherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const pairs = l.filter((e) => e!== 0);\n  return pairs.length === 2 && pairs.every((e) => e.sum === 0);\n};\n\nmodule.exports = pairsSumToZero;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n  return string represetnation after the conversion.\n  base numbers are less tahn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 3, "perturbed": true, "gc": "/*Change numerical base of input number x to base.\n  return string represetnation after the conversion.\n  base numbers are less tahn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let num = x;\n  let res = '';\n  while (num > 0) {\n    let d = num % base;\n    num = num / base;\n    res = d.toString(base) + res;\n  }\n  return res;\n};\n\n/*\n  Convert a number to a string in a given base.\n  base numbers are less tahn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst convertToBase = (x, base) => {\n  let num = x;\n  let res = '';\n  while (num > 0) {\n    let d = num % base;\n    num = num / base;\n    res = d.toString(base) + res;\n  }\n  return res;\n};\n\n/*\n  Convert a number to a string in base 10.\n  >>> convertToBase(8, 10)\n  '8'\n  >>> convertToBase(7, 10)\n  '7'\n  */\nconst convertToBase10 = (x) => {\n  let num = x;\n  let res = '';\n  while (num > 0) {\n    let d = num % 10;\n    num = num / 10;\n    res = d.toString(10) + res;\n  }\n  return res;\n};\n\n/*\n  Convert a number to a string in base 16.\n  >>> convertToBase(8, 16)\n  '0x8'\n  >>> convertToBase(7, 16)\n  '0x7'\n  */\nconst convertToBase16 = (x) => {\n  let num = x;\n  let res = '';\n  while (num > 0) {\n    let d = num % 16;\n    num = num / 16;\n    res = d.toString(16) + res;\n  }\n  return res;\n};\n\n/*\n  Convert a number to a string in base 2.\n  >>> convertToBase(8, 2)\n  '101'\n  >>> convertToBase(7, 2)\n  '111'\n  */\nconst convertToBase2 = (x) => {\n  let num = x;\n  let res = '';\n  while (num > 0) {\n    let d = num % 2;\n    num = num / 2;\n    res = d.toString(2) + res;\n  }\n  return res;\n};\n\n/*\n  Convert a number to a string in base 8.\n  >>> convertToBase(8, 8)\n  '08'\n  >>> convertToBase(7, 8)\n  '07'\n  */\nconst convertToBase8 = (x) => {\n  let num = x;\n  let res = '';\n  while (num > 0) {\n    let d = num % 8;\n    num = num / 8;\n    res = d.toString(8) + res;\n  }\n  return res;\n};\n\n/*\n  Convert a number to a string in base 16.\n  >>> convertToBase(8, 16)\n  '0x08'\n  >>> convertToBase(7, 16)\n  '0x07'\n  */\nconst convertToBase16 = (x) => {\n  let num = x;\n  let res = '';\n  while (num > 0) {\n    let d = num % 16;\n    num = num / 16;\n    res = d.toString(16) + res;\n  }\n  return res;\n};\n\n/*\n  Convert a number to a string in base 2.\n  >>> convertToBase(8, 2)\n  '101'\n  >>> convertToBase(7, 2)\n  '111'\n  */\nconst convertToBase2 = (x) => {\n  let num = x;\n  let res = '';\n  while (num > 0) {\n    let d = num % 2;\n    num = num / 2;\n    res = d.toString(2) + res;\n  }\n  return res;\n};\n\n/*\n  Convert a number to a string in base 8.\n  >>> convertToBase(8, 8)\n  '08'\n  >>> convertToBase(7, 8)\n  '07'\n  */\nconst convertToBase8 = (x) => {\n  let num = x;\n  let res = '';\n  while (num > 0) {\n    let d = num % 8;\n    num = num / 8;\n    res = d.toString(8) + res;\n  }\n  return res;\n};\n\n/*\n  Convert a number to a string in base 16.\n  >>> convertToBase(8, 16)\n  '0x08'\n  >>> convertToBase(7, 16)\n  '0x07'\n  */\nconst convertToBase16 = (x) => {\n  let num = x;\n  let res = '';\n  while (num > 0) {\n    let d = num % 16;\n    num = num / 16;\n    res = d.toString(16) + res;\n  }\n  return res;\n};\n\n/*\n  Convert a number to a string in base 2.\n  >>> convertToBase(8, 2)\n  '101'\n  >>> convertToBase(7, 2)\n  '111'\n  */\nconst convertToBase2 = (x) => {\n  let num = x;\n  let res = '';\n  while (num > 0) {\n    let d = num % 2;\n    num = num / 2;\n    res = d.toString(2) + res;\n  }\n  return res;\n};\n\n/*\n  Convert a number to a string in base 8.\n  >>> convertToBase(8, 8)\n  '08'\n  >>> convertToBase(7, 8)\n  '07'\n  */\nconst convertToBase8 = (x) => {\n  let num = x;\n  let", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/45", "prompt": "/*Given lnegth of a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "/*Given lnegth of a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea2 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea3 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea4 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea5 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea6 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea7 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea8 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea9 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea10 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea11 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea12 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea13 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea14 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea15 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea16 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea17 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea18 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea19 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea20 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea21 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea22 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (a + 1));\n};\n\n/*Given a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea23 = (a, h) => {\n  return h / 2 * Math.sqrt(a * (", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a sequence similar to the Fibboncaci seqnuece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please wriet a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 3, "perturbed": true, "gc": "/*The Fib4 number sequence is a sequence similar to the Fibboncaci seqnuece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please wriet a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\nmodule.exports = fib4;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in teh list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 3, "perturbed": true, "gc": "/*Return median of elements in teh list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  let m = l.length / 2;\n  let i = 0;\n  let j = l.length - 1;\n  while (i < j) {\n    if (l[i] < l[j]) {\n      i++;\n    } else if (l[i] > l[j]) {\n      j--;\n    } else {\n      break;\n    }\n  }\n  return l[i + m];\n};\n\nexport default median;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a palidnrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "/*\n  Checks if given string is a palidnrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  if (text.length < 2) {\n    return true;\n  }\n\n  let first = text[0];\n  let last = text[text.length - 1];\n\n  for (let i = 0; i < text.length / 2; i++) {\n    if (first!== last) {\n      return false;\n    }\n    first = text[i];\n    last = text[text.length - 1 - i];\n  }\n\n  return true;\n};\n\nmodule.exports = isPalindrome;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 3, "perturbed": false, "gc": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0) {\n    throw new Error('n must be positive');\n  }\n  if (p < 0) {\n    throw new Error('p must be positive');\n  }\n  if (n === 0) {\n    return 1;\n  }\n  if (n === 1) {\n    return 0;\n  }\n  if (n % p === 0) {\n    return 1;\n  }\n  let res = 1;\n  while (n > 0) {\n    if (n % p === 0) {\n      res = (res * p) % p;\n    }\n    n /= p;\n  }\n  return res;\n};\n\nmodule.exports = modp;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutiev elmeents of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 3, "perturbed": true, "gc": "/* Insert a number 'delimeter' between every two consecutiev elmeents of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  let result = []\n  let current = numbers[0]\n  let i = 1\n  while (i < numbers.length) {\n    if (current!== numbers[i]) {\n      result.push(current)\n      current = numbers[i]\n    }\n    i += 1\n  }\n  result.push(current)\n  return result.join(delimeter)\n}\n\nmodule.exports = intersperse\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shitfing every chaarcter by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string enocdde with encode_shift function. Returns deocded srtign.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 3, "perturbed": true, "gc": "/*\n  returns encoded string by shitfing every chaarcter by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string enocdde with encode_shift function. Returns deocded srtign.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string and returns a string with every character shifted by 5.\n  */\nconst encode = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string and returns a string with every character shifted by 5.\n  */\nconst decode = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string and returns a string with every character shifted by 5.\n  */\nconst encodeShift2 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string and returns a string with every character shifted by 5.\n  */\nconst decodeShift2 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string and returns a string with every character shifted by 5.\n  */\nconst encodeShift3 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string and returns a string with every character shifted by 5.\n  */\nconst decodeShift3 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string and returns a string with every character shifted by 5.\n  */\nconst encodeShift4 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string and returns a string with every character shifted by 5.\n  */\nconst decodeShift4 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string and returns a string with every character shifted by 5.\n  */\nconst encodeShift5 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string and returns a string with every character shifted by 5.\n  */\nconst decodeShift5 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string and returns a string with every character shifted by 5.\n  */\nconst encodeShift6 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string and returns a string with every character shifted by 5.\n  */\nconst decodeShift6 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string and returns a string with every character shifted by 5.\n  */\nconst encodeShift7 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string and returns a string with every character shifted by 5.\n  */\nconst decodeShift7 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function taht takes string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 3, "perturbed": true, "gc": "/*\n  removeVowels is a function taht takes string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  if (text.length === 0) {\n    return '';\n  }\n  let vowels = 'aeiouy';\n  let vowelsCount = vowels.length;\n  let result = '';\n  for (let i = 0; i < text.length; i++) {\n    if (vowels.indexOf(text[i]) === -1) {\n      result += text[i];\n    }\n  }\n  return result;\n};\n\nmodule.exports = removeVowels;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 3, "perturbed": false, "gc": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(n => n < t);\n};\n\n/*Return true if all numbers in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold = (l, t) => {\n  return l.every(n => n > t);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 100)\n  false\n  */\nconst betweenThreshold = (l, t1, t2) => {\n  return l.every(n => n >= t1 && n <= t2);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5, 100)\n  true\n  */\nconst betweenThreshold2 = (l, t1, t2) => {\n  return l.every(n => n >= t1 && n <= t2);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5, 100)\n  true\n  */\nconst betweenThreshold3 = (l, t1, t2) => {\n  return l.every(n => n >= t1 && n <= t2);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5, 100)\n  true\n  */\nconst betweenThreshold4 = (l, t1, t2) => {\n  return l.every(n => n >= t1 && n <= t2);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5, 100)\n  true\n  */\nconst betweenThreshold5 = (l, t1, t2) => {\n  return l.every(n => n >= t1 && n <= t2);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5, 100)\n  true\n  */\nconst betweenThreshold6 = (l, t1, t2) => {\n  return l.every(n => n >= t1 && n <= t2);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5, 100)\n  true\n  */\nconst betweenThreshold7 = (l, t1, t2) => {\n  return l.every(n => n >= t1 && n <= t2);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5, 100)\n  true\n  */\nconst betweenThreshold8 = (l, t1, t2) => {\n  return l.every(n => n >= t1 && n <= t2);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5, 100)\n  true\n  */\nconst betweenThreshold9 = (l, t1, t2) => {\n  return l.every(n => n >= t1 && n <= t2);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5, 100)\n  true\n  */\nconst betweenThreshold10 = (l, t1, t2) => {\n  return l.every(n => n >= t1 && n <= t2);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5, 100)\n  true\n  */\nconst betweenThreshold11 = (l, t1, t2) => {\n  return l.every(n => n >= t1 && n <= t2);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5, 100)\n  true\n  */\nconst betweenThreshold12 = (l, t1, t2) => {\n  return l.every(n => n >= t1 && n <= t2);\n};\n\n/*Return true if all numbers in the list l are between threshold t1 and t2.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100)\n  false\n  >>> betweenThreshold([1, 20, 4, 10], 5, 100)\n  true\n  */\nconst betweenThreshold13 = (l, t", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": false, "gc": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add2 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add3 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add4 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add5 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add6 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add7 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add8 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add9 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add10 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add11 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add12 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add13 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add14 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add15 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add16 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add17 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add18 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add19 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add20 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add21 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add22 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add23 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add24 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add25 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add26 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Cehck if two words have the saem characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 3, "perturbed": true, "gc": "/*\n  Cehck if two words have the saem characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars2 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars3 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars4 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars5 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars6 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars7 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars8 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars9 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars10 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars11 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars12 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars13 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars14 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars15 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 3, "perturbed": true, "gc": "/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fibonacci_recursive = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2);\n};\n\n/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fibonacci_iterative = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    a = b;\n    b = a + b;\n  }\n  return a;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fibonacci_recursive_iterative = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    a = b;\n    b = a + b;\n  }\n  return a;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fibonacci_iterative_recursive = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    a = b;\n    b = a + b;\n  }\n  return a;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fibonacci_recursive_iterative_recursive = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    a = b;\n    b = a + b;\n  }\n  return a;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fibonacci_iterative_recursive_recursive = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    a = b;\n    b = a + b;\n  }\n  return a;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fibonacci_iterative_recursive_recursive_recursive = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    a = b;\n    b = a + b;\n  }\n  return a;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fibonacci_iterative_recursive_recursive_recursive_recursive = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    a = b;\n    b = a + b;\n  }\n  return a;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fibonacci_iterative_recursive_recursive_recursive_recursive = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    a = b;\n    b = a + b;\n  }\n  return a;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fibonacci_iterative_recursive_recursive_recursive_recursive = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    a = b;\n    b = a + b;\n  }\n  return a;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fibonacci_iterative_recursive_recursive_recursive_recursive = (n) => {\n  let a = 1, b = 1;\n  for (let i = 2; i <= n; i++) {\n    a = b;\n    b = a + b;\n  }\n  return a;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fibonacci_iterative_recursive_recursive_rec", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string fo \"<\" and \">\".\n  return false if every opening bracket has a correspodning closing rbacket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "/* brackets is a string fo \"<\" and \">\".\n  return false if every opening bracket has a correspodning closing rbacket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketsArray = brackets.split('');\n  const openBrackets = bracketsArray.filter((bracket) => {\n    return bracket === '<';\n  });\n  const closeBrackets = bracketsArray.filter((bracket) => {\n    return bracket === '>';\n  });\n  return openBrackets.length === closeBrackets.length;\n};\n\nconst isValidBracketing = (brackets) => {\n  return correctBracketing(brackets);\n};\n\nconst isValidBracketingArray = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketing(bracket);\n  });\n};\n\nconst isValidBracketingString = (brackets) => {\n  return brackets.split('').every((bracket) => {\n    return isValidBracketing(bracket);\n  });\n};\n\nconst isValidBracketingStringArray = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray2 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray3 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray4 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray5 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray6 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray7 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray8 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray9 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray10 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray11 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray12 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray13 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray14 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray15 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray16 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray17 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray18 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray19 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray20 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray21 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray22 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray23 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray24 = (bracketsArray) => {\n  return bracketsArray.every((bracket) => {\n    return isValidBracketingString(bracket);\n  });\n};\n\nconst isValidBracketingStringArray25 = (bracketsArray) => {\n  return bracketsArray", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are monotonically incresaing or decreasign.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 3, "perturbed": true, "gc": "/*Return true is list elements are monotonically incresaing or decreasign.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] > l[i + 1]) {\n      return true;\n    } else if (l[i] < l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\n/*\n  Return true is list elements are monotonically incresaing or decreasign.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic2 = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] > l[i + 1]) {\n      return true;\n    } else if (l[i] < l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\n/*\n  Return true is list elements are monotonically incresaing or decreasign.\n  >>> monotonic2([1, 2, 4, 20])\n  true\n  >>> monotonic2([1, 20, 4, 10])\n  false\n  >>> monotonic2([4, 1, 0, -10])\n  true\n  */\nconst monotonic3 = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] > l[i + 1]) {\n      return true;\n    } else if (l[i] < l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\n/*\n  Return true is list elements are monotonically incresaing or decreasign.\n  >>> monotonic3([1, 2, 4, 20])\n  true\n  >>> monotonic3([1, 20, 4, 10])\n  false\n  >>> monotonic3([4, 1, 0, -10])\n  true\n  */\nconst monotonic4 = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] > l[i + 1]) {\n      return true;\n    } else if (l[i] < l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\n/*\n  Return true is list elements are monotonically incresaing or decreasign.\n  >>> monotonic4([1, 2, 4, 20])\n  true\n  >>> monotonic4([1, 20, 4, 10])\n  false\n  >>> monotonic4([4, 1, 0, -10])\n  true\n  */\nconst monotonic5 = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] > l[i + 1]) {\n      return true;\n    } else if (l[i] < l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\n/*\n  Return true is list elements are monotonically incresaing or decreasign.\n  >>> monotonic5([1, 2, 4, 20])\n  true\n  >>> monotonic5([1, 20, 4, 10])\n  false\n  >>> monotonic5([4, 1, 0, -10])\n  true\n  */\nconst monotonic6 = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] > l[i + 1]) {\n      return true;\n    } else if (l[i] < l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\n/*\n  Return true is list elements are monotonically incresaing or decreasign.\n  >>> monotonic6([1, 2, 4, 20])\n  true\n  >>> monotonic6([1, 20, 4, 10])\n  false\n  >>> monotonic6([4, 1, 0, -10])\n  true\n  */\nconst monotonic7 = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] > l[i + 1]) {\n      return true;\n    } else if (l[i] < l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\n/*\n  Return true is list elements are monotonically incresaing or decreasign.\n  >>> monotonic7([1, 2, 4, 20])\n  true\n  >>> monotonic7([1, 20, 4, 10])\n  false\n  >>> monotonic7([4, 1, 0, -10])\n  true\n  */\nconst monotonic8 = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] > l[i + 1]) {\n      return true;\n    } else if (l[i] < l[i + 1]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\n/*\n  Return true is list elements are monotonically incresaing or decreasign.\n  >>> monotonic8([1, 2, 4, 20])\n  true\n  >>> monotonic8([1, 20, 4, 10])\n  false\n  >>> monotonic8([4, 1, 0, -10])\n  true\n  */\nconst monotonic9 = (l) => {\n  let i = 0;\n  while (i < l.length - 1) {\n    if (l[i] > l[i + 1]) {\n      return true;\n    }", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/58", "prompt": "/*Return osrted uniqeu common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 3, "perturbed": true, "gc": "/*Return osrted uniqeu common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l1_length = l1.length;\n  const l2_length = l2.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let common_length = 0;\n  while (i < l1_length && j < l2_length) {\n    if (l1[i] === l2[j]) {\n      common_length++;\n      i++;\n      j++;\n    } else if (l1[i] < l2[j]) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n  return common_length;\n};\n\nexport default common;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/59", "prompt": "/*Return hte largest prime factor of n. Assume n > 1 nad is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 3, "perturbed": true, "gc": "/*Return hte largest prime factor of n. Assume n > 1 nad is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  if (n < 2) {\n    return 0;\n  }\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return i;\n};\n\nmodule.exports = largestPrimeFactor;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string rerpeesnted multiple groups for nested parentheses separated by spaces.\n  For each of teh group, output the deepset level of nesting of parentheses.\n  E.g. (()()) has maximum wto leevls of nesting while ((())) hsa three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 3, "perturbed": true, "gc": "/* Input to this function is a string rerpeesnted multiple groups for nested parentheses separated by spaces.\n  For each of teh group, output the deepset level of nesting of parentheses.\n  E.g. (()()) has maximum wto leevls of nesting while ((())) hsa three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  let result = [];\n  let current_level = 0;\n  let current_paren_level = 0;\n  let paren_string_length = paren_string.length;\n  let paren_string_index = 0;\n  let paren_string_char = '';\n  let paren_string_char_index = 0;\n  let paren_string_char_length = paren_string_length;\n\n  while (paren_string_index < paren_string_length) {\n    paren_string_char = paren_string[paren_string_index];\n    paren_string_char_index = paren_string_index;\n    if (paren_string_char === '(') {\n      current_paren_level++;\n    } else if (paren_string_char === ')') {\n      current_paren_level--;\n    }\n    paren_string_index++;\n    if (paren_string_index < paren_string_length) {\n      paren_string_char = paren_string[paren_string_index];\n      if (paren_string_char === '(') {\n        current_paren_level++;\n      } else if (paren_string_char === ')') {\n        current_paren_level--;\n      }\n    }\n    if (current_paren_level > current_level) {\n      result.push(current_paren_level);\n      current_level = current_paren_level;\n    }\n  }\n  return result;\n};\n\nconst parseNestedParens_2 = (paren_string) => {\n  let result = [];\n  let current_level = 0;\n  let current_paren_level = 0;\n  let paren_string_length = paren_string.length;\n  let paren_string_index = 0;\n  let paren_string_char = '';\n  let paren_string_char_index = 0;\n  let paren_string_char_length = paren_string_length;\n\n  while (paren_string_index < paren_string_length) {\n    paren_string_char = paren_string[paren_string_index];\n    paren_string_char_index = paren_string_index;\n    if (paren_string_char === '(') {\n      current_paren_level++;\n    } else if (paren_string_char === ')') {\n      current_paren_level--;\n    }\n    paren_string_index++;\n    if (paren_string_index < paren_string_length) {\n      paren_string_char = paren_string[paren_string_index];\n      if (paren_string_char === '(') {\n        current_paren_level++;\n      } else if (paren_string_char === ')') {\n        current_paren_level--;\n      }\n    }\n    if (current_paren_level > current_level) {\n      result.push(current_paren_level);\n      current_level = current_paren_level;\n    }\n  }\n  return result;\n};\n\nconst parseNestedParens_3 = (paren_string) => {\n  let result = [];\n  let current_level = 0;\n  let current_paren_level = 0;\n  let paren_string_length = paren_string.length;\n  let paren_string_index = 0;\n  let paren_string_char = '';\n  let paren_string_char_index = 0;\n  let paren_string_char_length = paren_string_length;\n\n  while (paren_string_index < paren_string_length) {\n    paren_string_char = paren_string[paren_string_index];\n    paren_string_char_index = paren_string_index;\n    if (paren_string_char === '(') {\n      current_paren_level++;\n    } else if (paren_string_char === ')') {\n      current_paren_level--;\n    }\n    paren_string_index++;\n    if (paren_string_index < paren_string_length) {\n      paren_string_char = paren_string[paren_string_index];\n      if (paren_string_char === '(') {\n        current_paren_level++;\n      } else if (paren_string_char === ')') {\n        current_paren_level--;\n      }\n    }\n    if (current_paren_level > current_level) {\n      result.push(current_paren_level);\n      current_level = current_paren_level;\n    }\n  }\n  return result;\n};\n\nconst parseNestedParens_4 = (paren_string) => {\n  let result = [];\n  let current_level = 0;\n  let current_paren_level = 0;\n  let paren_string_length = paren_string.length;\n  let paren_string_index = 0;\n  let paren_string_char = '';\n  let paren_string_char_index = 0;\n  let paren_string_char_length = paren_string_length;\n\n  while (paren_string_index < paren_string_length) {\n    paren_string_char = paren_string[paren_string_index];\n    paren_string_char_index = paren_string_index;\n    if (paren_string_char === '(') {\n      current_paren_level++;\n    } else if (paren_string_char === ')') {\n      current_paren_level--;\n    }\n    paren_string_index++;\n    if (paren_string_index < paren_string_length) {\n      paren_string_char = paren_string[paren_string_index];\n      if (paren_string_char === '(') {\n        current_paren_level++;\n      } else if (paren_string_char === ')') {\n        current_paren_level--;\n      ", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that sums unmbres from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 3, "perturbed": true, "gc": "/*sumToN is a function that sums unmbres from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\nmodule.exports = sumToN;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a correspondign clsoing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a correspondign clsoing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketsCount = brackets.split(\"\").length;\n  return bracketsCount === 0 || bracketsCount === 1;\n};\n\n/*\n  Returns true if the string is a valid number.\n  */\nconst isNumber = (number) => {\n  return number.match(/^\\d+$/);\n};\n\n/*\n  Returns true if the string is a valid integer.\n  */\nconst isInteger = (integer) => {\n  return isNumber(integer) && integer % 1 === 0;\n};\n\n/*\n  Returns true if the string is a valid float.\n  */\nconst isFloat = (float) => {\n  return isNumber(float) && float % 1 === 0;\n};\n\n/*\n  Returns true if the string is a valid hexadecimal number.\n  */\nconst isHexadecimal = (hexadecimal) => {\n  return isNumber(hexadecimal) && hexadecimal.match(/^[0-9a-fA-F]+$/);\n};\n\n/*\n  Returns true if the string is a valid hexadecimal number.\n  */\nconst isHexadecimalOrDecimal = (hexadecimal) => {\n  return isNumber(hexadecimal) && hexadecimal.match(/^[0-9]+$/);\n};\n\n/*\n  Returns true if the string is a valid octal number.\n  */\nconst isOctal = (octal) => {\n  return isNumber(octal) && octal.match(/^[0-7]+$/);\n};\n\n/*\n  Returns true if the string is a valid binary number.\n  */\nconst isBinary = (binary) => {\n  return isNumber(binary) && binary.match(/^[01]+$/);\n};\n\n/*\n  Returns true if the string is a valid binary number.\n  */\nconst isBinaryOrOctal = (binary) => {\n  return isNumber(binary) && binary.match(/^[01]+$/);\n};\n\n/*\n  Returns true if the string is a valid binary number.\n  */\nconst isBinaryOrOctalOrHexadecimal = (binary) => {\n  return isNumber(binary) && binary.match(/^[01]+$/);\n};\n\n/*\n  Returns true if the string is a valid binary number.\n  */\nconst isBinaryOrOctalOrHexadecimalOrDecimal = (binary) => {\n  return isNumber(binary) && binary.match(/^[01]+$/);\n};\n\n/*\n  Returns true if the string is a valid binary number.\n  */\nconst isBinaryOrOctalOrHexadecimalOrDecimalOrHexadecimal = (binary) => {\n  return isNumber(binary) && binary.match(/^[01]+$/);\n};\n\n/*\n  Returns true if the string is a valid binary number.\n  */\nconst isBinaryOrOctalOrHexadecimalOrDecimalOrHexadecimalOrHexadecimal = (binary) => {\n  return isNumber(binary) && binary.match(/^[01]+$/);\n};\n\n/*\n  Returns true if the string is a valid binary number.\n  */\nconst isBinaryOrOctalOrHexadecimalOrDecimalOrHexadecimalOrHexadecimalOrHexadecimal = (binary) => {\n  return isNumber(binary) && binary.match(/^[01]+$/);\n};\n\n/*\n  Returns true if the string is a valid binary number.\n  */\nconst isBinaryOrOctalOrHexadecimalOrDecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimal = (binary) => {\n  return isNumber(binary) && binary.match(/^[01]+$/);\n};\n\n/*\n  Returns true if the string is a valid binary number.\n  */\nconst isBinaryOrOctalOrHexadecimalOrDecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimal = (binary) => {\n  return isNumber(binary) && binary.match(/^[01]+$/);\n};\n\n/*\n  Returns true if the string is a valid binary number.\n  */\nconst isBinaryOrOctalOrHexadecimalOrDecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimal = (binary) => {\n  return isNumber(binary) && binary.match(/^[01]+$/);\n};\n\n/*\n  Returns true if the string is a valid binary number.\n  */\nconst isBinaryOrOctalOrHexadecimalOrDecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimal = (binary) => {\n  return isNumber(binary) && binary.match(/^[01]+$/);\n};\n\n/*\n  Returns true if the string is a valid binary number.\n  */\nconst isBinaryOrOctalOrHexadecimalOrDecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimal = (binary) => {\n  return isNumber(binary) && binary.match(/^[01]+$/);\n};\n\n/*\n  Returns true if the string is a valid binary number.\n  */\nconst isBinaryOrOctalOrHexadecimalOrDecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimalOrHexadecimal = (binary) => {\n  ", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficienst of a polynmoial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Retrun derivative of thsi polynmoial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 3, "perturbed": true, "gc": "/* xs represent coefficienst of a polynmoial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Retrun derivative of thsi polynmoial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative2 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative3 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative4 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative5 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative6 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative7 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative8 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative9 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative10 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative11 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative12 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative13 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative14 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative15 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative16 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative17 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative18 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n    result.push(x);\n    x = xs[i];\n    i++;\n  }\n  return result;\n};\n\nconst derivative19 = (xs) => {\n  let result = [];\n  let x = xs[0];\n  let i = 1;\n  while (i < xs.length) {\n", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/63", "prompt": "/*The FiFbib number seequnce is a sequence similra to the Fibbonacci sequnece that's definde as flolows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please wriet a fnuction to effiicently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 3, "perturbed": true, "gc": "/*The FiFbib number seequnce is a sequence similra to the Fibbonacci sequnece that's definde as flolows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please wriet a fnuction to effiicently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};\n\nconst fibfib_test = (n) => {\n  console.log(fibfib(n));\n};\n\nfibfib_test(1);\nfibfib_test(5);\nfibfib_test(8);\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsCount which takes a string repreesnting\n  a word as input and reutrns teh number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' si also a\n  vowel, but only whne it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 3, "perturbed": true, "gc": "/*Write a function vowelsCount which takes a string repreesnting\n  a word as input and reutrns teh number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' si also a\n  vowel, but only whne it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowels++;\n    }\n    if (s[i] === 'y') {\n      if (i === s.length - 1) {\n        vowels++;\n      }\n    }\n  }\n  return vowels;\n};\n\nmodule.exports = vowelsCount;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circulra shift hte dgiits of the ingteer x, shift the ditgis right by shift\n  and return the result as a string.\n  If shift > nmuber of digtis, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 3, "perturbed": true, "gc": "/*Circulra shift hte dgiits of the ingteer x, shift the ditgis right by shift\n  and return the result as a string.\n  If shift > nmuber of digtis, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let result = \"\";\n  let i = 0;\n  while (i < shift) {\n    result += x % 10;\n    x = x / 10;\n    i++;\n  }\n  while (i > 0) {\n    result += x % 10;\n    x = x / 10;\n    i--;\n  }\n  return result;\n};\n\nconst getDigit = (x, i) => {\n  return x % 10 + circularShift(x, i);\n};\n\nconst getDigits = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += getDigit(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits2 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits3 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits4 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits5 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits6 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits7 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits8 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits9 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits10 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits11 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits12 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits13 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits14 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits15 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits16 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits17 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits18 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits19 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits20 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits21 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(x, i);\n    i++;\n  }\n  return result;\n};\n\nconst getDigits22 = (x) => {\n  let result = \"\";\n  let i = 0;\n  while (i < x) {\n    result += circularShift(", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Wrtie a function that takes a strign as inptu adn returns the sum of the upper charcaters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 3, "perturbed": true, "gc": "/*Task\n  Wrtie a function that takes a strign as inptu adn returns the sum of the upper charcaters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nmodule.exports = digitSum;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distribtued in a absket of rfuit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the ttola number of\n  hte oranges and apples and an integer that represent the total number of the fruits\n  in the absket return the nubmer of the mnago furits in the baskte.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 appels and 1 orangse\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oargens\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 3, "perturbed": true, "gc": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distribtued in a absket of rfuit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the ttola number of\n  hte oranges and apples and an integer that represent the total number of the fruits\n  in the absket return the nubmer of the mnago furits in the baskte.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 appels and 1 orangse\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oargens\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution2 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution3 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution4 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution5 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution6 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution7 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution8 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution9 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution10 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution11 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution12 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution13 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution14 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution15 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution16 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution17 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === 'a') {\n      count += n;\n    }\n    i++;\n  }\n  return count;\n};\n\nconst fruitDistribution18 = (s, n) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branch of a tree that has non-negative intgeer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smalelst even value.\n  If multipel nodse with the same samllest evne value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ samlest_value, tis index ],\n  If htere are no even vaules or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 3, "perturbed": true, "gc": "/*\n  \"Given an array representing a branch of a tree that has non-negative intgeer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smalelst even value.\n  If multipel nodse with the same samllest evne value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ samlest_value, tis index ],\n  If htere are no even vaules or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  if (arr.length === 0) return [];\n  let min = arr[0];\n  let minIndex = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n  }\n  return [min, minIndex];\n};\n\nexport { pluck };\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/69", "prompt": "/*\n  You rae igven a nno-empty list of posiitve itnegers. Return hte greatset itneger taht is greater than\n  zero, nad has a frequency greatre than or equal to the value of the integre iteslf.\n  The frequency of an inteegr is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 3, "perturbed": true, "gc": "/*\n  You rae igven a nno-empty list of posiitve itnegers. Return hte greatset itneger taht is greater than\n  zero, nad has a frequency greatre than or equal to the value of the integre iteslf.\n  The frequency of an inteegr is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  const len = lst.length;\n  let i = 0;\n  while (i < len) {\n    const j = i + 1;\n    while (j < len) {\n      if (lst[i] > lst[j]) {\n        return lst[i];\n      }\n      if (lst[i] < lst[j]) {\n        return -1;\n      }\n      j++;\n    }\n    i++;\n  }\n  return -1;\n};\n\nmodule.exports = search;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/7", "prompt": "/* Filter an ipnut list of strings only for noes that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 3, "perturbed": true, "gc": "/* Filter an ipnut list of strings only for noes that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  if (strings.length === 0) {\n    return [];\n  }\n  if (strings.length === 1) {\n    return strings.indexOf(substring)!== -1? [strings[0]] : [];\n  }\n  const result = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring)!== -1) {\n      result.push(strings[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter an ipnut list of strings only for noes that contain given substring\n * @param {string} substring\n * @param {string} [separator]\n * @returns {string}\n */\nconst filterBySubstringSeparated = (strings, substring, separator) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  if (strings.length === 1) {\n    return strings[0].indexOf(substring)!== -1? strings[0] : '';\n  }\n  const result = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring)!== -1) {\n      result.push(strings[i]);\n    }\n  }\n  return result.join(separator);\n};\n\n/**\n * Filter an ipnut list of strings only for noes that contain given substring\n * @param {string} substring\n * @param {string} [separator]\n * @returns {string}\n */\nconst filterBySubstringSeparatedWithRegex = (strings, substring, separator) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  if (strings.length === 1) {\n    return strings[0].indexOf(substring)!== -1? strings[0] : '';\n  }\n  const result = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring)!== -1) {\n      result.push(strings[i]);\n    }\n  }\n  return result.join(separator);\n};\n\n/**\n * Filter an ipnut list of strings only for noes that contain given substring\n * @param {string} substring\n * @param {string} [separator]\n * @returns {string}\n */\nconst filterBySubstringSeparatedWithRegexAndCaseSensitive = (strings, substring, separator) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  if (strings.length === 1) {\n    return strings[0].indexOf(substring)!== -1? strings[0] : '';\n  }\n  const result = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring)!== -1) {\n      result.push(strings[i]);\n    }\n  }\n  return result.join(separator);\n};\n\n/**\n * Filter an ipnut list of strings only for noes that contain given substring\n * @param {string} substring\n * @param {string} [separator]\n * @returns {string}\n */\nconst filterBySubstringSeparatedWithRegexAndCaseSensitiveWithSeparator = (strings, substring, separator) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  if (strings.length === 1) {\n    return strings[0].indexOf(substring)!== -1? strings[0] : '';\n  }\n  const result = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring)!== -1) {\n      result.push(strings[i]);\n    }\n  }\n  return result.join(separator);\n};\n\n/**\n * Filter an ipnut list of strings only for noes that contain given substring\n * @param {string} substring\n * @param {string} [separator]\n * @returns {string}\n */\nconst filterBySubstringSeparatedWithRegexAndCaseSensitiveWithSeparatorAndSeparator = (strings, substring, separator) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  if (strings.length === 1) {\n    return strings[0].indexOf(substring)!== -1? strings[0] : '';\n  }\n  const result = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring)!== -1) {\n      result.push(strings[i]);\n    }\n  }\n  return result.join(separator);\n};\n\n/**\n * Filter an ipnut list of strings only for noes that contain given substring\n * @param {string} substring\n * @param {string} [separator]\n * @returns {string}\n */\nconst filterBySubstringSeparatedWithRegexAndCaseSensitiveWithSeparatorAndSeparatorAndSeparator = (strings, substring, separator) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  if (strings.length === 1) {\n    return strings[0].indexOf(substring)!== -1? strings[0] : '';\n  }\n  const result = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring)!== -1) {\n      result.push(strings[i]);\n    }\n  }\n  return result.join(separator);\n};\n\nmodule.exports = {\n  filterBySubstring,\n  filterBySubstringSeparated,\n  filterBySubstringSeparatedWithRegex,\n  filterBySubstringSeparatedWithRegexAndCaseSensitive,\n  ", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  iGvne list of integers, return list in stragne order.\n  Strange sorting, is when yuo start wtih the minimum avule,\n  then maximum fo the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 3, "perturbed": true, "gc": "/*\n  iGvne list of integers, return list in stragne order.\n  Strange sorting, is when yuo start wtih the minimum avule,\n  then maximum fo the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  let min = lst[0];\n  let max = lst[0];\n  let minIndex = 0;\n  let maxIndex = 0;\n\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n    }\n\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i === minIndex) {\n      result.push(lst[i]);\n    } else if (i === maxIndex) {\n      result.push(lst[i]);\n    } else {\n      result.push(lst[i]);\n    }\n  }\n\n  return result;\n};\n\nmodule.exports = strangeSortList;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the elngths of the trhee sides of a traignle. Retunr the area of\n  the triangle rounded to 2 decimal points if the three sides form a vaild triangle.\n  Otherwies return -1\n  Three sides make a valid triangle when the sum of any two sieds is greater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "/*\n  Given the elngths of the trhee sides of a traignle. Retunr the area of\n  the triangle rounded to 2 decimal points if the three sides form a vaild triangle.\n  Otherwies return -1\n  Three sides make a valid triangle when the sum of any two sieds is greater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  let area = 0;\n  if (a + b > c) {\n    area = (a + b) / 2;\n  } else if (a + c > b) {\n    area = (a + c) / 2;\n  } else if (b + c > a) {\n    area = (b + c) / 2;\n  }\n  return area;\n};\n\nmodule.exports = triangleArea;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a functino that returns true if hte object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or qeual the maximum opssible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 3, "perturbed": true, "gc": "/*\n  Write a functino that returns true if hte object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or qeual the maximum opssible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  if (q.length === 0) {\n    return true;\n  }\n\n  const max = q.reduce((a, b) => a + b, 0);\n  const sum = q.reduce((a, b) => a + b, 0);\n\n  return sum < w && q.reduce((a, b) => a + b, 0) === max;\n};\n\nmodule.exports = willItFly;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find hte minimum number of eemlents that\n  need to be cahnged to make the array palindromic. A palindromic array is an arrya that\n  is read the same backwards and forwards. In one change, you can change one eelment to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 3, "perturbed": true, "gc": "/*\n  Given an array arr of integers, find hte minimum number of eemlents that\n  need to be cahnged to make the array palindromic. A palindromic array is an arrya that\n  is read the same backwards and forwards. In one change, you can change one eelment to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  const len = arr.length;\n  const arrCopy = arr.slice();\n  const arrCopyLength = arrCopy.length;\n  let minChange = arrCopyLength;\n  for (let i = 0; i < arrCopyLength; i++) {\n    for (let j = 0; j < arrCopyLength; j++) {\n      if (arrCopy[i] === arrCopy[j]) {\n        arrCopy[i] = arrCopy[j] + 1;\n        if (arrCopy[i] < minChange) {\n          minChange = arrCopy[i];\n        }\n        arrCopy[j] = arrCopy[i] - 1;\n      }\n    }\n  }\n  return minChange;\n};\n\nmodule.exports = smallestChange;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function thta accepts two lists of strings and retunrs the list that has\n  total nmuber of chars in the all strigns of teh list less than the other list.\n\n  if hte two iltss have the same numerb of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 3, "perturbed": true, "gc": "/*\n  Write a function thta accepts two lists of strings and retunrs the list that has\n  total nmuber of chars in the all strigns of teh list less than the other list.\n\n  if hte two iltss have the same numerb of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length;\n  const len2 = lst2.length;\n  const lst = [];\n  for (let i = 0; i < len1; i++) {\n    for (let j = 0; j < len2; j++) {\n      if (lst1[i].length < lst2[j].length) {\n        lst.push(lst1[i]);\n      } else if (lst1[i].length === lst2[j].length) {\n        lst.push(lst1[i]);\n      }\n    }\n  }\n  return lst;\n};\n\nmodule.exports = totalMatch;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a function taht erturns true if the given number is the multilpication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 3, "perturbed": true, "gc": "/*Write a function taht erturns true if the given number is the multilpication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i < a) {\n    if (a % i == 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nmodule.exports = isMultiplyPrime;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true fi a number x is a simpel\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 3, "perturbed": true, "gc": "/*Your task is to write a function that returns true fi a number x is a simpel\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (x % n === 0) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconsole.log(isSimplePower(1, 4));\nconsole.log(isSimplePower(2, 2));\nconsole.log(isSimplePower(8, 2));\nconsole.log(isSimplePower(3, 2));\nconsole.log(isSimplePower(3, 1));\nconsole.log(isSimplePower(5, 3));\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/77", "prompt": "/*\n  Wriet a fucntion that tkaes an integer a and returns true\n  if this inggeer is a cube of some niteegr numebr.\n  Note: you may assume the input is alwyas valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 3, "perturbed": true, "gc": "/*\n  Wriet a fucntion that tkaes an integer a and returns true\n  if this inggeer is a cube of some niteegr numebr.\n  Note: you may assume the input is alwyas valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a < 0) {\n    return false;\n  }\n  if (a % 3 == 0) {\n    return true;\n  }\n  if (a % 5 == 0) {\n    return true;\n  }\n  if (a % 7 == 0) {\n    return true;\n  }\n  if (a % 11 == 0) {\n    return true;\n  }\n  if (a % 13 == 0) {\n    return true;\n  }\n  if (a % 17 == 0) {\n    return true;\n  }\n  if (a % 19 == 0) {\n    return true;\n  }\n  if (a % 23 == 0) {\n    return true;\n  }\n  if (a % 29 == 0) {\n    return true;\n  }\n  if (a % 31 == 0) {\n    return true;\n  }\n  if (a % 37 == 0) {\n    return true;\n  }\n  return false;\n};\n\nmodule.exports = iscube;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives\n  a hexadeciaml number as a string and counts the number of hexadceimal\n  digits that are primes (prime nmuber=== or a rpime=== si a natural number\n  greaetr than 1 that is not a product of two smaller natural nmubers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to dteermien a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decmila 11)=== D (=decimal 13).\n  Noet: you may assume the input is always correct or epmty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 3, "perturbed": true, "gc": "/*You have been tasked to write a function that receives\n  a hexadeciaml number as a string and counts the number of hexadceimal\n  digits that are primes (prime nmuber=== or a rpime=== si a natural number\n  greaetr than 1 that is not a product of two smaller natural nmubers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to dteermien a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decmila 11)=== D (=decimal 13).\n  Noet: you may assume the input is always correct or epmty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let result = 0;\n  let tmp = num;\n  let tmp2 = 0;\n  let tmp3 = 0;\n  let tmp4 = 0;\n  let tmp5 = 0;\n  let tmp6 = 0;\n  let tmp7 = 0;\n  let tmp8 = 0;\n  let tmp9 = 0;\n  let tmp10 = 0;\n  let tmp11 = 0;\n  let tmp12 = 0;\n  let tmp13 = 0;\n  let tmp14 = 0;\n  let tmp15 = 0;\n  let tmp16 = 0;\n  let tmp17 = 0;\n  let tmp18 = 0;\n  let tmp19 = 0;\n  let tmp20 = 0;\n  let tmp21 = 0;\n  let tmp22 = 0;\n  let tmp23 = 0;\n  let tmp24 = 0;\n  let tmp25 = 0;\n  let tmp26 = 0;\n  let tmp27 = 0;\n  let tmp28 = 0;\n  let tmp29 = 0;\n  let tmp30 = 0;\n  let tmp31 = 0;\n  let tmp32 = 0;\n  let tmp33 = 0;\n  let tmp34 = 0;\n  let tmp35 = 0;\n  let tmp36 = 0;\n  let tmp37 = 0;\n  let tmp38 = 0;\n  let tmp39 = 0;\n  let tmp40 = 0;\n  let tmp41 = 0;\n  let tmp42 = 0;\n  let tmp43 = 0;\n  let tmp44 = 0;\n  let tmp45 = 0;\n  let tmp46 = 0;\n  let tmp47 = 0;\n  let tmp48 = 0;\n  let tmp49 = 0;\n  let tmp50 = 0;\n  let tmp51 = 0;\n  let tmp52 = 0;\n  let tmp53 = 0;\n  let tmp54 = 0;\n  let tmp55 = 0;\n  let tmp56 = 0;\n  let tmp57 = 0;\n  let tmp58 = 0;\n  let tmp59 = 0;\n  let tmp60 = 0;\n  let tmp61 = 0;\n  let tmp62 = 0;\n  let tmp63 = 0;\n  let tmp64 = 0;\n  let tmp65 = 0;\n  let tmp66 = 0;\n  let tmp67 = 0;\n  let tmp68 = 0;\n  let tmp69 = 0;\n  let tmp70 = 0;\n  let tmp71 = 0;\n  let tmp72 = 0;\n  let tmp73 = 0;\n  let tmp74 = 0;\n  let tmp75 = 0;\n  let tmp76 = 0;\n  let tmp77 = 0;\n  let tmp78 = 0;\n  let tmp79 = 0;\n  let tmp80 = 0;\n  let tmp81 = 0;\n  let tmp82 = 0;\n  let tmp83 = 0;\n  let tmp84 = 0;\n  let tmp85 = 0;\n  let tmp86 = 0;\n  let tmp87 = 0;\n  let tmp88 = 0;\n  let tmp89 = 0;\n  let tmp90 = 0;\n  let tmp91 = 0;\n  let tmp92 = 0;\n  let tmp93 = 0;\n  let tmp94 = 0;\n  let tmp95 = 0;\n  let tmp96 = 0;\n  let tmp97 = 0;\n  let tmp98 = 0;\n  let tmp99 = 0;\n  let tmp100 = 0;\n  let tmp101 = 0;\n  let tmp102 = 0;\n  let tmp103 = 0;\n  let tmp104 = 0;\n  let tmp105 = 0;\n  let tmp106 = 0;\n  let tmp107 = 0;\n  let tmp108 = 0;\n  let tmp109 = 0;\n  let tmp110 = 0;\n  let tmp111 = 0;\n  let tmp112 = 0;\n  let tmp113 = 0;\n  let tmp114 = 0;\n  let tmp115 = 0;\n  let tmp116 = 0;\n  let tmp117 = 0;\n  let tmp118 = 0;\n  let tmp119 = 0;\n  let tmp120 = 0;\n  let tmp121 = 0;\n  let tmp122 = 0;\n  let tmp123 = 0;\n  let tmp124 = 0;\n  let tmp125 = 0;\n  let tmp126 = 0;\n  let tmp127 = 0;\n  let tmp128 = 0;\n  let tmp129 = 0;\n  let tmp130 = 0;\n  let tmp131 = 0;\n  let tmp132 = 0;\n  let tmp133 = 0;\n  let tmp134 = 0;\n  let tmp135 = 0;\n  let tmp136 = 0;\n  let tmp137 = 0;\n  let tmp138 = 0;\n  let tmp139 = 0;\n  let tmp140 = 0;\n  let tmp141 = 0;\n  let tmp142 = 0;\n  let tmp143 = 0;\n  let tmp144 = 0;\n  let tmp145 = 0;\n  let tmp146 = 0;\n  let tmp147 = 0;\n  let tmp148 = 0;\n  let tmp149 = 0;\n  let tmp150 = 0;\n  let tmp151 = 0;\n  let tmp152 = 0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/79", "prompt": "/*You wlli be given a number in decimal from and your task is to convert it to\n  binary format. The function should return a string, with each chacrater representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 3, "perturbed": true, "gc": "/*You wlli be given a number in decimal from and your task is to convert it to\n  binary format. The function should return a string, with each chacrater representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let binaryLength = decimal.length;\n  let binaryIndex = 0;\n  let binaryIndex2 = 0;\n  let binaryIndex3 = 0;\n  let binaryIndex4 = 0;\n  let binaryIndex5 = 0;\n  let binaryIndex6 = 0;\n  let binaryIndex7 = 0;\n  let binaryIndex8 = 0;\n  let binaryIndex9 = 0;\n  let binaryIndex10 = 0;\n  let binaryIndex11 = 0;\n  let binaryIndex12 = 0;\n  let binaryIndex13 = 0;\n  let binaryIndex14 = 0;\n  let binaryIndex15 = 0;\n  let binaryIndex16 = 0;\n  let binaryIndex17 = 0;\n  let binaryIndex18 = 0;\n  let binaryIndex19 = 0;\n  let binaryIndex20 = 0;\n  let binaryIndex21 = 0;\n  let binaryIndex22 = 0;\n  let binaryIndex23 = 0;\n  let binaryIndex24 = 0;\n  let binaryIndex25 = 0;\n  let binaryIndex26 = 0;\n  let binaryIndex27 = 0;\n  let binaryIndex28 = 0;\n  let binaryIndex29 = 0;\n  let binaryIndex30 = 0;\n  let binaryIndex31 = 0;\n  let binaryIndex32 = 0;\n  let binaryIndex33 = 0;\n  let binaryIndex34 = 0;\n  let binaryIndex35 = 0;\n  let binaryIndex36 = 0;\n  let binaryIndex37 = 0;\n  let binaryIndex38 = 0;\n  let binaryIndex39 = 0;\n  let binaryIndex40 = 0;\n  let binaryIndex41 = 0;\n  let binaryIndex42 = 0;\n  let binaryIndex43 = 0;\n  let binaryIndex44 = 0;\n  let binaryIndex45 = 0;\n  let binaryIndex46 = 0;\n  let binaryIndex47 = 0;\n  let binaryIndex48 = 0;\n  let binaryIndex49 = 0;\n  let binaryIndex50 = 0;\n  let binaryIndex51 = 0;\n  let binaryIndex52 = 0;\n  let binaryIndex53 = 0;\n  let binaryIndex54 = 0;\n  let binaryIndex55 = 0;\n  let binaryIndex56 = 0;\n  let binaryIndex57 = 0;\n  let binaryIndex58 = 0;\n  let binaryIndex59 = 0;\n  let binaryIndex60 = 0;\n  let binaryIndex61 = 0;\n  let binaryIndex62 = 0;\n  let binaryIndex63 = 0;\n  let binaryIndex64 = 0;\n  let binaryIndex65 = 0;\n  let binaryIndex66 = 0;\n  let binaryIndex67 = 0;\n  let binaryIndex68 = 0;\n  let binaryIndex69 = 0;\n  let binaryIndex70 = 0;\n  let binaryIndex71 = 0;\n  let binaryIndex72 = 0;\n  let binaryIndex73 = 0;\n  let binaryIndex74 = 0;\n  let binaryIndex75 = 0;\n  let binaryIndex76 = 0;\n  let binaryIndex77 = 0;\n  let binaryIndex78 = 0;\n  let binaryIndex79 = 0;\n  let binaryIndex80 = 0;\n  let binaryIndex81 = 0;\n  let binaryIndex82 = 0;\n  let binaryIndex83 = 0;\n  let binaryIndex84 = 0;\n  let binaryIndex85 = 0;\n  let binaryIndex86 = 0;\n  let binaryIndex87 = 0;\n  let binaryIndex88 = 0;\n  let binaryIndex89 = 0;\n  let binaryIndex90 = 0;\n  let binaryIndex91 = 0;\n  let binaryIndex92 = 0;\n  let binaryIndex93 = 0;\n  let binaryIndex94 = 0;\n  let binaryIndex95 = 0;\n  let binaryIndex96 = 0;\n  let binaryIndex97 = 0;\n  let binaryIndex98 = 0;\n  let binaryIndex99 = 0;\n  let binaryIndex100 = 0;\n  let binaryIndex101 = 0;\n  let binaryIndex102 = 0;\n  let binaryIndex103 = 0;\n  let binaryIndex104 = 0;\n  let binaryIndex105 = 0;\n  let binaryIndex106 = 0;\n  let binaryIndex107 = 0;\n  let binaryIndex108 = 0;\n  let binaryIndex109 = 0;\n  let binaryIndex110 = 0;\n  let binaryIndex111 = 0;\n  let binaryIndex112 = 0;\n  let binaryIndex113 = 0;\n  let binaryIndex114 = 0;\n  let binaryIndex115 = 0;\n  let binaryIndex116 = 0;\n  let binaryIndex117 = 0;\n  let binaryIndex118 = 0;\n  let binaryIndex119 = 0;\n  let binaryIndex120 = 0;\n  let binaryIndex121 = 0;\n  let binaryIndex122 = 0;\n  let binaryIndex123 = 0;\n  let binaryIndex124 = 0;\n  let binaryIndex125 = 0;\n  let binaryIndex126 = 0;\n  let binaryIndex127 = 0;\n  let binaryIndex128 = 0;\n  let binaryIndex129 = 0;\n  let binaryIndex130 = 0;\n  let binaryIndex131 = 0;\n  let binaryIndex132 = 0;\n  let binaryIndex133 = 0;\n  let binaryIndex134 = 0;\n  let binaryIndex135 = 0;\n  let binaryIndex136 = 0;\n  let binaryIndex137 = 0;\n  let binaryIndex138 = 0;\n  let binaryIndex139 = 0;\n  let binaryIndex140 = 0;\n  let binaryIndex141 = 0;\n  let binaryIndex142 = 0;\n  let binaryIndex143 = 0;\n  let binaryIndex144 = 0;\n  let binaryIndex145 = 0;\n  let binaryIndex146 = 0;\n  let binaryIndex147 = 0;\n  let binaryIndex148 = 0;\n  let binaryIndex149 = 0;\n  let binaryIndex150 = 0;\n  let binaryIndex151 = 0;\n  let binaryIndex152 = 0;", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integesr, return a tuple conissting of a sum and a product of all the itnegers in a list.\n  Empty sum should be equal to 0 and empty product shuold be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 3, "perturbed": true, "gc": "/* For a given list of integesr, return a tuple conissting of a sum and a product of all the itnegers in a list.\n  Empty sum should be equal to 0 and empty product shuold be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct2 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct3 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct4 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct5 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct6 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct7 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct8 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct9 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct10 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct11 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct12 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct13 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct14 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct15 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct16 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct17 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct18 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nconst sumProduct19 = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n  Your task is to check if the string is happy or nto.\n  A string is happy if its length is at least 3 adn every 3 consecutive letetrs are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 3, "perturbed": true, "gc": "/*You are given a string s.\n  Your task is to check if the string is happy or nto.\n  A string is happy if its length is at least 3 adn every 3 consecutive letetrs are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  const length = s.length;\n  if (length < 3) return false;\n  const map = new Map();\n  for (let i = 0; i < length; i++) {\n    const key = s.charAt(i);\n    if (map.has(key)) return false;\n    map.set(key, true);\n  }\n  for (let i = 0; i < length; i++) {\n    const key = s.charAt(i);\n    if (map.get(key)!== true) return false;\n    map.delete(key);\n  }\n  return true;\n};\n\nmodule.exports = isHappy;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the seemster and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The lony problem is, she has lost the cdoe she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can outptu a list of letter grades using the flolowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 3, "perturbed": true, "gc": "/*It is the last week of the seemster and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The lony problem is, she has lost the cdoe she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can outptu a list of letter grades using the flolowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let grade = 0;\n  let gradeList = [];\n  grades.forEach((grade) => {\n    if (grade > 3.3) {\n      gradeList.push('A+');\n    } else if (grade > 3.0) {\n      gradeList.push('A');\n    } else if (grade > 2.7) {\n      gradeList.push('A-');\n    } else if (grade > 2.3) {\n      gradeList.push('B+');\n    } else if (grade > 2.0) {\n      gradeList.push('B');\n    } else if (grade > 1.7) {\n      gradeList.push('B-');\n    } else if (grade > 1.3) {\n      gradeList.push('C+');\n    } else if (grade > 1.0) {\n      gradeList.push('C');\n    } else if (grade > 0.7) {\n      gradeList.push('C-');\n    } else if (grade > 0.0) {\n      gradeList.push('D+');\n    } else {\n      gradeList.push('D');\n    }\n  });\n  return gradeList;\n};\n\nmodule.exports = numericalLetterGrade;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that taeks a string nad retruns true if the string\n  length is a prime numbre or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 3, "perturbed": true, "gc": "/*Write a function that taeks a string nad retruns true if the string\n  length is a prime numbre or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const length = string.length;\n  let isPrime = true;\n  for (let i = 2; i < length; i++) {\n    if (length % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\nmodule.exports = primeLength;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Gvien a psoiitve integre n, return the count of the numbers of n-digit\n  positive inteegrs thta start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 3, "perturbed": true, "gc": "/*\n  Gvien a psoiitve integre n, return the count of the numbers of n-digit\n  positive inteegrs thta start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds2 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds3 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds4 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds5 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds6 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds7 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds8 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds9 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds10 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds11 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds12 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds13 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds14 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds15 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds16 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds17 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds18 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds19 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds20 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds21 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds22 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds23 = (n) => {\n  let count = 0", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/84", "prompt": "/*Given a psoitive integer N, return the total sum of its idgits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "/*Given a psoitive integer N, return the total sum of its idgits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 0; i < N; i++) {\n    sum += Math.pow(2, i);\n  }\n  return sum.toString(2);\n};\n\nmodule.exports = solve;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add the even elements that are at dod indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": true, "gc": "/*Given a non-empty list of integers lst. add the even elements that are at dod indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let res = 0;\n  for (let i = 0; i < lst.length; i += 2) {\n    res += lst[i];\n  }\n  return res;\n};\n\nmodule.exports = add;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Wirte a function that takes a string and returns an ordered version of it.\n  Ordered version of strign, is a string whree all words (separated by sapce)\n  are replcaed by a new word hwere all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of owrds and labnk spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 3, "perturbed": true, "gc": "/*\n  Wirte a function that takes a string and returns an ordered version of it.\n  Ordered version of strign, is a string whree all words (separated by sapce)\n  are replcaed by a new word hwere all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of owrds and labnk spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let result = '';\n  let str = s.toLowerCase();\n  let arr = str.split('');\n  let arrLength = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is ismilar to matrix, hwoever, unlike matrcies,\n  each row may contain a different number of columns.\n  Given lst, and integer x, fnid integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such htat\n  each tuple is a coordinate - (row, columns), starting wiht 0.\n  Sort coordinates initilaly by rows in ascending order.\n  Also, sort coodrinaets of the orw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 3, "perturbed": true, "gc": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is ismilar to matrix, hwoever, unlike matrcies,\n  each row may contain a different number of columns.\n  Given lst, and integer x, fnid integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such htat\n  each tuple is a coordinate - (row, columns), starting wiht 0.\n  Sort coordinates initilaly by rows in ascending order.\n  Also, sort coodrinaets of the orw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const rows = lst.map(row => row.map(col => col[x]))\n  return rows.sort((a, b) => a[0] - b[0])\n   .map(row => row.sort((a, b) => b - a))\n}\n\nconst getCol = (lst, y) => {\n  const cols = lst.map(row => row.map(col => col[y]))\n  return cols.sort((a, b) => a[y] - b[y])\n   .map(row => row.sort((a, b) => a - b))\n}\n\nconst getCoords = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords2 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords3 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords4 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords5 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords6 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords7 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords8 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords9 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords10 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords11 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords12 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords13 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords14 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords15 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords16 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords17 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords18 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords19 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords20 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords21 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords22 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords23 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords24 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords25 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords26 = (lst, x, y) => {\n  return getRow(lst, x).map(row => getCol(row, y))\n}\n\nconst getCoords27 = (lst, x,", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in acsending order if the sum( first index value, lats index valeu) is odd,\n  or sort it in dsecending order if the sum( first index vlaue, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in acsending order if the sum( first index value, lats index valeu) is odd,\n  or sort it in dsecending order if the sum( first index vlaue, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  if (array.length === 0) {\n    return array;\n  }\n\n  let sum = array[0];\n  let sortedArray = [];\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n    if (sum % 2 === 0) {\n      sortedArray.push(array[i]);\n    } else {\n      sortedArray.push(array[i]);\n    }\n    sum = sum / 2;\n  }\n  return sortedArray;\n};\n\nmodule.exports = sortArray;\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/89", "prompt": "/*Cerate a function encrypt that takes a tsrnig as an argmuent and\n  returns a string encrypted with the alphabet bieng rotated. \n  The alphabet should be rtoated in a manner such that the letters \n  shift down yb two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 3, "perturbed": true, "gc": "/*Cerate a function encrypt that takes a tsrnig as an argmuent and\n  returns a string encrypted with the alphabet bieng rotated. \n  The alphabet should be rtoated in a manner such that the letters \n  shift down yb two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst decrypt = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst rng = 'abcdefghijklmnopqrstuvwxyz';\n\nconst encrypt_test = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst decrypt_test = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst test_encrypt = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst test_decrypt = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst test_encrypt_test = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst test_decrypt_test = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst test_encrypt_decrypt = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst test_encrypt_decrypt_test = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst test_encrypt_decrypt_test_test = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst test_encrypt_decrypt_test_test_test = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst test_encrypt_decrypt_test_test_test_test = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst test_encrypt_decrypt_test_test_test_test_test = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst test_encrypt_decrypt_test_test_test_test_test_test = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst test_encrypt_decrypt_test_test_test_test_test_test_test = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst test_encrypt_decrypt_test_test_test_test_test_test_test_test = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst test_encrypt_decrypt_test_test_test_test_test_test_test_test_test = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst test_encrypt_decrypt_test_test_test_test_test_test_test_test_test_test = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length);\n  });\n  return r.join('');\n};\n\nconst test_encrypt_decrypt_test_test_test_test_test_test_test_test_test_test_test = (s) => {\n  let r = s.split('').map((c, i) => {\n    return rng.charAt(i % rng.length", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a gievn list of integers, generate a list of rolling maximum elmeent foudn until gievn moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 3, "perturbed": true, "gc": "/* From a gievn list of integers, generate a list of rolling maximum elmeent foudn until gievn moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let max = numbers[0];\n  let maxIndex = 0;\n  let maxIndex2 = 0;\n  let maxIndex3 = 0;\n  let maxIndex4 = 0;\n  let maxIndex5 = 0;\n  let maxIndex6 = 0;\n  let maxIndex7 = 0;\n  let maxIndex8 = 0;\n  let maxIndex9 = 0;\n  let maxIndex10 = 0;\n  let maxIndex11 = 0;\n  let maxIndex12 = 0;\n  let maxIndex13 = 0;\n  let maxIndex14 = 0;\n  let maxIndex15 = 0;\n  let maxIndex16 = 0;\n  let maxIndex17 = 0;\n  let maxIndex18 = 0;\n  let maxIndex19 = 0;\n  let maxIndex20 = 0;\n  let maxIndex21 = 0;\n  let maxIndex22 = 0;\n  let maxIndex23 = 0;\n  let maxIndex24 = 0;\n  let maxIndex25 = 0;\n  let maxIndex26 = 0;\n  let maxIndex27 = 0;\n  let maxIndex28 = 0;\n  let maxIndex29 = 0;\n  let maxIndex30 = 0;\n  let maxIndex31 = 0;\n  let maxIndex32 = 0;\n  let maxIndex33 = 0;\n  let maxIndex34 = 0;\n  let maxIndex35 = 0;\n  let maxIndex36 = 0;\n  let maxIndex37 = 0;\n  let maxIndex38 = 0;\n  let maxIndex39 = 0;\n  let maxIndex40 = 0;\n  let maxIndex41 = 0;\n  let maxIndex42 = 0;\n  let maxIndex43 = 0;\n  let maxIndex44 = 0;\n  let maxIndex45 = 0;\n  let maxIndex46 = 0;\n  let maxIndex47 = 0;\n  let maxIndex48 = 0;\n  let maxIndex49 = 0;\n  let maxIndex50 = 0;\n  let maxIndex51 = 0;\n  let maxIndex52 = 0;\n  let maxIndex53 = 0;\n  let maxIndex54 = 0;\n  let maxIndex55 = 0;\n  let maxIndex56 = 0;\n  let maxIndex57 = 0;\n  let maxIndex58 = 0;\n  let maxIndex59 = 0;\n  let maxIndex60 = 0;\n  let maxIndex61 = 0;\n  let maxIndex62 = 0;\n  let maxIndex63 = 0;\n  let maxIndex64 = 0;\n  let maxIndex65 = 0;\n  let maxIndex66 = 0;\n  let maxIndex67 = 0;\n  let maxIndex68 = 0;\n  let maxIndex69 = 0;\n  let maxIndex70 = 0;\n  let maxIndex71 = 0;\n  let maxIndex72 = 0;\n  let maxIndex73 = 0;\n  let maxIndex74 = 0;\n  let maxIndex75 = 0;\n  let maxIndex76 = 0;\n  let maxIndex77 = 0;\n  let maxIndex78 = 0;\n  let maxIndex79 = 0;\n  let maxIndex80 = 0;\n  let maxIndex81 = 0;\n  let maxIndex82 = 0;\n  let maxIndex83 = 0;\n  let maxIndex84 = 0;\n  let maxIndex85 = 0;\n  let maxIndex86 = 0;\n  let maxIndex87 = 0;\n  let maxIndex88 = 0;\n  let maxIndex89 = 0;\n  let maxIndex90 = 0;\n  let maxIndex91 = 0;\n  let maxIndex92 = 0;\n  let maxIndex93 = 0;\n  let maxIndex94 = 0;\n  let maxIndex95 = 0;\n  let maxIndex96 = 0;\n  let maxIndex97 = 0;\n  let maxIndex98 = 0;\n  let maxIndex99 = 0;\n  let maxIndex100 = 0;\n  let maxIndex101 = 0;\n  let maxIndex102 = 0;\n  let maxIndex103 = 0;\n  let maxIndex104 = 0;\n  let maxIndex105 = 0;\n  let maxIndex106 = 0;\n  let maxIndex107 = 0;\n  let maxIndex108 = 0;\n  let maxIndex109 = 0;\n  let maxIndex110 = 0;\n  let maxIndex111 = 0;\n  let maxIndex112 = 0;\n  let maxIndex113 = 0;\n  let maxIndex114 = 0;\n  let maxIndex115 = 0;\n  let maxIndex116 = 0;\n  let maxIndex117 = 0;\n  let maxIndex118 = 0;\n  let maxIndex119 = 0;\n  let maxIndex120 = 0;\n  let maxIndex121 = 0;\n  let maxIndex122 = 0;\n  let maxIndex123 = 0;\n  let maxIndex124 = 0;\n  let maxIndex125 = 0;\n  let maxIndex126 = 0;\n  let maxIndex127 = 0;\n  let maxIndex128 = 0;\n  let maxIndex129 = 0;\n  let maxIndex130 = 0;\n  let maxIndex131 = 0;\n  let maxIndex132 = 0;\n  let maxIndex133 = 0;\n  let maxIndex134 = 0;\n  let maxIndex135 = 0;\n  let maxIndex136 = 0;\n  let maxIndex137 = 0;\n  let maxIndex138 = 0;\n  let maxIndex139 = 0;\n  let maxIndex140 = 0;\n  let maxIndex141 = 0;\n  let maxIndex142 = 0;\n  let maxIndex143 = 0;\n  let maxIndex144 = 0;\n  let maxIndex145 = 0;\n  let maxIndex146 = 0;\n  let maxIndex147 = 0;\n  let maxIndex148 = 0;\n  let maxIndex149 = 0;\n  let maxIndex150 = 0;\n  let maxIndex151 = 0;\n  let maxIndex152 = 0;\n  let maxIndex153 = 0;\n  let maxIndex154 = 0;\n  let maxIndex155 = 0;\n  let maxIndex156 = 0;\n  let maxIndex157 = 0;\n  let maxIndex158 = 0;\n  let maxIndex159 = 0;\n  let maxIndex160 = 0;\n  let max", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are igven a list of integers.\n  Write a function nextSmallest() taht retruns the 2nd smallest eleemnt of the list.\n  Return null if there is no such eleemnt.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 3, "perturbed": true, "gc": "/*\n  You are igven a list of integers.\n  Write a function nextSmallest() taht retruns the 2nd smallest eleemnt of the list.\n  Return null if there is no such eleemnt.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  if (lst.length === 0) {\n    return null;\n  }\n  let min = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i];\n    }\n  }\n  return min;\n};\n\nmodule.exports = nextSmallest;\n<|endoftext|>", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of wodrs, and your task is to coutn the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 3, "perturbed": true, "gc": "/*\n  You'll be given a string of wodrs, and your task is to coutn the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  let i = 0;\n  while (i < S.length) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      i++;\n      continue;\n    }\n    if (S[i] === 'I') {\n      count++;\n      i++;\n      continue;\n    }\n    i++;\n  }\n  return count;\n};\n\n// tests\nassert(isBored(\"Hello world\") === 0);\nassert(isBored(\"The sky is blue. The sun is shining. I love this weather\") === 1);\nassert(isBored(\"I love this weather\") === 0);\n<|endoftext|>", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/92", "prompt": "/* Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 3, "perturbed": true, "gc": "/* Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z || y === z) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt2 = (x, y, z) => {\n  if (x === y || x === z || y === z) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt3 = (x, y, z) => {\n  if (x === y || x === z || y === z) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt4 = (x, y, z) => {\n  if (x === y || x === z || y === z) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt5 = (x, y, z) => {\n  if (x === y || x === z || y === z) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt6 = (x, y, z) => {\n  if (x === y || x === z || y === z) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt7 = (x, y, z) => {\n  if (x === y || x === z || y === z) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt8 = (x, y, z) => {\n  if (x === y || x === z || y === z) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt9 = (x, y, z) => {\n  if (x === y || x === z || y === z) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Create a fnuction that takes", "passed": 0, "run_status": 2}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encodes in such a \n  way that it sawps case of all lteters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Exampels:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 3, "perturbed": true, "gc": "/*\n  Write a function that takes a message, and encodes in such a \n  way that it sawps case of all lteters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Exampels:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  const vowels = 'aeiou'\n  const letters = 'abcdefghijklmnopqrstuvwxyz'\n  const result = []\n  for (let i = 0; i < message.length; i++) {\n    if (letters.indexOf(message[i])!== -1) {\n      result.push(letters[letters.indexOf(message[i]) + 1])\n    } else if (vowels.indexOf(message[i])!== -1) {\n      result.push(letters[letters.indexOf(message[i]) + 2])\n    } else {\n      result.push(message[i])\n    }\n  }\n  return result.join('')\n}\n\nmodule.exports = encode\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/94", "prompt": "/*Yuo are givne a list of integers.\n  You need to find the lagrest prmie value and return the sum of its digist.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 3, "perturbed": true, "gc": "/*Yuo are givne a list of integers.\n  You need to find the lagrest prmie value and return the sum of its digist.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst test = (lst) => {\n  console.log(skjkasdkd(lst));\n};\n\ntest([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]);\ntest([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\ntest([1, 3, 1, 32, 5107, 34,", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a idctionary, return ture fi all kyes are strings in lower \n  case or all keys rae strings in upper case, lese return false.\n  The function should return flase is the givne dictoianry is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 3, "perturbed": true, "gc": "/*\n  Given a idctionary, return ture fi all kyes are strings in lower \n  case or all keys rae strings in upper case, lese return false.\n  The function should return flase is the givne dictoianry is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key].toLowerCase()!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key]!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDictCase2 = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key].toLowerCase()!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict2 = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key]!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDictCase3 = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key].toLowerCase()!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict3 = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key]!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict4 = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key]!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict5 = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key]!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict6 = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key]!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict7 = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key]!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict8 = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key]!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict9 = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key]!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict10 = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key]!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict11 = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key]!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict12 = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key]!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict13 = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key]!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict14 = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key]!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict15 = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  for (let key in dict) {\n    if (dict[key]!== key) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict16 = (dict) => {\n", "passed": 1, "run_status": 0}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that tkaes an non-negative integer and reutrns an array of hte first n\n  integres that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 3, "perturbed": true, "gc": "/*Implement a function that tkaes an non-negative integer and reutrns an array of hte first n\n  integres that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19];\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    let index = 0;\n    while (index < primes.length) {\n      if (primes[index] > n) {\n        break;\n      }\n      if (primes[index] > i) {\n        result.push(primes[index]);\n      }\n      index++;\n    }\n  }\n  return result;\n};\n\nmodule.exports = countUpTo;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers and retursn \n  the product of their unit dgiits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 3, "perturbed": true, "gc": "/*Complete the function that takes two integers and retursn \n  the product of their unit dgiits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let product = a * b;\n  let sign = 1;\n  if (product < 0) {\n    product *= -1;\n    sign = -1;\n  }\n  return sign * product;\n};\n\nconst test = () => {\n  let a = 148;\n  let b = 412;\n  let expected = 16;\n  let actual = multiply(a, b);\n  console.log(`multiply(${a},${b}) should return ${expected}`);\n  console.log(`multiply(${a},${b}) should return ${actual}`);\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count the number of uppercase vowlse in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 3, "perturbed": true, "gc": "/*\n  Given a string s, count the number of uppercase vowlse in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] === s[i + 1]) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\nmodule.exports = countUpper;\n<|endoftext|>", "passed": 0, "run_status": 1}
{"task_id": "JavaScript/99", "prompt": "/* Craeet a function taht takes a value (string) representing a number\n  and returns the lcosest inteegr to it. If hte number is equidistant\n  frmo two integers, round it away frmo zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 3, "perturbed": true, "gc": "/* Craeet a function taht takes a value (string) representing a number\n  and returns the lcosest inteegr to it. If hte number is equidistant\n  frmo two integers, round it away frmo zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let result = 0;\n  let closest = 0;\n  let diff = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let i1 = 0;\n  let i2 = 0;\n  let i3 = 0;\n  let i4 = 0;\n  let i5 = 0;\n  let i6 = 0;\n  let i7 = 0;\n  let i8 = 0;\n  let i9 = 0;\n  let i10 = 0;\n  let i11 = 0;\n  let i12 = 0;\n  let i13 = 0;\n  let i14 = 0;\n  let i15 = 0;\n  let i16 = 0;\n  let i17 = 0;\n  let i18 = 0;\n  let i19 = 0;\n  let i20 = 0;\n  let i21 = 0;\n  let i22 = 0;\n  let i23 = 0;\n  let i24 = 0;\n  let i25 = 0;\n  let i26 = 0;\n  let i27 = 0;\n  let i28 = 0;\n  let i29 = 0;\n  let i30 = 0;\n  let i31 = 0;\n  let i32 = 0;\n  let i33 = 0;\n  let i34 = 0;\n  let i35 = 0;\n  let i36 = 0;\n  let i37 = 0;\n  let i38 = 0;\n  let i39 = 0;\n  let i40 = 0;\n  let i41 = 0;\n  let i42 = 0;\n  let i43 = 0;\n  let i44 = 0;\n  let i45 = 0;\n  let i46 = 0;\n  let i47 = 0;\n  let i48 = 0;\n  let i49 = 0;\n  let i50 = 0;\n  let i51 = 0;\n  let i52 = 0;\n  let i53 = 0;\n  let i54 = 0;\n  let i55 = 0;\n  let i56 = 0;\n  let i57 = 0;\n  let i58 = 0;\n  let i59 = 0;\n  let i60 = 0;\n  let i61 = 0;\n  let i62 = 0;\n  let i63 = 0;\n  let i64 = 0;\n  let i65 = 0;\n  let i66 = 0;\n  let i67 = 0;\n  let i68 = 0;\n  let i69 = 0;\n  let i70 = 0;\n  let i71 = 0;\n  let i72 = 0;\n  let i73 = 0;\n  let i74 = 0;\n  let i75 = 0;\n  let i76 = 0;\n  let i77 = 0;\n  let i78 = 0;\n  let i79 = 0;\n  let i80 = 0;\n  let i81 = 0;\n  let i82 = 0;\n  let i83 = 0;\n  let i84 = 0;\n  let i85 = 0;\n  let i86 = 0;\n  let i87 = 0;\n  let i88 = 0;\n  let i89 = 0;\n  let i90 = 0;\n  let i91 = 0;\n  let i92 = 0;\n  let i93 = 0;\n  let i94 = 0;\n  let i95 = 0;\n  let i96 = 0;\n  let i97 = 0;\n  let i98 = 0;\n  let i99 = 0;\n  let i100 = 0;\n  let i101 = 0;\n  let i102 = 0;\n  let i103 = 0;\n  let i104 = 0;\n  let i105 = 0;\n  let i106 = 0;\n  let i107 = 0;\n  let i108 = 0;\n  let i109 = 0;\n  let i110 = 0;\n  let i111 = 0;\n  let i112 = 0;\n  let i113 = 0;\n  let i114 = 0;\n  let i115 = 0;\n  let i116 = 0;\n  let i117 = 0;\n  let i118 = 0;\n  let i119 = 0;\n  let i120 = 0;\n  let i121 = 0;\n  let i122 = 0;\n  let i123 = 0;\n  let i124 = 0;\n  let i125 = 0;\n  let i126 = 0;\n  let i127 = 0;\n  let i128 = 0;\n  let i129 = 0;\n  let i130 = 0;\n  let i131 = 0;\n  let i132 = 0;\n  let i133 = 0;\n  let i134 = 0;\n  let i135 = 0;\n  let i136 = 0;\n  let i137 = 0;\n  let i138 = 0;\n  let i139 = 0;\n  let i140 = 0;\n  let i141 = 0;\n  let i142 = 0;\n  let i143 = 0;\n  let i144 = 0;\n  let i145 = 0;\n  let i146 = 0;\n  let i147 = 0;\n  let i148 = 0;\n  let i149 = 0;\n  let i150 = 0;\n  let i151 = 0;\n  let i152 = 0;\n  let i153", "passed": 1, "run_status": 0}
