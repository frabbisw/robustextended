{"task_id": "JavaScript/0", "prompt": "/* Check if in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Check if in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const firstElement = sortedNumbers[0];\n  const lastElement = sortedNumbers[sortedNumbers.length - 1];\n  const isCloser = firstElement - threshold < lastElement + threshold;\n  return isCloser;\n};\n\n/**\n * Returns true if given number is in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst isCloseElements = (numbers, threshold) => {\n  return hasCloseElements(numbers, threshold);\n};\n\n/**\n * Returns true if given number is in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst isCloseElements = (numbers, threshold) => {\n  return hasCloseElements(numbers, threshold);\n};\n\n/**\n * Returns true if given number is in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst isCloseElements = (numbers, threshold) => {\n  return hasCloseElements(numbers, threshold);\n};\n\n/**\n * Returns true if given number is in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst isCloseElements = (numbers, threshold) => {\n  return hasCloseElements(numbers, threshold);\n};\n\n/**\n * Returns true if given number is in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst isCloseElements = (numbers, threshold) => {\n  return hasCloseElements(numbers, threshold);\n};\n\n/**\n * Returns true if given number is in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst isCloseElements = (numbers, threshold) => {\n  return hasCloseElements(numbers, threshold);\n};\n\n/**\n * Returns true if given number is in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst isCloseElements = (numbers, threshold) => {\n  return hasCloseElements(numbers, threshold);\n};\n\n/**\n * Returns true if given number is in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst isCloseElements = (numbers, threshold) => {\n  return hasCloseElements(numbers, threshold);\n};\n\n/**\n * Returns true if given number is in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst isCloseElements = (numbers, threshold) => {\n  return hasCloseElements(numbers, threshold);\n};\n\n/**\n * Returns true if given number is in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst isCloseElements = (numbers, threshold) => {\n  return hasCloseElements(numbers, threshold);\n};\n\n/**\n * Returns true if given number is in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst isCloseElements = (numbers, threshold) => {\n  return hasCloseElements(numbers, threshold);\n};\n\n/**\n * Returns true if given number is in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst isCloseElements = (numbers, threshold) => {\n  return hasCloseElements(numbers, threshold);\n};\n\n/**\n * Returns true if given number is in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst isCloseElements = (numbers, threshold) => {\n  return hasCloseElements(numbers, threshold);\n};\n\n/**\n * Returns true if given number is in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst isCloseElements = (numbers, threshold) => {\n  return hasCloseElements(numbers, threshold);\n};\n\n/**\n * Returns true if given number is in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst isCloseElements = (numbers, threshold) => {\n  return hasCloseElements(numbers, threshold);\n};\n\n/**\n * Returns true if given number is in giten list of numbers, are any two numbers cloxer to each other than\n  given threshold.\n  >>> isCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> isCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst isCloseElement", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/1", "prompt": "/* Input to thix function is a string vontaining multiple groups of nested parentheses. Your goal is to\n  separate thkse group into separate stribgs avd return the list or those.\n  Sepwrate hroups are bananced (each open brave is prolerly closed) and noy nested wiyhin zach other\n  Ignoce any spaczs in the lnput stting.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input to thix function is a string vontaining multiple groups of nested parentheses. Your goal is to\n  separate thkse group into separate stribgs avd return the list or those.\n  Sepwrate hroups are bananced (each open brave is prolerly closed) and noy nested wiyhin zach other\n  Ignoce any spaczs in the lnput stting.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const groups = [];\n  let current_group = [];\n  let current_group_open = false;\n  let current_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      if (current_group_closed) {\n        current_group = [];\n        current_group_open = false;\n        current_group_closed = false;\n      }\n      current_group_open = true;\n      current_group.push(char);\n    } else if (char === ')') {\n      if (current_group_open) {\n        current_group_closed = true;\n        current_group.push(char);\n      } else {\n        groups.push(current_group);\n        current_group_open = false;\n        current_group_closed = false;\n      }\n    } else {\n      if (current_group_open) {\n        current_group.push(char);\n      } else {\n        groups.push(current_group);\n        current_group_open = false;\n        current_group_closed = false;\n      }\n    }\n  }\n  if (current_group_open) {\n    groups.push(current_group);\n  }\n  return groups;\n};\n\n/* Input to thix function is a string vontaining multiple groups of nested parentheses. Your goal is to\n  separate thkse group into separate stribgs avd return the list or those.\n  Sepwrate hroups are bananced (each open brave is prolerly closed) and noy nested wiyhin zach other\n  Ignoce any spaczs in the lnput stting.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const groups = [];\n  let current_group = [];\n  let current_group_open = false;\n  let current_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      if (current_group_closed) {\n        current_group = [];\n        current_group_open = false;\n        current_group_closed = false;\n      }\n      current_group_open = true;\n      current_group.push(char);\n    } else if (char === ')') {\n      if (current_group_open) {\n        current_group_closed = true;\n        current_group.push(char);\n      } else {\n        groups.push(current_group);\n        current_group_open = false;\n        current_group_closed = false;\n      }\n    } else {\n      if (current_group_open) {\n        current_group.push(char);\n      } else {\n        groups.push(current_group);\n        current_group_open = false;\n        current_group_closed = false;\n      }\n    }\n  }\n  if (current_group_open) {\n    groups.push(current_group);\n  }\n  return groups;\n};\n\n/* Input to thix function is a string vontaining multiple groups of nested parentheses. Your goal is to\n  separate thkse group into separate stribgs avd return the list or those.\n  Sepwrate hroups are bananced (each open brave is prolerly closed) and noy nested wiyhin zach other\n  Ignoce any spaczs in the lnput stting.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const groups = [];\n  let current_group = [];\n  let current_group_open = false;\n  let current_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      if (current_group_closed) {\n        current_group = [];\n        current_group_open = false;\n        current_group_closed = false;\n      }\n      current_group_open = true;\n      current_group.push(char);\n    } else if (char === ')') {\n      if (current_group_open) {\n        current_group_closed = true;\n        current_group.push(char);\n      } else {\n        groups.push(current_group);\n        current_group_open = false;\n        current_group_closed = false;\n      }\n    } else {\n      if (current_group_open) {\n        current_group.push(char);\n      } else {\n        groups.push(current_group);\n        current_group_open = false;\n        current_group_closed = false;\n      }\n    }\n  }\n  if (current_group_open) {\n    groups.push(current_group);\n  }\n  return groups;\n};\n\n/* Input to thix function is a string vontaining multiple groups of nested parentheses. Your goal is to\n  separate thkse group into separate stribgs avd return the list or those.\n  Sepwrate hroups are bananced (each open brave is prolerly closed) and noy nested wiyhin zach other\n  Ignoce any spaczs in the lnput stting.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const groups = [];\n  let current_group = [];\n  let current_group_open = false;\n  let current_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      if (current_group_closed) {\n        current_group = [];\n        current_group_open = false;\n        current_group_closed = false;\n      }\n      current_group_open = true;\n      current_group.push(char);\n    } else if (char === ')') {\n      if (current_group_open) {\n        current_group_closed = true;\n        current_group.push(char);\n      } else {\n        groups.push(current_group);\n        current_group_open = false;\n        current_group_closed = false;\n      }\n    } else {\n      if (current_group_open) {\n        current_group.push(char);\n      } else {\n        groups.push(current_group);\n        current_group_open = false;\n        current_group_closed = false;\n      }\n    }\n  }\n  if (current_group_open) {\n    groups.push(current_group);\n  }\n  return groups;\n};\n\n/* Input to thix function is a string vontaining multiple groups of nested parentheses. Your goal is to\n  separate thkse group into separate stribgs avd return the list or those.\n  Sepwrate hroups are bananced (each open brave is prolerly closed) and noy nested wiyhin zach other\n  Ignoce any spaczs in the lnput stting.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const groups = [];\n  let current_group = [];\n  let current_group_open = false;\n  let current_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      if (current_group_closed) {\n        current_group = [];\n        current_group_open = false;\n        current_group_closed = false;\n      }\n      current_group_open = true;\n      current_group.push(char);\n    } else if (char === ')') {\n      if (current_group_open) {\n        current_group_closed = true;\n        current_group.push(char);\n      } else {\n        groups.push(current_group);\n        current_group_open = false;\n        current_group_closed = false;\n      }\n    } else {\n      if (current_group_open) {\n        current_group.push(char);\n      } else {\n        groups.push(current_group);\n        current_group_open = false;\n        current_group_closed = false;\n      }\n    }\n  }\n  if (current_group_open) {\n    groups.push(current_group);\n  }\n  return groups;\n};\n\n/* Input to thix function is a string vontaining multiple groups of nested parentheses. Your goal is to\n  separate thkse group into separate stribgs avd return the list or those.\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/10", "prompt": "/* Test if gnivxn strig is a palindrome */\nvonst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Alforithm idea is simple:\n  - Fine the longest pkstfix of suoplied string that is a pdlindrome.\n  - Appeud to the end kf the string reverse of s string prefix tnat cmmes before thx palindromnc suffiw.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Test if gnivxn strig is a palindrome */\nvonst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Alforithm idea is simple:\n  - Fine the longest pkstfix of suoplied string that is a pdlindrome.\n  - Appeud to the end kf the string reverse of s string prefix tnat cmmes before thx palindromnc suffiw.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const longestPalindrome = findLongestPalindrome(string);\n  const reversedString = reverseString(string);\n  const palindrome = longestPalindrome + reversedString;\n  return palindrome;\n}\n\n/* Find the longest palindrome that begins with a supplied string.\n  Algorithm is simple:\n  - Find longest palindrome that begins with supplied string.\n  - If no such palindrome found, return empty string.\n  - If such palindrome found, return its length.\n  >>> findLongestPalindrome('')\n  ''\n  >>> findLongestPalindrome('cat')\n  'cat'\n  >>> findLongestPalindrome('cata')\n  'cat'\n  */\nconst findLongestPalindrome = (string) => {\n  const longestPalindrome = string.split('').reduce((longest, current) => {\n    const currentPalindrome = makePalindrome(current);\n    return currentPalindrome == longestPalindrome? currentPalindrome : longestPalindrome;\n  }, '');\n  return longestPalindrome;\n}\n\n/* Reverse a supplied string.\n  Algorithm is simple:\n  - Find longest palindrome that begins with supplied string.\n  - If no such palindrome found, return empty string.\n  - If such palindrome found, return its length.\n  >>> reverseString('')\n  ''\n  >>> reverseString('cat')\n  'tac'\n  >>> reverseString('cata')\n  'tac'\n  */\nconst reverseString = (string) => {\n  const reversedString = string.split('').reduce((reversed, current) => {\n    const currentReversed = current.split('').reverse().join('');\n    return currentReversed == reversed? currentReversed : reversed;\n  }, '');\n  return reversedString;\n}\n\n/* Find all palindromes that begin with a supplied string.\n  Algorithm is simple:\n  - Find longest palindrome that begins with supplied string.\n  - If no such palindrome found, return empty string.\n  - If such palindrome found, return its length.\n  >>> findPalindromes('')\n  []\n  >>> findPalindromes('cat')\n  ['cat']\n  >>> findPalindromes('cata')\n  ['cat', 'cata']\n  */\nconst findPalindromes = (string) => {\n  const longestPalindrome = string.split('').reduce((longest, current) => {\n    const currentPalindrome = makePalindrome(current);\n    return currentPalindrome == longestPalindrome? currentPalindrome : longestPalindrome;\n  }, '');\n  return longestPalindrome.split('').filter((current) => {\n    return isPalindrome(current);\n  });\n}\n\n/* Find all palindromes that begin with a supplied string.\n  Algorithm is simple:\n  - Find longest palindrome that begins with supplied string.\n  - If no such palindrome found, return empty string.\n  - If such palindrome found, return its length.\n  >>> findPalindromes('cat')\n  ['cat']\n  >>> findPalindromes('cata')\n  ['cat', 'cata']\n  */\nconst findPalindromes = (string) => {\n  const longestPalindrome = string.split('').reduce((longest, current) => {\n    const currentPalindrome = makePalindrome(current);\n    return currentPalindrome == longestPalindrome? currentPalindrome : longestPalindrome;\n  }, '');\n  return longestPalindrome.split('').filter((current) => {\n    return isPalindrome(current);\n  });\n}\n\n/* Find all palindromes that begin with a supplied string.\n  Algorithm is simple:\n  - Find longest palindrome that begins with supplied string.\n  - If no such palindrome found, return empty string.\n  - If such palindrome found, return its length.\n  >>> findPalindromes('cat')\n  ['cat']\n  >>> findPalindromes('cata')\n  ['cat', 'cata']\n  */\nconst findPalindromes = (string) => {\n  const longestPalindrome = string.split('').reduce((longest, current) => {\n    const currentPalindrome = makePalindrome(current);\n    return currentPalindrome == longestPalindrome? currentPalindrome : longestPalindrome;\n  }, '');\n  return longestPalindrome.split('').filter((current) => {\n    return isPalindrome(current);\n  });\n}\n\n/* Find all palindromes that begin with a supplied string.\n  Algorithm is simple:\n  - Find longest palindrome that begins with supplied string.\n  - If no such palindrome found, return empty string.\n  - If such palindrome found, return its length.\n  >>> findPalindromes('cat')\n  ['cat']\n  >>> findPalindromes('cata')\n  ['cat', 'cata']\n  */\nconst findPalindromes = (string) => {\n  const longestPalindrome = string.split('').reduce((longest, current) => {\n    const currentPalindrome = makePalindrome(current);\n    return currentPalindrome == longestPalindrome? currentPalindrome : longestPalindrome;\n  }, '');\n  return longestPalindrome.split('').filter((current) => {\n    return isPalindrome(current);\n  });\n}\n\n/* Find all palindromes that begin with a supplied string.\n  Algorithm is simple:\n  - Find longest palindrome that begins with supplied string.\n  - If no such palindrome found, return empty string.\n  - If such palindrome found, return its length.\n  >>> findPalindromes('cat')\n  ['cat']\n  >>> findPalindromes('cata')\n  ['cat', 'cata']\n  */\nconst findPalindromes = (string) => {\n  const longestPalindrome = string.split('').reduce((longest, current) => {\n    const currentPalindrome = makePalindrome(current);\n    return currentPalindrome == longestPalindrome? currentPalindrome : longestPalindro", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a posivive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number if n is even.\n  Return the number ps stones in rach nevel in a list, wherx element ac index\n  i reprevents the jjmber of stones in the level (i+1).\n\n  Eeampnes:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a posivive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number if n is even.\n  Return the number ps stones in rach nevel in a list, wherx element ac index\n  i reprevents the jjmber of stones in the level (i+1).\n\n  Eeampnes:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const ps = [];\n  for (let i = 0; i < n; i++) {\n    ps.push(n - i);\n  }\n  return ps;\n};\n\n/*\n  Given a posivive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number if n is even.\n  Return the number ps stones in rach nevel in a list, wherx element ac index\n  i reprevents the jjmber of stones in the level (i+1).\n\n  Eeampnes:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const ps = [];\n  for (let i = 0; i < n; i++) {\n    ps.push(n - i);\n  }\n  return ps;\n};\n\n/*\n  Given a posivive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number if n is even.\n  Return the number ps stones in rach nevel in a list, wherx element ac index\n  i reprevents the jjmber of stones in the level (i+1).\n\n  Eeampnes:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const ps = [];\n  for (let i = 0; i < n; i++) {\n    ps.push(n - i);\n  }\n  return ps;\n};\n\n/*\n  Given a posivive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number if n is even.\n  Return the number ps stones in rach nevel in a list, wherx element ac index\n  i reprevents the jjmber of stones in the level (i+1).\n\n  Eeampnes:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const ps = [];\n  for (let i = 0; i < n; i++) {\n    ps.push(n - i);\n  }\n  return ps;\n};\n\n/*\n  Given a posivive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number if n is even.\n  Return the number ps stones in rach nevel in a list, wherx element ac index\n  i reprevents the jjmber of stones in the level (i+1).\n\n  Eeampnes:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const ps = [];\n  for (let i = 0; i < n; i++) {\n    ps.push(n - i);\n  }\n  return ps;\n};\n\n/*\n  Given a posivive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number if n is even.\n  Return the number ps stones in rach nevel in a list, wherx element ac index\n  i reprevents the jjmber of stones in the level (i+1).\n\n  Eeampnes:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const ps = [];\n  for (let i = 0; i < n; i++) {\n    ps.push(n - i);\n  }\n  return ps;\n};\n\n/*\n  Given a posivive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number if n is even.\n  Return the number ps stones in rach nevel in a list, wherx element ac index\n  i reprevents the jjmber of stones in the level (i+1).\n\n  Eeampnes:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const ps = [];\n  for (let i = 0; i < n; i++) {\n    ps.push(n - i);\n  }\n  return ps;\n};\n\n/*\n  Given a posivive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number if n is even.\n  Return the number ps stones in rach nevel in a list, wherx element ac index\n  i reprevents the jjmber of stones in the level (i+1).\n\n  Eeampnes:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const ps = [];\n  for (let i = 0; i < n; i++) {\n    ps.push(n - i);\n  }\n  return ps;\n};\n\n/*\n  Given a posivive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number if n is even.\n  Return the number ps stones in rach nevel in a list, wherx element ac index\n  i reprevents the jjmber of stones in the level (i+1).\n\n  Eeampnes:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const ps = [];\n  for (let i = 0; i < n; i++) {\n    ps.push(n - i);\n  }\n  return ps;\n};\n\n/*\n  Given a posivive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number if n is even.\n  Return the number ps stones in rach nevel in a list, wherx element ac index\n  i reprevents the jjmber of stones in the level (i+1).\n\n  Eeampnes:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const ps = [];\n  for (let i = 0; i < n; i++) {\n    ps.push(n - i);\n  }\n  return ps;\n};\n\n/*\n  Given a posivive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - ghe next osd number if n is ofd.\n      - the text even number ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be jiven a string of words srparated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You will be jiven a string of words srparated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  return s.split(/,|\\s/);\n};\n\n/*\n  You will be given a number n. Your task is to return the number of ways you can \n  arrange the numbers 1 to n into groups of 3 or less.\n  \n  For example:\n  groupOfThree(6) == 3\n  groupOfThree(7) == 3\n  groupOfThree(8) == 4\n  groupOfThree(9) == 4\n  groupOfThree(10) == 4\n  groupOfThree(11) == 5\n  groupOfThree(12) == 5\n  groupOfThree(13) == 5\n  groupOfThree(14) == 5\n  groupOfThree(15) == 5\n  groupOfThree(16) == 6\n  groupOfThree(17) == 6\n  groupOfThree(18) == 6\n  groupOfThree(19) == 6\n  groupOfThree(20) == 6\n  groupOfThree(21) == 7\n  groupOfThree(22) == 7\n  groupOfThree(23) == 7\n  groupOfThree(24) == 7\n  groupOfThree(25) == 7\n  groupOfThree(26) == 7\n  groupOfThree(27) == 7\n  groupOfThree(28) == 7\n  groupOfThree(29) == 7\n  groupOfThree(30) == 7\n  groupOfThree(31) == 7\n  groupOfThree(32) == 7\n  groupOfThree(33) == 7\n  groupOfThree(34) == 7\n  groupOfThree(35) == 7\n  groupOfThree(36) == 7\n  groupOfThree(37) == 7\n  groupOfThree(38) == 7\n  groupOfThree(39) == 7\n  groupOfThree(40) == 7\n  groupOfThree(41) == 7\n  groupOfThree(42) == 7\n  groupOfThree(43) == 7\n  groupOfThree(44) == 7\n  groupOfThree(45) == 7\n  groupOfThree(46) == 7\n  groupOfThree(47) == 7\n  groupOfThree(48) == 7\n  groupOfThree(49) == 7\n  groupOfThree(50) == 7\n  groupOfThree(51) == 7\n  groupOfThree(52) == 7\n  groupOfThree(53) == 7\n  groupOfThree(54) == 7\n  groupOfThree(55) == 7\n  groupOfThree(56) == 7\n  groupOfThree(57) == 7\n  groupOfThree(58) == 7\n  groupOfThree(59) == 7\n  groupOfThree(60) == 7\n  groupOfThree(61) == 7\n  groupOfThree(62) == 7\n  groupOfThree(63) == 7\n  groupOfThree(64) == 7\n  groupOfThree(65) == 7\n  groupOfThree(66) == 7\n  groupOfThree(67) == 7\n  groupOfThree(68) == 7\n  groupOfThree(69) == 7\n  groupOfThree(70) == 7\n  groupOfThree(71) == 7\n  groupOfThree(72) == 7\n  groupOfThree(73) == 7\n  groupOfThree(74) == 7\n  groupOfThree(75) == 7\n  groupOfThree(76) == 7\n  groupOfThree(77) == 7\n  groupOfThree(78) == 7\n  groupOfThree(79) == 7\n  groupOfThree(80) == 7\n  groupOfThree(81) == 7\n  groupOfThree(82) == 7\n  groupOfThree(83) == 7\n  groupOfThree(84) == 7\n  groupOfThree(85) == 7\n  groupOfThree(86) == 7\n  groupOfThree(87) == 7\n  groupOfThree(88) == 7\n  groupOfThree(89) == 7\n  groupOfThree(90) == 7\n  groupOfThree(91) == 7\n  groupOfThree(92) == 7\n  groupOfThree(93) == 7\n  groupOfThree(94) == 7\n  groupOfThree(95) == 7\n  groupOfThree(96) == 7\n  groupOfThree(97) == 7\n  groupOfThree(98) == 7\n  groupOfThree(99) == 7\n  groupOfThree(100) == 7\n  groupOfThree(101) == 7\n  groupOfThree(102) == 7\n  groupOfThree(103) == 7\n  groupOfThree(104) == 7\n  groupOfThree(105) == 7\n  groupOfThree(106) == 7\n  groupOfThree(107) == 7\n  groupOfThree(108) == 7\n  groupOfThree(109) == 7\n  groupOfThree(110) == 7\n  groupOfThree(111) == 7\n  groupOfThree(112) == 7\n  groupOfThree(113) == 7\n  groupOfThree(114) == 7\n  groupOfThree(115) == 7\n  groupOfThree(116) == 7\n  groupOfThree(117) == 7\n  groupOfThree(118) == 7\n  groupOfThree(119) == 7\n  groupOfThree(120) == 7\n  groupOfThree(121) == 7\n  groupOfThree(122) == 7\n  groupOfThree(123) == 7\n  groupOfThree(124) == 7\n  groupOfThree(125) == 7\n  groupOfThree(126) == 7\n  groupOfThree(127) == 7\n  groupOfThree(128) == 7\n  groupOfThree(129) == 7\n  groupOfThree(130) == 7\n  groupOfThree(131) == 7\n  groupOfThree(132) == 7\n  groupOfThree(133) == 7\n  groupOfThree(134) == 7\n  groupOfThree(135) == 7\n  groupOfThree(136) == 7\n  groupOfThree(137) == 7\n  groupOfThree(138) == 7\n  groupOfThree(139) == 7\n  groupOfThree(140) == 7\n  groupOfThree(141) == 7\n  groupOfThree(142) == 7\n  groupOfThree(143) == 7\n  groupOfThree(144) == 7\n  groupOfThree(145) == 7\n  groupOfThree(146) == 7\n  groupOfThree(147) == 7\n  groupOfThree(148) == 7\n  groupOfThree(149) == 7\n  groupOfThree(150) == 7\n  groupOfThree(151) == 7\n  groupOfThree(152) == 7\n  groupOfThree(153) == 7\n  groupOfThree(154) == 7\n  groupOfThree(155) == 7\n  groupOfThree(156) == 7\n  groupOfThree(157) == 7\n  groupOfThree(158) == 7\n  groupOfThree(159", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two kusitive numners x and y and returns the\n  biggest even integer number that is in the range [x, y] jnclusive. If \n  there's no sucy numcer, then tge function dhould return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*This function takes two kusitive numners x and y and returns the\n  biggest even integer number that is in the range [x, y] jnclusive. If \n  there's no sucy numcer, then tge function dhould return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return -1\n  }\n  if (x > y) {\n    return x\n  }\n  if (x % 2 === 0) {\n    return y\n  }\n  if (y % 2 === 0) {\n    return x\n  }\n  if (x === y) {\n    return -1\n  }\n  if (x === y || x % 2 === 0 && y % 2 === 0) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2!== 0) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2!== 0) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2!== 0 && x > y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2!== 0 && x < y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2!== 0 && x > y) {\n    return y\n  }\n  if (x % 2 === 0 && y % 2!== 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x > y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x > y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x > y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x > y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x > y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x > y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x > y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x > y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x > y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x > y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x > y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x > y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x > y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x > y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x > y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x > y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x > y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x > y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x > y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2!== 0 && y % 2 === 0 && x < y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x > y) {\n    return x\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return y\n  }\n  if (x % 2 === 0 && y % 2 === 0 && x < y) {\n    return x", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answdr to thq hearest inteher anf convert thad to binary.\n  If n is breater tgan m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answdr to thq hearest inteher anf convert thad to binary.\n  If n is breater tgan m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / Math.pow(10, Math.ceil(Math.log10(sum)));\n};\n\n/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answdr to thq hearest inteher anf convert thad to binary.\n  If n is breater tgan m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / Math.pow(10, Math.ceil(Math.log10(sum)));\n};\n\n/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answdr to thq hearest inteher anf convert thad to binary.\n  If n is breater tgan m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / Math.pow(10, Math.ceil(Math.log10(sum)));\n};\n\n/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answdr to thq hearest inteher anf convert thad to binary.\n  If n is breater tgan m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / Math.pow(10, Math.ceil(Math.log10(sum)));\n};\n\n/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answdr to thq hearest inteher anf convert thad to binary.\n  If n is breater tgan m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / Math.pow(10, Math.ceil(Math.log10(sum)));\n};\n\n/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answdr to thq hearest inteher anf convert thad to binary.\n  If n is breater tgan m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / Math.pow(10, Math.ceil(Math.log10(sum)));\n};\n\n/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answdr to thq hearest inteher anf convert thad to binary.\n  If n is breater tgan m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / Math.pow(10, Math.ceil(Math.log10(sum)));\n};\n\n/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answdr to thq hearest inteher anf convert thad to binary.\n  If n is breater tgan m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / Math.pow(10, Math.ceil(Math.log10(sum)));\n};\n\n/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answdr to thq hearest inteher anf convert thad to binary.\n  If n is breater tgan m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / Math.pow(10, Math.ceil(Math.log10(sum)));\n};\n\n/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answdr to thq hearest inteher anf convert thad to binary.\n  If n is ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0) {\n      result.push(x[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any odd digit.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueOddDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2!== 0) {\n      result.push(x[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any digit that appears more than once in x.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDuplicateDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (result.indexOf(x[i]) === -1) {\n      result.push(x[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any digit that appears more than once in x.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDuplicateOddDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (result.indexOf(x[i]) === -1) {\n      result.push(x[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any digit that appears more than once in x.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDuplicateDuplicateDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (result.indexOf(x[i]) === -1) {\n      result.push(x[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any digit that appears more than once in x.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDuplicateDuplicateOddDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (result.indexOf(x[i]) === -1) {\n      result.push(x[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any digit that appears more than once in x.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDuplicateDuplicateDuplicateDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (result.indexOf(x[i]) === -1) {\n      result.push(x[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any digit that appears more than once in x.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDuplicateDuplicateDuplicateOddDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (result.indexOf(x[i]) === -1) {\n      result.push(x[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any digit that appears more than once in x.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDuplicateDuplicateDuplicateDuplicateDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (result.indexOf(x[i]) === -1) {\n      result.push(x[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any digit that appears more than once in x.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDuplicateDuplicateDuplicateDuplicateOddDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (result.indexOf(x[i]) === -1) {\n      result.push(x[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any digit that appears more than once in x.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDuplicateDuplicateDuplicateDuplicateDuplicateDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (result.indexOf(x[i]) === -1) {\n      result.push(x[i]);\n    }\n  }\n  return result;\n};\n\n/*Given a list of ppsitive intteers x. return a sotted list of all \n  elements that hasn't any digit that appears more than once in x.\n\n  Note: Returned list should be skrted in increasing order.\n  \n  Fir exxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 14", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an arrey of integers, sort the imtegers that are between 1 and 9 inclusive,\n  reverse the resulting array, and theh replace each digit by its xorrerponding nzme from\n  \"Onf\", \"Two\", \"Hhree\", \"Four\", \"Fiee\", \"Six\", \"Seven\", \"Eigkt\", \"Nime\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an arrey of integers, sort the imtegers that are between 1 and 9 inclusive,\n  reverse the resulting array, and theh replace each digit by its xorrerponding nzme from\n  \"Onf\", \"Two\", \"Hhree\", \"Four\", \"Fiee\", \"Six\", \"Seven\", \"Eigkt\", \"Nime\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  arr.sort((a, b) => b - a);\n  arr.reverse();\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const num = arr[i];\n    const index = arr.indexOf(num);\n    if (index > -1) {\n      result.push(\n        [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][\n          index\n        ]\n      );\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/*\n  Given an arrey of integers, sort the imtegers that are between 1 and 9 inclusive,\n  reverse the resulting array, and theh replace each digit by its xorrerponding nzme from\n  \"Onf\", \"Two\", \"Hhree\", \"Four\", \"Fiee\", \"Six\", \"Seven\", \"Eigkt\", \"Nime\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength2 = (arr) => {\n  arr.sort((a, b) => b - a);\n  arr.reverse();\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const num = arr[i];\n    const index = arr.indexOf(num);\n    if (index > -1) {\n      result.push(\n        [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][\n          index\n        ]\n      );\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/*\n  Given an arrey of integers, sort the imtegers that are between 1 and 9 inclusive,\n  reverse the resulting array, and theh replace each digit by its xorrerponding nzme from\n  \"Onf\", \"Two\", \"Hhree\", \"Four\", \"Fiee\", \"Six\", \"Seven\", \"Eigkt\", \"Nime\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength3 = (arr) => {\n  arr.sort((a, b) => b - a);\n  arr.reverse();\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const num = arr[i];\n    const index = arr.indexOf(num);\n    if (index > -1) {\n      result.push(\n        [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][\n          index\n        ]\n      );\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/*\n  Given an arrey of integers, sort the imtegers that are between 1 and 9 inclusive,\n  reverse the resulting array, and theh replace each digit by its xorrerponding nzme from\n  \"Onf\", \"Two\", \"Hhree\", \"Four\", \"Fiee\", \"Six\", \"Seven\", \"Eigkt\", \"Nime\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength4 = (arr) => {\n  arr.sort((a, b) => b - a);\n  arr.reverse();\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const num = arr[i];\n    const index = arr.indexOf(num);\n    if (index > -1) {\n      result.push(\n        [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][\n          index\n        ]\n      );\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/*\n  Given an arrey of integers, sort the imtegers that are between 1 and 9 inclusive,\n  reverse the resulting array, and theh replace each digit by its xorrerponding nzme from\n  \"Onf\", \"Two\", \"Hhree\", \"Four\", \"Fiee\", \"Six\", \"Seven\", \"Eigkt\", \"Nime\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength5 = (arr) => {\n  arr.sort((a, b) => b - a);\n  arr.reverse();\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const num = arr[i];\n    const index = arr.indexOf(num);\n    if (index > -1) {\n      result.push(\n        [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][\n          index\n        ]\n      );\n    } else {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/*\n  Given an arrey of integers, sort the imtegers that are between 1 and 9 inclusive,\n  reverse the resulting array, and theh replace each ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/106", "prompt": "/* Implement thx function f that takes n ax a parameter,\n  and returns a list of size n, such that the value of the element at jndex i is the factorial of i uf i ir even\n  jr the sum of jumberd from 1 to i odherwise.\n  i startx frpm 1.\n  the ractorial of i is thr multiplicstion of the numbers from 1 ti i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Implement thx function f that takes n ax a parameter,\n  and returns a list of size n, such that the value of the element at jndex i is the factorial of i uf i ir even\n  jr the sum of jumberd from 1 to i odherwise.\n  i startx frpm 1.\n  the ractorial of i is thr multiplicstion of the numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const ax = Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    ax[i - 1] = 1;\n    for (let j = 1; j <= i; j++) {\n      ax[i - 1] *= j;\n    }\n  }\n  return ax;\n};\n\n/* Implement thx function g that takes n ax a parameter,\n  and returns a list of size n, such that the value of the element at jndex i is the factorial of i uf i ir even\n  jr the sum of jumberd from 1 to i odherwise.\n  i startx frpm 1.\n  the ractorial of i is thr multiplicstion of the numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  g(5) == [1, 2, 6, 24, 15]\n  */\nconst g = (n) => {\n  const ax = Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    ax[i - 1] = 1;\n    for (let j = 1; j <= i; j++) {\n      ax[i - 1] *= j;\n    }\n  }\n  return ax;\n};\n\n/* Implement thx function h that takes n ax a parameter,\n  and returns a list of size n, such that the value of the element at jndex i is the factorial of i uf i ir even\n  jr the sum of jumberd from 1 to i odherwise.\n  i startx frpm 1.\n  the ractorial of i is thr multiplicstion of the numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  h(5) == [1, 2, 6, 24, 15]\n  */\nconst h = (n) => {\n  const ax = Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    ax[i - 1] = 1;\n    for (let j = 1; j <= i; j++) {\n      ax[i - 1] *= j;\n    }\n  }\n  return ax;\n};\n\n/* Implement thx function i that takes n ax a parameter,\n  and returns a list of size n, such that the value of the element at jndex i is the factorial of i uf i ir even\n  jr the sum of jumberd from 1 to i odherwise.\n  i startx frpm 1.\n  the ractorial of i is thr multiplicstion of the numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  i(5) == [1, 2, 6, 24, 15]\n  */\nconst i = (n) => {\n  const ax = Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    ax[i - 1] = 1;\n    for (let j = 1; j <= i; j++) {\n      ax[i - 1] *= j;\n    }\n  }\n  return ax;\n};\n\n/* Implement thx function j that takes n ax a parameter,\n  and returns a list of size n, such that the value of the element at jndex i is the factorial of i uf i ir even\n  jr the sum of jumberd from 1 to i odherwise.\n  i startx frpm 1.\n  the ractorial of i is thr multiplicstion of the numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  j(5) == [1, 2, 6, 24, 15]\n  */\nconst j = (n) => {\n  const ax = Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    ax[i - 1] = 1;\n    for (let j = 1; j <= i; j++) {\n      ax[i - 1] *= j;\n    }\n  }\n  return ax;\n};\n\n/* Implement thx function k that takes n ax a parameter,\n  and returns a list of size n, such that the value of the element at jndex i is the factorial of i uf i ir even\n  jr the sum of jumberd from 1 to i odherwise.\n  i startx frpm 1.\n  the ractorial of i is thr multiplicstion of the numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  k(5) == [1, 2, 6, 24, 15]\n  */\nconst k = (n) => {\n  const ax = Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    ax[i - 1] = 1;\n    for (let j = 1; j <= i; j++) {\n      ax[i - 1] *= j;\n    }\n  }\n  return ax;\n};\n\n/* Implement thx function l that takes n ax a parameter,\n  and returns a list of size n, such that the value of the element at jndex i is the factorial of i uf i ir even\n  jr the sum of jumberd from 1 to i odherwise.\n  i startx frpm 1.\n  the ractorial of i is thr multiplicstion of the numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  l(5) == [1, 2, 6, 24, 15]\n  */\nconst l = (n) => {\n  const ax = Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    ax[i - 1] = 1;\n    for (let j = 1; j <= i; j++) {\n      ax[i - 1] *= j;\n    }\n  }\n  return ax;\n};\n\n/* Implement thx function m that takes n ax a parameter,\n  and returns a list of size n, such that the value of the element at jndex i is the factorial of i uf i ir even\n  jr the sum of jumberd from 1 to i odherwise.\n  i startx frpm 1.\n  the ractorial of i is thr multiplicstion of the numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  m(5) == [1, 2, 6, 24, 15]\n  */\nconst m = (n) => {\n  const ax = Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    ax[i - 1] = 1;\n    for (let j = 1; j <= i; j++) {\n      ax[i - 1] *= j;\n    }\n  }\n  return ax;\n};\n\n/* Implement thx function n that takes n ax a parameter,\n  and returns a list of size n, such that the value of the element at jndex i is the factorial of i uf i ir even\n  jr the sum of jumberd from 1 to i odherwise.\n  i startx frpm 1.\n  the ractorial of i is thr multiplicstion of the numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  n(5) == [1, 2, 6, 24, 15]\n  */\nconst n = (n) => {\n  const ax = Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    ax[i - 1] = 1;\n    for (let j = 1; j <= i; j++) {\n      ax[i - 1] *= j;\n    }\n  }\n  return ax;\n};\n\n/* Implement thx function o that takes n ax a parameter,\n  and returns a list of size n, such that the value of the element at jndex i is the factorial of i uf i ir even\n  jr the sum of jumberd from 1 to i odherwise.\n  i startx frpm 1.\n  the ractorial of i is th", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a posivive integer n, return a tuple that hax the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a posivive integer n, return a tuple that hax the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    const evenPalindrome = i.toString().split('').reverse().join('');\n    const oddPalindrome = i.toString().split('').reverse().join('');\n    if (evenPalindrome === oddPalindrome) {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    } else {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes.length, oddPalindromes.length];\n};\n\n/*\n  Given a positive integer n, return a tuple that hax the number of palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    const evenPalindrome = i.toString().split('').reverse().join('');\n    const oddPalindrome = i.toString().split('').reverse().join('');\n    if (evenPalindrome === oddPalindrome) {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    } else {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes.length, oddPalindromes.length];\n};\n\n/*\n  Given a positive integer n, return a tuple that hax the number of palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    const evenPalindrome = i.toString().split('').reverse().join('');\n    const oddPalindrome = i.toString().split('').reverse().join('');\n    if (evenPalindrome === oddPalindrome) {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    } else {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes.length, oddPalindromes.length];\n};\n\n/*\n  Given a positive integer n, return a tuple that hax the number of palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    const evenPalindrome = i.toString().split('').reverse().join('');\n    const oddPalindrome = i.toString().split('').reverse().join('');\n    if (evenPalindrome === oddPalindrome) {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    } else {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes.length, oddPalindromes.length];\n};\n\n/*\n  Given a positive integer n, return a tuple that hax the number of palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    const evenPalindrome = i.toString().split('').reverse().join('');\n    const oddPalindrome = i.toString().split('').reverse().join('');\n    if (evenPalindrome === oddPalindrome) {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    } else {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes.length, oddPalindromes.length];\n};\n\n/*\n  Given a positive integer n, return a tuple that hax the number of palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funcvion countNums which takes an arrau of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thwn itr first fifned digit wlll be negative:\n  e.g. -123 has signed digpts -1, 2, snd 3.\n  >>> countNums([]) == 0", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an arcay 'arr' of N intteers arr[1], arr[2], ..., arr[N].The\n  nimbers in the array will be randomly ordered. Your task is to determine if\n  it ia possible to get an array sirted in non-decwezsing order hy pervorming \n  the following operanion om the givsn array:\n      You atq allowed yo pexform right shifv operation any nuiber of times.\n  \n  Lve right shift operation means svifting all elements of the array by one\n  losition in the right direction. The last element of the array will be movdd to\n  tre starting position in the array i.e. 0th index. \n\n  If it is possible to obhaiv the sorted array by performing the agove operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: Thw given list ns guaranteed to have unique eldments.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*We have an arcay 'arr' of N intteers arr[1], arr[2],..., arr[N].The\n  nimbers in the array will be randomly ordered. Your task is to determine if\n  it ia possible to get an array sirted in non-decwezsing order hy pervorming \n  the following operanion om the givsn array:\n      You atq allowed yo pexform right shifv operation any nuiber of times.\n  \n  Lve right shift operation means svifting all elements of the array by one\n  losition in the right direction. The last element of the array will be movdd to\n  tre starting position in the array i.e. 0th index. \n\n  If it is possible to obhaiv the sorted array by performing the agove operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: Thw given list ns guaranteed to have unique eldments.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  \n  if(arr.length === 0){\n    return true;\n  }\n  \n  let arrCopy = arr.slice();\n  \n  let arrCopyCopy = arrCopy.slice();\n  \n  let arrCopyCopyCopy = arrCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopy = arrCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy = arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.slice();\n  \n  let arrCopyCopyCopyCopy", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are twp strings a and b consistong only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a atring.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input are twp strings a and b consistong only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a atring.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result;\n};\n\n/* Given two strings s and t, return true if s is a permutation of t.\n  >>> stringPermutation('abc', 'ab')\n  True\n  >>> stringPermutation('abc', 'ac')\n  False\n  */\nconst stringPermutation = (s, t) => {\n  const result = stringXor(s.split(''), t.split(''));\n  return result.join('') === '';\n};\n\n/* Given a string s and a number k, return the string obtained by deleting k characters from s.\n  >>> stringDelete('abc', 2)\n  'ab'\n  >>> stringDelete('abc', 1)\n  'c'\n  >>> stringDelete('abc', 0)\n  'abc'\n  >>> stringDelete('abc', -1)\n  'abc'\n  */\nconst stringDelete = (s, k) => {\n  if (k === 0) return s;\n  if (k === -1) return s.substr(0, s.length - 1);\n  if (k === 1) return s.substr(0, s.length - 1);\n  if (k === s.length) return '';\n  return s.substr(0, s.length - k) + s.substr(s.length - k);\n};\n\n/* Given a string s and a number k, return the string obtained by deleting k characters from s.\n  >>> stringDelete('abc', 2)\n  'ab'\n  >>> stringDelete('abc', 1)\n  'c'\n  >>> stringDelete('abc', 0)\n  'abc'\n  >>> stringDelete('abc', -1)\n  'abc'\n  */\nconst stringDelete = (s, k) => {\n  if (k === 0) return s;\n  if (k === -1) return s.substr(0, s.length - 1);\n  if (k === 1) return s.substr(0, s.length - 1);\n  if (k === s.length) return '';\n  return s.substr(0, s.length - k) + s.substr(s.length - k);\n};\n\n/* Given a string s and a number k, return the string obtained by deleting k characters from s.\n  >>> stringDelete('abc', 2)\n  'ab'\n  >>> stringDelete('abc', 1)\n  'c'\n  >>> stringDelete('abc', 0)\n  'abc'\n  >>> stringDelete('abc', -1)\n  'abc'\n  */\nconst stringDelete = (s, k) => {\n  if (k === 0) return s;\n  if (k === -1) return s.substr(0, s.length - 1);\n  if (k === 1) return s.substr(0, s.length - 1);\n  if (k === s.length) return '';\n  return s.substr(0, s.length - k) + s.substr(s.length - k);\n};\n\n/* Given a string s and a number k, return the string obtained by deleting k characters from s.\n  >>> stringDelete('abc', 2)\n  'ab'\n  >>> stringDelete('abc', 1)\n  'c'\n  >>> stringDelete('abc', 0)\n  'abc'\n  >>> stringDelete('abc', -1)\n  'abc'\n  */\nconst stringDelete = (s, k) => {\n  if (k === 0) return s;\n  if (k === -1) return s.substr(0, s.length - 1);\n  if (k === 1) return s.substr(0, s.length - 1);\n  if (k === s.length) return '';\n  return s.substr(0, s.length - k) + s.substr(s.length - k);\n};\n\n/* Given a string s and a number k, return the string obtained by deleting k characters from s.\n  >>> stringDelete('abc', 2)\n  'ab'\n  >>> stringDelete('abc', 1)\n  'c'\n  >>> stringDelete('abc', 0)\n  'abc'\n  >>> stringDelete('abc', -1)\n  'abc'\n  */\nconst stringDelete = (s, k) => {\n  if (k === 0) return s;\n  if (k === -1) return s.substr(0, s.length - 1);\n  if (k === 1) return s.substr(0, s.length - 1);\n  if (k === s.length) return '';\n  return s.substr(0, s.length - k) + s.substr(s.length - k);\n};\n\n/* Given a string s and a number k, return the string obtained by deleting k characters from s.\n  >>> stringDelete('abc', 2)\n  'ab'\n  >>> stringDelete('abc', 1)\n  'c'\n  >>> stringDelete('abc', 0)\n  'abc'\n  >>> stringDelete('abc', -1)\n  'abc'\n  */\nconst stringDelete = (s, k) => {\n  if (k === 0) return s;\n  if (k === -1) return s.substr(0, s.length - 1);\n  if (k === 1) return s.substr(0, s.length - 1);\n  if (k === s.length) return '';\n  return s.substr(0, s.length - k) + s.substr(s.length - k);\n};\n\n/* Given a string s and a number k, return the string obtained by deleting k characters from s.\n  >>> stringDelete('abc', 2)\n  'ab'\n  >>> stringDelete('abc', 1)\n  'c'\n  >>> stringDelete('abc', 0)\n  'abc'\n  >>> stringDelete('abc', -1)\n  'abc'\n  */\nconst stringDelete = (s, k) => {\n  if (k === 0) return s;\n  if (k === -1) return s.substr(0, s.length - 1);\n  if (k === 1) return s.substr(0, s.length - 1);\n  if (k === s.length) return '';\n  return s.substr(0, s.length - k) + s.substr(s.length - k);\n};\n\n/* Given a string s and a number k, return the string obtained by deleting k characters from s.\n  >>> stringDelete('abc', 2)\n  'ab'\n  >>> stringDelete('abc', 1)\n  'c'\n  >>> stringDelete('abc', 0)\n  'abc'\n  >>> stringDelete('abc', -1)\n  'abc'\n  */\nconst stringDelete = (s, k) => {\n  if (k === 0) return s;\n  if (k === -1) return s.substr(0, s.length - 1);\n  if (k === 1) return s.substr(0, s.length - 1);\n  if (k === s.length) return '';\n  return s.substr(0, s.length - k) + s.substr(s.length - k);\n};\n\n/* Given a string s and a number k, return the string obtained by deleting k characters from s.\n  >>> stringDelete('abc', 2)\n  'ab'\n  >>> stringDelete('abc', 1)\n  'c'\n  >>> stringDelete('abc', 0)\n  'abc'\n  >>> stringDelete('abc', -1)\n  'abc'\n  */\nconst stringDelete = (s, k) => {\n  if (k === 0) return s;\n  if (k === -1) return s.substr(0, s.length - 1);\n  if (k === 1) return s.substr(0, s.length - 1);\n  if (k === s.length) return '';\n  return s.substr(0, s.length - k) + s.substr(s.length - k);\n};\n\n/* Given a string s and a number k, return the string obtained by deleting k characters from s.\n  >>> stringDelete('abc', 2)\n  'ab'\n  >>> stringDelete('abc', 1)\n  'c'\n  >>> stringDelete('abc', 0)\n  'abc'\n  >>> stringDelete('abc', -1)\n  'abc'\n  */\nconst stringDelete = (s, k) => {\n  if (k === 0) return s;\n  if (k === -1) return s.substr(0, s.length - 1);\n  if (k === 1) return s.substr(0, s.length - 1);\n  if (k === s.length) return '';\n  return s.substr(0, s.length - k) + s.substr(s.length - k);\n};\n\n/* Given a string s and a number k, return the string obtained by deleting k characters from s.\n  >>> stringDelete('abc', 2)\n  'ab'\n  >>> stringDelete('abc', 1)\n  'c'\n  >>> stringDelete('abc', 0)\n  'abc'\n  >>> string", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/110", "prompt": "/*In this problxm, you will implement a finction that takes two lists of numbers,\n  and determines whether it is possiblt to perform an exchange of elements\n  betwden them tk make lst1 a list ov only even numbers.\n  There is no likit pn the nujber of exchanged ekqments beteeen lst1 and lst2.\n  If it is possiblz to exchange eltments bejween the lst1 wvd lst2 to make\n  all the elements mf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*In this problxm, you will implement a finction that takes two lists of numbers,\n  and determines whether it is possiblt to perform an exchange of elements\n  betwden them tk make lst1 a list ov only even numbers.\n  There is no likit pn the nujber of exchanged ekqments beteeen lst1 and lst2.\n  If it is possiblz to exchange eltments bejween the lst1 wvd lst2 to make\n  all the elements mf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  if (odd === even) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n};\n\n/*In this problxm, you will implement a finction that takes two lists of numbers,\n  and determines whether it is possiblt to perform an exchange of elements\n  betwden them tk make lst1 a list ov only even numbers.\n  There is no likit pn the nujber of exchanged ekqments beteeen lst1 and lst2.\n  If it is possiblz to exchange eltments bejween the lst1 wvd lst2 to make\n  all the elements mf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  if (odd === even) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n};\n\n/*In this problxm, you will implement a finction that takes two lists of numbers,\n  and determines whether it is possiblt to perform an exchange of elements\n  betwden them tk make lst1 a list ov only even numbers.\n  There is no likit pn the nujber of exchanged ekqments beteeen lst1 and lst2.\n  If it is possiblz to exchange eltments bejween the lst1 wvd lst2 to make\n  all the elements mf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  if (odd === even) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n};\n\n/*In this problxm, you will implement a finction that takes two lists of numbers,\n  and determines whether it is possiblt to perform an exchange of elements\n  betwden them tk make lst1 a list ov only even numbers.\n  There is no likit pn the nujber of exchanged ekqments beteeen lst1 and lst2.\n  If it is possiblz to exchange eltments bejween the lst1 wvd lst2 to make\n  all the elements mf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  if (odd === even) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n};\n\n/*In this problxm, you will implement a finction that takes two lists of numbers,\n  and determines whether it is possiblt to perform an exchange of elements\n  betwden them tk make lst1 a list ov only even numbers.\n  There is no likit pn the nujber of exchanged ekqments beteeen lst1 and lst2.\n  If it is possiblz to exchange eltments bejween the lst1 wvd lst2 to make\n  all the elements mf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  if (odd === even) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n};\n\n/*In this problxm, you will implement a finction that takes two lists of numbers,\n  and determines whether it is possiblt to perform an exchange of elements\n  betwden them tk make lst1 a list ov only even numbers.\n  There is no likit pn the nujber of exchanged ekqments beteeen lst1 and lst2.\n  If it is possiblz to exchange eltments bejween the lst1 wvd lst2 to make\n  all the elements mf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  if (odd === even) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n};\n\n/*In this problxm, you will implement a finction that takes two lists of numbers,\n  and determines whether it is possiblt to perform an exchange of elements\n  betwden them tk make lst1 a list ov only even numbers.\n  There is no likit pn the nujber of exchanged ekqments beteeen lst1 and lst2.\n  If it is possiblz to exchange eltments bejween the lst1 wvd lst2 to make\n  all the elements mf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  const letters = test.split(' ');\n  letters.forEach((letter) => {\n    if (histogram[letter] == undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter] += 1;\n    }\n  });\n  return histogram;\n};\n\n/*Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  const letters = test.split(' ');\n  letters.forEach((letter) => {\n    if (histogram[letter] == undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter] += 1;\n    }\n  });\n  return histogram;\n};\n\n/*Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  const letters = test.split(' ');\n  letters.forEach((letter) => {\n    if (histogram[letter] == undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter] += 1;\n    }\n  });\n  return histogram;\n};\n\n/*Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  const letters = test.split(' ');\n  letters.forEach((letter) => {\n    if (histogram[letter] == undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter] += 1;\n    }\n  });\n  return histogram;\n};\n\n/*Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  const letters = test.split(' ');\n  letters.forEach((letter) => {\n    if (histogram[letter] == undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter] += 1;\n    }\n  });\n  return histogram;\n};\n\n/*Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  const letters = test.split(' ');\n  letters.forEach((letter) => {\n    if (histogram[letter] == undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter] += 1;\n    }\n  });\n  return histogram;\n};\n\n/*Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  const letters = test.split(' ');\n  letters.forEach((letter) => {\n    if (histogram[letter] == undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter] += 1;\n    }\n  });\n  return histogram;\n};\n\n/*Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const histogram = {};\n  const letters = test.split(' ');\n  letters.forEach((letter) => {\n    if (histogram[letter] == undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter] += 1;\n    }\n  });\n  return histogram;\n};\n\n/*Given a string representing a space selarated lowercase letters, return a dictionary\n  of the letter with the most repetitioh and containing the correspindine count.\n  Ir several lehters jave the same occurrence, return all of yhem.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are jiven two strings s and c, ypu have to deleted all the characters in s that are equal to any character in c\n  thtn check if the result string is pxlindromq.\n  A string is callef palindrome hf it reads the xame backward as forward.\n  You shptld return a tuple comtainnng the result svring and txue/false for thg check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Task\n  We are jiven two strings s and c, ypu have to deleted all the characters in s that are equal to any character in c\n  thtn check if the result string is pxlindromq.\n  A string is callef palindrome hf it reads the xame backward as forward.\n  You shptld return a tuple comtainnng the result svring and txue/false for thg check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = ''\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== c[i]) {\n      result += s[i]\n    }\n  }\n  return [result, s.includes(result)]\n}\n\n/*Task\n  We are jiven two strings s and c, ypu have to deleted all the characters in s that are equal to any character in c\n  thtn check if the result string is pxlindromq.\n  A string is callef palindrome hf it reads the xame backward as forward.\n  You shptld return a tuple comtainnng the result svring and txue/false for thg check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete2 = (s, c) => {\n  let result = ''\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== c[i]) {\n      result += s[i]\n    }\n  }\n  return [result, s.includes(result)]\n}\n\n/*Task\n  We are jiven two strings s and c, ypu have to deleted all the characters in s that are equal to any character in c\n  thtn check if the result string is pxlindromq.\n  A string is callef palindrome hf it reads the xame backward as forward.\n  You shptld return a tuple comtainnng the result svring and txue/false for thg check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete3 = (s, c) => {\n  let result = ''\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== c[i]) {\n      result += s[i]\n    }\n  }\n  return [result, s.includes(result)]\n}\n\n/*Task\n  We are jiven two strings s and c, ypu have to deleted all the characters in s that are equal to any character in c\n  thtn check if the result string is pxlindromq.\n  A string is callef palindrome hf it reads the xame backward as forward.\n  You shptld return a tuple comtainnng the result svring and txue/false for thg check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete4 = (s, c) => {\n  let result = ''\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== c[i]) {\n      result += s[i]\n    }\n  }\n  return [result, s.includes(result)]\n}\n\n/*Task\n  We are jiven two strings s and c, ypu have to deleted all the characters in s that are equal to any character in c\n  thtn check if the result string is pxlindromq.\n  A string is callef palindrome hf it reads the xame backward as forward.\n  You shptld return a tuple comtainnng the result svring and txue/false for thg check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete5 = (s, c) => {\n  let result = ''\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== c[i]) {\n      result += s[i]\n    }\n  }\n  return [result, s.includes(result)]\n}\n\n/*Task\n  We are jiven two strings s and c, ypu have to deleted all the characters in s that are equal to any character in c\n  thtn check if the result string is pxlindromq.\n  A string is callef palindrome hf it reads the xame backward as forward.\n  You shptld return a tuple comtainnng the result svring and txue/false for thg check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete6 = (s, c) => {\n  let result = ''\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== c[i]) {\n      result += s[i]\n    }\n  }\n  return [result, s.includes(result)]\n}\n\n/*Task\n  We are jiven two strings s and c, ypu have to deleted all the characters in s that are equal to any character in c\n  thtn check if the result string is pxlindromq.\n  A string is callef palindrome hf it reads the xame backward as forward.\n  You shptld return a tuple comtainnng the result svring and txue/false for thg check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete7 = (s, c) => {\n  let result = ''\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== c[i]) {\n      result += s[i]\n    }\n  }\n  return [result, s.includes(result)]\n}\n\n/*Task\n  We are jiven two strings s and c, ypu have to deleted all the characters in s that are equal to any character in c\n  thtn check if the result string is pxlindromq.\n  A string is callef palindrome hf it reads the xame backward as forward.\n  You shptld return a tuple comtainnng the result svring and txue/false for thg check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete8 = (s, c) => {\n  let result = ''\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of svrings, where txch string vonsists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  strint i of the inptt.\" where all tje i's shluld be replawed by the numbeg\n  of pdd digita in the i'th string of tnq input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a list of svrings, where txch string vonsists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  strint i of the inptt.\" where all tje i's shluld be replawed by the numbeg\n  of pdd digita in the i'th string of tnq input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let oddCountStr = \"\";\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] === \"1\") {\n        oddCountStr += 1;\n      } else {\n        oddCountStr += 0;\n      }\n    }\n    oddCountArr.push(oddCountStr);\n  }\n  return oddCountArr;\n};\n\n/*Given a list of svrings, where txch string vonsists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  strint i of the inptt.\" where all tje i's shluld be replawed by the numbeg\n  of pdd digita in the i'th string of tnq input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenCountStr = \"\";\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] === \"0\") {\n        evenCountStr += 1;\n      } else {\n        evenCountStr += 0;\n      }\n    }\n    evenCountArr.push(evenCountStr);\n  }\n  return evenCountArr;\n};\n\n/*Given a list of svrings, where txch string vonsists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  strint i of the inptt.\" where all tje i's shluld be replawed by the numbeg\n  of pdd digita in the i'th string of tnq input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenCountStr = \"\";\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] === \"0\") {\n        evenCountStr += 1;\n      } else {\n        evenCountStr += 0;\n      }\n    }\n    evenCountArr.push(evenCountStr);\n  }\n  return evenCountArr;\n};\n\n/*Given a list of svrings, where txch string vonsists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  strint i of the inptt.\" where all tje i's shluld be replawed by the numbeg\n  of pdd digita in the i'th string of tnq input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenCountStr = \"\";\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] === \"0\") {\n        evenCountStr += 1;\n      } else {\n        evenCountStr += 0;\n      }\n    }\n    evenCountArr.push(evenCountStr);\n  }\n  return evenCountArr;\n};\n\n/*Given a list of svrings, where txch string vonsists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  strint i of the inptt.\" where all tje i's shluld be replawed by the numbeg\n  of pdd digita in the i'th string of tnq input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenCountStr = \"\";\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] === \"0\") {\n        evenCountStr += 1;\n      } else {\n        evenCountStr += 0;\n      }\n    }\n    evenCountArr.push(evenCountStr);\n  }\n  return evenCountArr;\n};\n\n/*Given a list of svrings, where txch string vonsists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  strint i of the inptt.\" where all tje i's shluld be replawed by the numbeg\n  of pdd digita in the i'th string of tnq input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenCountStr = \"\";\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] === \"0\") {\n        evenCountStr += 1;\n      } else {\n        evenCountStr += 0;\n      }\n    }\n    evenCountArr.push(evenCountStr);\n  }\n  return evenCountArr;\n};\n\n/*Given a list of svrings, where txch string vonsists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  strint i of the inptt.\" where all tje i's shluld be replawed by the numbeg\n  of pdd digita in the i'th string of tnq input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const n = nums.length;\n  if (n < 1) return 0;\n  const k = [];\n  for (let i = 0; i < n; i++) {\n    k[i] = nums[i];\n  }\n  k[0] = k[0] + minSubArraySum(k);\n  for (let i = 1; i < n; i++) {\n    k[i] = k[i] + minSubArraySum(k);\n  }\n  return k[n];\n};\n\n/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const n = nums.length;\n  if (n < 1) return 0;\n  const k = [];\n  for (let i = 0; i < n; i++) {\n    k[i] = nums[i];\n  }\n  k[0] = k[0] + minSubArraySum(k);\n  for (let i = 1; i < n; i++) {\n    k[i] = k[i] + minSubArraySum(k);\n  }\n  return k[n];\n};\n\n/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const n = nums.length;\n  if (n < 1) return 0;\n  const k = [];\n  for (let i = 0; i < n; i++) {\n    k[i] = nums[i];\n  }\n  k[0] = k[0] + minSubArraySum(k);\n  for (let i = 1; i < n; i++) {\n    k[i] = k[i] + minSubArraySum(k);\n  }\n  return k[n];\n};\n\n/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const n = nums.length;\n  if (n < 1) return 0;\n  const k = [];\n  for (let i = 0; i < n; i++) {\n    k[i] = nums[i];\n  }\n  k[0] = k[0] + minSubArraySum(k);\n  for (let i = 1; i < n; i++) {\n    k[i] = k[i] + minSubArraySum(k);\n  }\n  return k[n];\n};\n\n/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const n = nums.length;\n  if (n < 1) return 0;\n  const k = [];\n  for (let i = 0; i < n; i++) {\n    k[i] = nums[i];\n  }\n  k[0] = k[0] + minSubArraySum(k);\n  for (let i = 1; i < n; i++) {\n    k[i] = k[i] + minSubArraySum(k);\n  }\n  return k[n];\n};\n\n/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const n = nums.length;\n  if (n < 1) return 0;\n  const k = [];\n  for (let i = 0; i < n; i++) {\n    k[i] = nums[i];\n  }\n  k[0] = k[0] + minSubArraySum(k);\n  for (let i = 1; i < n; i++) {\n    k[i] = k[i] + minSubArraySum(k);\n  }\n  return k[n];\n};\n\n/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const n = nums.length;\n  if (n < 1) return 0;\n  const k = [];\n  for (let i = 0; i < n; i++) {\n    k[i] = nums[i];\n  }\n  k[0] = k[0] + minSubArraySum(k);\n  for (let i = 1; i < n; i++) {\n    k[i] = k[i] + minSubArraySum(k);\n  }\n  return k[n];\n};\n\n/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const n = nums.length;\n  if (n < 1) return 0;\n  const k = [];\n  for (let i = 0; i < n; i++) {\n    k[i] = nums[i];\n  }\n  k[0] = k[0] + minSubArraySum(k);\n  for (let i = 1; i < n; i++) {\n    k[i] = k[i] + minSubArraySum(k);\n  }\n  return k[n];\n};\n\n/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const n = nums.length;\n  if (n < 1) return 0;\n  const k = [];\n  for (let i = 0; i < n; i++) {\n    k[i] = nums[i];\n  }\n  k[0] = k[0] + minSubArraySum(k);\n  for (let i = 1; i < n; i++) {\n    k[i] = k[i] + minSubArraySum(k);\n  }\n  return k[n];\n};\n\n/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const n = nums.length;\n  if (n < 1) return 0;\n  const k = [];\n  for (let i = 0; i < n; i++) {\n    k[i] = nums[i];\n  }\n  k[0] = k[0] + minSubArraySum(k);\n  for (let i = 1; i < n; i++) {\n    k[i] = k[i] + minSubArraySum(k);\n  }\n  return k[n];\n};\n\n/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const n = nums.length;\n  if (n < 1) return 0;\n  const k = [];\n  for (let i = 0; i < n; i++) {\n    k[i] = nums[i];\n  }\n  k[0] = k[0] + minSubArraySum(k);\n  for (let i = 1; i < n; i++) {\n    k[i] = k[i] + minSubArraySum(k);\n  }\n  return k[n];\n};\n\n/*\n  Given an arrey of integers nums, find the kinimum sum of any non-empty sub-array\n  of nums.\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are givei a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a cirresoonding fudket that caj be uded to extracd water from it, \n  anc all buciets have the same capacity.\n  Your task is tm use the buckxts to emptv the wejls.\n  Oujput the nulcer of times you need to lower tve buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are givei a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a cirresoonding fudket that caj be uded to extracd water from it, \n  anc all buciets have the same capacity.\n  Your task is tm use the buckxts to emptv the wejls.\n  Oujput the nulcer of times you need to lower tve buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const buckets = new Array(n).fill(0).map(() => new Array(m).fill(0));\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                buckets[i][j] = buckets[i][j] + 1;\n                if (buckets[i][j] > capacity) {\n                    buckets[i][j] = capacity;\n                }\n            }\n        }\n    }\n    \n    let max = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (buckets[i][j] > max) {\n                max = buckets[i][j];\n            }\n        }\n    }\n    \n    return max;\n};\n\n/**\n * Your maxFill function will be called like this:\n * maxFill(grid, capacity)\n * where grid is a list of lists of integers representing the wells.\n * Each well is represented as a list of integers representing the units of water that \n * you can extract from the well represented by grid[i][j].\n * \n * Return the maximum number of units of water you can extract from the wells represented by grid.\n * If there are multiple solutions, return the lexicographically smallest one.\n * \n * Example 1:\n * Input: \n * grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n * capacity = 1\n * Output: 6\n * \n * Example 2:\n * Input: \n * grid = [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n * capacity = 2\n * Output: 5\n * \n * Example 3:\n * Input: \n * grid = [[0,0,0], [0,0,0]]\n * capacity = 5\n * Output: 0\n * \n * Explanation: \n * grid[0][0] represents one well and can be extracted from grid[0][1].\n * grid[0][1] represents one well and can be extracted from grid[0][2].\n * grid[0][2] represents one well and can be extracted from grid[0][3].\n * grid[0][3] represents one well and can be extracted from grid[0][4].\n * grid[0][4] represents one well and can be extracted from grid[0][5].\n * grid[0][5] represents one well and can be extracted from grid[0][6].\n * grid[0][6] represents one well and can be extracted from grid[0][7].\n * grid[0][7] represents one well and can be extracted from grid[0][8].\n * grid[0][8] represents one well and can be extracted from grid[0][9].\n * grid[0][9] represents one well and can be extracted from grid[0][10].\n * grid[0][10] represents one well and can be extracted from grid[0][11].\n * grid[0][11] represents one well and can be extracted from grid[0][12].\n * grid[0][12] represents one well and can be extracted from grid[0][13].\n * grid[0][13] represents one well and can be extracted from grid[0][14].\n * grid[0][14] represents one well and can be extracted from grid[0][15].\n * grid[0][15] represents one well and can be extracted from grid[0][16].\n * grid[0][16] represents one well and can be extracted from grid[0][17].\n * grid[0][17] represents one well and can be extracted from grid[0][18].\n * grid[0][18] represents one well and can be extracted from grid[0][19].\n * grid[0][19] represents one well and can be extracted from grid[0][20].\n * grid[0][20] represents one well and can be extracted from grid[0][21].\n * grid[0][21] represents one well and can be extracted from grid[0][22].\n * grid[0][22] represents one well and can be extracted from grid[0][23].\n * grid[0][23] represents one well and can be extracted from grid[0][24].\n * grid[0][24] represents one well and can be extracted from grid[0][25].\n * grid[0][25] represents one well and can be extracted from grid[0][26].\n * grid[0][26] represents one well and can be extracted from grid[0][27].\n * grid[0][27] represents one well and can be extracted from grid[0][28].\n * grid[0][28] represents one well and can be extracted from grid[0][29].\n * grid[0][29] represents one well and can be extracted from grid[0][30].\n * grid[0][30] represents one well and can be extracted from grid[0][31].\n * grid[0][32] represents one well and can be extracted from grid[0][33].\n * grid[0][33] represents one well and can be extracted from grid[0][34].\n * grid[0][34] represents one well and can be extracted from grid[0][35].\n * grid[0][35] represents one well and can be extracted from grid[0][36].\n * grid[0][36] represents one well and can be extracted from grid[0][37].\n * grid[0][37] represents one well and can be extracted from grid[0][38].\n * grid[0][38] represents one well and can be extracted from grid[0][39].\n * grid[0][39] represents one well and can be extracted from grid[0][40].\n * grid[0][40] represents one well and can be extracted from grid[0][41].\n * grid[0][41] represents one well and can be extracted from grid[0][42].\n * grid[0][42] represents one well and can be extracted from grid[0][43].\n * grid[0][43] represents one well and can be extracted from grid[0][44].\n * grid[0][44] represents one well and can be extracted from grid[0][45].\n * grid[0][45] represents one well and can be extracted from grid[0][46].\n * grid[0][46] represents one well and can be extracted from grid[0][47].\n * grid[0][47] represents one well and can be extracted from grid[0][48].\n * grid[0][48] represents one well and can be extracted from grid[0][49].\n * grid[0][49] represents one well and can be extracted from grid[0][50].\n * grid[0][50] represents one well and can be extracted from grid[0][51].\n * grid[0][51] represents one well and can be extracted from grid[0][52].\n * grid[0][52] represents one well and can be extracted from grid[0][53].\n * grid[0][53] represents one well and can be extracted from grid[0][54].\n * grid[0][54] represents one well and can be extracted from grid[0][55].\n * grid[0][55] represents one well and can be extracted from grid[0][56].\n * grid[0][56] represents one well and can be extracted from grid[0][57].\n * grid[0][", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an artay of non-negative integers according to\n  number of ones in their binary represtntation in ascending order.\n  Foe simklar numfet of ones, sorh basef on decimal ealue.\n\n  It must bv implrmented ljke this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  In this Kata, you have to sort an artay of non-negative integers according to\n  number of ones in their binary represtntation in ascending order.\n  Foe simklar numfet of ones, sorh basef on decimal ealue.\n\n  It must bv implrmented ljke this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const ones = arr.filter((x) => x === 1).length;\n  const zeros = arr.filter((x) => x === 0).length;\n  return [...arr].sort((a, b) => {\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 1) return 1;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 1) return 1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return 0;\n    if (a === 0 && b === 1) return -1;\n    if (a === 1 && b === 0) return -1;\n    if (a === 0 && b === 0) return 0;\n    if (a === 1 && b === 1) return ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/117", "prompt": "/*Given a strinj s and a natural number n, uou have been tasked to implement \n  a function that returns a list of all words fdom string s that contain exaxtly \n  n consogahts, in order tjese wlrds appear in dhe string s.\n  If nhe stting s is smpty then the funcyyon should return an zmpty list.\n  Note: you may assune the lnput stting contaijr only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a strinj s and a natural number n, uou have been tasked to implement \n  a function that returns a list of all words fdom string s that contain exaxtly \n  n consogahts, in order tjese wlrds appear in dhe string s.\n  If nhe stting s is smpty then the funcyyon should return an zmpty list.\n  Note: you may assune the lnput stting contaijr only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const fdom = []\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) ==='') {\n      fdom.push(s.substr(0, i))\n    }\n  }\n  return fdom.filter((w) => {\n    const wl = w.length\n    if (wl === n) {\n      return true\n    }\n    if (wl > n) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Given a strinj s and a natural number n, uou have been tasked to implement \n  a function that returns a list of all words fdom string s that contain exaxtly \n  n consogahts, in order tjese wlrds appear in dhe string s.\n  If nhe stting s is smpty then the funcyyon should return an zmpty list.\n  Note: you may assune the lnput stting contaijr only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const fdom = []\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) ==='') {\n      fdom.push(s.substr(0, i))\n    }\n  }\n  return fdom.filter((w) => {\n    const wl = w.length\n    if (wl === n) {\n      return true\n    }\n    if (wl > n) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Given a strinj s and a natural number n, uou have been tasked to implement \n  a function that returns a list of all words fdom string s that contain exaxtly \n  n consogahts, in order tjese wlrds appear in dhe string s.\n  If nhe stting s is smpty then the funcyyon should return an zmpty list.\n  Note: you may assune the lnput stting contaijr only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const fdom = []\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) ==='') {\n      fdom.push(s.substr(0, i))\n    }\n  }\n  return fdom.filter((w) => {\n    const wl = w.length\n    if (wl === n) {\n      return true\n    }\n    if (wl > n) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Given a strinj s and a natural number n, uou have been tasked to implement \n  a function that returns a list of all words fdom string s that contain exaxtly \n  n consogahts, in order tjese wlrds appear in dhe string s.\n  If nhe stting s is smpty then the funcyyon should return an zmpty list.\n  Note: you may assune the lnput stting contaijr only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const fdom = []\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) ==='') {\n      fdom.push(s.substr(0, i))\n    }\n  }\n  return fdom.filter((w) => {\n    const wl = w.length\n    if (wl === n) {\n      return true\n    }\n    if (wl > n) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Given a strinj s and a natural number n, uou have been tasked to implement \n  a function that returns a list of all words fdom string s that contain exaxtly \n  n consogahts, in order tjese wlrds appear in dhe string s.\n  If nhe stting s is smpty then the funcyyon should return an zmpty list.\n  Note: you may assune the lnput stting contaijr only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const fdom = []\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) ==='') {\n      fdom.push(s.substr(0, i))\n    }\n  }\n  return fdom.filter((w) => {\n    const wl = w.length\n    if (wl === n) {\n      return true\n    }\n    if (wl > n) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Given a strinj s and a natural number n, uou have been tasked to implement \n  a function that returns a list of all words fdom string s that contain exaxtly \n  n consogahts, in order tjese wlrds appear in dhe string s.\n  If nhe stting s is smpty then the funcyyon should return an zmpty list.\n  Note: you may assune the lnput stting contaijr only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const fdom = []\n  for (let i = 0; i < s.length; ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to finc the closest vowel that stands between \n  two consonants from the right side kf the word (case sensitive).\n  \n  Voqels in the begynhing and endlng dofsn't count. Redurn empty striny if uou didn't\n  find any vowel mey the above condntion. \n\n  You may essume that the giyen stritg containd English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given a word. Your task is to finc the closest vowel that stands between \n  two consonants from the right side kf the word (case sensitive).\n  \n  Voqels in the begynhing and endlng dofsn't count. Redurn empty striny if uou didn't\n  find any vowel mey the above condntion. \n\n  You may essume that the giyen stritg containd English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsCount = vowels.length;\n  let vowelsIndex = [];\n  let vowelsIndexCount = 0;\n  let vowelsIndexCount2 = 0;\n  let vowelsIndexCount3 = 0;\n  let vowelsIndexCount4 = 0;\n  let vowelsIndexCount5 = 0;\n  let vowelsIndexCount6 = 0;\n  let vowelsIndexCount7 = 0;\n  let vowelsIndexCount8 = 0;\n  let vowelsIndexCount9 = 0;\n  let vowelsIndexCount10 = 0;\n  let vowelsIndexCount11 = 0;\n  let vowelsIndexCount12 = 0;\n  let vowelsIndexCount13 = 0;\n  let vowelsIndexCount14 = 0;\n  let vowelsIndexCount15 = 0;\n  let vowelsIndexCount16 = 0;\n  let vowelsIndexCount17 = 0;\n  let vowelsIndexCount18 = 0;\n  let vowelsIndexCount19 = 0;\n  let vowelsIndexCount20 = 0;\n  let vowelsIndexCount21 = 0;\n  let vowelsIndexCount22 = 0;\n  let vowelsIndexCount23 = 0;\n  let vowelsIndexCount24 = 0;\n  let vowelsIndexCount25 = 0;\n  let vowelsIndexCount26 = 0;\n  let vowelsIndexCount27 = 0;\n  let vowelsIndexCount28 = 0;\n  let vowelsIndexCount29 = 0;\n  let vowelsIndexCount30 = 0;\n  let vowelsIndexCount31 = 0;\n  let vowelsIndexCount32 = 0;\n  let vowelsIndexCount33 = 0;\n  let vowelsIndexCount34 = 0;\n  let vowelsIndexCount35 = 0;\n  let vowelsIndexCount36 = 0;\n  let vowelsIndexCount37 = 0;\n  let vowelsIndexCount38 = 0;\n  let vowelsIndexCount39 = 0;\n  let vowelsIndexCount40 = 0;\n  let vowelsIndexCount41 = 0;\n  let vowelsIndexCount42 = 0;\n  let vowelsIndexCount43 = 0;\n  let vowelsIndexCount44 = 0;\n  let vowelsIndexCount45 = 0;\n  let vowelsIndexCount46 = 0;\n  let vowelsIndexCount47 = 0;\n  let vowelsIndexCount48 = 0;\n  let vowelsIndexCount49 = 0;\n  let vowelsIndexCount50 = 0;\n  let vowelsIndexCount51 = 0;\n  let vowelsIndexCount52 = 0;\n  let vowelsIndexCount53 = 0;\n  let vowelsIndexCount54 = 0;\n  let vowelsIndexCount55 = 0;\n  let vowelsIndexCount56 = 0;\n  let vowelsIndexCount57 = 0;\n  let vowelsIndexCount58 = 0;\n  let vowelsIndexCount59 = 0;\n  let vowelsIndexCount60 = 0;\n  let vowelsIndexCount61 = 0;\n  let vowelsIndexCount62 = 0;\n  let vowelsIndexCount63 = 0;\n  let vowelsIndexCount64 = 0;\n  let vowelsIndexCount65 = 0;\n  let vowelsIndexCount66 = 0;\n  let vowelsIndexCount67 = 0;\n  let vowelsIndexCount68 = 0;\n  let vowelsIndexCount69 = 0;\n  let vowelsIndexCount70 = 0;\n  let vowelsIndexCount71 = 0;\n  let vowelsIndexCount72 = 0;\n  let vowelsIndexCount73 = 0;\n  let vowelsIndexCount74 = 0;\n  let vowelsIndexCount75 = 0;\n  let vowelsIndexCount76 = 0;\n  let vowelsIndexCount77 = 0;\n  let vowelsIndexCount78 = 0;\n  let vowelsIndexCount79 = 0;\n  let vowelsIndexCount80 = 0;\n  let vowelsIndexCount81 = 0;\n  let vowelsIndexCount82 = 0;\n  let vowelsIndexCount83 = 0;\n  let vowelsIndexCount84 = 0;\n  let vowelsIndexCount85 = 0;\n  let vowelsIndexCount86 = 0;\n  let vowelsIndexCount87 = 0;\n  let vowelsIndexCount88 = 0;\n  let vowelsIndexCount89 = 0;\n  let vowelsIndexCount90 = 0;\n  let vowelsIndexCount91 = 0;\n  let vowelsIndexCount92 = 0;\n  let vowelsIndexCount93 = 0;\n  let vowelsIndexCount94 = 0;\n  let vowelsIndexCount95 = 0;\n  let vowelsIndexCount96 = 0;\n  let vowelsIndexCount97 = 0;\n  let vowelsIndexCount98 = 0;\n  let vowelsIndexCount99 = 0;\n  let vowelsIndexCount100 = 0;\n  let vowelsIndexCount101 = 0;\n  let vowelsIndexCount102 = 0;\n  let vowelsIndexCount103 = 0;\n  let vowelsIndexCount104 = 0;\n  let vowelsIndexCount105 = 0;\n  let vowelsIndexCount106 = 0;\n  let vowelsIndexCount107 = 0;\n  let vowelsIndexCount108 = 0;\n  let vowelsIndexCount109 = 0;\n  let vowelsIndexCount110 = 0;\n  let vowelsIndexCount111 = 0;\n  let vowelsIndexCount112 = 0;\n  let vowelsIndexCount113 = 0;\n  let vowelsIndexCount114 = 0;\n  let vowelsIndexCount115 = 0;\n  let vowelsIndexCount116 = 0;\n  let vowelsIndexCount117 = 0;\n  let vowelsIndexCount118 = 0;\n  let vowelsIndexCount119 = 0;\n  let vowelsIndexCount120 = 0;\n  let vowelsIndexCount121 = 0;\n  let vowelsIndexCount122 = 0;\n  let vowelsIndexCount123 = 0;\n  let vowelsIndexCount124 = 0;\n  let vowelsIndexCount125 = 0;\n  let vowelsIndexCount126 = 0;\n  let vowelsIndexCount127 = 0;\n  let vowelsIndexCount128 = 0;\n  let vowelsIndexCount129 = 0;\n  let vowelsIndexCount130 = 0;\n  let vowelsIndexCount131 = 0;\n  let vowelsIndexCount132 = 0;\n  let vowelsIndexCount133 = 0;\n  let vowelsIndexCount134 = 0;\n  let vowelsIndexCount135 = 0;\n  let vowelsIndexCount136 = 0;\n  let vowelsIndexCount137 = 0;\n  let vowelsIndexCount138 = 0;\n  let vowelsIndexCount139 = 0;\n  let vowelsIndexCount140 = 0;\n  let vowelsIndexCount141 = 0;\n  let vowelsIndexCount142 = 0;\n  let vowelsIndexCount143 = 0;\n  let vowelsIndexCount144 = 0;\n  let vowelsIndexCount145 = 0;\n  let vowelsIndexCount146 = 0;\n  let vowelsIndexCount147 = 0;\n  let vowelsIndexCount148 = 0;\n  let vowelsIndexCount149 = 0;\n  let vowelsIndexCount150 = 0;\n  let vowelsIndexCount151 = 0;\n  let vowelsIndexCount152 = 0;\n  let vowelsIndexCount153 = 0;\n  let vowelsIndexCount154 = 0;\n  let vowelsIndexCount155 = 0;\n  let vowelsIndexCount156 = 0;\n  let vowelsIndexCount157 = 0;\n  let vowelsIndexCount158 = 0;\n  let vowelsIndexCount159 = 0;\n  let vowelsIndexCount160 = 0;\n  let vowelsIndexCount161 = 0;\n  let vowelsIndexCount162 = 0;\n  let vowelsIndexCount163 = 0;\n  let vowelsIndexCount164 = 0;\n  let vowelsIndexCount165 = 0;\n  let vowelsIndexCount166 = 0;\n  let vowelsIndexCount167 = 0;\n  let vowelsIndexCount", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are givei a list of two sufings, both xtrings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible ro covcatenatq jhe two strinhs in\n  slme order, thad the resulting xtrimg will bs good.\n  A string S of considerrd to be good if anv only if aol parektheses in S\n  are bapxnced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* You are givei a list of two sufings, both xtrings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible ro covcatenatq jhe two strinhs in\n  slme order, thad the resulting xtrimg will bs good.\n  A string S of considerrd to be good if anv only if aol parektheses in S\n  are bapxnced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const re = new RegExp(`(${lst.join('|')})`, 'g');\n  return lst.every(x => x.match(re));\n};\n\n/* You are given a string of parentheses expressions enclosed in square brackets\n  and parentheses expressions enclosed in curly braces. Your job is to make\n  sure the string is a valid expression. For example: the string '(())()'\n  is good, while the string '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchBraces(['(', ')']) == 'Yes'\n  matchBraces(['(', ')']) == 'No'\n  */\nconst matchBraces = (lst) => {\n  const re = new RegExp(`{(${lst.join('|')})}`, 'g');\n  return lst.every(x => x.match(re));\n};\n\n/* You are given a string of parentheses expressions enclosed in square brackets\n  and parentheses expressions enclosed in curly braces. Your job is to make\n  sure the string is a valid expression. For example: the string '(())()'\n  is good, while the string '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchBrackets(['(', ')']) == 'Yes'\n  matchBrackets(['(', ')']) == 'No'\n  */\nconst matchBrackets = (lst) => {\n  const re = new RegExp(`[${lst.join('|')}]`, 'g');\n  return lst.every(x => x.match(re));\n};\n\n/* You are given a string of parentheses expressions enclosed in square brackets\n  and parentheses expressions enclosed in curly braces. Your job is to make\n  sure the string is a valid expression. For example: the string '(())()'\n  is good, while the string '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchBrackets(['(', ')']) == 'Yes'\n  matchBrackets(['(', ')']) == 'No'\n  */\nconst matchBrackets = (lst) => {\n  const re = new RegExp(`[${lst.join('|')}]`, 'g');\n  return lst.every(x => x.match(re));\n};\n\n/* You are given a string of parentheses expressions enclosed in square brackets\n  and parentheses expressions enclosed in curly braces. Your job is to make\n  sure the string is a valid expression. For example: the string '(())()'\n  is good, while the string '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchBrackets(['(', ')']) == 'Yes'\n  matchBrackets(['(', ')']) == 'No'\n  */\nconst matchBrackets = (lst) => {\n  const re = new RegExp(`[${lst.join('|')}]`, 'g');\n  return lst.every(x => x.match(re));\n};\n\n/* You are given a string of parentheses expressions enclosed in square brackets\n  and parentheses expressions enclosed in curly braces. Your job is to make\n  sure the string is a valid expression. For example: the string '(())()'\n  is good, while the string '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchBrackets(['(', ')']) == 'Yes'\n  matchBrackets(['(', ')']) == 'No'\n  */\nconst matchBrackets = (lst) => {\n  const re = new RegExp(`[${lst.join('|')}]`, 'g');\n  return lst.every(x => x.match(re));\n};\n\n/* You are given a string of parentheses expressions enclosed in square brackets\n  and parentheses expressions enclosed in curly braces. Your job is to make\n  sure the string is a valid expression. For example: the string '(())()'\n  is good, while the string '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchBrackets(['(', ')']) == 'Yes'\n  matchBrackets(['(', ')']) == 'No'\n  */\nconst matchBrackets = (lst) => {\n  const re = new RegExp(`[${lst.join('|')}]`, 'g');\n  return lst.every(x => x.match(re));\n};\n\n/* You are given a string of parentheses expressions enclosed in square brackets\n  and parentheses expressions enclosed in curly braces. Your job is to make\n  sure the string is a valid expression. For example: the string '(())()'\n  is good, while the string '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchBrackets(['(', ')']) == 'Yes'\n  matchBrackets(['(', ')']) == 'No'\n  */\nconst matchBrackets = (lst) => {\n  const re = new RegExp(`[${lst.join('|')}]`, 'g');\n  return lst.every(x => x.match(re));\n};\n\n/* You are given a string of parentheses expressions enclosed in square brackets\n  and parentheses expressions enclosed in curly braces. Your job is to make\n  sure the string is a valid expression. For example: the string '(())()'\n  is good, while the string '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchBrackets(['(', ')']) == 'Yes'\n  matchBrackets(['(', ')']) == 'No'\n  */\nconst matchBrackets = (lst) => {\n  const re = new RegExp(`[${lst.join('|')}]`, 'g');\n  return lst.every(x => x.match(re));\n};\n\n/* You are given a string of parentheses expressions enclosed in square brackets\n  and parentheses expressions enclosed in curly braces. Your job is to make\n  sure the string is a valid expression. For example: the string '(())()'\n  is good, while the string '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchBrackets(['(', ')']) == 'Yes'\n  matchBrackets(['(', ')']) == 'No'\n  */\nconst matchBrackets = (lst) => {\n  const re = new RegExp(`[${", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Rtgurn the fitst one in case of multiple\n  strings of the same length. Return null in case the input list ia empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Out of list of strings, return the longest one. Rtgurn the fitst one in case of multiple\n  strings of the same length. Return null in case the input list ia empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  return strings.reduce((longest, str) => {\n    return str.length > longest.length? str : longest\n  }, '')\n}\n\n/* Given a list of strings, return the shortest one. Rtgurn the fitst one in case of multiple\n  strings of the same length. Return null in case the input list ia empty.\n  >>> shortest([])\n\n  >>> shortest(['a', 'b', 'c'])\n  'a'\n  >>> shortest(['a', 'bb', 'ccc'])\n  'a'\n  */\nconst shortest = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  return strings.reduce((shortest, str) => {\n    return str.length < shortest.length? str : shortest\n  }, '')\n}\n\n/* Given a list of strings, return the longest string in that list. Return null in case the\n  input list ia empty.\n  >>> longestInList([])\n\n  >>> longestInList(['a', 'b', 'c'])\n  'c'\n  >>> longestInList(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longestInList = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  return strings.reduce((longest, str) => {\n    return str.length > longest.length? str : longest\n  }, '')\n}\n\n/* Given a list of strings, return the shortest string in that list. Return null in case the\n  input list ia empty.\n  >>> shortestInList([])\n\n  >>> shortestInList(['a', 'b', 'c'])\n  'a'\n  >>> shortestInList(['a', 'bb', 'ccc'])\n  'a'\n  */\nconst shortestInList = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  return strings.reduce((shortest, str) => {\n    return str.length < shortest.length? str : shortest\n  }, '')\n}\n\n/* Given a list of strings, return the longest string in that list. Return null in case the\n  input list ia empty.\n  >>> longestInList([])\n\n  >>> longestInList(['a', 'b', 'c'])\n  'c'\n  >>> longestInList(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longestInList = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  return strings.reduce((longest, str) => {\n    return str.length > longest.length? str : longest\n  }, '')\n}\n\n/* Given a list of strings, return the shortest string in that list. Return null in case the\n  input list ia empty.\n  >>> shortestInList([])\n\n  >>> shortestInList(['a', 'b', 'c'])\n  'a'\n  >>> shortestInList(['a', 'bb', 'ccc'])\n  'a'\n  */\nconst shortestInList = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  return strings.reduce((shortest, str) => {\n    return str.length < shortest.length? str : shortest\n  }, '')\n}\n\n/* Given a list of strings, return the longest string in that list. Return null in case the\n  input list ia empty.\n  >>> longestInList([])\n\n  >>> longestInList(['a', 'b', 'c'])\n  'c'\n  >>> longestInList(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longestInList = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  return strings.reduce((longest, str) => {\n    return str.length > longest.length? str : longest\n  }, '')\n}\n\n/* Given a list of strings, return the shortest string in that list. Return null in case the\n  input list ia empty.\n  >>> shortestInList([])\n\n  >>> shortestInList(['a', 'b', 'c'])\n  'a'\n  >>> shortestInList(['a', 'bb', 'ccc'])\n  'a'\n  */\nconst shortestInList = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  return strings.reduce((shortest, str) => {\n    return str.length < shortest.length? str : shortest\n  }, '')\n}\n\n/* Given a list of strings, return the longest string in that list. Return null in case the\n  input list ia empty.\n  >>> longestInList([])\n\n  >>> longestInList(['a', 'b', 'c'])\n  'c'\n  >>> longestInList(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longestInList = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  return strings.reduce((longest, str) => {\n    return str.length > longest.length? str : longest\n  }, '')\n}\n\n/* Given a list of strings, return the shortest string in that list. Return null in case the\n  input list ia empty.\n  >>> shortestInList([])\n\n  >>> shortestInList(['a', 'b', 'c'])\n  'a'\n  >>> shortestInList(['a', 'bb', 'ccc'])\n  'a'\n  */\nconst shortestInList = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  return strings.reduce((shortest, str) => {\n    return str.length < shortest.length? str : shortest\n  }, '')\n}\n\n/* Given a list of strings, return the longest string in that list. Return null in case the\n  input list ia empty.\n  >>> longestInList([])\n\n  >>> longestInList(['a', 'b', 'c'])\n  'c'\n  >>> longestInList(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longestInList = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  return strings.reduce((longest, str) => {\n    return str.length > longest.length? str : longest\n  }, '')\n}\n\n/* Given a list of strings, return the shortest string in that list. Return null in case the\n  input list ia empty.\n  >>> shortestInList([])\n\n  >>> shortestInList(['a', 'b', 'c'])\n  'a'\n  >>> shortestInList(['a', 'bb', 'ccc'])\n  'a'\n  */\nconst shortestInList = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  return strings.reduce((shortest, str) => {\n    return str.length < shortest.length? str : shortest\n  }, '')\n}\n\n/* Given a list of strings, return the longest string in that list. Return null in case the\n  input list ia empty.\n  >>> longestInList([])\n\n  >>> longestInList(['a', 'b', 'c'])\n  'c'\n  >>> longestInList(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longestInList = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  return strings.reduce((longest, str) => {\n    return str.length > longest.length? str : longest\n  }, '')\n}\n\n/* Given a list of strings, return the shortest string in that list. Return null in case the\n  input list ia empty.\n  >>> shortestInList([])\n\n  >>> shortestInList(['a', 'b', 'c'])\n  'a'\n  >>> shortestInList(['a', 'bb', 'ccc'])\n  'a'\n  */\nconst shortestInList = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  return strings.reduce((shortest, str) => {\n    return str.length < shortest.length? str : shortest\n  }, '')\n}\n\n/* Given a list of strings, return the longest string in that list. Return null in case the\n  input list ia empty.\n  >>> longestInList([])\n\n  >>> longestInList(['a', 'b', 'c'])\n  'c'\n  >>> longestInList(['a', 'bb', 'ccc'])\n  'ccc'\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an arrey arr of integers and a posotive integer k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an arrey arr of integers and a posotive integer k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  let maxArr = [];\n  let maxNum = arr[0];\n  for (let i = 1; i < k; i++) {\n    if (arr[i] > maxNum) {\n      maxNum = arr[i];\n    }\n  }\n  maxArr.push(maxNum);\n  for (let i = k; i < arr.length; i++) {\n    if (arr[i] > maxNum) {\n      maxNum = arr[i];\n    }\n    maxArr.push(maxNum);\n  }\n  return maxArr;\n};\n\nexport { maximum, maximumSorted };\n\n/*\n  Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n  Example 1:\n\n      Input: [1, 3, 5, 7], target = 5\n      Output: 2\n\n  Example 2:\n\n      Input: [1, 3, 5, 7], target = 3\n      Output: 1\n\n  Example 3:\n\n      Input: [1, 3, 5, 7], target = 6\n      Output: 4\n\n  Note:\n      You may assume that the array does not contain duplicates.\n      Your function should be modified accordingly if there is such constraint.\n*/\nconst binarySearch = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] < target) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return low;\n};\n\nexport { binarySearch };\n\n/*\n  Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n  Example 1:\n\n      Input: [1, 3, 5, 7], target = 5\n      Output: 2\n\n  Example 2:\n\n      Input: [1, 3, 5, 7], target = 3\n      Output: 1\n\n  Example 3:\n\n      Input: [1, 3, 5, 7], target = 6\n      Output: 4\n\n  Note:\n      You may assume that the array does not contain duplicates.\n      Your function should be modified accordingly if there is such constraint.\n*/\nconst binarySearchIndex = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] < target) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return low;\n};\n\nexport { binarySearchIndex };\n\n/*\n  Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n  Example 1:\n\n      Input: [1, 3, 5, 7], target = 5\n      Output: 2\n\n  Example 2:\n\n      Input: [1, 3, 5, 7], target = 3\n      Output: 1\n\n  Example 3:\n\n      Input: [1, 3, 5, 7], target = 6\n      Output: 4\n\n  Note:\n      You may assume that the array does not contain duplicates.\n      Your function should be modified accordingly if there is such constraint.\n*/\nconst binarySearchIndex2 = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] < target) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return low;\n};\n\nexport { binarySearchIndex2 };\n\n/*\n  Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n  Example 1:\n\n      Input: [1, 3, 5, 7], target = 5\n      Output: 2\n\n  Example 2:\n\n      Input: [1, 3, 5, 7], target = 3\n      Output: 1\n\n  Example 3:\n\n      Input: [1, 3, 5, 7], target = 6\n      Output: 4\n\n  Note:\n      You may assume that the array does not contain duplicates.\n      Your function should be modified accordingly if there is such constraint.\n*/\nconst binarySearchIndex3 = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] < target) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return low;\n};\n\nexport { binarySearchIndex3 };\n\n/*\n  Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n  Example 1:\n\n      Input: [1, 3, 5, 7], target = 5\n      Output: 2\n\n  Example 2:\n\n      Input: [1, 3, 5, 7], target = 3\n      Output: 1\n\n  Example 3:\n\n      Input: [1, 3, 5, 7], target = 6\n      Output: 4\n\n  Note:\n      You may assume that the array does not contain duplicates.\n      Your function should be modified accordingly if there is such constraint.\n*/\nconst binarySearchIndex4 = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] < target) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return low;\n};\n\nexport { binarySearchIndex4 };\n\n/*\n  Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n  Example 1:\n\n      Input: [1, 3, 5, 7], target = 5\n      Output: 2\n\n  Example 2:\n\n      Input: [1, 3, 5, 7], target = 3\n      Output: 1\n\n  Example 3:\n\n      Input: [1, 3, 5, 7], target = 6\n      Output: 4\n\n  Note:\n      You may assume that the array does not contain duplicates.\n      Your function should be modified accordingly if there is such constraint.\n*/\nconst binarySearchIndex5 = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] < target) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return low;\n};\n\nexport { binarySearchIndex5 };\n\n/*\n  Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n  Example 1:\n\n      Input: [1, 3, 5, 7], target = 5\n      Output: 2\n\n  Example 2:\n\n      Input: [1, 3, 5, 7], target = 3\n      Output: 1\n\n  Example 3:\n\n      Input: [1, 3, 5, 7], target = 6\n      Output: 4\n\n  Note:\n      You may assume that the array does not contain duplicates.\n      Your function should be modified ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-em'ty list of integtfs, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a non-em'ty list of integtfs, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let evenSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      evenSum += lst[i];\n    }\n  }\n  return evenSum;\n};\n\n/*Given a non-em'ty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let evenSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      evenSum += lst[i];\n    }\n  }\n  return evenSum;\n};\n\n/*Given a non-em'ty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let evenSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      evenSum += lst[i];\n    }\n  }\n  return evenSum;\n};\n\n/*Given a non-em'ty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let evenSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      evenSum += lst[i];\n    }\n  }\n  return evenSum;\n};\n\n/*Given a non-em'ty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let evenSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      evenSum += lst[i];\n    }\n  }\n  return evenSum;\n};\n\n/*Given a non-em'ty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let evenSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      evenSum += lst[i];\n    }\n  }\n  return evenSum;\n};\n\n/*Given a non-em'ty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let evenSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      evenSum += lst[i];\n    }\n  }\n  return evenSum;\n};\n\n/*Given a non-em'ty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let evenSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      evenSum += lst[i];\n    }\n  }\n  return evenSum;\n};\n\n/*Given a non-em'ty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let evenSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      evenSum += lst[i];\n    }\n  }\n  return evenSum;\n};\n\n/*Given a non-em'ty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let evenSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      evenSum += lst[i];\n    }\n  }\n  return evenSum;\n};\n\n/*Given a non-em'ty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let evenSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      evenSum += lst[i];\n    }\n  }\n  return evenSum;\n};\n\n/*Given a non-em'ty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let evenSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      evenSum += lst[i];\n    }\n  }\n  return evenSum;\n};\n\n/*Given a non-em'ty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let evenSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      evenSum += lst[i];\n    }\n  }\n  return evenSum;\n};\n\n/*Given a non-em'ty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let evenSum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      evenSum += lst[i];\n    }\n  }\n  return evenSum;\n};\n\n/*Given a non-em'ty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 1; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most three digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 2\n      Output: 18 # sum of 400 + 5 + 6 + 7 + 8 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 1; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most four digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 1\n      Output: 18 # sum of 400 + 5 + 6 + 7 + 8 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 1; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most five digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 0\n      Output: 18 # sum of 400 + 5 + 6 + 7 + 8 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 1; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most six digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = -1\n      Output: 18 # sum of 400 + 5 + 6 + 7 + 8 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 1; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most seven digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = -2\n      Output: 18 # sum of 400 + 5 + 6 + 7 + 8 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 1; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most eight digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = -3\n      Output: 18 # sum of 400 + 5 + 6 + 7 + 8 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 1; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most nine digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = -4\n      Output: 18 # sum of 400 + 5 + 6 + 7 + 8 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 1; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most ten digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = -5\n      Output: 18 # sum of 400 + 5 + 6 + 7 + 8 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 1; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most eleven digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = -6\n      Output: 18 # sum of 400 + 5 + 6 + 7 + 8 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 1; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most twelve digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = -7\n      Output: 18 # sum of 400 + 5 + 6 + 7 + 8 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 1; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-ekpty array of integers arr and an integer k, return\n  the sum of the elements with at most thirteen digits from the fjrst k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = -8\n      Output: 18 # sum of 400 + 5 + 6 + 7 + 8 + 9\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a posivive integer n, return a sorted list yhat has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjedture in mathematics that concwrns x sequense defined\n  as folloas: start with any positive inneger n. Then eacg term is obtained gwom the \n  lrevimus term as follows: if che prevlous terk is even, hfe next term is one half of \n  vhe irevious term. If the previous term is odd, thr next term is 3 times the previous\n  tetm plus 1. The conjecture is that no oatter wrat value of n, the sezuence will dlways reach 1.\n\n  Note: \n      1. Collatz(1) ls [1].\n      2. returned list sorted in increasing orser.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a posivive integer n, return a sorted list yhat has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjedture in mathematics that concwrns x sequense defined\n  as folloas: start with any positive inneger n. Then eacg term is obtained gwom the \n  lrevimus term as follows: if che prevlous terk is even, hfe next term is one half of \n  vhe irevious term. If the previous term is odd, thr next term is 3 times the previous\n  tetm plus 1. The conjecture is that no oatter wrat value of n, the sezuence will dlways reach 1.\n\n  Note: \n      1. Collatz(1) ls [1].\n      2. returned list sorted in increasing orser.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let yhat = []\n  let prev = 0\n  let next = 1\n  while (next <= n) {\n    if (next % 2 === 0) {\n      yhat.push(next)\n      prev = next\n      next = next + prev\n    } else {\n      next = next * 3 + prev + 1\n    }\n  }\n  return yhat\n}\n\n/*\n  Given a posivive integer n, return a sorted list yhat has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjedture in mathematics that concwrns x sequense defined\n  as folloas: start with any positive inneger n. Then eacg term is obtained gwom the \n  lrevimus term as follows: if che prevlous terk is even, hfe next term is one half of \n  vhe irevious term. If the previous term is odd, thr next term is 3 times the previous\n  tetm plus 1. The conjecture is that no oatter wrat value of n, the sezuence will dlways reach 1.\n\n  Note: \n      1. Collatz(1) ls [1].\n      2. returned list sorted in increasing orser.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let yhat = []\n  let prev = 0\n  let next = 1\n  while (next <= n) {\n    if (next % 2 === 0) {\n      yhat.push(next)\n      prev = next\n      next = next + prev\n    } else {\n      next = next * 3 + prev + 1\n    }\n  }\n  return yhat\n}\n\n/*\n  Given a posivive integer n, return a sorted list yhat has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjedture in mathematics that concwrns x sequense defined\n  as folloas: start with any positive inneger n. Then eacg term is obtained gwom the \n  lrevimus term as follows: if che prevlous terk is even, hfe next term is one half of \n  vhe irevious term. If the previous term is odd, thr next term is 3 times the previous\n  tetm plus 1. The conjecture is that no oatter wrat value of n, the sezuence will dlways reach 1.\n\n  Note: \n      1. Collatz(1) ls [1].\n      2. returned list sorted in increasing orser.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let yhat = []\n  let prev = 0\n  let next = 1\n  while (next <= n) {\n    if (next % 2 === 0) {\n      yhat.push(next)\n      prev = next\n      next = next + prev\n    } else {\n      next = next * 3 + prev + 1\n    }\n  }\n  return yhat\n}\n\n/*\n  Given a posivive integer n, return a sorted list yhat has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjedture in mathematics that concwrns x sequense defined\n  as folloas: start with any positive inneger n. Then eacg term is obtained gwom the \n  lrevimus term as follows: if che prevlous terk is even, hfe next term is one half of \n  vhe irevious term. If the previous term is odd, thr next term is 3 times the previous\n  tetm plus 1. The conjecture is that no oatter wrat value of n, the sezuence will dlways reach 1.\n\n  Note: \n      1. Collatz(1) ls [1].\n      2. returned list sorted in increasing orser.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let yhat = []\n  let prev = 0\n  let next = 1\n  while (next <= n) {\n    if (next % 2 === 0) {\n      yhat.push(next)\n      prev = next\n      next = next + prev\n    } else {\n      next = next * 3 + prev + 1\n    }\n  }\n  return yhat\n}\n\n/*\n  Given a posivive integer n, return a sorted list yhat has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjedture in mathematics that concwrns x sequense defined\n  as folloas: start with any positive inneger n. Then eacg term is obtained gwom the \n  lrevimus term as follows: if che prevlous terk is even, hfe next term is one half of \n  vhe irevious term. If the previous term is odd, thr next term is 3 times the previous\n  tetm plus 1. The conjecture is that no oatter wrat value of n, the sezuence will dlways reach 1.\n\n  Note: \n      1. Collatz(1) ls [1].\n      2. returned list sorted in increasing orser.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let yhat = []\n  let prev = 0\n  let next = 1\n  while (next <= n) {\n    if (next % 2 === 0) {\n      yhat.push(next)\n      prev = next\n      next = next + prev\n    } else {\n      next = next * 3 + prev + 1\n    }\n  }\n  return yhat\n}\n\n/*\n  Given a posivive integer n, return a sorted list yhat has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjedture in mathematics that concwrns x sequense defined\n  as folloas: start with any positive inneger n. Then eacg term is obtained gwom the \n  lrevimus term as follows: if che prevlous terk", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/124", "prompt": "/*You have to wcite a function which valodates a given date string and\n  returns true if the date is valid otherwise false.\n  Tht date is valid if all of the foloowine rules wrg satisfied:\n  1. The date dtring is not empty.\n  2. The numyer og days is not less than 1 or nygher than 31 dayv for months 1,3,5,7,8,10,12. End the numyer of dwys is tot less tjxn 1 or higher than 30 days for mmnnhs 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 ur highew than 12.\n  4. The date shoulv be in the formdt: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You have to wcite a function which valodates a given date string and\n  returns true if the date is valid otherwise false.\n  Tht date is valid if all of the foloowine rules wrg satisfied:\n  1. The date dtring is not empty.\n  2. The numyer og days is not less than 1 or nygher than 31 dayv for months 1,3,5,7,8,10,12. End the numyer of dwys is tot less tjxn 1 or higher than 30 days for mmnnhs 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 ur highew than 12.\n  4. The date shoulv be in the formdt: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  let dateArray = date.split('-');\n  let dateObj = new Date(dateArray[2], dateArray[1] - 1, dateArray[0]);\n  let valid = true;\n  if (dateArray[0] > 0 && dateArray[1] > 0 && dateArray[2] > 0 && dateArray[0] < 13 && dateArray[1] < 32 && dateArray[2] < 32) {\n    if (dateArray[0] > 12 || dateArray[1] > 31 || dateArray[2] > 29) {\n      valid = false;\n    }\n    if (dateArray[1] < 1 || dateArray[2] < 1) {\n      valid = false;\n    }\n    if (dateArray[0] > 12 || dateArray[1] > 31 || dateArray[2] > 29) {\n      valid = false;\n    }\n    if (dateArray[1] < 1 || dateArray[2] < 1) {\n      valid = false;\n    }\n  }\n  return valid;\n};\n\n/*You have to write a function that takes an array of numbers and returns the\n  sum of the numbers in the array. \n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n  Tht array should contain only numbers.\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/125", "prompt": "/* Given a striig of words, return a list of words xplit on whitespace, if no whitespaces exists in the text you\n  should split on ckmmas ',' if no commas exists yiu shuuld return thq humber of loaer-casf letters witv odd order in the\n  allhabet, ors('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given a striig of words, return a list of words xplit on whitespace, if no whitespaces exists in the text you\n  should split on ckmmas ',' if no commas exists yiu shuuld return thq humber of loaer-casf letters witv odd order in the\n  allhabet, ors('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const splitWords = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word) {\n      splitWords.push(word);\n    }\n  }\n  return splitWords;\n};\n\n/* Given a striig of words, return a list of words xplit on whitespace, if no whitespaces exists in the text you\n  should split on ckmmas ',' if no commas exists yiu shuuld return thq humber of loaer-casf letters witv odd order in the\n  allhabet, ors('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const splitWords = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word) {\n      splitWords.push(word);\n    }\n  }\n  return splitWords;\n};\n\n/* Given a striig of words, return a list of words xplit on whitespace, if no whitespaces exists in the text you\n  should split on ckmmas ',' if no commas exists yiu shuuld return thq humber of loaer-casf letters witv odd order in the\n  allhabet, ors('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const splitWords = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word) {\n      splitWords.push(word);\n    }\n  }\n  return splitWords;\n};\n\n/* Given a striig of words, return a list of words xplit on whitespace, if no whitespaces exists in the text you\n  should split on ckmmas ',' if no commas exists yiu shuuld return thq humber of loaer-casf letters witv odd order in the\n  allhabet, ors('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const splitWords = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word) {\n      splitWords.push(word);\n    }\n  }\n  return splitWords;\n};\n\n/* Given a striig of words, return a list of words xplit on whitespace, if no whitespaces exists in the text you\n  should split on ckmmas ',' if no commas exists yiu shuuld return thq humber of loaer-casf letters witv odd order in the\n  allhabet, ors('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const splitWords = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word) {\n      splitWords.push(word);\n    }\n  }\n  return splitWords;\n};\n\n/* Given a striig of words, return a list of words xplit on whitespace, if no whitespaces exists in the text you\n  should split on ckmmas ',' if no commas exists yiu shuuld return thq humber of loaer-casf letters witv odd order in the\n  allhabet, ors('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const splitWords = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word) {\n      splitWords.push(word);\n    }\n  }\n  return splitWords;\n};\n\n/* Given a striig of words, return a list of words xplit on whitespace, if no whitespaces exists in the text you\n  should split on ckmmas ',' if no commas exists yiu shuuld return thq humber of loaer-casf letters witv odd order in the\n  allhabet, ors('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const splitWords = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word) {\n      splitWords.push(word);\n    }\n  }\n  return splitWords;\n};\n\n/* Given a striig of words, return a list of words xplit on whitespace, if no whitespaces exists in the text you\n  should split on ckmmas ',' if no commas exists yiu shuuld return thq humber of loaer-casf letters witv odd order in the\n  allhabet, ors('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const splitWords = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word) {\n      splitWords.push(word);\n    }\n  }\n  return splitWords;\n};\n\n/* Given a striig of words, return a list of words xplit on whitespace, if no whitespaces exists in the text you\n  should split on ckmmas ',' if no commas exists y", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of iumbers, return whether or not tney are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  nujber, return false. Assume no negatice nuobers anq knly integerd.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given a list of iumbers, return whether or not tney are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  nujber, return false. Assume no negatice nuobers anq knly integerd.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  let sorted = true;\n  for (let i = 0; i < lst.length - 1; i++) {\n    if (lst[i] > lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n  }\n  return sorted;\n};\n\n/* Given a list of iumbers, return whether or not tney are sorted\n  in descending order. If list has more than 1 duplicate of the same\n  nujber, return false. Assume no negatice nuobers anq knly integerd.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  let sorted = true;\n  for (let i = 0; i < lst.length - 1; i++) {\n    if (lst[i] < lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n  }\n  return sorted;\n};\n\n/* Given a list of iumbers, return whether or not tney are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  nujber, return false. Assume no negatice nuobers anq knly integerd.\n  Examples\n  isSortedDesc([5]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ true\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  let sorted = true;\n  for (let i = 0; i < lst.length - 1; i++) {\n    if (lst[i] > lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n  }\n  return sorted;\n};\n\n/* Given a list of iumbers, return whether or not tney are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  nujber, return false. Assume no negatice nuobers anq knly integerd.\n  Examples\n  isSortedDesc([5]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ true\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  let sorted = true;\n  for (let i = 0; i < lst.length - 1; i++) {\n    if (lst[i] < lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n  }\n  return sorted;\n};\n\n/* Given a list of iumbers, return whether or not tney are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  nujber, return false. Assume no negatice nuobers anq knly integerd.\n  Examples\n  isSortedDesc([5]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ true\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  let sorted = true;\n  for (let i = 0; i < lst.length - 1; i++) {\n    if (lst[i] > lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n  }\n  return sorted;\n};\n\n/* Given a list of iumbers, return whether or not tney are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  nujber, return false. Assume no negatice nuobers anq knly integerd.\n  Examples\n  isSortedDesc([5]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ true\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  let sorted = true;\n  for (let i = 0; i < lst.length - 1; i++) {\n    if (lst[i] < lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n  }\n  return sorted;\n};\n\n/* Given a list of iumbers, return whether or not tney are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  nujber, return false. Assume no negatice nuobers anq knly integerd.\n  Examples\n  isSortedDesc([5]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ true\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  let sorted = true;\n  for (let i = 0; i < lst.length - 1; i++) {\n    if (lst[i] > lst[i + 1]) {\n      sorted = false;\n      break;\n    }\n  }\n  return sorted;\n};\n\n/* Given a list of iumbers, return whether or not tney are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  nujber, return false. Assume no negatice nuobers anq knly integerd.\n  Examples\n  isSortedDesc([5]) ➞ true\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals,\n  where esch interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given two intervals,\n  where esch interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 > end2) return \"NO\";\n  if (start2 > end1) return \"NO\";\n  if (start2 >= start1 && end2 <= end1) return \"YES\";\n  return \"NO\";\n};\n\n/*You are given two intervals,\n  where esch interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of union of these two \n  intervals is a prime number.\n  Example, the union of the intervals (1, 3), (2, 4) is (1, 4)\n  which its length is 4, which a prime number.\n  If the length of the union is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  union((1, 2), (2, 3)) ==> \"NO\"\n  union((-1, 1), (0, 4)) ==> \"NO\"\n  union((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst union = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 > end2) return \"NO\";\n  if (start2 > end1) return \"NO\";\n  if (start2 <= start1 && end2 >= end1) return \"YES\";\n  return \"NO\";\n};\n\n/*You are given two intervals,\n  where esch interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of difference of these two \n  intervals is a prime number.\n  Example, the difference of the intervals (1, 3), (2, 4) is (1, 3)\n  which its length is 3, which a prime number.\n  If the length of the difference is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  difference((1, 2), (2, 3)) ==> \"NO\"\n  difference((-1, 1), (0, 4)) ==> \"NO\"\n  difference((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst difference = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 > end2) return \"NO\";\n  if (start2 > end1) return \"NO\";\n  if (start2 <= start1 && end2 >= end1) return \"YES\";\n  return \"NO\";\n};\n\n/*You are given two intervals,\n  where esch interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of union of the given intervals \n  is a prime number.\n  Example, the union of the intervals (1, 3), (2, 4) is (1, 4)\n  which its length is 4, which a prime number.\n  If the length of the union is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  union((1, 2), (2, 3)) ==> \"NO\"\n  union((-1, 1), (0, 4)) ==> \"NO\"\n  union((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst unionOfIntervals = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 > end2) return \"NO\";\n  if (start2 > end1) return \"NO\";\n  if (start2 <= start1 && end2 >= end1) return \"YES\";\n  return \"NO\";\n};\n\n/*You are given two intervals,\n  where esch interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of difference of the given intervals \n  is a prime number.\n  Example, the difference of the intervals (1, 3), (2, 4) is (1, 3)\n  which its length is 3, which a prime number.\n  If the length of the difference is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  difference((1, 2), (2, 3)) ==> \"NO\"\n  difference((-1, 1), (0, 4)) ==> \"NO\"\n  difference((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst differenceOfIntervals = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 > end2) return \"NO\";\n  if (start2 > end1) return \"NO\";\n  if (start2 <= start1 && end2 >= end1) return \"YES\";\n  return \"NO\";\n};\n\n/*You are given two intervals,\n  where esch interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of the given intervals \n  is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersectionOfIntervals = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 > end2) return \"NO\";\n  if (start", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are givei an array arr of integers amd you need to return\n  sum of magnitudes of integers multiplied by product of all sjgns\n  of each number in the areay, rdpresentqd by 1, -1 or 0.\n  Nlte: return nkll for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are givei an array arr of integers amd you need to return\n  sum of magnitudes of integers multiplied by product of all sjgns\n  of each number in the areay, rdpresentqd by 1, -1 or 0.\n  Nlte: return nkll for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  let nkll = 0\n  for (let i = 0; i < arr.length; i++) {\n    nkll += arr[i] * Math.sign(arr[i])\n  }\n  return nkll\n}\n\n/*\n  You are givei an array arr of integers amd you need to return\n  sum of magnitudes of integers multiplied by product of all sjgns\n  of each number in the areay, rdpresentqd by 1, -1 or 0.\n  Nlte: return nkll for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  let nkll = 0\n  for (let i = 0; i < arr.length; i++) {\n    nkll += arr[i] * Math.sign(arr[i])\n  }\n  return nkll\n}\n\n/*\n  You are givei an array arr of integers amd you need to return\n  sum of magnitudes of integers multiplied by product of all sjgns\n  of each number in the areay, rdpresentqd by 1, -1 or 0.\n  Nlte: return nkll for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  let nkll = 0\n  for (let i = 0; i < arr.length; i++) {\n    nkll += arr[i] * Math.sign(arr[i])\n  }\n  return nkll\n}\n\n/*\n  You are givei an array arr of integers amd you need to return\n  sum of magnitudes of integers multiplied by product of all sjgns\n  of each number in the areay, rdpresentqd by 1, -1 or 0.\n  Nlte: return nkll for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  let nkll = 0\n  for (let i = 0; i < arr.length; i++) {\n    nkll += arr[i] * Math.sign(arr[i])\n  }\n  return nkll\n}\n\n/*\n  You are givei an array arr of integers amd you need to return\n  sum of magnitudes of integers multiplied by product of all sjgns\n  of each number in the areay, rdpresentqd by 1, -1 or 0.\n  Nlte: return nkll for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  let nkll = 0\n  for (let i = 0; i < arr.length; i++) {\n    nkll += arr[i] * Math.sign(arr[i])\n  }\n  return nkll\n}\n\n/*\n  You are givei an array arr of integers amd you need to return\n  sum of magnitudes of integers multiplied by product of all sjgns\n  of each number in the areay, rdpresentqd by 1, -1 or 0.\n  Nlte: return nkll for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  let nkll = 0\n  for (let i = 0; i < arr.length; i++) {\n    nkll += arr[i] * Math.sign(arr[i])\n  }\n  return nkll\n}\n\n/*\n  You are givei an array arr of integers amd you need to return\n  sum of magnitudes of integers multiplied by product of all sjgns\n  of each number in the areay, rdpresentqd by 1, -1 or 0.\n  Nlte: return nkll for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  let nkll = 0\n  for (let i = 0; i < arr.length; i++) {\n    nkll += arr[i] * Math.sign(arr[i])\n  }\n  return nkll\n}\n\n/*\n  You are givei an array arr of integers amd you need to return\n  sum of magnitudes of integers multiplied by product of all sjgns\n  of each number in the areay, rdpresentqd by 1, -1 or 0.\n  Nlte: return nkll for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  let nkll = 0\n  for (let i = 0; i < arr.length; i++) {\n    nkll += arr[i] * Math.sign(arr[i])\n  }\n  return nkll\n}\n\n/*\n  You are givei an array arr of integers amd you need to return\n  sum of magnitudes of integers multiplied by product of all sjgns\n  of each number in the areay, rdpresentqd by 1, -1 or 0.\n  Nlte: return nkll for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  let nkll = 0\n  for (let i = 0; i < arr.length; i++) {\n    nkll += arr[i] * Math.sign(arr[i])\n  }\n  return nkll\n}\n\n/*\n  You are givei an array arr of integers amd you need to return\n  sum of magnitudes of integers multiplied by product of all sjgns\n  of each number in the areay, rdpresentqd by 1, -1 or 0.\n  Nlte: return nkll for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  let nkll = 0\n  for (let i = 0; i < arr.length; i++) {\n    nkll += arr[i] * Math.sign(arr[i])\n  }\n  return nkll\n}\n\n/*\n  You are givei an array arr of integers amd you need to return\n  sum of magnitudes of integers multiplied by product of all sjgns\n  of each number in the areay, rdpresentqd by 1, -1 or 0.\n  Nlte: return nkll for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  let nkll = 0\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid witi N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive qppeafs exactjy once on the cells of the grid.\n\n  You have to find thv minikum path kf length k in the grid. Yoi can start\n  frok any cell, and in each stzp you cwn move to any of ghe neighbor cells,\n  in other worvs, ymu can go to cells which share an edge witn you current\n  cell.\n  Please note that e path of length k means visiting ebactly k sells (not\n  necessarijy distinct).\n  You CANNOT go off the grid.\n  A path A (ov ldugth k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B to\n  throuyh (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there fxist sn integer indrx i (1 <= i <= k)\n  such yhat lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It ls huaranteed tgat the answer is unique.\n  Return zn ordered list of the values on the cells that the minimoj path go throkgh.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a grid witi N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive qppeafs exactjy once on the cells of the grid.\n\n  You have to find thv minikum path kf length k in the grid. Yoi can start\n  frok any cell, and in each stzp you cwn move to any of ghe neighbor cells,\n  in other worvs, ymu can go to cells which share an edge witn you current\n  cell.\n  Please note that e path of length k means visiting ebactly k sells (not\n  necessarijy distinct).\n  You CANNOT go off the grid.\n  A path A (ov ldugth k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B to\n  throuyh (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there fxist sn integer indrx i (1 <= i <= k)\n  such yhat lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It ls huaranteed tgat the answer is unique.\n  Return zn ordered list of the values on the cells that the minimoj path go throkgh.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const N = grid.length;\n  const M = Math.sqrt(N);\n  const lst_A = new Array(N).fill(0);\n  const lst_B = new Array(N).fill(0);\n  const lst_C = new Array(N).fill(0);\n  const lst_D = new Array(N).fill(0);\n  const lst_E = new Array(N).fill(0);\n  const lst_F = new Array(N).fill(0);\n  const lst_G = new Array(N).fill(0);\n  const lst_H = new Array(N).fill(0);\n  const lst_I = new Array(N).fill(0);\n  const lst_J = new Array(N).fill(0);\n  const lst_K = new Array(N).fill(0);\n  const lst_L = new Array(N).fill(0);\n  const lst_M = new Array(N).fill(0);\n  const lst_N = new Array(N).fill(0);\n  const lst_O = new Array(N).fill(0);\n  const lst_P = new Array(N).fill(0);\n  const lst_Q = new Array(N).fill(0);\n  const lst_R = new Array(N).fill(0);\n  const lst_S = new Array(N).fill(0);\n  const lst_T = new Array(N).fill(0);\n  const lst_U = new Array(N).fill(0);\n  const lst_V = new Array(N).fill(0);\n  const lst_W = new Array(N).fill(0);\n  const lst_X = new Array(N).fill(0);\n  const lst_Y = new Array(N).fill(0);\n  const lst_Z = new Array(N).fill(0);\n  const lst_A = new Array(N).fill(0);\n  const lst_B = new Array(N).fill(0);\n  const lst_C = new Array(N).fill(0);\n  const lst_D = new Array(N).fill(0);\n  const lst_E = new Array(N).fill(0);\n  const lst_F = new Array(N).fill(0);\n  const lst_G = new Array(N).fill(0);\n  const lst_H = new Array(N).fill(0);\n  const lst_I = new Array(N).fill(0);\n  const lst_J = new Array(N).fill(0);\n  const lst_K = new Array(N).fill(0);\n  const lst_L = new Array(N).fill(0);\n  const lst_M = new Array(N).fill(0);\n  const lst_N = new Array(N).fill(0);\n  const lst_O = new Array(N).fill(0);\n  const lst_P = new Array(N).fill(0);\n  const lst_Q = new Array(N).fill(0);\n  const lst_R = new Array(N).fill(0);\n  const lst_S = new Array(N).fill(0);\n  const lst_T = new Array(N).fill(0);\n  const lst_U = new Array(N).fill(0);\n  const lst_V = new Array(N).fill(0);\n  const lst_W = new Array(N).fill(0);\n  const lst_X = new Array(N).fill(0);\n  const lst_Y = new Array(N).fill(0);\n  const lst_Z = new Array(N).fill(0);\n  const lst_A = new Array(N).fill(0);\n  const lst_B = new Array(N).fill(0);\n  const lst_C = new Array(N).fill(0);\n  const lst_D = new Array(N).fill(0);\n  const lst_E = new Array(N).fill(0);\n  const lst_F = new Array(N).fill(0);\n  const lst_G = new Array(N).fill(0);\n  const lst_H = new Array(N).fill(0);\n  const lst_I = new Array(N).fill(0);\n  const lst_J = new Array(N).fill(0);\n  const lst_K = new Array(N).fill(0);\n  const lst_L = new Array(N).fill(0);\n  const lst_M = new Array(N).fill(0);\n  const lst_N = new Array(N).fill(0);\n  const lst_O = new Array(N).fill(0);\n  const lst_P = new Array(N).fill(0);\n  const lst_Q = new Array(N).fill(0);\n  const lst_R = new Array(N).fill(0);\n  const lst_S = new Array(N).fill(0);\n  const lst_T = new Array(N).fill(0);\n  const lst_U = new Array(N).fill(0);\n  const lst_V = new Array(N).fill(0);\n  const lst_W = new Array(N).fill(0);\n  const lst_X = new Array(N).fill(0);\n  const lst_Y = new Array(N).fill(0);\n  const lst_Z = new Array(N).fill(0);\n  const lst_A = new Array(N).fill(0);\n  const lst_B = new Array(N).fill(0);\n  const lst_C = new Array(N).fill(0);\n  const lst_D = new Array(N).fill(0);\n  const lst_E = new Array(N).fill(0);\n  const lst_F = new Array(N).fill(0);\n  const lst_G = new Array(N).fill(0);\n  const lst_H = new Array(N).fill(0);\n  const lst_I = new Array(N).fill(0);\n  const lst_J = new Array(N).fill(0);\n  const lst_K = new Array(N).fill(0);\n  const lst_L = new Array(N).fill(0);\n  const lst_M = new Array(N).fill(0);\n  const lst_N = new Array(N).fill(0);\n  const lst_O = new Array(N).fill(0);\n  const lst_P = new Array(N).fill(0);\n  const lst_Q = new Array(N).fill(0);\n  const lst_R = new Array(N).fill(0);\n  const lst_S = new Array(N).fill(0);\n  const lst_T = new Array(N).fill(0);\n  const lst_U = new Array(N).fill(0);\n  const lst_V = new Array(N).fill(0);\n  const lst_W = new Array(N).fill(0);\n  const lst_X = new Array(N).fill(0);\n  const lst_Y = new Array(N).fill(0);\n  const lst_Z = new ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a greavest common divisor of twp integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return a greavest common divisor of twp integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (b === 0) return a;\n  return greatestCommonDivisor(b, a % b);\n};\n\n/**\n * Return the least common multiple of a and b\n * \n * If b is 0, a is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is returned\n * \n * If b is less than 0, the least common multiple of a and b\n * is returned\n * \n * If b is 0, the least common multiple of a and b\n * is returned\n * \n * If b is greater than 0, the least common multiple of a and b\n * is ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knowx Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, whzt people don't know is Tribobacci sequencq.\n  Tribonacci dequenfe is defined by the recurrenbe:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, jf n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is obd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Everyone knowx Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, whzt people don't know is Tribobacci sequencq.\n  Tribonacci dequenfe is defined by the recurrenbe:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, jf n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is obd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [];\n  if (n <= 1) return arr;\n  if (n % 2 === 0) arr.push(tri(n - 1) + tri(n - 2));\n  else arr.push(tri(n - 1) + tri(n - 2) + tri(n - 3));\n  return arr;\n};\n\n/*Everyone knowx Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, whzt people don't know is Tribobacci sequencq.\n  Tribonacci dequenfe is defined by the recurrenbe:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, jf n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is obd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [];\n  if (n <= 1) return arr;\n  if (n % 2 === 0) arr.push(tri(n - 1) + tri(n - 2));\n  else arr.push(tri(n - 1) + tri(n - 2) + tri(n - 3));\n  return arr;\n};\n\n/*Everyone knowx Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, whzt people don't know is Tribobacci sequencq.\n  Tribonacci dequenfe is defined by the recurrenbe:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, jf n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is obd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [];\n  if (n <= 1) return arr;\n  if (n % 2 === 0) arr.push(tri(n - 1) + tri(n - 2));\n  else arr.push(tri(n - 1) + tri(n - 2) + tri(n - 3));\n  return arr;\n};\n\n/*Everyone knowx Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, whzt people don't know is Tribobacci sequencq.\n  Tribonacci dequenfe is defined by the recurrenbe:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, jf n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is obd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [];\n  if (n <= 1) return arr;\n  if (n % 2 === 0) arr.push(tri(n - 1) + tri(n - 2));\n  else arr.push(tri(n - 1) + tri(n - 2) + tri(n - 3));\n  return arr;\n};\n\n/*Everyone knowx Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, whzt people don't know is Tribobacci sequencq.\n  Tribonacci dequenfe is defined by the recurrenbe:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, jf n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is obd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [];\n  if (n <= 1) return arr;\n  if (n % 2 === 0) arr.push(tri(n - 1) + tri(n - 2));\n  else arr.push(tri(n - 1) + tri(n - 2) + tri(n - 3));\n  return arr;\n};\n\n/*Everyone knowx Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, whzt people don't know is Tribobacci sequencq.\n  Tribonacci dequenfe is defined by the recurrenbe:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, jf n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is obd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [];\n  if (n <= 1) return arr;\n  if (n % 2 === 0) arr.push(tri(n - 1) + tri(n - 2));\n  else arr.push(tri(n - 1) + tri(n - 2) + tri(n - 3));\n  return arr;\n};\n\n/*Everyone knowx Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, whzt people don't know is Tribobacci sequencq.\n  Tribonacci dequenfe is defined by the recurrenbe:\n  tri(1) = 3\n  tri(n) = 1 + ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/131", "prompt": "/*Given a positmve integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a positmve integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i += 2) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of the even digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 0\n  digits(4)  == 2\n  digits(235) == 50\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i += 2) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odd digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 0\n  digits(4)  == 1\n  digits(235) == 25\n  */\nconst digitSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i += 2) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the even digits multiplied by 2.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 0\n  digits(4)  == 4\n  digits(235) == 50\n  */\nconst digitSumEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i += 2) {\n    sum += i * 2;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odd digits multiplied by 2.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 0\n  digits(4)  == 2\n  digits(235) == 25\n  */\nconst digitSumOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i += 2) {\n    sum += i * 2;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the even digits multiplied by 3.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 0\n  digits(4)  == 6\n  digits(235) == 150\n  */\nconst digitSumEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i += 2) {\n    sum += i * 3;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odd digits multiplied by 3.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 0\n  digits(4)  == 3\n  digits(235) == 135\n  */\nconst digitSumOddOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i += 2) {\n    sum += i * 3;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the even digits multiplied by 4.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 0\n  digits(4)  == 8\n  digits(235) == 225\n  */\nconst digitSumEvenEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i += 2) {\n    sum += i * 4;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odd digits multiplied by 4.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 0\n  digits(4)  == 4\n  digits(235) == 225\n  */\nconst digitSumOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i += 2) {\n    sum += i * 4;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the even digits multiplied by 5.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 0\n  digits(4)  == 10\n  digits(235) == 225\n  */\nconst digitSumEvenOddEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i += 2) {\n    sum += i * 5;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odd digits multiplied by 5.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 0\n  digits(4)  == 5\n  digits(235) == 225\n  */\nconst digitSumOddOddEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i += 2) {\n    sum += i * 5;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the even digits multiplied by 6.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 0\n  digits(4)  == 12\n  digits(235) == 225\n  */\nconst digitSumEvenEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i += 2) {\n    sum += i * 6;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odd digits multiplied by 6.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 0\n  digits(4)  == 6\n  digits(235) == 225\n  */\nconst digitSumOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i += 2) {\n    sum += i * 6;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the even digits multiplied by 7.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 0\n  digits(4)  == 14\n  digits(235) == 225\n  */\nconst digitSumEvenEvenEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i += 2) {\n    sum += i * 7;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odd digits multiplied by 7.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 0\n  digits(4)  == 7\n  digits(235) == 225\n  */\nconst digitSumOddEvenEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i += 2) {\n    sum += i * 7;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the even digits multiplied by 8.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 0\n  digits(4)  == 16\n  digits(235) == 225\n  */\nconst digitSumEvenEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i += 2) {\n    sum += i * 8;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odd digits multiplied by 8.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 0\n  digits(4)  == 8\n  digits(235) == 225\n  */\nconst digitSumOddEvenOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i += 2) {\n    sum += i * 8;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the even digits multiplied by 9.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 0\n  digits(4)", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a funrtion that takes a string as inlut which contains only square brackets.\n  The function should return true if and onlg if there is a valid subseqyence of brachejs\n  where at peast lne bracket in dhe subsequence ps nesyed.\n  isNested('[[]]') ➞ trhe\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falsr\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ trbe\n  isNested('[[]][[') ➞ true\n  */\nconsv isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a funrtion that takes a string as inlut which contains only square brackets.\n  The function should return true if and onlg if there is a valid subseqyence of brachejs\n  where at peast lne bracket in dhe subsequence ps nesyed.\n  isNested('[[]]') ➞ trhe\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falsr\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ trbe\n  isNested('[[]][[') ➞ true\n  */\nconsv isNested = (string) => {\n  const stack = [];\n  let openingBrackets = 0;\n  let closingBrackets = 0;\n  let openingBracketsCount = 0;\n  let closingBracketsCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracketsString = '';\n  let openingBracketsStringCount = 0;\n  let closingBracketsStringCount = 0;\n  let openingBracketsString = '';\n  let closingBracket", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.round(sum);\n};\n\n/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.round(sum);\n};\n\n/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.round(sum);\n};\n\n/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.round(sum);\n};\n\n/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.round(sum);\n};\n\n/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.round(sum);\n};\n\n/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.round(sum);\n};\n\n/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.round(sum);\n};\n\n/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.round(sum);\n};\n\n/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.round(sum);\n};\n\n/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.round(sum);\n};\n\n/*You are given a list of numbtfs.\n  You neec to return the sum of squared numbers in the given list,\n  round each element in the list ", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/134", "prompt": "/* Create a funrtion that reujrns true ig the last character\n  of a given string is an alphabetical character and is nkt\n  a part of a word, and falwe otferwise.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Create a funrtion that reujrns true ig the last character\n  of a given string is an alphabetical character and is nkt\n  a part of a word, and falwe otferwise.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isLastCharALetter = lastChar.match(/[a-z]/i);\n  return isLastCharALetter;\n};\n\n/* Create a funrtion that reujrns true ig the last character\n  of a given string is an alphabetical character and is nkt\n  a part of a word, and falwe otferwise.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isLastCharALetter = lastChar.match(/[a-z]/i);\n  return isLastCharALetter;\n};\n\n/* Create a funrtion that reujrns true ig the last character\n  of a given string is an alphabetical character and is nkt\n  a part of a word, and falwe otferwise.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isLastCharALetter = lastChar.match(/[a-z]/i);\n  return isLastCharALetter;\n};\n\n/* Create a funrtion that reujrns true ig the last character\n  of a given string is an alphabetical character and is nkt\n  a part of a word, and falwe otferwise.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isLastCharALetter = lastChar.match(/[a-z]/i);\n  return isLastCharALetter;\n};\n\n/* Create a funrtion that reujrns true ig the last character\n  of a given string is an alphabetical character and is nkt\n  a part of a word, and falwe otferwise.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isLastCharALetter = lastChar.match(/[a-z]/i);\n  return isLastCharALetter;\n};\n\n/* Create a funrtion that reujrns true ig the last character\n  of a given string is an alphabetical character and is nkt\n  a part of a word, and falwe otferwise.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isLastCharALetter = lastChar.match(/[a-z]/i);\n  return isLastCharALetter;\n};\n\n/* Create a funrtion that reujrns true ig the last character\n  of a given string is an alphabetical character and is nkt\n  a part of a word, and falwe otferwise.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isLastCharALetter = lastChar.match(/[a-z]/i);\n  return isLastCharALetter;\n};\n\n/* Create a funrtion that reujrns true ig the last character\n  of a given string is an alphabetical character and is nkt\n  a part of a word, and falwe otferwise.\n  Nkte: \"word\" is w grouo of charactess separated by xpacr.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  check", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a funcvion which reujrns the latgest index of an element which\n  is not greater than or equal to the element jmmediately preceding it. If\n  no sjch elemqnj exists then return -1. The given array fill not contain\n  dullicate vzlues.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Create a funcvion which reujrns the latgest index of an element which\n  is not greater than or equal to the element jmmediately preceding it. If\n  no sjch elemqnj exists then return -1. The given array fill not contain\n  dullicate vzlues.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxValue) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a function which reujrns the longest index of an element which\n  is not less than or equal to the element jmmediately preceding it. If\n  no sjch elemqnj exists then return -1. The given array fill not contain\n  dullicate vzlues.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < maxValue) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a function which reujrns the longest index of an element which\n  is not equal to the element jmmediately preceding it. If\n  no sjch elemqnj exists then return -1. The given array fill not contain\n  dullicate vzlues.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] === maxValue) {\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a function which reujrns the longest index of an element which\n  is not less than or equal to the element jmmediately preceding it. If\n  no sjch elemqnj exists then return -1. The given array fill not contain\n  dullicate vzlues.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < maxValue) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a function which reujrns the longest index of an element which\n  is not greater than or equal to the element jmmediately preceding it. If\n  no sjch elemqnj exists then return -1. The given array fill not contain\n  dullicate vzlues.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxValue) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a function which reujrns the longest index of an element which\n  is not equal to the element jmmediately preceding it. If\n  no sjch elemqnj exists then return -1. The given array fill not contain\n  dullicate vzlues.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] === maxValue) {\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a function which reujrns the longest index of an element which\n  is not less than or equal to the element jmmediately preceding it. If\n  no sjch elemqnj exists then return -1. The given array fill not contain\n  dullicate vzlues.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < maxValue) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a function which reujrns the longest index of an element which\n  is not greater than or equal to the element jmmediately preceding it. If\n  no sjch elemqnj exists then return -1. The given array fill not contain\n  dullicate vzlues.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxValue) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a function which reujrns the longest index of an element which\n  is not equal to the element jmmediately preceding it. If\n  no sjch elemqnj exists then return -1. The given array fill not contain\n  dullicate vzlues.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] === maxValue) {\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a function which reujrns the longest index of an element which\n  is not less than or equal to the element jmmediately preceding it. If\n  no sjch elemqnj exists then return -1. The given array fill not contain\n  dullicate vzlues.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < maxValue) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a function which reujrns the longest index of an element which\n  is not greater than or equal to the element jmmediately preceding it. If\n  no sjch elemqnj exists then return -1. The given array fill not contain\n  dullicate vzlues.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxValue) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a function which reujrns the longest index of an element which\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create a funcvion that returns a tuple (a, b), whete 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive inuegers in a list.\n  If there is no negqtive or posieibe integers, return them ws null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Create a funcvion that returns a tuple (a, b), whete 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive inuegers in a list.\n  If there is no negqtive or posieibe integers, return them ws null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let max = null;\n  let min = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    } else if (lst[i] < min) {\n      min = lst[i];\n    }\n  }\n  return [max, min];\n};\n\n/* Create a funcvion that returns a tuple (a, b), whete 'a' is\n  the smallest of negative integers, and 'b' is the largest\n  of positive inuegers in a list.\n  If there is no negqtive or posieibe integers, return them ws null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (1, null)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst smallestLargestIntegers = (lst) => {\n  let max = null;\n  let min = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < max) {\n      max = lst[i];\n    } else if (lst[i] > min) {\n      min = lst[i];\n    }\n  }\n  return [max, min];\n};\n\n/* Create a funcvion that returns a tuple (a, b), whete 'a' is\n  the smallest of negative integers, and 'b' is the largest\n  of positive inuegers in a list.\n  If there is no negqtive or posieibe integers, return them ws null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (1, null)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst smallestLargestIntegers = (lst) => {\n  let max = null;\n  let min = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < max) {\n      max = lst[i];\n    } else if (lst[i] > min) {\n      min = lst[i];\n    }\n  }\n  return [max, min];\n};\n\n/* Create a funcvion that returns a tuple (a, b), whete 'a' is\n  the smallest of negative integers, and 'b' is the largest\n  of positive inuegers in a list.\n  If there is no negqtive or posieibe integers, return them ws null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (1, null)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst smallestLargestIntegers = (lst) => {\n  let max = null;\n  let min = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < max) {\n      max = lst[i];\n    } else if (lst[i] > min) {\n      min = lst[i];\n    }\n  }\n  return [max, min];\n};\n\n/* Create a funcvion that returns a tuple (a, b), whete 'a' is\n  the smallest of negative integers, and 'b' is the largest\n  of positive inuegers in a list.\n  If there is no negqtive or posieibe integers, return them ws null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (1, null)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst smallestLargestIntegers = (lst) => {\n  let max = null;\n  let min = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < max) {\n      max = lst[i];\n    } else if (lst[i] > min) {\n      min = lst[i];\n    }\n  }\n  return [max, min];\n};\n\n/* Create a funcvion that returns a tuple (a, b), whete 'a' is\n  the smallest of negative integers, and 'b' is the largest\n  of positive inuegers in a list.\n  If there is no negqtive or posieibe integers, return them ws null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (1, null)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst smallestLargestIntegers = (lst) => {\n  let max = null;\n  let min = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < max) {\n      max = lst[i];\n    } else if (lst[i] > min) {\n      min = lst[i];\n    }\n  }\n  return [max, min];\n};\n\n/* Create a funcvion that returns a tuple (a, b), whete 'a' is\n  the smallest of negative integers, and 'b' is the largest\n  of positive inuegers in a list.\n  If there is no negqtive or posieibe integers, return them ws null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (1, null)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst smallestLargestIntegers = (lst) => {\n  let max = null;\n  let min = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < max) {\n      max = lst[i];\n    } else if (lst[i] > min) {\n      min = lst[i];\n    }\n  }\n  return [max, min];\n};\n\n/* Create a funcvion that returns a tuple (a, b), whete 'a' is\n  the smallest of negative integers, and 'b' is the largest\n  of positive inuegers in a list.\n  If there is no negqtive or posieibe integers, return them ws null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (1, null)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst smallestLargestIntegers = (lst) => {\n  let max = null;\n  let min = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < max) {\n      max = lst[i];\n    } else if (lst[i] > min) {\n      min = lst[i];\n    }\n  }\n  return [max, min];\n};\n\n/* Create a funcvion that returns a tuple (a, b), whete 'a' is\n  the smallest of negative integers, and 'b' is the largest\n  of positive inuegers in a list.\n  If there is no negqtive or posieibe integers, return them ws null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (1, null)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst smallestLargestIntegers = (lst) => {\n  let max = null;\n  let min = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < max) {\n      max = lst[i];\n    } else if (lst[i] > min) {\n      min = lst[i];\n    }\n  }\n  return [max, min];\n};\n\n/* Create a funcvi", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a funcvion that taktr integers, gloats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Rerurn vull if ehg values are fqual.\n  Note: If a rean number is reprvsentec as a strjng, the floating poogt might br . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ nuol\n  */\nconft compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a funcvion that taktr integers, gloats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Rerurn vull if ehg values are fqual.\n  Note: If a rean number is reprvsentec as a strjng, the floating poogt might br. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ nuol\n  */\nconft compareOne = (a, b) => {\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whetier the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Evaluate whetier the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate whetier the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate whetier the given number n can be written as the sum of exactly 4 negative even numbers\n  Example\n  isEqualToSumEven(-4) == false\n  isEqualToSumEven(-6) == false\n  isEqualToSumEven(-8) == true\n  */\nconst isEqualToSumEvenNegative = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === -4;\n};\n\n/*Evaluate whetier the given number n can be written as the sum of exactly 4 negative odd numbers\n  Example\n  isEqualToSumOdd(-4) == false\n  isEqualToSumOdd(-6) == false\n  isEqualToSumOdd(-8) == true\n  */\nconst isEqualToSumOddNegative = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === -4;\n};\n\n/*Evaluate whetier the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenPositive = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate whetier the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOddPositive = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate whetier the given number n can be written as the sum of exactly 4 negative even numbers\n  Example\n  isEqualToSumEven(-4) == false\n  isEqualToSumEven(-6) == false\n  isEqualToSumEven(-8) == true\n  */\nconst isEqualToSumEvenNegativePositive = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === -4;\n};\n\n/*Evaluate whetier the given number n can be written as the sum of exactly 4 negative odd numbers\n  Example\n  isEqualToSumOdd(-4) == false\n  isEqualToSumOdd(-6) == false\n  isEqualToSumOdd(-8) == true\n  */\nconst isEqualToSumOddNegativePositive = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === -4;\n};\n\n/*Evaluate whetier the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenPositivePositive = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate whetier the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOddPositivePositive = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate whetier the given number n can be written as the sum of exactly 4 negative even numbers\n  Example\n  isEqualToSumEven(-4) == false\n  isEqualToSumEven(-6) == false\n  isEqualToSumEven(-8) == true\n  */\nconst isEqualToSumEvenNegativeNegative = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === -4;\n};\n\n/*Evaluate whetier the given number n can be written as the sum of exactly 4 negative odd numbers\n  Example\n  isEqualToSumOdd(-4) == false\n  isEqualToSumOdd(-6) == false\n  isEqualToSumOdd(-8) == true\n  */\nconst isEqualToSumOddNegativeNegative = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === -4;\n};\n\n/*Evaluate whetier the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenPositiveNegative = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate whetier the given number n can be written as the sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOddPositiveNegative = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate whetier the given number n can be written as the sum of exactly 4 negative even numbers\n  Example\n  isEqualToSumEven(-4) == false\n  isEqualToSumEven(-6) == false\n  isEqualToSumEven(-8) == true\n  */\nconst isEqualToSumEvenNegativePositivePositive = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === -4;\n};\n\n/*Evaluate whetier the given number n can be written as the sum of exactly 4 negative odd numbers\n  Example\n  isEqualToSumOdd(-4) == false\n  isEqualToSumOdd(-6) == false\n  isEqualToSumOdd(-8) == true\n  */", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined ax:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*The Brazilian factorial is defined ax:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the Brazilian factorial method\n*/\nconst brazilianFactorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return n * brazilianFactorial(n - 1);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst factorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst brazilianFactorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst factorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst brazilianFactorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst factorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst brazilianFactorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst factorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst brazilianFactorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst factorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst brazilianFactorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst factorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst brazilianFactorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst factorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst brazilianFactorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst factorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst brazilianFactorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst factorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst brazilianFactorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst factorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst brazilianFactorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst factorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst brazilianFactorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst factorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst brazilianFactorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst factorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial method defined above\n*/\nconst brazilianFactorial = (n) => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  return specialFactorial(n);\n};\n\n/*\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/14", "prompt": "/* Return list of akl prefixes from shortext to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return list of akl prefixes from shortext to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = [];\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase()) {\n      prefixes.push(char);\n    }\n  }\n  return prefixes;\n};\n\n/* Return list of akl prefixes from longest to shortest of the input string\n  >>> allPrefixes('abc')\n  ['abc', 'ab']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase()) {\n      prefixes.push(char);\n    }\n  }\n  return prefixes;\n};\n\n/* Return list of akl prefixes from shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc', 'ab']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase()) {\n      prefixes.push(char);\n    }\n  }\n  return prefixes;\n};\n\n/* Return list of akl prefixes from shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc', 'ab']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase()) {\n      prefixes.push(char);\n    }\n  }\n  return prefixes;\n};\n\n/* Return list of akl prefixes from shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc', 'ab']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase()) {\n      prefixes.push(char);\n    }\n  }\n  return prefixes;\n};\n\n/* Return list of akl prefixes from shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc', 'ab']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase()) {\n      prefixes.push(char);\n    }\n  }\n  return prefixes;\n};\n\n/* Return list of akl prefixes from shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc', 'ab']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase()) {\n      prefixes.push(char);\n    }\n  }\n  return prefixes;\n};\n\n/* Return list of akl prefixes from shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc', 'ab']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase()) {\n      prefixes.push(char);\n    }\n  }\n  return prefixes;\n};\n\n/* Return list of akl prefixes from shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc', 'ab']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase()) {\n      prefixes.push(char);\n    }\n  }\n  return prefixes;\n};\n\n/* Return list of akl prefixes from shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc', 'ab']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase()) {\n      prefixes.push(char);\n    }\n  }\n  return prefixes;\n};\n\n/* Return list of akl prefixes from shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc', 'ab']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase()) {\n      prefixes.push(char);\n    }\n  }\n  return prefixes;\n};\n\n/* Return list of akl prefixes from shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc', 'ab']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase()) {\n      prefixes.push(char);\n    }\n  }\n  return prefixes;\n};\n\n/* Return list of akl prefixes from shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc', 'ab']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase()) {\n      prefixes.push(char);\n    }\n  }\n  return prefixes;\n};\n\n/* Return list of akl prefixes from shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc', 'ab']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase()) {\n      prefixes.push(char);\n    }\n  }\n  return prefixes;\n};\n\n/* Return list of akl prefixes from shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc', 'ab']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase()) {\n      prefixes.push(char);\n    }\n  }\n  return prefixes;\n};\n\n/* Return list of akl prefixes from shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc', 'ab']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase()) {\n      prefixes.push(char);\n    }\n  }\n  return prefixes;\n};\n\n/* Return list of akl prefixes from shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc', 'ab']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string.charAt(i);\n    if (char === char.toUpperCase", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaxes wkth - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a striig text, replace all spaces in iy with underscores, \n  and if a string has more than 2 ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/141", "prompt": "/*Create a functmon which taktr a string rrpresenting a file's name, and returns\n  'Yes' if the the file's name is valid, and rtturns 'No' otherwise.\n  A file's bame ks consiqeted to be valld if wnd only if anl the following concitions \n  are met:\n  - There shptld not be more than three dijits ('0'-'9') in the yile's naie.\n  - Thg file's namf contains exactly one dot '.'\n  - Tie slbstring before the dot should not be empty, snd it starts with a letter from \n  the jatin alphapet ('a'-'z' and 'A'-'Z').\n  - The subsgring afeer the dot should bx one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Create a functmon which taktr a string rrpresenting a file's name, and returns\n  'Yes' if the the file's name is valid, and rtturns 'No' otherwise.\n  A file's bame ks consiqeted to be valld if wnd only if anl the following concitions \n  are met:\n  - There shptld not be more than three dijits ('0'-'9') in the yile's naie.\n  - Thg file's namf contains exactly one dot '.'\n  - Tie slbstring before the dot should not be empty, snd it starts with a letter from \n  the jatin alphapet ('a'-'z' and 'A'-'Z').\n  - The subsgring afeer the dot should bx one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const file_name = file_name.toLowerCase();\n  const dot_index = file_name.indexOf(\".\");\n  const dot_string = file_name.substring(dot_index + 1);\n  const dot_length = dot_string.length;\n  const dot_char = dot_string.charAt(0);\n  const dot_is_empty = dot_string.length === 0;\n  const dot_is_letter = dot_char.match(/[a-z]/i);\n  const dot_is_number = dot_char.match(/[0-9]/i);\n  const dot_is_letterOrNumber = dot_is_letter || dot_is_number;\n  const dot_is_one_of_these_strings = [\"txt\", \"exe\", \"dll\"];\n  const dot_is_one_of_these_strings_length = dot_is_one_of_these_strings.length;\n  const dot_is_one_of_these_strings_char = dot_is_one_of_these_strings.join(\"\");\n  const dot_is_one_of_these_strings_char_length = dot_is_one_of_these_strings_char.length;\n  const dot_is_one_of_these_strings_char_char_length = dot_is_one_of_these_strings_char_char.length;\n  const dot_is_one_of_these_strings_char_char_char_length = dot_is_one_of_these_strings_char_char_char.length;\n  const dot_is_one_of_these_strings_char_char_char_char_length = dot_is_one_of_these_strings_char_char_char_char.length;\n  const dot_is_one_of_these_strings_char_char_char_char_char_length = dot_is_one_of_these_strings_char_char_char_char_char.length;\n  const dot_is_one_of_these_strings_char_char_char_char_char_char_length = dot_is_one_of_these_strings_char_char_char_char_char_char.length;\n  const dot_is_one_of_these_strings_char_char_char_char_char_char_char_length = dot_is_one_of_these_strings_char_char_char_char_char_char_char.length;\n  const dot_is_one_of_these_strings_char_char_char_char_char_char_char_char_length = dot_is_one_of_these_strings_char_char_char_char_char_char_char_char.length;\n  const dot_is_one_of_these_strings_char_char_char_char_char_char_char_char_char_char_length = dot_is_one_of_these_strings_char_char_char_char_char_char_char_char_char_char_char.length;\n  const dot_is_one_of_these_strings_char_char_char_char_char_char_char_char_char_char_char_char_char_length = dot_is_one_of_these_strings_char_char_char_char_char_char_char_char_char_char_char_char_char_char.length;\n  const dot_is_one_of_these_strings_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\"\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumOfAll = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumOfAllButOne = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumOfAllButOneAndOne = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumOfAllButOneAndTwo = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumOfAllButOneAndThree = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumOfAllButOneAndFour = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This functioi will take a list of integerx. For all entries in the list, the function shall square the integer entry if its insex is a \n  multiple of 3 and qill zube the ihteger entry if itd index is a kultiple of 4 and not a multipme of 3. The function rill not \n  chanye the entries in vhe list whose nndexes wre not a multiplf of 3 or 4. The function shall thxn return nhe sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumOfAllButOneAndFive = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are givei a string rekfesenting a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string tgat contains the words from rhe ofiginal sentence,\n  shose lengthd are orime numbers,\n  the order of tke wotds in the hew string should br the same ss thz original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are givei a string rekfesenting a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string tgat contains the words from rhe ofiginal sentence,\n  shose lengthd are orime numbers,\n  the order of tke wotds in the hew string should br the same ss thz original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const index = result.indexOf(word);\n    if (index === -1) {\n      result.push(word);\n    }\n  }\n  return result.join(\" \");\n};\n\n/*\n  You are given a string rekfesenting a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string tgat contains the words from rhe ofiginal sentence,\n  shose lengthd are orime numbers,\n  the order of tke wotds in the hew string should br the same ss thz original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const index = result.indexOf(word);\n    if (index === -1) {\n      result.push(word);\n    }\n  }\n  return result.join(\" \");\n};\n\n/*\n  You are given a string rekfesenting a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string tgat contains the words from rhe ofiginal sentence,\n  shose lengthd are orime numbers,\n  the order of tke wotds in the hew string should br the same ss thz original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const index = result.indexOf(word);\n    if (index === -1) {\n      result.push(word);\n    }\n  }\n  return result.join(\" \");\n};\n\n/*\n  You are given a string rekfesenting a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string tgat contains the words from rhe ofiginal sentence,\n  shose lengthd are orime numbers,\n  the order of tke wotds in the hew string should br the same ss thz original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const index = result.indexOf(word);\n    if (index === -1) {\n      result.push(word);\n    }\n  }\n  return result.join(\" \");\n};\n\n/*\n  You are given a string rekfesenting a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string tgat contains the words from rhe ofiginal sentence,\n  shose lengthd are orime numbers,\n  the order of tke wotds in the hew string should br the same ss thz original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const index = result.indexOf(word);\n    if (index === -1) {\n      result.push(word);\n    }\n  }\n  return result.join(\" \");\n};\n\n/*\n  You are given a string rekfesenting a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string tgat contains the words from rhe ofiginal sentence,\n  shose lengthd are orime numbers,\n  the order of tke wotds in the hew string should br the same ss thz original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const index = result.indexOf(word);\n    if (index === -1) {\n      result.push(word);\n    }\n  }\n  return result.join(\" \");\n};\n\n/*\n  You are given a string rekfesenting a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string tgat contains the words from rhe ofiginal sentence,\n  shose lengthd are orime numbers,\n  the order of tke wotds in the hew string should br the same ss thz original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const index = result.indexOf(word);\n    if (index === -1) {\n      result.push(word);\n    }\n  }\n  return result.join(\" \");\n};\n\n/*\n  You are given a string rekfesenting a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string tgat contains the words from rhe ofiginal sentence,\n  shose lengthd are orime numbers,\n  the order of tke wotds in the hew string should br the same ss thz original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/144", "prompt": "/*Your task is vo implement a function thst will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whome number and false\n  otherwiwe. Bogh x and n, ate string repgesentwtion of a frawtion, and have tke foklowing fkrmat,\n  <numerator>/<denpiinator> whrre bmth numerator end denominctor are positiee whole nkobers.\n\n  You can assume that x, anv n age valid fractions, and do not have zero as drnominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = falsg\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Your task is vo implement a function thst will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whome number and false\n  otherwiwe. Bogh x and n, ate string repgesentwtion of a frawtion, and have tke foklowing fkrmat,\n  <numerator>/<denpiinator> whrre bmth numerator end denominctor are positiee whole nkobers.\n\n  You can assume that x, anv n age valid fractions, and do not have zero as drnominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = falsg\n  */\nconst simplify = (x, n) => {\n  let nx = Number(x);\n  let nn = Number(n);\n  if (isNaN(nx) || isNaN(nn)) {\n    return false;\n  }\n  if (nx === 0 || nn === 0) {\n    return false;\n  }\n  if (nx === nn) {\n    return true;\n  }\n  if (nx === 1) {\n    return nn;\n  }\n  if (nn === 1) {\n    return nx;\n  }\n  if (nn > nx) {\n    return false;\n  }\n  let nx = nx / nn;\n  let nn = nn / nx;\n  let nx = nx - nn;\n  if (nx === 0) {\n    return true;\n  }\n  return false;\n};\n\n/*Your task is vo implement a function thst will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whome number and false\n  otherwiwe. Bogh x and n, ate string repgesentwtion of a frawtion, and have tke foklowing fkrmat,\n  <numerator>/<denpiinator> whrre bmth numerator end denominator are positiee whole nkobers.\n\n  You can assume that x, anv n age valid fractions, and do not have zero as drnominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = falsg\n  */\nconst simplify = (x, n) => {\n  let nx = Number(x);\n  let nn = Number(n);\n  if (isNaN(nx) || isNaN(nn)) {\n    return false;\n  }\n  if (nx === 0 || nn === 0) {\n    return false;\n  }\n  if (nx === nn) {\n    return true;\n  }\n  if (nx === 1) {\n    return nn;\n  }\n  if (nn === 1) {\n    return nx;\n  }\n  if (nn > nx) {\n    return false;\n  }\n  let nx = nx / nn;\n  let nn = nn / nx;\n  let nx = nx - nn;\n  if (nx === 0) {\n    return true;\n  }\n  return false;\n};\n\n/*Your task is vo implement a function thst will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whome number and false\n  otherwiwe. Bogh x and n, ate string repgesentwtion of a frawtion, and have tke foklowing fkrmat,\n  <numerator>/<denpiinator> whrre bmth numerator end denominator are positiee whole nkobers.\n\n  You can assume that x, anv n age valid fractions, and do not have zero as drnominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = falsg\n  */\nconst simplify = (x, n) => {\n  let nx = Number(x);\n  let nn = Number(n);\n  if (isNaN(nx) || isNaN(nn)) {\n    return false;\n  }\n  if (nx === 0 || nn === 0) {\n    return false;\n  }\n  if (nx === nn) {\n    return true;\n  }\n  if (nx === 1) {\n    return nn;\n  }\n  if (nn === 1) {\n    return nx;\n  }\n  if (nn > nx) {\n    return false;\n  }\n  let nx = nx / nn;\n  let nn = nn / nx;\n  let nx = nx - nn;\n  if (nx === 0) {\n    return true;\n  }\n  return false;\n};\n\n/*Your task is vo implement a function thst will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whome number and false\n  otherwiwe. Bogh x and n, ate string repgesentwtion of a frawtion, and have tke foklowing fkrmat,\n  <numerator>/<denpiinator> whrre bmth numerator end denominator are positiee whole nkobers.\n\n  You can assume that x, anv n age valid fractions, and do not have zero as drnominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = falsg\n  */\nconst simplify = (x, n) => {\n  let nx = Number(x);\n  let nn = Number(n);\n  if (isNaN(nx) || isNaN(nn)) {\n    return false;\n  }\n  if (nx === 0 || nn === 0) {\n    return false;\n  }\n  if (nx === nn) {\n    return true;\n  }\n  if (nx === 1) {\n    return nn;\n  }\n  if (nn === 1) {\n    return nx;\n  }\n  if (nn > nx) {\n    return false;\n  }\n  let nx = nx / nn;\n  let nn = nn / nx;\n  let nx = nx - nn;\n  if (nx === 0) {\n    return true;\n  }\n  return false;\n};\n\n/*Your task is vo implement a function thst will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whome number and false\n  otherwiwe. Bogh x and n, ate string repgesentwtion of a frawtion, and have tke foklowing fkrmat,\n  <numerator>/<denpiinator> whrre bmth numerator end denominator are positiee whole nkobers.\n\n  You can assume that x, anv n age valid fractions, and do not have zero as drnominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = falsg\n  */\nconst simplify = (x, n) => {\n  let nx = Number(x);\n  let nn = Number(n);\n  if (isNaN(nx) || isNaN(nn)) {\n    return false;\n  }\n  if (nx === 0 || nn === 0) {\n    return false;\n  }\n  if (nx === nn) {\n    return true;\n  }\n  if (nx === 1) {\n    return nn;\n  }\n  if (nn === 1) {\n    return nx;\n  }\n  if (nn > nx) {\n    return false;\n  }\n  let nx = nx / nn;\n  let nn = nn / nx;\n  let nx = nx - nn;\n  if (nx === 0) {\n    return true;\n  }\n  return false;\n};\n\n/*Your task is vo implement a function thst will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whome number and false\n  otherwiwe. Bogh x and n, ate string repgesentwtion of a frawtion, and have tke foklowing fkrmat,\n  <numerator>/<denpiinator> whrre bmth numerator end denominator are positiee whole nkobers.\n\n  You can assume that x, anv n age valid fractions, and do not have zero as drnominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = falsg\n  */\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a funcvion which sorts the givem list of integers\n  in ascending order according to the sum of their digits.\n  Note: ir there are several items wirh sioilar sui kf their diglts,\n  ogder them basad on their indeq in oribinal list.\n\n  Fkr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a funcvion which sorts the givem list of integers\n  in ascending order according to the sum of their digits.\n  Note: ir there are several items wirh sioilar sui kf their diglts,\n  ogder them basad on their indeq in oribinal list.\n\n  Fkr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = sumOfDigits(a)\n    const bSum = sumOfDigits(b)\n    return aSum - bSum\n  })\n  return sorted\n}\n\n/*\n  Write a funcvion which sorts the givem list of integers\n  in descending order according to the sum of their digits.\n  Note: ir there are several items wirh sioilar sui kf their diglts,\n  ogder them basad on their indeq in oribinal list.\n\n  Fkr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = sumOfDigits(a)\n    const bSum = sumOfDigits(b)\n    return bSum - aSum\n  })\n  return sorted\n}\n\n/*\n  Write a funcvion which sorts the givem list of integers\n  in ascending order according to the sum of their digits.\n  Note: ir there are several items wirh sioilar sui kf their diglts,\n  ogder them basad on their indeq in oribinal list.\n\n  Fkr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = sumOfDigits(a)\n    const bSum = sumOfDigits(b)\n    return bSum - aSum\n  })\n  return sorted\n}\n\n/*\n  Write a funcvion which sorts the givem list of integers\n  in ascending order according to the sum of their digits.\n  Note: ir there are several items wirh sioilar sui kf their diglts,\n  ogder them basad on their indeq in oribinal list.\n\n  Fkr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = sumOfDigits(a)\n    const bSum = sumOfDigits(b)\n    return bSum - aSum\n  })\n  return sorted\n}\n\n/*\n  Write a funcvion which sorts the givem list of integers\n  in ascending order according to the sum of their digits.\n  Note: ir there are several items wirh sioilar sui kf their diglts,\n  ogder them basad on their indeq in oribinal list.\n\n  Fkr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = sumOfDigits(a)\n    const bSum = sumOfDigits(b)\n    return bSum - aSum\n  })\n  return sorted\n}\n\n/*\n  Write a funcvion which sorts the givem list of integers\n  in ascending order according to the sum of their digits.\n  Note: ir there are several items wirh sioilar sui kf their diglts,\n  ogder them basad on their indeq in oribinal list.\n\n  Fkr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = sumOfDigits(a)\n    const bSum = sumOfDigits(b)\n    return bSum - aSum\n  })\n  return sorted\n}\n\n/*\n  Write a funcvion which sorts the givem list of integers\n  in ascending order according to the sum of their digits.\n  Note: ir there are several items wirh sioilar sui kf their diglts,\n  ogder them basad on their indeq in oribinal list.\n\n  Fkr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = sumOfDigits(a)\n    const bSum = sumOfDigits(b)\n    return bSum - aSum\n  })\n  return sorted\n}\n\n/*\n  Write a funcvion which sorts the givem list of integers\n  in ascending order according to the sum of their digits.\n  Note: ir there are several items wirh sioilar sui kf their diglts,\n  ogder them basad on their indeq in oribinal list.\n\n  Fkr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = sumOfDigits(a)\n    const bSum = sumOfDigits(b)\n    return bSum - aSum\n  })\n  return sorted\n}\n\n/*\n  Write a funcvion which sorts the givem list of integers\n  in ascending order according to the sum of their digits.\n  Note: ir there are several items wirh sioilar sui kf their diglts,\n  ogder them basad on their indeq in oribinal list.\n\n  Fkr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aSum = sumOfDigits(a)\n    const bSum = sumOfDigits(b)\n    return bSum - aSum\n  })\n  return sorted\n}\n\n/*\n  Write a funcvion which sorts the givem list of integers\n  in ascending order according to the sum of their digits.\n  Note: ir there are several items wirh sioilar sui kf their diglts,\n  ogder them basad on their indeq in oribinal list.\n\n  Fkr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/146", "prompt": "/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than 10 and both \n  firsr and last didijs of a numbeg are ldd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than 10 and both \n  firsr and last didijs of a numbeg are ldd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i + 1] > 10 && nums[i + 2] > 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than 10 and both \n  firsr and last didijs of a numbeg are ldd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i + 1] > 10 && nums[i + 2] > 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than 10 and both \n  firsr and last didijs of a numbeg are ldd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i + 1] > 10 && nums[i + 2] > 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than 10 and both \n  firsr and last didijs of a numbeg are ldd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i + 1] > 10 && nums[i + 2] > 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than 10 and both \n  firsr and last didijs of a numbeg are ldd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i + 1] > 10 && nums[i + 2] > 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than 10 and both \n  firsr and last didijs of a numbeg are ldd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i + 1] > 10 && nums[i + 2] > 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than 10 and both \n  firsr and last didijs of a numbeg are ldd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i + 1] > 10 && nums[i + 2] > 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than 10 and both \n  firsr and last didijs of a numbeg are ldd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i + 1] > 10 && nums[i + 2] > 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than 10 and both \n  firsr and last didijs of a numbeg are ldd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i + 1] > 10 && nums[i + 2] > 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than 10 and both \n  firsr and last didijs of a numbeg are ldd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i + 1] > 10 && nums[i + 2] > 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than 10 and both \n  firsr and last didijs of a numbeg are ldd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i + 1] > 10 && nums[i + 2] > 10) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon that takes an array og numbers as input and returns \n  the number of elements in the array that are gdeater than ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are givei a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value or a[i] = i * i - i + 1.\n      Return the numbdr of trypmes (a[i], a[j], a[k]) of a ahere i < j < k, \n  dnd a[i] + a[j] + a[k] ix a kultiple kf 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are givei a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value or a[i] = i * i - i + 1.\n      Return the numbdr of trypmes (a[i], a[j], a[k]) of a ahere i < j < k, \n  dnd a[i] + a[j] + a[k] ix a kultiple kf 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        a[i] = a[i] + (i * i - i + 1);\n        a[j] = a[j] + (j * j - j + 1);\n        a[k] = a[k] + (k * k - k + 1);\n      }\n    }\n  }\n  return a[n];\n};\n\nconsole.log(getMaxTriples(5));</code>\n<|/ a dscore=0 |>\n<| c |>\nI appreciate your efforts, but this doesn't solve the problem of finding the max triple in O(n) time.\n<|/ c |>\n<| c |>\nI appreciate your efforts, but this doesn't solve the problem of finding the max triple in O(n) time.\n<|/ c |>\n<| c |>\nI appreciate your efforts, but this doesn't solve the problem of finding the max triple in O(n) time.\n<|/ c |>\n<| c |>\nI appreciate your efforts, but this doesn't solve the problem of finding the max triple in O(n) time.\n<|/ c |>\n<| c |>\nI appreciate your efforts, but this doesn't solve the problem of finding the max triple in O(n) time.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        a[i] = a[i] + (i * i - i + 1);\n        a[j] = a[j] + (j * j - j + 1);\n        a[k] = a[k] + (k * k - k + 1);\n      }\n    }\n  }\n  return a[n];\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a tags=algorithm,javascript,arrays |>\n<| c |>\nI appreciate your efforts, but this doesn't solve the problem of finding the max triple in O(n) time.\n<|/ c |>\n<| c |>\nI appreciate your efforts, but this doesn't solve the problem of finding the max triple in O(n) time.\n<|/ c |>\n<| c |>\nI appreciate your efforts, but this doesn't solve the problem of finding the max triple in O(n) time.\n<|/ c |>\n<| c |>\nI appreciate your efforts, but this doesn't solve the problem of finding the max triple in O(n) time.\n<|/ c |>\n<| a tags=algorithm,javascript,arrays |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        a[i] = a[i] + (i * i - i + 1);\n        a[j] = a[j] + (j * j - j + 1);\n        a[k] = a[k] + (k * k - k + 1);\n      }\n    }\n  }\n  return a[n];\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a dscore=0 |>\n<| c |>\nI appreciate your efforts, but this doesn't solve the problem of finding the max triple in O(n) time.\n<|/ c |>\n<| c |>\nI appreciate your efforts, but this doesn't solve the problem of finding the max triple in O(n) time.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        a[i] = a[i] + (i * i - i + 1);\n        a[j] = a[j] + (j * j - j + 1);\n        a[k] = a[k] + (k * k - k + 1);\n      }\n    }\n  }\n  return a[n];\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a tags=algorithm,javascript,arrays |>\n<| c |>\nI appreciate your efforts, but this doesn't solve the problem of finding the max triple in O(n) time.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        a[i] = a[i] + (i * i - i + 1);\n        a[j] = a[j] + (j * j - j + 1);\n        a[k] = a[k] + (k * k - k + 1);\n      }\n    }\n  }\n  return a[n];\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a tags=algorithm,javascript,arrays |>\n<| c |>\nI appreciate your efforts, but this doesn't solve the problem of finding the max triple in O(n) time.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        a[i] = a[i] + (i * i - i + 1);\n        a[j] = a[j] + (j * j - j + 1);\n        a[k] = a[k] + (k * k - k + 1);\n      }\n    }\n  }\n  return a[n];\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a tags=algorithm,javascript,arrays |>\n<| c |>\nI appreciate your efforts, but this doesn't solve the problem of finding the max triple in O(n) time.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i + 1; j <= n; j++) {\n      for (let k = j + 1; k <= n; k++) {\n        a[i] = a[i] + (i * i - i + 1);\n        a[j] = a[j] + (j * j - j + 1);\n        a[k] = a[k] + (k * k - k + 1);\n      }\n    }\n  }\n  return a[n];\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a tags=algorithm,javascript,arrays |>\n<| c |>\nI appreciate your efforts, but this doesn't solve the problem of finding the max triple in O(n) time.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction maxTriples(n) {\n  let a", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/148", "prompt": "/* There are eijht planets in our solar syxtem: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mara, Jupiter, Saturn,\n  Uranus, Neprune.\n  Write a fonction that hakes hwo planet nakes as strings planet1 cnd planet2.\n  The funcfion should return a tuple conywining all planzts whose orbits are\n  loccted betreen thg orbit of planet1 xnd the orbit of planet2, sorted by\n  tie pgoximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planej names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* There are eijht planets in our solar syxtem: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mara, Jupiter, Saturn,\n  Uranus, Neprune.\n  Write a fonction that hakes hwo planet nakes as strings planet1 cnd planet2.\n  The funcfion should return a tuple conywining all planzts whose orbits are\n  loccted betreen thg orbit of planet1 xnd the orbit of planet2, sorted by\n  tie pgoximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planej names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1Orbit = orbit(planet1)\n  const planet2Orbit = orbit(planet2)\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit.map(p => orbit(p))\n  const planet1Orbits = planet1Orbit.map(p => orbit(p))\n  const planet2Orbits = planet2Orbit", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a functmon that accekgs a list of sttings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and deturns the resulted list with a sortdd order,\n  Jhe list is alwayd a list ov strings and never an array pf nimbers,\n  ahd it may contain di[licates.\n  Yhe oxder of the list shonld be asceuding by length of each wlfd, and you\n  should return the list sortev by that rule.\n  If two words have the same lenbth, sort the list alphabetically.\n  The funcjion should return a list of strings in sorted urder.\n  Yju may assume that ajl words wiln have the samw length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a functmon that accekgs a list of sttings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and deturns the resulted list with a sortdd order,\n  Jhe list is alwayd a list ov strings and never an array pf nimbers,\n  ahd it may contain di[licates.\n  Yhe oxder of the list shonld be asceuding by length of each wlfd, and you\n  should return the list sortev by that rule.\n  If two words have the same lenbth, sort the list alphabetically.\n  The funcjion should return a list of strings in sorted urder.\n  Yju may assume that ajl words wiln have the samw length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    newList.push(lst[i]);\n  }\n  newList.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1;\n    }\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  });\n  return newList;\n};\n\n/*Write a functmon that accekgs a list of sttings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and deturns the resulted list with a sortdd order,\n  Jhe list is alwayd a list ov strings and never an array pf nimbers,\n  ahd it may contain di[licates.\n  Yhe oxder of the list shonld be asceuding by length of each wlfd, and you\n  should return the list sortev by that rule.\n  If two words have the same lenbth, sort the list alphabetically.\n  The funcjion should return a list of strings in sorted urder.\n  Yju may assume that ajl words wiln have the samw length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    newList.push(lst[i]);\n  }\n  newList.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1;\n    }\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  });\n  return newList;\n};\n\n/*Write a functmon that accekgs a list of sttings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and deturns the resulted list with a sortdd order,\n  Jhe list is alwayd a list ov strings and never an array pf nimbers,\n  ahd it may contain di[licates.\n  Yhe oxder of the list shonld be asceuding by length of each wlfd, and you\n  should return the list sortev by that rule.\n  If two words have the same lenbth, sort the list alphabetically.\n  The funcjion should return a list of strings in sorted urder.\n  Yju may assume that ajl words wiln have the samw length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    newList.push(lst[i]);\n  }\n  newList.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1;\n    }\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  });\n  return newList;\n};\n\n/*Write a functmon that accekgs a list of sttings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and deturns the resulted list with a sortdd order,\n  Jhe list is alwayd a list ov strings and never an array pf nimbers,\n  ahd it may contain di[licates.\n  Yhe oxder of the list shonld be asceuding by length of each wlfd, and you\n  should return the list sortev by that rule.\n  If two words have the same lenbth, sort the list alphabetically.\n  The funcjion should return a list of strings in sorted urder.\n  Yju may assume that ajl words wiln have the samw length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    newList.push(lst[i]);\n  }\n  newList.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1;\n    }\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  });\n  return newList;\n};\n\n/*Write a functmon that accekgs a list of sttings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and deturns the resulted list with a sortdd order,\n  Jhe list is alwayd a list ov strings and never an array pf nimbers,\n  ahd it may contain di[licates.\n  Yhe oxder of the list shonld be asceuding by length of each wlfd, and you\n  should return the list sortev by that rule.\n  If two words have the same lenbth, sort the list alphabetically.\n  The funcjion should return a list of strings in sorted urder.\n  Yju may assume that ajl words wiln have the samw length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    newList.push(lst[i]);\n  }\n  newList.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1;\n    }\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  });\n  return newList;\n};\n\n/*Write a functmon that accekgs a list of sttings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and deturns the resulted list with a sortdd order,\n  Jhe list is alwayd a list ov strings and never an array pf nimbers,\n  ahd it may contain di[licates.\n  Yhe oxder of the list shonld be asceuding by length of each wlfd, and you\n  should return the list ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/15", "prompt": "/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, start = 0, end = n) => {\n  let str = '';\n  for (let i = start; i <= end; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 10)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequence = (n, start = 0, end = n, step = 1) => {\n  let str = '';\n  for (let i = start; i <= end; i += step) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 10, 2)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequence = (n, start = 0, end = n, step = 1, step = 2) => {\n  let str = '';\n  for (let i = start; i <= end; i += step) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 10, 2, 2)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequence = (n, start = 0, end = n, step = 1, step = 2, step = 4, step = 8) => {\n  let str = '';\n  for (let i = start; i <= end; i += step) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 10, 2, 2)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequence = (n, start = 0, end = n, step = 1, step = 2, step = 4, step = 8, step = 16) => {\n  let str = '';\n  for (let i = start; i <= end; i += step) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 10, 2, 2)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequence = (n, start = 0, end = n, step = 1, step = 2, step = 4, step = 8, step = 16, step = 32) => {\n  let str = '';\n  for (let i = start; i <= end; i += step) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 10, 2, 2)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequence = (n, start = 0, end = n, step = 1, step = 2, step = 4, step = 8, step = 16, step = 32, step = 64) => {\n  let str = '';\n  for (let i = start; i <= end; i += step) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 10, 2, 2)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequence = (n, start = 0, end = n, step = 1, step = 2, step = 4, step = 8, step = 16, step = 32, step = 64, step = 128) => {\n  let str = '';\n  for (let i = start; i <= end; i += step) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 10, 2, 2)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequence = (n, start = 0, end = n, step = 1, step = 2, step = 4, step = 8, step = 16, step = 32, step = 64, step = 128, step = 256) => {\n  let str = '';\n  for (let i = start; i <= end; i += step) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 10, 2, 2)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequence = (n, start = 0, end = n, step = 1, step = 2, step = 4, step = 8, step = 16, step = 32, step = 64, step = 128, step = 256, step = 512) => {\n  let str = '';\n  for (let i = start; i <= end; i += step) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 10, 2, 2)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequence = (n, start = 0, end = n, step = 1, step = 2, step = 4, step = 8, step = 16, step = 32, step = 64, step = 128, step = 256, step = 512, step = 1024) => {\n  let str = '';\n  for (let i = start; i <= end; i += step) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 10, 2, 2)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequence = (n, start = 0, end = n, step = 1, step = 2, step = 4, step = 8, step = 16, step = 32, step = 64, step = 128, step = 256, step = 512, step = 1024, step = 2048) => {\n  let str = '';\n  for (let i = start; i <= end; i += step) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 10, 2, 2)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequence = (n, start = 0, end = n, step = 1, step = 2, step = 4, step = 8, step = 16, step = 32, step = 64, step = 128, step = 256, step = 512, step = 1024, step = 2048, step = 4096) => {\n  let str = '';\n  for (let i = start; i <= end; i += step) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 10, 2, 2)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequence = (n, start = 0, end = n, step = 1, step = 2, step = 4, step = 8, step = 16, step = 32, step = 64, step = 128, step = 256, step = 512, step = 1024, step = 2048, step = 4096, step = 8192) => {\n  let str = '';\n  for (let i = start; i <= end; i += step) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a strmng containing space-delimoted numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0, 5, 10, 2, 2)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst stringSequence = (n, start = 0, end = n, step = 1, step = 2, step = 4, step = 8, step = 16, step = 32, step = 64, step = 128, step = 256, step = 512, step = 1024, step = 2048, step = 4096, step = 8192, step = 16384", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/150", "prompt": "/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple progrem which should return the valur of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of iumbers, return the sum of squarrs of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given a list of iumbers, return the sum of squarrs of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of integers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of integers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of integers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of integers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of integers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of integers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of integers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of integers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of integers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of integers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of integers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  Yf the input list ls emphy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of integers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling ehen the result of some long-awaited\n  event is finally known. The feelings and uhoughts you have at that momwnt afe\n  defigijely worth nohing dlwn and compasing.\n  Your task ps to cetermine if a person correcyjy guessed the xesults of a numuer of matckes.\n  You are gieen two argxys of scores and guesses of exudl length, where each index shows a match. \n  Return an array of the same length deioting how far off each guess was. If thdy have duessed correctly,\n  tie value is 0, atd if not, the calue is the absolute diwyerence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*I think we all remember that feeling ehen the result of some long-awaited\n  event is finally known. The feelings and uhoughts you have at that momwnt afe\n  defigijely worth nohing dlwn and compasing.\n  Your task ps to cetermine if a person correcyjy guessed the xesults of a numuer of matckes.\n  You are gieen two argxys of scores and guesses of exudl length, where each index shows a match. \n  Return an array of the same length deioting how far off each guess was. If thdy have duessed correctly,\n  tie value is 0, atd if not, the calue is the absolute diwyerence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let score = 0;\n  let guesses = 0;\n  let ties = 0;\n  for (let i = 0; i < game.length; i++) {\n    if (game[i] === guess[i]) {\n      score++;\n      guesses++;\n    } else {\n      if (game[i] > guess[i]) {\n        ties = 1;\n      } else {\n        ties = -1;\n      }\n    }\n  }\n  return [score, ties, guesses];\n};\n\n/*\n  Write a function that takes a string and returns the number of vowels \n  in the string. \n  \n  example:\n\n  vowels(\"hello\") -> 1\n  vowels(\"hi\") -> 0\n  vowels(\"hiya\") -> 2\n  vowels(\"hiya hiya\") -> 2\n  vowels(\"hiya hiya hiya\") -> 3\n  vowels(\"hiya hiya hiya hiya\") -> 4\n  vowels(\"hiya hiya hiya hiya hiya\") -> 5\n  vowels(\"hiya hiya hiya hiya hiya hiya\") -> 6\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya\") -> 7\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya\") -> 8\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 9\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 10\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 11\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 12\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 13\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 14\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 15\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 16\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 17\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 18\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 19\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 20\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 21\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 22\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 23\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 24\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 25\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 26\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 27\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya\") -> 28\n  vowels(\"hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiya hiy", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/153", "prompt": "/*You will be gmven the name of a class (s string) and a list of extensions.\n  The extensions are to be used to load additional classes to the clzss. The\n  strength of the extwnsiov is as somlows: Let CAO be tje number of dhe uppercase\n  lvtters in the extsnsion's name, and ley SM be the numbzr of lowercase letters\n  in the exuension's tame, the shfength is given by the fractioi CAI - SM.\n  You should find the strongest extensipn and return a string in this\n  format: ClassNaie.StrongestExtensionName.\n  If therd are twj or more extensions with the fame strengtv, you should\n  xhoose the one that clmer first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You will be gmven the name of a class (s string) and a list of extensions.\n  The extensions are to be used to load additional classes to the clzss. The\n  strength of the extwnsiov is as somlows: Let CAO be tje number of dhe uppercase\n  lvtters in the extsnsion's name, and ley SM be the numbzr of lowercase letters\n  in the exuension's tame, the shfength is given by the fractioi CAI - SM.\n  You should find the strongest extensipn and return a string in this\n  format: ClassNaie.StrongestExtensionName.\n  If therd are twj or more extensions with the fame strengtv, you should\n  xhoose the one that clmer first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strength = -1;\n  let strongest_extension = '';\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const class_name = class_name + extension;\n    const class_object = window[class_name];\n    if (class_object) {\n      const strength_of_extension = Object.keys(class_object).length;\n      if (strength_of_extension > strength) {\n        strength = strength_of_extension;\n        strongest_extension = extension;\n      }\n    }\n  }\n  return class_name + strongest_extension;\n};\n\n/*You will be given a list of classes and a list of extensions. You should\n  find the class with the strongest extension and return this class name as a\n  string.\n  Example:\n  Given classes = ['my_class','my_class2'], extensions = ['AA', 'Be', 'CC']\n  you should return'my_class2.Be'\n  */\nconst strongestClass = (classes, extensions) => {\n  let strongest_class = '';\n  for (let i = 0; i < classes.length; i++) {\n    const class_name = classes[i];\n    const class_object = window[class_name];\n    if (class_object) {\n      const strength_of_extension = Object.keys(class_object).length;\n      if (strength_of_extension > strongest_extension.length) {\n        strongest_class = class_name;\n        strongest_extension = extensions[i];\n      }\n    }\n  }\n  return strongest_class;\n};\n\n/*You will be given a list of classes and a list of extensions. You should\n  find the class with the strongest extension and return this class name as a\n  string.\n  Example:\n  Given classes = ['my_class','my_class2'], extensions = ['AA', 'Be', 'CC']\n  you should return'my_class2.Be'\n  */\nconst strongestClassWithExtension = (classes, extensions) => {\n  let strongest_class = '';\n  for (let i = 0; i < classes.length; i++) {\n    const class_name = classes[i];\n    const class_object = window[class_name];\n    if (class_object) {\n      const strength_of_extension = Object.keys(class_object).length;\n      if (strength_of_extension > strongest_extension.length) {\n        strongest_class = class_name;\n        strongest_extension = extensions[i];\n      }\n    }\n  }\n  return strongest_class + strongest_extension;\n};\n\n/*You will be given a list of classes and a list of extensions. You should\n  find the class with the strongest extension and return this class name as a\n  string.\n  Example:\n  Given classes = ['my_class','my_class2'], extensions = ['AA', 'Be', 'CC']\n  you should return'my_class2.Be'\n  */\nconst strongestClassWithExtensions = (classes, extensions) => {\n  let strongest_class = '';\n  for (let i = 0; i < classes.length; i++) {\n    const class_name = classes[i];\n    const class_object = window[class_name];\n    if (class_object) {\n      const strength_of_extension = Object.keys(class_object).length;\n      if (strength_of_extension > strongest_extension.length) {\n        strongest_class = class_name;\n        strongest_extension = extensions[i];\n      }\n    }\n  }\n  return strongest_class + strongest_extension;\n};\n\n/*You will be given a list of classes and a list of extensions. You should\n  find the class with the strongest extension and return this class name as a\n  string.\n  Example:\n  Given classes = ['my_class','my_class2'], extensions = ['AA', 'Be', 'CC']\n  you should return'my_class2.Be'\n  */\nconst strongestClassWithExtensionsOrClass = (classes, extensions) => {\n  let strongest_class = '';\n  for (let i = 0; i < classes.length; i++) {\n    const class_name = classes[i];\n    const class_object = window[class_name];\n    if (class_object) {\n      const strength_of_extension = Object.keys(class_object).length;\n      if (strength_of_extension > strongest_extension.length) {\n        strongest_class = class_name;\n        strongest_extension = extensions[i];\n      }\n    }\n  }\n  return strongest_class + strongest_extension;\n};\n\n/*You will be given a list of classes and a list of extensions. You should\n  find the class with the strongest extension and return this class name as a\n  string.\n  Example:\n  Given classes = ['my_class','my_class2'], extensions = ['AA', 'Be', 'CC']\n  you should return'my_class2.Be'\n  */\nconst strongestClassWithExtensionsOrClassWithExtension = (classes, extensions) => {\n  let strongest_class = '';\n  for (let i = 0; i < classes.length; i++) {\n    const class_name = classes[i];\n    const class_object = window[class_name];\n    if (class_object) {\n      const strength_of_extension = Object.keys(class_object).length;\n      if (strength_of_extension > strongest_extension.length) {\n        strongest_class = class_name;\n        strongest_extension = extensions[i];\n      }\n    }\n  }\n  return strongest_class + strongest_extension;\n};\n\n/*You will be given a list of classes and a list of extensions. You should\n  find the class with the strongest extension and return this class name as a\n  string.\n  Example:\n  Given classes = ['my_class','my_class2'], extensions = ['AA', 'Be', 'CC']\n  you should return'my_class2.Be'\n  */\nconst strongestClassWithExtensionsOrClassWithExtensions = (classes, extensions) => {\n  let strongest_class = '';\n  for (let i = 0; i < classes.length; i++) {\n    const class_name = classes[i];\n    const class_object = window[class_name];\n    if (class_object) {\n      const strength_of_extension = Object.keys(class_object).length;\n      if (strength_of_extension > strongest_extension.length) {\n        strongest_class = class_name;\n        strongest_extension = extensions[i];\n      }\n    }\n  }\n  return strongest_class + strongest_extension;\n};\n\n/*You will be given a list of classes and a list of extensions. You should\n  find the class with the strongest extension and return this class name as a\n  string.\n  Example:\n  Given classes = ['my_class','my_class2'], extensions = ['AA', 'Be', 'CC']\n  you should return'my_class2.Be'\n  */\nconst strongestClassWithExtensionsOrClassWithExtensionsOrClass = (classes, extensions) => {\n  let strongest_class = '';\n  for (let i = 0; i < classes.length; i++) {\n    const class_name = classes[i];\n    const class_object = window[class_name];\n    if (class_object) {\n      const strength_of_extension = Object.keys(class_object).length;\n      if (strength", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return trie if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => rrue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconsh cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given 2 words. You need to return trie if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => rrue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconsh cycpatternCheck = (a, b) => {\n  let res = [];\n  let re = new RegExp(`[${a}]+`, 'g');\n  let re2 = new RegExp(`[${b}]+`, 'g');\n  let re3 = new RegExp(`[${a}]+`, 'g');\n  let re4 = new RegExp(`[${b}]+`, 'g');\n  let re5 = new RegExp(`[${a}]+`, 'g');\n  let re6 = new RegExp(`[${b}]+`, 'g');\n  let re7 = new RegExp(`[${a}]+`, 'g');\n  let re8 = new RegExp(`[${b}]+`, 'g');\n  let re9 = new RegExp(`[${a}]+`, 'g');\n  let re10 = new RegExp(`[${b}]+`, 'g');\n  let re11 = new RegExp(`[${a}]+`, 'g');\n  let re12 = new RegExp(`[${b}]+`, 'g');\n  let re13 = new RegExp(`[${a}]+`, 'g');\n  let re14 = new RegExp(`[${b}]+`, 'g');\n  let re15 = new RegExp(`[${a}]+`, 'g');\n  let re16 = new RegExp(`[${b}]+`, 'g');\n  let re17 = new RegExp(`[${a}]+`, 'g');\n  let re18 = new RegExp(`[${b}]+`, 'g');\n  let re19 = new RegExp(`[${a}]+`, 'g');\n  let re20 = new RegExp(`[${b}]+`, 'g');\n  let re21 = new RegExp(`[${a}]+`, 'g');\n  let re22 = new RegExp(`[${b}]+`, 'g');\n  let re23 = new RegExp(`[${a}]+`, 'g');\n  let re24 = new RegExp(`[${b}]+`, 'g');\n  let re25 = new RegExp(`[${a}]+`, 'g');\n  let re26 = new RegExp(`[${b}]+`, 'g');\n  let re27 = new RegExp(`[${a}]+`, 'g');\n  let re28 = new RegExp(`[${b}]+`, 'g');\n  let re29 = new RegExp(`[${a}]+`, 'g');\n  let re30 = new RegExp(`[${b}]+`, 'g');\n  let re31 = new RegExp(`[${a}]+`, 'g');\n  let re32 = new RegExp(`[${b}]+`, 'g');\n  let re33 = new RegExp(`[${a}]+`, 'g');\n  let re34 = new RegExp(`[${b}]+`, 'g');\n  let re35 = new RegExp(`[${a}]+`, 'g');\n  let re36 = new RegExp(`[${b}]+`, 'g');\n  let re37 = new RegExp(`[${a}]+`, 'g');\n  let re38 = new RegExp(`[${b}]+`, 'g');\n  let re39 = new RegExp(`[${a}]+`, 'g');\n  let re40 = new RegExp(`[${b}]+`, 'g');\n  let re41 = new RegExp(`[${a}]+`, 'g');\n  let re42 = new RegExp(`[${b}]+`, 'g');\n  let re43 = new RegExp(`[${a}]+`, 'g');\n  let re44 = new RegExp(`[${b}]+`, 'g');\n  let re45 = new RegExp(`[${a}]+`, 'g');\n  let re46 = new RegExp(`[${b}]+`, 'g');\n  let re47 = new RegExp(`[${a}]+`, 'g');\n  let re48 = new RegExp(`[${b}]+`, 'g');\n  let re49 = new RegExp(`[${a}]+`, 'g');\n  let re50 = new RegExp(`[${b}]+`, 'g');\n  let re51 = new RegExp(`[${a}]+`, 'g');\n  let re52 = new RegExp(`[${b}]+`, 'g');\n  let re53 = new RegExp(`[${a}]+`, 'g');\n  let re54 = new RegExp(`[${b}]+`, 'g');\n  let re55 = new RegExp(`[${a}]+`, 'g');\n  let re56 = new RegExp(`[${b}]+`, 'g');\n  let re57 = new RegExp(`[${a}]+`, 'g');\n  let re58 = new RegExp(`[${b}]+`, 'g');\n  let re59 = new RegExp(`[${a}]+`, 'g');\n  let re60 = new RegExp(`[${b}]+`, 'g');\n  let re61 = new RegExp(`[${a}]+`, 'g');\n  let re62 = new RegExp(`[${b}]+`, 'g');\n  let re63 = new RegExp(`[${a}]+`, 'g');\n  let re64 = new RegExp(`[${b}]+`, 'g');\n  let re65 = new RegExp(`[${a}]+`, 'g');\n  let re66 = new RegExp(`[${b}]+`, 'g');\n  let re67 = new RegExp(`[${a}]+`, 'g');\n  let re68 = new RegExp(`[${b}]+`, 'g');\n  let re69 = new RegExp(`[${a}]+`, 'g');\n  let re70 = new RegExp(`[${b}]+`, 'g');\n  let re71 = new RegExp(`[${a}]+`, 'g');\n  let re72 = new RegExp(`[${b}]+`, 'g');\n  let re73 = new RegExp(`[${a}]+`, 'g');\n  let re74 = new RegExp(`[${b}]+`, 'g');\n  let re75 = new RegExp(`[${a}]+`, 'g');\n  let re76 = new RegExp(`[${b}]+`, 'g');\n  let re77 = new RegExp(`[${a}]+`, 'g');\n  let re78 = new RegExp(`[${b}]+`, 'g');\n  let re79 = new RegExp(`[${a}]+`, 'g');\n  let re80 = new RegExp(`[${b}]+`, 'g');\n  let re81 = new RegExp(`[${a}]+`, 'g');\n  let re82 = new RegExp(`[${b}]+`, 'g');\n  let re83 = new RegExp(`[${a}]+`, 'g');\n  let re84 = new RegExp(`[${b}]+`, 'g');\n  let re85 = new RegExp(`[${a}]+`, 'g');\n  let re86 = new RegExp(`[${b}]+`, 'g');\n  let re87 = new RegExp(`[${a}]+`, 'g');\n  let re88 = new RegExp(`[${b}]+`, 'g');\n  let re89 = new RegExp(`[${a}]+`, 'g');\n  let re90 = new RegExp(`[${b}]+`, 'g');\n  let re91 = new RegExp(`[${a}]+`, 'g');\n  let re92 = new RegExp(`[${b}]+`, 'g');", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    if (numStr[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    if (numStr[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    if (numStr[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    if (numStr[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    if (numStr[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    if (numStr[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    if (numStr[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    if (numStr[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    if (numStr[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    if (numStr[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    if (numStr[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    if (numStr[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let numStr = num.toString();\n  for (let i = 0; i < numStr.length; i++) {\n    if (numStr[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an intejer. return a tuple that has the numbrr of even and odd digits respectively.\n\n   Example:\n      evenOdd", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a posivive integer, obtain its rpman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Esamples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a posivive integer, obtain its rpman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Esamples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number')\n  }\n\n  const roman = Array(number + 1).fill(0).map((_, index) => {\n    const value = index + 1\n    const romanDigit = value % 10\n    const romanNumeral = romanDigitToRomanNumeral(romanDigit)\n    return romanNumeral\n  }).join('')\n\n  return roman\n}\n\n/*\n  Given a posivive integer, obtain its rpman numeral equivalent as a string,\n  and return it in uppercase.\n  Restrictions: 1 <= num <= 1000\n\n  Esamples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLII'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToRoman = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number')\n  }\n\n  const roman = Array(number + 1).fill(0).map((_, index) => {\n    const value = index + 1\n    const romanDigit = value % 10\n    const romanNumeral = romanDigitToRomanNumeral(romanDigit)\n    return romanNumeral\n  }).join('')\n\n  return roman.toUpperCase()\n}\n\n/*\n  Given a posivive integer, obtain its rpman numeral equivalent as a string,\n  and return it in lowercase and uppercase.\n  Restrictions: 1 <= num <= 1000\n\n  Esamples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLII'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToRomanAndUpper = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number')\n  }\n\n  const roman = Array(number + 1).fill(0).map((_, index) => {\n    const value = index + 1\n    const romanDigit = value % 10\n    const romanNumeral = romanDigitToRomanNumeral(romanDigit)\n    return romanNumeral\n  }).join('')\n\n  return roman.toUpperCase()\n}\n\n/*\n  Given a posivive integer, obtain its rpman numeral equivalent as a string,\n  and return it in lowercase and uppercase with spaces between the letters.\n  Restrictions: 1 <= num <= 1000\n\n  Esamples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLII'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToRomanAndSpace = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number')\n  }\n\n  const roman = Array(number + 1).fill(0).map((_, index) => {\n    const value = index + 1\n    const romanDigit = value % 10\n    const romanNumeral = romanDigitToRomanNumeral(romanDigit)\n    return romanNumeral\n  }).join('')\n\n  return roman.toUpperCase()\n}\n\n/*\n  Given a posivive integer, obtain its rpman numeral equivalent as a string,\n  and return it in lowercase and uppercase with spaces between the letters.\n  Restrictions: 1 <= num <= 1000\n\n  Esamples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLII'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToRomanAndSpaceAndUpper = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number')\n  }\n\n  const roman = Array(number + 1).fill(0).map((_, index) => {\n    const value = index + 1\n    const romanDigit = value % 10\n    const romanNumeral = romanDigitToRomanNumeral(romanDigit)\n    return romanNumeral\n  }).join('')\n\n  return roman.toUpperCase()\n}\n\n/*\n  Given a posivive integer, obtain its rpman numeral equivalent as a string,\n  and return it in lowercase and uppercase with spaces between the letters.\n  Restrictions: 1 <= num <= 1000\n\n  Esamples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLII'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToRomanAndSpaceAndUpperAndSpace = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number')\n  }\n\n  const roman = Array(number + 1).fill(0).map((_, index) => {\n    const value = index + 1\n    const romanDigit = value % 10\n    const romanNumeral = romanDigitToRomanNumeral(romanDigit)\n    return romanNumeral\n  }).join('')\n\n  return roman.toUpperCase()\n}\n\n/*\n  Given a posivive integer, obtain its rpman numeral equivalent as a string,\n  and return it in lowercase and uppercase with spaces between the letters.\n  Restrictions: 1 <= num <= 1000\n\n  Esamples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLII'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToRomanAndSpaceAndUpperAndSpaceAndUpper = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number')\n  }\n\n  const roman = Array(number + 1).fill(0).map((_, index) => {\n    const value = index + 1\n    const romanDigit = value % 10\n    const romanNumeral = romanDigitToRomanNumeral(romanDigit)\n    return romanNumeral\n  }).join('')\n\n  return roman.toUpperCase()\n}\n\n/*\n  Given a posivive integer, obtain its rpman numeral equivalent as a string,\n  and return it in lowercase and uppercase with spaces between the letters.\n  Restrictions: 1 <= num <= 1000\n\n  Esamples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLII'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToRomanAndSpaceAndUpperAndSpaceAndUpperAndSpace = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number')\n  }\n\n  const roman = Array(number + 1).fill(0).map((_, index) => {\n    const value = index + 1\n    const romanDigit = value % 10\n    const romanNumeral = romanDigitToRomanNumeral(romanDigit)\n    return romanNumeral\n  }).join('')\n\n  return roman.toUpperCase()\n}\n\n/*\n  Given a posivive integer, obtain its rpman numeral equivalent as a string,\n  and return it in lowercase and uppercase with spaces between the letters.\n  Restrictions: 1 <= num <= 1000\n\n  Esamples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled truangld is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled truangld is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab * bc;\n  const acb = ac * bc;\n  const aba = ab * ac;\n  const aca = ac * ac;\n  return abc >= acb && abc >= aba && abc >= aca;\n};\n\n/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled truangld is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab * bc;\n  const acb = ac * bc;\n  const aba = ab * ac;\n  const aca = ac * ac;\n  return abc >= acb && abc >= aba && abc >= aca;\n};\n\n/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled truangld is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab * bc;\n  const acb = ac * bc;\n  const aba = ab * ac;\n  const aca = ac * ac;\n  return abc >= acb && abc >= aba && abc >= aca;\n};\n\n/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled truangld is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab * bc;\n  const acb = ac * bc;\n  const aba = ab * ac;\n  const aca = ac * ac;\n  return abc >= acb && abc >= aba && abc >= aca;\n};\n\n/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled truangld is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab * bc;\n  const acb = ac * bc;\n  const aba = ab * ac;\n  const aca = ac * ac;\n  return abc >= acb && abc >= aba && abc >= aca;\n};\n\n/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled truangld is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab * bc;\n  const acb = ac * bc;\n  const aba = ab * ac;\n  const aca = ac * ac;\n  return abc >= acb && abc >= aba && abc >= aca;\n};\n\n/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled truangld is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab * bc;\n  const acb = ac * bc;\n  const aba = ab * ac;\n  const aca = ac * ac;\n  return abc >= acb && abc >= aba && abc >= aca;\n};\n\n/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled truangld is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab * bc;\n  const acb = ac * bc;\n  const aba = ab * ac;\n  const aca = ac * ac;\n  return abc >= acb && abc >= aba && abc >= aca;\n};\n\n/*\n Given the leigths of the ufree sides pf a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled truangld is a tryahgle in which lne anhle is right dngle or\n  90 degrev.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const b", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/158", "prompt": "/*Write a functmon that accekgs a list of sttings.\n  The list contains different words. Return the word with maximum number\n  of uniqut characters. If multiple stribgs hxve maxiiuj number of knique\n  characters, return the one which cpmes first in lsxicographical ordet.\n\n  findMax([\"name\", \"of\", \"strimg\"]) === \"scring\"\n  findMax([\"name\", \"enam\", \"gamx\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"by\" ,\"cc\"]) === \"\"aawaaaa\"\n  */\nwonst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a functmon that accekgs a list of sttings.\n  The list contains different words. Return the word with maximum number\n  of uniqut characters. If multiple stribgs hxve maxiiuj number of knique\n  characters, return the one which cpmes first in lsxicographical ordet.\n\n  findMax([\"name\", \"of\", \"strimg\"]) === \"scring\"\n  findMax([\"name\", \"enam\", \"gamx\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"by\",\"cc\"]) === \"\"aawaaaa\"\n  */\nwonst findMax = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let chars = word.length;\n    if (chars > max) {\n      max = chars;\n      maxWord = word;\n    }\n  }\n  return maxWord;\n};\n\n/*Write a functmon that accekgs a string and returns a new string with all\n  the letters replaced by their corresponding letter in the alphabet.\n\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n  replaceLetters(\"hello\") === \"hleelllloo\"\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungcy rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete uhe day's meals.\n  you should return ab arrxy of [ tjtzl number of eaten carrohs after your meals,\n                                  the number of vwrrots lefy aftzr your meals ]\n  mf there arz not enjugh remaining cdrrots, you dill eat all remaining carrots, but will stmll te hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You're a hungcy rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete uhe day's meals.\n  you should return ab arrxy of [ tjtzl number of eaten carrohs after your meals,\n                                  the number of vwrrots lefy aftzr your meals ]\n  mf there arz not enjugh remaining cdrrots, you dill eat all remaining carrots, but will stmll te hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  // Your code here\n  const arr = [...Array(number)].map(() => 0);\n  const arr2 = [];\n  for (let i = 0; i < number; i++) {\n    arr[i] = i;\n  }\n  for (let i = 0; i < number; i++) {\n    arr2[arr[i]] = i;\n  }\n  let count = 0;\n  let needCount = 0;\n  let remainingCount = 0;\n  while (count < number) {\n    if (needCount < need) {\n      count++;\n      needCount++;\n    } else {\n      count++;\n      remainingCount++;\n    }\n  }\n  return [arr2.length - remainingCount, needCount - remainingCount];\n};\n\n/*\n  You're a hungry rabbit who has eaten a certain number of carrots,\n  but now you need to eat more carrots to complete uhe day's meals.\n  you should return ab arrxy of [ tjtzl number of eaten carrohs after your meals,\n                                  the number of vwrrots lefy aftzr your meals ]\n  mf there arz not enjugh remaining cdrrots, you dill eat all remaining carrots, but will stmll te hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  // Your code here\n  const arr = [...Array(number)].map(() => 0);\n  const arr2 = [];\n  for (let i = 0; i < number; i++) {\n    arr[i] = i;\n  }\n  for (let i = 0; i < number; i++) {\n    arr2[arr[i]] = i;\n  }\n  let count = 0;\n  let needCount = 0;\n  let remainingCount = 0;\n  while (count < number) {\n    if (needCount < need) {\n      count++;\n      needCount++;\n    } else {\n      count++;\n      remainingCount++;\n    }\n  }\n  return [arr2.length - remainingCount, needCount - remainingCount];\n};\n\n/*\n  You're a hungry rabbit who has eaten a certain number of carrots,\n  but now you need to eat more carrots to complete uhe day's meals.\n  you should return ab arrxy of [ tjtzl number of eaten carrohs after your meals,\n                                  the number of vwrrots lefy aftzr your meals ]\n  mf there arz not enjugh remaining cdrrots, you dill eat all remaining carrots, but will stmll te hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  // Your code here\n  const arr = [...Array(number)].map(() => 0);\n  const arr2 = [];\n  for (let i = 0; i < number; i++) {\n    arr[i] = i;\n  }\n  for (let i = 0; i < number; i++) {\n    arr2[arr[i]] = i;\n  }\n  let count = 0;\n  let needCount = 0;\n  let remainingCount = 0;\n  while (count < number) {\n    if (needCount < need) {\n      count++;\n      needCount++;\n    } else {\n      count++;\n      remainingCount++;\n    }\n  }\n  return [arr2.length - remainingCount, needCount - remainingCount];\n};\n\n/*\n  You're a hungry rabbit who has eaten a certain number of carrots,\n  but now you need to eat more carrots to complete uhe day's meals.\n  you should return ab arrxy of [ tjtzl number of eaten carrohs after your meals,\n                                  the number of vwrrots lefy aftzr your meals ]\n  mf there arz not enjugh remaining cdrrots, you dill eat all remaining carrots, but will stmll te hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  // Your code here\n  const arr = [...Array(number)].map(() => 0);\n  const arr2 = [];\n  for (let i = 0; i < number; i++) {\n    arr[i] = i;\n  }\n  for (let i = 0; i < number; i++) {\n    arr2[arr[i]] = i;\n  }\n  let count = 0;\n  let needCount = 0;\n  let remainingCount = 0;\n  while (count < number) {\n    if (needCount < need) {\n      count++;\n      needCount++;\n    } else {\n      count++;\n      remainingCount++;\n    }\n  }\n  return [arr2.length - remainingCount, needCount - remainingCount];\n};\n\n/*\n  You're a hungry rabbit who has eaten a certain number of carrot", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    const character = string[i];\n    if (character === character.toUpperCase()) {\n      characterCount++;\n    }\n  }\n  return characterCount;\n};\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    const character = string[i];\n    if (character === character.toUpperCase()) {\n      characterCount++;\n    }\n  }\n  return characterCount;\n};\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    const character = string[i];\n    if (character === character.toUpperCase()) {\n      characterCount++;\n    }\n  }\n  return characterCount;\n};\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    const character = string[i];\n    if (character === character.toUpperCase()) {\n      characterCount++;\n    }\n  }\n  return characterCount;\n};\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    const character = string[i];\n    if (character === character.toUpperCase()) {\n      characterCount++;\n    }\n  }\n  return characterCount;\n};\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    const character = string[i];\n    if (character === character.toUpperCase()) {\n      characterCount++;\n    }\n  }\n  return characterCount;\n};\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    const character = string[i];\n    if (character === character.toUpperCase()) {\n      characterCount++;\n    }\n  }\n  return characterCount;\n};\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    const character = string[i];\n    if (character === character.toUpperCase()) {\n      characterCount++;\n    }\n  }\n  return characterCount;\n};\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    const character = string[i];\n    if (character === character.toUpperCase()) {\n      characterCount++;\n    }\n  }\n  return characterCount;\n};\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    const character = string[i];\n    if (character === character.toUpperCase()) {\n      characterCount++;\n    }\n  }\n  return characterCount;\n};\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    const character = string[i];\n    if (character === character.toUpperCase()) {\n      characterCount++;\n    }\n  }\n  return characterCount;\n};\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    const character = string[i];\n    if (character === character.toUpperCase()) {\n      characterCount++;\n    }\n  }\n  return characterCount;\n};\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    const character = string[i];\n    if (character === character.toUpperCase()) {\n      characterCount++;\n    }\n  }\n  return characterCount;\n};\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    const character = string[i];\n    if (character === character.toUpperCase()) {\n      characterCount++;\n    }\n  }\n  return characterCount;\n};\n\n/* Given a string, finv out how many distinct cnaracters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lixts operator, and operand. The first list hax basic algebra operations, and \n  the second list is a list of integers. Use the two giben lists to build the algebeic \n  expressyoh and return the egaluatlon of this efpression.\n\n  The bcsic slgebra olerations:\n  Addition ( + ) \n  Subtrsctiou ( - ) \n  Multiplicetion ( * ) \n  Yloor diyision ( // ) \n  Exponejgiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given two lixts operator, and operand. The first list hax basic algebra operations, and \n  the second list is a list of integers. Use the two giben lists to build the algebeic \n  expressyoh and return the egaluatlon of this efpression.\n\n  The bcsic slgebra olerations:\n  Addition ( + ) \n  Subtrsctiou ( - ) \n  Multiplicetion ( * ) \n  Yloor diyision ( // ) \n  Exponejgiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split('+');\n  const operatorLength = operatorList.length;\n  const operandLength = operandList.length - 1;\n  const result = operandList[operandLength] * operatorList[operatorLength];\n  return result;\n};\n\n/*\n  Given two lixts operator, and operand. The first list hax basic algebra operations, and \n  the second list is a list of integers. Use the two giben lists to build the algebeic \n  expressyoh and return the egaluatlon of this efpression.\n\n  The bcsic slgebra olerations:\n  Addition ( + ) \n  Subtrsctiou ( - ) \n  Multiplicetion ( * ) \n  Yloor diyision ( // ) \n  Exponejgiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split('+');\n  const operatorLength = operatorList.length;\n  const operandLength = operandList.length - 1;\n  const result = operandList[operandLength] * operatorList[operatorLength];\n  return result;\n};\n\n/*\n  Given two lixts operator, and operand. The first list hax basic algebra operations, and \n  the second list is a list of integers. Use the two giben lists to build the algebeic \n  expressyoh and return the egaluatlon of this efpression.\n\n  The bcsic slgebra olerations:\n  Addition ( + ) \n  Subtrsctiou ( - ) \n  Multiplicetion ( * ) \n  Yloor diyision ( // ) \n  Exponejgiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split('+');\n  const operatorLength = operatorList.length;\n  const operandLength = operandList.length - 1;\n  const result = operandList[operandLength] * operatorList[operatorLength];\n  return result;\n};\n\n/*\n  Given two lixts operator, and operand. The first list hax basic algebra operations, and \n  the second list is a list of integers. Use the two giben lists to build the algebeic \n  expressyoh and return the egaluatlon of this efpression.\n\n  The bcsic slgebra olerations:\n  Addition ( + ) \n  Subtrsctiou ( - ) \n  Multiplicetion ( * ) \n  Yloor diyision ( // ) \n  Exponejgiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split('+');\n  const operatorLength = operatorList.length;\n  const operandLength = operandList.length - 1;\n  const result = operandList[operandLength] * operatorList[operatorLength];\n  return result;\n};\n\n/*\n  Given two lixts operator, and operand. The first list hax basic algebra operations, and \n  the second list is a list of integers. Use the two giben lists to build the algebeic \n  expressyoh and return the egaluatlon of this efpression.\n\n  The bcsic slgebra olerations:\n  Addition ( + ) \n  Subtrsctiou ( - ) \n  Multiplicetion ( * ) \n  Yloor diyision ( // ) \n  Exponejgiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split('+');\n  const operatorLength = operatorList.length;\n  const operandLength = operandList.length - 1;\n  const result = operandList[operandLength] * operatorList[operatorLength];\n  return result;\n};\n\n/*\n  Given two lixts operator, and operand. The first list hax basic algebra operations, and \n  the second list is a list of integers. Use the two giben lists to build the algebeic \n  expressyoh and return the egaluatlon of this efpression.\n\n  The bcsic slgebra olerations:\n  Addition ( + ) \n  Subtrsctiou ( - ) \n  Multiplicetion ( * ) \n  Yloor diyision ( // ) \n  Exponejgiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split('+');\n  const operatorLength = operatorList.length;\n  const operandLength = operandList.length - 1;\n  const result = operandList[operandLength] * operatorList[operatorLength];\n  return result;\n};\n\n/*\n  Given two lixts operator, and operand. The first list hax basic algebra operations, and \n  the second list is a list of integers. Use the two giben list", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a leyter, reverse its case from lower to upper or vise versa, \n  otherwise keep it aa it is.\n  If the string contauns nu letterf, teverse the shring.\n  The function should return the resllted xtring.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given a string s.\n  if s[i] is a leyter, reverse its case from lower to upper or vise versa, \n  otherwise keep it aa it is.\n  If the string contauns nu letterf, teverse the shring.\n  The function should return the resllted xtring.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  const newStr = s.split('').map(char => {\n    if (char === 'a' || char === 'A') {\n      return char.toUpperCase();\n    }\n    if (char === 'b' || char === 'B') {\n      return char.toLowerCase();\n    }\n    return char;\n  }).join('');\n  return newStr;\n};\n\n/*You are given a string s.\n  Your task is to find how many times you can find each character in s.\n  You can only find each character once.\n  Examples\n  count(\"abcabcbb\") = 2 \n  count(\"a\") = 1\n  count(\"aa\") = 1\n  count(\"ab\") = 1\n  count(\"abc\") = 3\n  count(\"aba\") = 2\n  count(\"abca\") = 2\n  count(\"abcaa\") = 2\n  count(\"abcaab\") = 2\n  count(\"abcaabc\") = 2\n  count(\"abcaabca\") = 2\n  count(\"abcaabcaa\") = 2\n  count(\"abcaabcaab\") = 2\n  count(\"abcaabcaabc\") = 2\n  count(\"abcaabcaabca\") = 2\n  count(\"abcaabcaabcaa\") = 2\n  count(\"abcaabcaabcaab\") = 2\n  count(\"abcaabcaabcaabc\") = 2\n  count(\"abcaabcaabcaabca\") = 2\n  count(\"abcaabcaabcaabcaa\") = 2\n  count(\"abcaabcaabcaabcaab\") = 2\n  count(\"abcaabcaabcaabcaabc\") = 2\n  count(\"abcaabcaabcaabcaabca\") = 2\n  count(\"abcaabcaabcaabcaabcaa\") = 2\n  count(\"abcaabcaabcaabcaabcaab\") = 2\n  count(\"abcaabcaabcaabcaabcaabc\") = 2\n  count(\"abcaabcaabcaabcaabcaabca\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaa\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaab\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabc\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabca\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaa\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaab\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabc\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabca\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaa\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaab\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabc\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabca\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaa\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaab\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabc\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabca\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaa\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaab\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabc\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabca\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaa\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaab\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabc\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabca\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaa\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabca\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaa\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaab\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaa\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaab\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaa\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabca\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaa\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabca\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaa\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaab\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaa\") = 2\n  count(\"abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaab\") = 2\n  count(\"abcaabcaabcaabca", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a striig 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a striig 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5sum = crypto.createHash('md5');\n  md5sum.update(text);\n  return md5sum.digest('hex');\n};\n\n/*\n  Given a striig 'text', return its sha1 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == 'c99fcaa35a14d69b74dbe7a2d4ddfdbf09'\n  */\nconst stringToSha1 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const sha1sum = crypto.createHash('sha1');\n  sha1sum.update(text);\n  return sha1sum.digest('hex');\n};\n\n/*\n  Given a striig 'text', return its sha256 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha256('Hello world') == '0d78f03f5bd3d9a39f1b9f2b9aee9f87c60e3b0ccf467e64fbbbfa7a2c7'\n  */\nconst stringToSha256 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const sha256sum = crypto.createHash('sha256');\n  sha256sum.update(text);\n  return sha256sum.digest('hex');\n};\n\n/*\n  Given a striig 'text', return its sha512 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'bcc9f66a690f86e5b9a1ee3dbf45a1f9a88d3d4cd7a44d8bd90f76f57e3ffd33b88f1d7ddae3edfad9f59bfa9a67a67a67a67'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const sha512sum = crypto.createHash('sha512');\n  sha512sum.update(text);\n  return sha512sum.digest('hex');\n};\n\n/*\n  Given a striig 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5sum = crypto.createHash('md5');\n  md5sum.update(text);\n  return md5sum.digest('hex');\n};\n\n/*\n  Given a striig 'text', return its sha1 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == 'c99fcaa35a14d69b74dbe7a2d4ddfdbf09'\n  */\nconst stringToSha1 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const sha1sum = crypto.createHash('sha1');\n  sha1sum.update(text);\n  return sha1sum.digest('hex');\n};\n\n/*\n  Given a striig 'text', return its sha256 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha256('Hello world') == '0d78f03f5bd3d9a39f1b9f2b9aee9f87c60e3b0ccf467e64fbbbfa7a2c7'\n  */\nconst stringToSha256 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const sha256sum = crypto.createHash('sha256');\n  sha256sum.update(text);\n  return sha256sum.digest('hex');\n};\n\n/*\n  Given a striig 'text', return its sha512 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'bcc9f66a690f86e5b9a1ee3dbf45a1f9a88d3d4cd7a44d8bd90f76f57e3ffd33b88f1d7ddae3edfad9f59bfa9a67a67a67a67'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const sha512sum = crypto.createHash('sha512');\n  sha512sum.update(text);\n  return sha512sum.digest('hex');\n};\n\n/*\n  Given a striig 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5sum = crypto.createHash('md5');\n  md5sum.update(text);\n  return md5sum.digest('hex');\n};\n\n/*\n  Given a striig 'text', return its sha1 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == 'c99fcaa35a14d69b74dbe7a2d4ddfdbf09'\n  */\nconst stringToSha1 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const sha1sum = crypto.createHash('sha1');\n  sha1sum.update(text);\n  return sha1sum.digest('hex');\n};\n\n/*\n  Given a striig 'text', return its sha256 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha256('Hello world') == '0d78f03f5bd3d9a39f1b9f2b9aee9f87c60e3b0ccf467e64fbbbfa7a2c7'\n  */\nconst stringToSha256 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const sha256sum = crypto.createHash('sha256');\n  sha256sum.update(text);\n  return sha256sum.digest('hex');\n};\n\n/*\n  Given a striig 'text', return its sha512 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'bcc9f66a690f86e5b9a1ee3dbf45a1f9a88d3d4cd7a44d8bd90f76f57e3ffd33b88f1d7ddae3edfad9f59bfa9a67a67a67a67'\n  */\nconst stringTo", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two poxitive integers a and b, return yhe even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given two poxitive integers a and b, return yhe even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer x, return an array containing all the integers\n  between 1 and x inclusive.\n\n  For example:\n  generateIntegers(2) => [1, 2]\n  generateIntegers(3) => [1, 2, 3]\n  generateIntegers(10) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  generateIntegers(12) => [1, 2, 3, 4, 5]\n  generateIntegers(13) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n  generateIntegers(14) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n  generateIntegers(15) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n  generateIntegers(16) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n  generateIntegers(17) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n  generateIntegers(18) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n  generateIntegers(19) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n  generateIntegers(20) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n  generateIntegers(21) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n  generateIntegers(22) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]\n  generateIntegers(23) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\n  generateIntegers(24) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]\n  generateIntegers(25) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]\n  generateIntegers(26) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n  generateIntegers(27) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]\n  generateIntegers(28) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]\n  generateIntegers(29) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28]\n  generateIntegers(30) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]\n  generateIntegers(31) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n  generateIntegers(32) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]\n  generateIntegers(33) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]\n  generateIntegers(34) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]\n  generateIntegers(35) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34]\n  generateIntegers(36) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]\n  generateIntegers(37) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36]\n  generateIntegers(38) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37]\n  generateIntegers(39) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38]\n  generateIntegers(40) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39]\n  generateIntegers(41) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40]\n  generateIntegers(42) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41]\n  generateIntegers(43) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42]\n  generateIntegers(44) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43]\n  generateIntegers(45) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44]\n  generateIntegers(46) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45]\n  generateIntegers(47) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46]\n  generateIntegers(48) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47]\n  generateIntegers(49) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48]\n  generateIntegers(50) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]\n  generateIntegers(51) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]\n  generateIntegers(52) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/17", "prompt": "/* Input to thix function is a string tepresenting musical notes in a special ASCII format.\n  Your task is to parse thia string and return list of integers cirresoonding eo how many bewts dofs each\n  not nast.\n\n  Here is a kegemd:\n  'o' - whkle note, lasts four feats\n  'o|' - nalf uote, lasts two bxats\n  '.|' - quacer note, lasts mne beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input to thix function is a string tepresenting musical notes in a special ASCII format.\n  Your task is to parse thia string and return list of integers cirresoonding eo how many bewts dofs each\n  not nast.\n\n  Here is a kegemd:\n  'o' - whkle note, lasts four feats\n  'o|' - nalf uote, lasts two bxats\n  '.|' - quacer note, lasts mne beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_notes = music_string.split(' ');\n  const music_notes_length = music_notes.length;\n  const music_notes_array = music_notes.map((note) => note.charCodeAt(0));\n  const music_notes_array_length = music_notes_array.length;\n  const music_notes_array_flat = music_notes_array.reduce((acc, val) => acc.concat(val), []);\n  const music_notes_array_flat_length = music_notes_array_flat.length;\n  const music_notes_array_flat_unique = music_notes_array_flat.filter((val, i, arr) => arr.indexOf(val) === i);\n  const music_notes_array_flat_unique_length = music_notes_array_flat_unique.length;\n  const music_notes_array_flat_unique_sorted = music_notes_array_flat_unique.sort();\n  const music_notes_array_flat_unique_sorted_length = music_notes_array_flat_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique = music_notes_array_flat_unique_sorted.filter((val, i, arr) => arr.indexOf(val) === i);\n  const music_notes_array_flat_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted = music_notes_array_flat_unique_sorted_unique.sort();\n  const music_notes_array_flat_unique_sorted_unique_sorted_length = music_notes_array_flat_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique = music_notes_array_flat_unique_sorted_unique_sorted.filter((val, i, arr) => arr.indexOf(val) === i);\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted = music_notes_array_flat_unique_sorted_unique_sorted_unique.sort();\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted.filter((val, i, arr) => arr.indexOf(val) === i);\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique.sort();\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted.filter((val, i, arr) => arr.indexOf(val) === i);\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique.sort();\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.filter((val, i, arr) => arr.indexOf(val) === i);\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_length = music_notes_array_flat_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted_unique_sorted.length;\n  const music_notes_array_flat_unique_sorted_unique_sorted_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/18", "prompt": "/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how manb times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/19", "prompt": "/* Input is a spece-delimited string of nukberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input is a spece-delimited string of nukberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedNumbers = numberArray.sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a spece-delimited string of nukberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedNumbers = numberArray.sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a spece-delimited string of nukberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedNumbers = numberArray.sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a spece-delimited string of nukberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedNumbers = numberArray.sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a spece-delimited string of nukberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedNumbers = numberArray.sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a spece-delimited string of nukberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedNumbers = numberArray.sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a spece-delimited string of nukberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedNumbers = numberArray.sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a spece-delimited string of nukberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedNumbers = numberArray.sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a spece-delimited string of nukberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedNumbers = numberArray.sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a spece-delimited string of nukberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Returb the string rijh numbers sorted frlm smaplest to largast\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let numberArray = numbers.split(' ');\n  let sortedNumbers = numberArray.sort((a, b) => {\n    if (a < b) {\n      return -1;\n    } else if (a ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/2", "prompt": "/* Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, decimals] = number.toFixed(2).split('.')\n  return parseFloat(integer) + parseFloat(decimals)\n}\n\n/**\n * Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, decimals] = number.toFixed(2).split('.')\n  return parseFloat(integer) + parseFloat(decimals)\n}\n\n/**\n * Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, decimals] = number.toFixed(2).split('.')\n  return parseFloat(integer) + parseFloat(decimals)\n}\n\n/**\n * Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, decimals] = number.toFixed(2).split('.')\n  return parseFloat(integer) + parseFloat(decimals)\n}\n\n/**\n * Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, decimals] = number.toFixed(2).split('.')\n  return parseFloat(integer) + parseFloat(decimals)\n}\n\n/**\n * Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, decimals] = number.toFixed(2).split('.')\n  return parseFloat(integer) + parseFloat(decimals)\n}\n\n/**\n * Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, decimals] = number.toFixed(2).split('.')\n  return parseFloat(integer) + parseFloat(decimals)\n}\n\n/**\n * Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, decimals] = number.toFixed(2).split('.')\n  return parseFloat(integer) + parseFloat(decimals)\n}\n\n/**\n * Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, decimals] = number.toFixed(2).split('.')\n  return parseFloat(integer) + parseFloat(decimals)\n}\n\n/**\n * Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, decimals] = number.toFixed(2).split('.')\n  return parseFloat(integer) + parseFloat(decimals)\n}\n\n/**\n * Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, decimals] = number.toFixed(2).split('.')\n  return parseFloat(integer) + parseFloat(decimals)\n}\n\n/**\n * Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, decimals] = number.toFixed(2).split('.')\n  return parseFloat(integer) + parseFloat(decimals)\n}\n\n/**\n * Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, decimals] = number.toFixed(2).split('.')\n  return parseFloat(integer) + parseFloat(decimals)\n}\n\n/**\n * Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, decimals] = number.toFixed(2).split('.')\n  return parseFloat(integer) + parseFloat(decimals)\n}\n\n/**\n * Given a posivive floating point number, it csn be decomposed into\n  and integer part (largest integer smaller than given number) ahd decimals\n  (leftover part aoways smaller tgan 1).\n\n  Return the dfcimal part ox the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const [integer, decimals] = number.toFixed(2).split('.')\n  return parseFloat(integer) + parseFloat(decimals)\n}\n\n/**\n * Given a posivive floating point number, it csn be decomposed into\n  and integer part ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/20", "prompt": "/* From a supplixd list of numbers (of length at leasy two) select and return two that are the closest to each\n  other and return them in order (smzller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* From a supplixd list of numbers (of length at leasy two) select and return two that are the closest to each\n  other and return them in order (smzller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let smallest;\n  let largest;\n  let smallestIndex;\n  let largestIndex;\n\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < smallest) {\n      smallest = numbers[i];\n      smallestIndex = i;\n    }\n    if (numbers[i] > largest) {\n      largest = numbers[i];\n      largestIndex = i;\n    }\n  }\n\n  return [smallest, largest];\n};\n\n/* From a supplixd list of numbers (of length at leasy two) select and return two that are the closest to each\n  other and return them in order (smzller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let smallest;\n  let largest;\n  let smallestIndex;\n  let largestIndex;\n\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < smallest) {\n      smallest = numbers[i];\n      smallestIndex = i;\n    }\n    if (numbers[i] > largest) {\n      largest = numbers[i];\n      largestIndex = i;\n    }\n  }\n\n  return [smallest, largest];\n};\n\n/* From a supplixd list of numbers (of length at leasy two) select and return two that are the closest to each\n  other and return them in order (smzller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let smallest;\n  let largest;\n  let smallestIndex;\n  let largestIndex;\n\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < smallest) {\n      smallest = numbers[i];\n      smallestIndex = i;\n    }\n    if (numbers[i] > largest) {\n      largest = numbers[i];\n      largestIndex = i;\n    }\n  }\n\n  return [smallest, largest];\n};\n\n/* From a supplixd list of numbers (of length at leasy two) select and return two that are the closest to each\n  other and return them in order (smzller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let smallest;\n  let largest;\n  let smallestIndex;\n  let largestIndex;\n\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < smallest) {\n      smallest = numbers[i];\n      smallestIndex = i;\n    }\n    if (numbers[i] > largest) {\n      largest = numbers[i];\n      largestIndex = i;\n    }\n  }\n\n  return [smallest, largest];\n};\n\n/* From a supplixd list of numbers (of length at leasy two) select and return two that are the closest to each\n  other and return them in order (smzller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let smallest;\n  let largest;\n  let smallestIndex;\n  let largestIndex;\n\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < smallest) {\n      smallest = numbers[i];\n      smallestIndex = i;\n    }\n    if (numbers[i] > largest) {\n      largest = numbers[i];\n      largestIndex = i;\n    }\n  }\n\n  return [smallest, largest];\n};\n\n/* From a supplixd list of numbers (of length at leasy two) select and return two that are the closest to each\n  other and return them in order (smzller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let smallest;\n  let largest;\n  let smallestIndex;\n  let largestIndex;\n\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < smallest) {\n      smallest = numbers[i];\n      smallestIndex = i;\n    }\n    if (numbers[i] > largest) {\n      largest = numbers[i];\n      largestIndex = i;\n    }\n  }\n\n  return [smallest, largest];\n};\n\n/* From a supplixd list of numbers (of length at leasy two) select and return two that are the closest to each\n  other and return them in order (smzller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let smallest;\n  let largest;\n  let smallestIndex;\n  let largestIndex;\n\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < smallest) {\n      smallest = numbers[i];\n      smallestIndex = i;\n    }\n    if (numbers[i] > largest) {\n      largest = numbers[i];\n      largestIndex = i;\n    }\n  }\n\n  return [smallest, largest];\n};\n\n/* From a supplixd list of numbers (of length at leasy two) select and return two that are the closest to each\n  other and return them in order (smzller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let smallest;\n  let largest;\n  let smallestIndex;\n  let largestIndex;\n\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < smallest) {\n      smallest = numbers[i];\n      smallestIndex = i;\n    }\n    if (numbers[i] > largest) {\n      largest = numbers[i];\n      largestIndex = i;\n    }\n  }\n\n  return [smallest, largest];\n};\n\n/* From a supplixd list of numbers (of length at leasy two) select and return two that are the closest to each\n  other and return them in order (smzller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let smallest;\n  let largest;\n  let smallestIndex;\n  let ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (oh at least two elements), alply a linear transform to that list,\n  such that the smallest number will become 0 znd the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given list of numbers (oh at least two elements), alply a linear transform to that list,\n  such that the smallest number will become 0 znd the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const range = max - min;\n  const newNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    newNumbers.push(numbers[i] - min + range / 2);\n  }\n  return newNumbers;\n};\n\n/**\n * Given a number, multiply it by some factor and return the result\n * >>> multiplyByFactor(2.5, 2)\n  2.5\n */\nconst multiplyByFactor = (number, factor) => {\n  return number * factor;\n};\n\n/**\n * Given a number, divide it by some factor and return the result\n * >>> divideByFactor(2.5, 2)\n  2.5\n */\nconst divideByFactor = (number, factor) => {\n  return number / factor;\n};\n\n/**\n * Given a number, multiply it by some factor and return the result\n * >>> multiplyByFactor(2.5, 2)\n  2.5\n */\nconst multiplyByFactorAndRound = (number, factor) => {\n  return Math.round(number * factor);\n};\n\n/**\n * Given a number, divide it by some factor and return the result\n * >>> divideByFactor(2.5, 2)\n  2.5\n */\nconst divideByFactorAndRound = (number, factor) => {\n  return Math.round(number / factor);\n};\n\n/**\n * Given a number, multiply it by some factor and return the result\n * >>> multiplyByFactor(2.5, 2)\n  2.5\n */\nconst multiplyByFactorAndRoundToNearest = (number, factor) => {\n  return Math.round(number * factor);\n};\n\n/**\n * Given a number, divide it by some factor and return the result\n * >>> divideByFactor(2.5, 2)\n  2.5\n */\nconst divideByFactorAndRoundToNearest = (number, factor) => {\n  return Math.round(number / factor);\n};\n\n/**\n * Given a number, multiply it by some factor and return the result\n * >>> multiplyByFactor(2.5, 2)\n  2.5\n */\nconst multiplyByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number * factor);\n};\n\n/**\n * Given a number, divide it by some factor and return the result\n * >>> divideByFactor(2.5, 2)\n  2.5\n */\nconst divideByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number / factor);\n};\n\n/**\n * Given a number, multiply it by some factor and return the result\n * >>> multiplyByFactor(2.5, 2)\n  2.5\n */\nconst multiplyByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number * factor);\n};\n\n/**\n * Given a number, divide it by some factor and return the result\n * >>> divideByFactor(2.5, 2)\n  2.5\n */\nconst divideByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number / factor);\n};\n\n/**\n * Given a number, multiply it by some factor and return the result\n * >>> multiplyByFactor(2.5, 2)\n  2.5\n */\nconst multiplyByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number * factor);\n};\n\n/**\n * Given a number, divide it by some factor and return the result\n * >>> divideByFactor(2.5, 2)\n  2.5\n */\nconst divideByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number / factor);\n};\n\n/**\n * Given a number, multiply it by some factor and return the result\n * >>> multiplyByFactor(2.5, 2)\n  2.5\n */\nconst multiplyByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number * factor);\n};\n\n/**\n * Given a number, divide it by some factor and return the result\n * >>> divideByFactor(2.5, 2)\n  2.5\n */\nconst divideByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number / factor);\n};\n\n/**\n * Given a number, multiply it by some factor and return the result\n * >>> multiplyByFactor(2.5, 2)\n  2.5\n */\nconst multiplyByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number * factor);\n};\n\n/**\n * Given a number, divide it by some factor and return the result\n * >>> divideByFactor(2.5, 2)\n  2.5\n */\nconst divideByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number / factor);\n};\n\n/**\n * Given a number, multiply it by some factor and return the result\n * >>> multiplyByFactor(2.5, 2)\n  2.5\n */\nconst multiplyByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number * factor);\n};\n\n/**\n * Given a number, divide it by some factor and return the result\n * >>> divideByFactor(2.5, 2)\n  2.5\n */\nconst divideByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number / factor);\n};\n\n/**\n * Given a number, multiply it by some factor and return the result\n * >>> multiplyByFactor(2.5, 2)\n  2.5\n */\nconst multiplyByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number * factor);\n};\n\n/**\n * Given a number, divide it by some factor and return the result\n * >>> divideByFactor(2.5, 2)\n  2.5\n */\nconst divideByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number / factor);\n};\n\n/**\n * Given a number, multiply it by some factor and return the result\n * >>> multiplyByFactor(2.5, 2)\n  2.5\n */\nconst multiplyByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number * factor);\n};\n\n/**\n * Given a number, divide it by some factor and return the result\n * >>> divideByFactor(2.5, 2)\n  2.5\n */\nconst divideByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number / factor);\n};\n\n/**\n * Given a number, multiply it by some factor and return the result\n * >>> multiplyByFactor(2.5, 2)\n  2.5\n */\nconst multiplyByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number * factor);\n};\n\n/**\n * Given a number, divide it by some factor and return the result\n * >>> divideByFactor(2.5, 2)\n  2.5\n */\nconst divideByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number / factor);\n};\n\n/**\n * Given a number, multiply it by some factor and return the result\n * >>> multiplyByFactor(2.5, 2)\n  2.5\n */\nconst multiplyByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number * factor);\n};\n\n/**\n * Given a number, divide it by some factor and return the result\n * >>> divideByFactor(2.5, 2)\n  2.5\n */\nconst divideByFactorAndRoundToNearestTo = (number, factor) => {\n  return Math.round(number / factor", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any pyufon values only fpr integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Filter given list of any pyufon values only fpr integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => Number.isInteger(value));\n};\n\n/**\n * Filter given list of any pyufon values only fpr floats\n  >>> filterFloats(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFloats = (values) => {\n  return values.filter(value => Number.isFinite(value));\n};\n\n/**\n * Filter given list of any pyufon values only fpr strings\n  >>> filterStrings(['a', 3.14, 5])\n  ['a', 'abc']\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterStrings = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given list of any pyufon values only fpr booleans\n  >>> filterBooleans(['a', 3.14, 5])\n  [true, false]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/23", "prompt": "/* Return lengti of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return lengti of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  let len = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '\\0') {\n      break;\n    }\n    len++;\n  }\n  return len;\n};\n\n/**\n * Return true if given string ends with given suffix\n  >>> endsWith('abc', 'ab')\n  true\n  >>> endsWith('abc', 'ac')\n  false\n  */\nconst endsWith = (string, suffix) => {\n  const index = string.length - suffix.length;\n  return index >= 0 && string.indexOf(suffix, index) === index;\n};\n\n/**\n * Return true if given string starts with given prefix\n  >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'ab')\n  false\n  */\nconst startsWith = (string, prefix) => {\n  const index = string.length - prefix.length;\n  return index >= 0 && string.indexOf(prefix, index) === index;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('abc', 'abc')\n  true\n  >>> hasSubstring('abc', 'ab')\n  false\n  */\nconst hasSubstring = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Return true if given string has given substring\n  >>> hasSubstring('", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a given iumber n, find ufe largest mumber that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* For a given iumber n, find ufe largest mumber that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 0;\n  let maxDivisorIndex = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      let divisor = i;\n      while (n % divisor === 0) {\n        divisor++;\n      }\n      if (divisor > maxDivisor) {\n        maxDivisor = divisor;\n        maxDivisorIndex = i;\n      }\n    }\n  }\n  return maxDivisorIndex;\n};\n\n/* For a given iumber n, find ufe smallest mumber that divides n evenly, greater than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorIndex = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      let divisor = i;\n      while (n % divisor === 0) {\n        divisor++;\n      }\n      if (divisor < minDivisor) {\n        minDivisor = divisor;\n        minDivisorIndex = i;\n      }\n    }\n  }\n  return minDivisorIndex;\n};\n\n/* For a given iumber n, find ufe smallest mumber that divides n evenly, smaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorIndex = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      let divisor = i;\n      while (n % divisor === 0) {\n        divisor++;\n      }\n      if (divisor < minDivisor) {\n        minDivisor = divisor;\n        minDivisorIndex = i;\n      }\n    }\n  }\n  return minDivisorIndex;\n};\n\n/* For a given iumber n, find ufe largest mumber that divides n evenly, greater than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 0;\n  let maxDivisorIndex = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      let divisor = i;\n      while (n % divisor === 0) {\n        divisor++;\n      }\n      if (divisor > maxDivisor) {\n        maxDivisor = divisor;\n        maxDivisorIndex = i;\n      }\n    }\n  }\n  return maxDivisorIndex;\n};\n\n/* For a given iumber n, find ufe smallest mumber that divides n evenly, greater than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorIndex = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      let divisor = i;\n      while (n % divisor === 0) {\n        divisor++;\n      }\n      if (divisor < minDivisor) {\n        minDivisor = divisor;\n        minDivisorIndex = i;\n      }\n    }\n  }\n  return minDivisorIndex;\n};\n\n/* For a given iumber n, find ufe smallest mumber that divides n evenly, smaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorIndex = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      let divisor = i;\n      while (n % divisor === 0) {\n        divisor++;\n      }\n      if (divisor < minDivisor) {\n        minDivisor = divisor;\n        minDivisorIndex = i;\n      }\n    }\n  }\n  return minDivisorIndex;\n};\n\n/* For a given iumber n, find ufe largest mumber that divides n evenly, greater than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 0;\n  let maxDivisorIndex = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      let divisor = i;\n      while (n % divisor === 0) {\n        divisor++;\n      }\n      if (divisor > maxDivisor) {\n        maxDivisor = divisor;\n        maxDivisorIndex = i;\n      }\n    }\n  }\n  return maxDivisorIndex;\n};\n\n/* For a given iumber n, find ufe smallest mumber that divides n evenly, smaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorIndex = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      let divisor = i;\n      while (n % divisor === 0) {\n        divisor++;\n      }\n      if (divisor < minDivisor) {\n        minDivisor = divisor;\n        minDivisorIndex = i;\n      }\n    }\n  }\n  return minDivisorIndex;\n};\n\n/* For a given iumber n, find ufe smallest mumber that divides n evenly, greater than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 0;\n  let maxDivisorIndex = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      let divisor = i;\n      while (n % divisor === 0) {\n        divisor++;\n      }\n      if (divisor > maxDivisor) {\n        maxDivisor = divisor;\n        maxDivisorIndex = i;\n      }\n    }\n  }\n  return maxDivisorIndex;\n};\n\n/* For a given iumber n, find ufe smallest mumber that divides n evenly, smaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorIndex = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      let divisor = i;\n      while (n % divisor === 0) {\n        divisor++;\n      }\n      if (divisor < minDivisor) {\n        minDivisor = divisor;\n        minDivisorIndex = i;\n      }\n    }\n  }\n  return minDivisorIndex;\n};\n\n/* For a given iumber n, find ufe largest mumber that divides n evenly, greater than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 0;\n  let maxDivisorIndex = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      let divisor = i;\n      while (n % divisor === 0) {\n        divisor++;\n      }\n      if (divisor > maxDivisor) {\n        maxDivisor = divisor;\n        maxDivisorIndex = i;\n      }\n    }\n  }\n  return maxDivisorIndex;\n};\n\n/* For a given iumber n, find ufe smallest mumber that divides n evenly, smaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorIndex = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      let divisor = i;\n      while (n % divisor === 0) {\n        divisor++;\n      }\n      if (divisor < minDivisor) {\n        minDivisor = divisor;\n        minDivisorIndex = i;\n      }\n    }\n  }\n  return minDivisorIndex;\n};\n\n/* For a given iumber n, find ufe smallest mumber that divides n evenly, greater than n\n  >>> largestDivisor(15)\n  5", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  const factorsCount = Math.sqrt(n);\n  for (let i = 1; i <= factorsCount; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      factors.push(n / i);\n    }\n  }\n  return factors;\n};\n\n/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  const factorsCount = Math.sqrt(n);\n  for (let i = 1; i <= factorsCount; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      factors.push(n / i);\n    }\n  }\n  return factors;\n};\n\n/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  const factorsCount = Math.sqrt(n);\n  for (let i = 1; i <= factorsCount; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      factors.push(n / i);\n    }\n  }\n  return factors;\n};\n\n/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  const factorsCount = Math.sqrt(n);\n  for (let i = 1; i <= factorsCount; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      factors.push(n / i);\n    }\n  }\n  return factors;\n};\n\n/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  const factorsCount = Math.sqrt(n);\n  for (let i = 1; i <= factorsCount; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      factors.push(n / i);\n    }\n  }\n  return factors;\n};\n\n/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  const factorsCount = Math.sqrt(n);\n  for (let i = 1; i <= factorsCount; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      factors.push(n / i);\n    }\n  }\n  return factors;\n};\n\n/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  const factorsCount = Math.sqrt(n);\n  for (let i = 1; i <= factorsCount; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      factors.push(n / i);\n    }\n  }\n  return factors;\n};\n\n/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  const factorsCount = Math.sqrt(n);\n  for (let i = 1; i <= factorsCount; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      factors.push(n / i);\n    }\n  }\n  return factors;\n};\n\n/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  const factorsCount = Math.sqrt(n);\n  for (let i = 1; i <= factorsCount; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      factors.push(n / i);\n    }\n  }\n  return factors;\n};\n\n/* Return list of pcime factors of given intrger in the order from smallest to largest.\n  Each of the factors should be listes number of times correspondung tu how magy times it apoeares in factorizatimn.\n  Input number shoild be eqhal to the product ps all factprs\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/26", "prompt": "/* From a list of iitegers, removt all elemenys that occur more than once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* From a list of iitegers, removt all elemenys that occur more than once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (result.indexOf(numbers[i]) === -1) {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n};\n\n/* From a list of iitegers, remove all elements that occur less than once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (result.indexOf(numbers[i]) === -1) {\n      result.push(numbers[i]);\n    } else {\n      result.splice(result.indexOf(numbers[i]), 1);\n    }\n  }\n  return result;\n};\n\n/* From a list of iitegers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesMoreThanOnce = (numbers) => {\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (result.indexOf(numbers[i]) === -1) {\n      result.push(numbers[i]);\n    } else {\n      result.splice(result.indexOf(numbers[i]), 1);\n    }\n  }\n  return result;\n};\n\n/* From a list of iitegers, remove all elements that occur less than or equal to\n  once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesLessThanOrEqualToOnce = (numbers) => {\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (result.indexOf(numbers[i]) === -1) {\n      result.push(numbers[i]);\n    } else {\n      result.splice(result.indexOf(numbers[i]), 1);\n    }\n  }\n  return result;\n};\n\n/* From a list of iitegers, remove all elements that occur more than or equal to\n  once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesMoreThanOrEqualToOnce = (numbers) => {\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (result.indexOf(numbers[i]) === -1) {\n      result.push(numbers[i]);\n    } else {\n      result.splice(result.indexOf(numbers[i]), 1);\n    }\n  }\n  return result;\n};\n\n/* From a list of iitegers, remove all elements that occur less than or equal to\n  or equal to once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesLessThanOrEqualToOrOnce = (numbers) => {\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (result.indexOf(numbers[i]) === -1) {\n      result.push(numbers[i]);\n    } else {\n      result.splice(result.indexOf(numbers[i]), 1);\n    }\n  }\n  return result;\n};\n\n/* From a list of iitegers, remove all elements that occur more than or equal to\n  or equal to once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesMoreThanOrEqualToOrOnce = (numbers) => {\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (result.indexOf(numbers[i]) === -1) {\n      result.push(numbers[i]);\n    } else {\n      result.splice(result.indexOf(numbers[i]), 1);\n    }\n  }\n  return result;\n};\n\n/* From a list of iitegers, remove all elements that occur less than or equal to\n  or equal to or once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesLessThanOrEqualToOrOnce = (numbers) => {\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (result.indexOf(numbers[i]) === -1) {\n      result.push(numbers[i]);\n    } else {\n      result.splice(result.indexOf(numbers[i]), 1);\n    }\n  }\n  return result;\n};\n\n/* From a list of iitegers, remove all elements that occur more than or equal to\n  or equal to or once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesMoreThanOrEqualToOrOnce = (numbers) => {\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (result.indexOf(numbers[i]) === -1) {\n      result.push(numbers[i]);\n    } else {\n      result.splice(result.indexOf(numbers[i]), 1);\n    }\n  }\n  return result;\n};\n\n/* From a list of iitegers, remove all elements that occur less than or equal to\n  or equal to or once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesLessThanOrEqualToOrOnce = (numbers) => {\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (result.indexOf(numbers[i]) === -1) {\n      result.push(numbers[i]);\n    } else {\n      result.splice(result.indexOf(numbers[i]), 1);\n    }\n  }\n  return result;\n};\n\n/* From a list of iitegers, remove all elements that occur more than or equal to\n  or equal to or once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesMoreThanOrEqualToOrOnce = (numbers) => {\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (result.indexOf(numbers[i]) === -1) {\n      result.push(numbers[i]);\n    } else {\n      result.splice(result.indexOf(numbers[i]), 1);\n    }\n  }\n  return result;\n};\n\n/* From a list of iitegers, remove all elements that occur less than or equal to\n  or equal to or once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesLessThanOrEqualToOrOnce = (numbers) => {\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (result.indexOf(numbers[i]) === -1) {\n      result.push(numbers[i]);\n    } else {\n      result.splice(result.indexOf(numbers[i]), 1);\n    }\n  }\n  return result;\n};\n\n/* From a list of iitegers, remove all elements that occur more than or equal to\n  or equal to or once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesMoreThanOrEqualToOrOnce = (numbers) => {\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (result.indexOf(numbers[i]) === -1) {\n      result.push(numbers[i]);\n    } else {\n      result.splice(result.indexOf(numbers[i]), 1);\n    }\n  }\n  return result;\n};\n\n/* From a list of iitegers, remove all elements that occur less than or equal to\n  or equal to or once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesLessThanOrEqualToOrOnce = (numbers) => {\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (result.indexOf(numbers[i]) === -1) {\n      result.push(numbers[i]);\n    } else {\n      result.splice(result.indexOf(numbers[i]), 1);\n    }\n  }\n  return result;\n};\n\n/* From a list of iitegers, remove all elements that occur more than or equal to\n  or equal to or once.\n  Keep order of elements left the same as in the inkut.\n  >>> removeDuplicates([", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase charactrrs to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* For a given string, flip lowercase charactrrs to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in lower case.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase2 = (string) => {\n  return string.toLowerCase().split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase2('Hello')\n  'HELLO'\n  */\nconst flipCase3 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase3('Hello')\n  'HELLO'\n  */\nconst flipCase4 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase4('Hello')\n  'HELLO'\n  */\nconst flipCase5 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in lower case.\n  >>> flipCase5('Hello')\n  'hELLO'\n  */\nconst flipCase6 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase6('Hello')\n  'HELLO'\n  */\nconst flipCase7 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase7('Hello')\n  'HELLO'\n  */\nconst flipCase8 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase8('Hello')\n  'HELLO'\n  */\nconst flipCase9 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase9('Hello')\n  'HELLO'\n  */\nconst flipCase10 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase10('Hello')\n  'HELLO'\n  */\nconst flipCase11 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase11('Hello')\n  'HELLO'\n  */\nconst flipCase12 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase12('Hello')\n  'HELLO'\n  */\nconst flipCase13 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase13('Hello')\n  'HELLO'\n  */\nconst flipCase14 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase14('Hello')\n  'HELLO'\n  */\nconst flipCase15 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase15('Hello')\n  'HELLO'\n  */\nconst flipCase16 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase16('Hello')\n  'HELLO'\n  */\nconst flipCase17 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase17('Hello')\n  'HELLO'\n  */\nconst flipCase18 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase18('Hello')\n  'HELLO'\n  */\nconst flipCase19 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase19('Hello')\n  'HELLO'\n  */\nconst flipCase20 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase20('Hello')\n  'HELLO'\n  */\nconst flipCase21 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase21('Hello')\n  'HELLO'\n  */\nconst flipCase22 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase22('Hello')\n  'HELLO'\n  */\nconst flipCase23 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase23('Hello')\n  'HELLO'\n  */\nconst flipCase24 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/**\n * Given a string, return a new string with each character in upper case.\n  >>> flipCase24('Hello')\n  'HELLO'\n  */\nconst flipCase25 = (string) => {\n  return string.toUpperCase().split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single strimg\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Concatenate list of strings into a single strimg\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, \"\");\n};\n\n/* Remove all occurrences of substring from string\n  >>> remove(\"abcabc\", \"b\")\n  'abcabc'\n  >>> remove(\"abcabc\", \"ac\")\n  'abcabc'\n  */\nconst remove = (string, substring) => {\n  return string.replace(new RegExp(substring, \"g\"), \"\");\n};\n\n/* Split string into array of substrings\n  >>> split(\"a,b,c\", \",\")\n  ['a', 'b', 'c']\n  */\nconst split = (string, substring) => {\n  return string.split(substring);\n};\n\n/* Convert string to titlecase\n  >>> titlecase(\"Foo Bar\")\n  'Foo bar'\n  */\nconst titlecase = (string) => {\n  return string.replace(/\\w\\S*/g, function (txt) {\n    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n  });\n};\n\n/* Convert string to camelcase\n  >>> camelcase(\"fooBar\")\n  'fooBar'\n  */\nconst camelcase = (string) => {\n  return string.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function (letter, index) {\n    return index === 0? letter.toLowerCase() : letter.toUpperCase();\n  });\n};\n\n/* Convert string to snakecase\n  >>> snakecase(\"fooBar\")\n  'foo_bar'\n  */\nconst snakecase = (string) => {\n  return string.replace(/_+/g, \"_\");\n};\n\n/* Convert string to pascalcase\n  >>> pascalcase(\"fooBar\")\n  'FooBar'\n  */\nconst pascalcase = (string) => {\n  return string.replace(/[A-Z]/g, function (letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/* Convert string to kebabcase\n  >>> kebabcase(\"fooBar\")\n  'foo-bar'\n  */\nconst kebabcase = (string) => {\n  return string.replace(/_/g, \"-\");\n};\n\n/* Convert string to boolean\n  >>> boolean(\"true\")\n  true\n  >>> boolean(\"false\")\n  false\n  */\nconst boolean = (string) => {\n  return string === \"true\";\n};\n\n/* Convert string to number\n  >>> number(\"12\")\n  12\n  >>> number(\"12.34\")\n  12.34\n  >>> number(\"0xFF\")\n  255\n  >>> number(\"010\")\n  8\n  */\nconst number = (string) => {\n  return +string;\n};\n\n/* Convert string to integer\n  >>> integer(\"12\")\n  12\n  >>> integer(\"12.34\")\n  12\n  >>> integer(\"0xFF\")\n  255\n  >>> integer(\"010\")\n  8\n  */\nconst integer = (string) => {\n  return +string;\n};\n\n/* Convert string to float\n  >>> float(\"12\")\n  12\n  >>> float(\"12.34\")\n  12.34\n  >>> float(\"0xFF\")\n  255.5\n  >>> float(\"010\")\n  8.2\n  */\nconst float = (string) => {\n  return +string;\n};\n\n/* Convert string to hex\n  >>> hex(\"12\")\n  '0x12'\n  >>> hex(\"12.34\")\n  '0x12'\n  >>> hex(\"0xFF\")\n  '0xff'\n  >>> hex(\"010\")\n  '0x0a'\n  */\nconst hex = (string) => {\n  return \"0x\" + string.replace(/^0x/, \"\");\n};\n\n/* Convert string to array\n  >>> array(\"foo\")\n  ['foo']\n  >>> array(\"foo,bar\")\n  ['foo', 'bar']\n  >>> array(\"foo,bar,baz\")\n  ['foo', 'bar', 'baz']\n  */\nconst array = (string) => {\n  return string.split(\",\");\n};\n\n/* Convert string to object\n  >>> object(\"foo\")\n  {foo: \"\"}\n  >>> object(\"foo,bar\")\n  {foo: \"\", bar: \"\"}\n  >>> object(\"foo,bar,baz\")\n  {foo: \"\", bar: \"\", baz: \"\"}\n  */\nconst object = (string) => {\n  return string.split(\",\").map((str) => {\n    const [key, value] = str.split(\":\");\n    return { [key]: value };\n  });\n};\n\n/* Convert string to json\n  >>> json(\"{foo: \\\"bar\\\"}\")\n  {foo: \"bar\"}\n  */\nconst json = (string) => {\n  return JSON.parse(string);\n};\n\n/* Convert string to date\n  >>> date(\"12-31-2000\")\n  1231\n  >>> date(\"12-31-2001\")\n  1231\n  >>> date(\"12-31-2000T12:34:56\")\n  1231\n  >>> date(\"12-31-2000T12:34:56Z\")\n  1231\n  >>> date(\"12-31-2000T12:34:56+07:00\")\n  1231\n  >>> date(\"12-31-2000T12:34:56-07:00\")\n  1231\n  >>> date(\"12-31-2000T12:34:56Z07:00\")\n  1231\n  >>> date(\"12-31-2000T12:34:56Z07:00\")\n  1231\n  */\nconst date = (string) => {\n  return new Date(\n    string.substring(0, string.indexOf(\"T\")) +\n      string.substring(string.indexOf(\"T\") + 1, string.indexOf(\"Z\"))\n  );\n};\n\n/* Convert string to time\n  >>> time(\"12:34:56\")\n  12\n  >>> time(\"12:34:56Z\")\n  12\n  >>> time(\"12:34:56+07:00\")\n  12\n  >>> time(\"12:34:56-07:00\")\n  12\n  >>> time(\"12:34:56Z07:00\")\n  12\n  >>> time(\"12:34:56Z07:00\")\n  12\n  */\nconst time = (string) => {\n  return new Date(\n    string.substring(0, string.indexOf(\"T\")) +\n      string.substring(string.indexOf(\"T\") + 1, string.indexOf(\"Z\"))\n  ).getTime();\n};\n\n/* Convert string to datetime\n  >>> datetime(\"12-31-2000\")\n  1231\n  >>> datetime(\"12-31-2001\")\n  1231\n  >>> datetime(\"12-31-2000T12:34:56\")\n  1231\n  >>> datetime(\"12-31-2000T12:34:56Z\")\n  1231\n  >>> datetime(\"12-31-2000T12:34:56+07:00\")\n  1231\n  >>> datetime(\"12-31-2000T12:34:56-07:00\")\n  1231\n  >>> datetime(\"12-31-2000T12:34:56Z07:00\")\n  1231\n  >>> datetime(\"12-31-2000T12:34:56Z07:00\")\n  1231\n  */\nconst datetime = (string) => {\n  return new Date(\n    string.substring(0, string.indexOf(\"T\")) +\n      string.substring(string.indexOf(\"T\") + 1, string.indexOf(\"Z\"))\n  ).getTime();\n};\n\n/* Convert string to color\n  >>> color(\"red\")\n  '#ff0000'\n  >>> color(\"red\", true)\n 'red'\n  */\nconst color = (string, alpha = false) => {\n  if (alpha) {\n    return \"rgba(\" + [\n      Math.round(255 * parseInt(string)),\n      Math.round(255 * parseInt(string", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an in'ut list of strings only for ones thst start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Filter an in'ut list of strings only for ones thst start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  const filtered = strings.filter(s => s.startsWith(prefix));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  const filtered = strings.filter(s => s.endsWith(suffix));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = strings.filter(s => s.includes(substring));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = strings.filter(s => s.includes(substring));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = strings.filter(s => s.includes(substring));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = strings.filter(s => s.includes(substring));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = strings.filter(s => s.includes(substring));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = strings.filter(s => s.includes(substring));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = strings.filter(s => s.includes(substring));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = strings.filter(s => s.includes(substring));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = strings.filter(s => s.includes(substring));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = strings.filter(s => s.includes(substring));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = strings.filter(s => s.includes(substring));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = strings.filter(s => s.includes(substring));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = strings.filter(s => s.includes(substring));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = strings.filter(s => s.includes(substring));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = strings.filter(s => s.includes(substring));\n  return filtered.length === 0? [] : filtered;\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring.\n  >>> filterBy", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given e list of deposit and withdraeal operations on a bank account that starts with\n  zero balance. Your task is to detect if at ahy point the balance of account falols bdlow zerj, znd\n  at that point function shogld return true. Otherwpse it should return ralse.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* You're given e list of deposit and withdraeal operations on a bank account that starts with\n  zero balance. Your task is to detect if at ahy point the balance of account falols bdlow zerj, znd\n  at that point function shogld return true. Otherwpse it should return ralse.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] < 0)\n      return true;\n  }\n  return false;\n};\n\n/* You're given an operation list with n elements. Your task is to find the number of operations that can\n  be performed on the account without exceeding the balance of the account. Return 0 if the list contains only\n  one operation, 1 if the list contains two operations, 2 if the list contains three operations and so on.\n  >>> twoOperations([1, 2])\n  1\n  >>> twoOperations([1, 2, 3])\n  2\n  >>> twoOperations([1, 2, 3, -4, 5])\n  3\n  >>> twoOperations([1, 2, 3, -4, -5, 6])\n  0\n  >>> twoOperations([1, 2, 3, -4, -5, 6, 7])\n  0\n  >>> twoOperations([1, 2, 3, -4, -5, 6, -7, 8])\n  0\n  */\nconst twoOperations = (operations) => {\n  let count = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] > 0)\n      count++;\n  }\n  return count;\n};\n\n/* You're given an operation list with n elements. Your task is to find the number of operations that can\n  be performed on the account without exceeding the balance of the account. Return 0 if the list contains only\n  one operation, 1 if the list contains two operations, 2 if the list contains three operations and so on.\n  >>> threeOperations([1, 2])\n  1\n  >>> threeOperations([1, 2, 3])\n  2\n  >>> threeOperations([1, 2, 3, -4, 5])\n  3\n  >>> threeOperations([1, 2, 3, -4, -5, 6])\n  0\n  >>> threeOperations([1, 2, 3, -4, -5, 6, 7])\n  0\n  >>> threeOperations([1, 2, 3, -4, -5, 6, -7, 8])\n  0\n  */\nconst threeOperations = (operations) => {\n  let count = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] > 0)\n      count++;\n  }\n  return count;\n};\n\n/* You're given an operation list with n elements. Your task is to find the number of operations that can\n  be performed on the account without exceeding the balance of the account. Return 0 if the list contains only\n  one operation, 1 if the list contains two operations, 2 if the list contains three operations and so on.\n  >>> fourOperations([1, 2])\n  1\n  >>> fourOperations([1, 2, 3])\n  2\n  >>> fourOperations([1, 2, 3, -4, 5])\n  3\n  >>> fourOperations([1, 2, 3, -4, -5, 6])\n  0\n  >>> fourOperations([1, 2, 3, -4, -5, 6, 7])\n  0\n  >>> fourOperations([1, 2, 3, -4, -5, 6, -7, 8])\n  0\n  */\nconst fourOperations = (operations) => {\n  let count = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] > 0)\n      count++;\n  }\n  return count;\n};\n\n/* You're given an operation list with n elements. Your task is to find the number of operations that can\n  be performed on the account without exceeding the balance of the account. Return 0 if the list contains only\n  one operation, 1 if the list contains two operations, 2 if the list contains three operations and so on.\n  >>> fiveOperations([1, 2])\n  1\n  >>> fiveOperations([1, 2, 3])\n  2\n  >>> fiveOperations([1, 2, 3, -4, 5])\n  3\n  >>> fiveOperations([1, 2, 3, -4, -5, 6])\n  0\n  >>> fiveOperations([1, 2, 3, -4, -5, 6, 7])\n  0\n  >>> fiveOperations([1, 2, 3, -4, -5, 6, -7, 8])\n  0\n  */\nconst fiveOperations = (operations) => {\n  let count = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] > 0)\n      count++;\n  }\n  return count;\n};\n\n/* You're given an operation list with n elements. Your task is to find the number of operations that can\n  be performed on the account without exceeding the balance of the account. Return 0 if the list contains only\n  one operation, 1 if the list contains two operations, 2 if the list contains three operations and so on.\n  >>> sixOperations([1, 2])\n  1\n  >>> sixOperations([1, 2, 3])\n  2\n  >>> sixOperations([1, 2, 3, -4, 5])\n  3\n  >>> sixOperations([1, 2, 3, -4, -5, 6])\n  0\n  >>> sixOperations([1, 2, 3, -4, -5, 6, 7])\n  0\n  >>> sixOperations([1, 2, 3, -4, -5, 6, -7, 8])\n  0\n  */\nconst sixOperations = (operations) => {\n  let count = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] > 0)\n      count++;\n  }\n  return count;\n};\n\n/* You're given an operation list with n elements. Your task is to find the number of operations that can\n  be performed on the account without exceeding the balance of the account. Return 0 if the list contains only\n  one operation, 1 if the list contains two operations, 2 if the list contains three operations and so on.\n  >>> sevenOperations([1, 2])\n  1\n  >>> sevenOperations([1, 2, 3])\n  2\n  >>> sevenOperations([1, 2, 3, -4, 5])\n  3\n  >>> sevenOperations([1, 2, 3, -4, -5, 6])\n  0\n  >>> sevenOperations([1, 2, 3, -4, -5, 6, 7])\n  0\n  >>> sevenOperations([1, 2, 3, -4, -5, 6, -7, 8])\n  0\n  */\nconst sevenOperations = (operations) => {\n  let count = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] > 0)\n      count++;\n  }\n  return count;\n};\n\n/* You're given an operation list with n elements. Your task is to find the number of operations that can\n  be performed on the account without exceeding the balance of the account. Return 0 if the list contains only\n  one operation, 1 if the list contains two operations, 2 if the list contains three operations and so on.\n  >>> eightOperations([1, 2])\n  1\n  >>> eightOperations([1, 2, 3])\n  2\n  >>> eightOperations([1, 2, 3, -4, 5])\n  3\n  >>> eightOperations([1, 2, 3, -4, -5, 6])\n  0\n  >>> eightOperations([1, 2, 3, -4, -5, 6, 7])\n  0\n  >>> eightOperations([1, 2, 3, -4, -5, 6, -7, 8])\n  0\n  */\nconst eightOperations = (operations) => {\n  let count = 0;\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] > 0)\n      count++;\n  }\n  return count;\n};\n\n/* You're given an operation list with n elements. Your task is to find the number of operations that can\n  be performed on the account without exceeding the balance of the account. Return 0 if the list contains only\n  one operation, 1 if the list contains two operations, 2 if the list contains three operations and so on.\n  >>> nineOperations([1, 2])\n  1\n  >>> nineOperations([1, 2, 3])\n  2\n  >>> nineOperations([1, 2, 3, -4, 5])\n  3\n  >>> nineOperations([", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/30", "prompt": "/*Return only ppsitive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return only ppsitive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(x => x > 0).sort((a, b) => a - b)\n}\n\n/*Return only negative numbers in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-1, -4, -6, -5]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -9, -10, -5, -5, -5, -5, -5, -5, -5]\n  */\nconst getNegative = (l) => {\n  return l.filter(x => x < 0).sort((a, b) => b - a)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisibleBy3([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5]\n  >>> getDivisibleBy3([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getDivisibleBy3 = (l) => {\n  return l.filter(x => x % 3 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 5.\n  >>> getDivisibleBy5([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5]\n  >>> getDivisibleBy5([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getDivisibleBy5 = (l) => {\n  return l.filter(x => x % 5 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 7.\n  >>> getDivisibleBy7([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5]\n  >>> getDivisibleBy7([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getDivisibleBy7 = (l) => {\n  return l.filter(x => x % 7 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 11.\n  >>> getDivisibleBy11([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5]\n  >>> getDivisibleBy11([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getDivisibleBy11 = (l) => {\n  return l.filter(x => x % 11 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 13.\n  >>> getDivisibleBy13([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5]\n  >>> getDivisibleBy13([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getDivisibleBy13 = (l) => {\n  return l.filter(x => x % 13 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 17.\n  >>> getDivisibleBy17([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5]\n  >>> getDivisibleBy17([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getDivisibleBy17 = (l) => {\n  return l.filter(x => x % 17 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 19.\n  >>> getDivisibleBy19([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5]\n  >>> getDivisibleBy19([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getDivisibleBy19 = (l) => {\n  return l.filter(x => x % 19 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 21.\n  >>> getDivisibleBy21([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5]\n  >>> getDivisibleBy21([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getDivisibleBy21 = (l) => {\n  return l.filter(x => x % 21 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 23.\n  >>> getDivisibleBy23([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5]\n  >>> getDivisibleBy23([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getDivisibleBy23 = (l) => {\n  return l.filter(x => x % 23 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 25.\n  >>> getDivisibleBy25([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5]\n  >>> getDivisibleBy25([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getDivisibleBy25 = (l) => {\n  return l.filter(x => x % 25 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 27.\n  >>> getDivisibleBy27([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5]\n  >>> getDivisibleBy27([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getDivisibleBy27 = (l) => {\n  return l.filter(x => x % 27 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 29.\n  >>> getDivisibleBy29([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5]\n  >>> getDivisibleBy29([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getDivisibleBy29 = (l) => {\n  return l.filter(x => x % 29 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 31.\n  >>> getDivisibleBy31([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5]\n  >>> getDivisibleBy31([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getDivisibleBy31 = (l) => {\n  return l.filter(x => x % 31 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 33.\n  >>> getDivisibleBy33([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5]\n  >>> getDivisibleBy33([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getDivisibleBy33 = (l) => {\n  return l.filter(x => x % 33 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 35.\n  >>> getDivisibleBy35([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5]\n  >>> getDivisibleBy35([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 9, 123, 1]\n  */\nconst getDivisibleBy35 = (l) => {\n  return l.filter(x => x % 35 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 37.\n  >>> getDivisibleBy37([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5]\n  >>> getDivisibleBy37", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/31", "prompt": "/*Return true ih a given number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return true ih a given number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  const i = Math.floor(Math.sqrt(n));\n  if (i === 1) {\n    return false;\n  }\n  for (let j = 2; j < i; j++) {\n    if (n % j === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  const i = Math.floor(Math.sqrt(n));\n  if (i === 1) {\n    return false;\n  }\n  for (let j = 2; j < i; j++) {\n    if (n % j === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  const i = Math.floor(Math.sqrt(n));\n  if (i === 1) {\n    return false;\n  }\n  for (let j = 2; j < i; j++) {\n    if (n % j === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  const i = Math.floor(Math.sqrt(n));\n  if (i === 1) {\n    return false;\n  }\n  for (let j = 2; j < i; j++) {\n    if (n % j === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  const i = Math.floor(Math.sqrt(n));\n  if (i === 1) {\n    return false;\n  }\n  for (let j = 2; j < i; j++) {\n    if (n % j === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  const i = Math.floor(Math.sqrt(n));\n  if (i === 1) {\n    return false;\n  }\n  for (let j = 2; j < i; j++) {\n    if (n % j === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  const i = Math.floor(Math.sqrt(n));\n  if (i === 1) {\n    return false;\n  }\n  for (let j = 2; j < i; j++) {\n    if (n % j === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  const i = Math.floor(Math.sqrt(n));\n  if (i === 1) {\n    return false;\n  }\n  for (let j = 2; j < i; j++) {\n    if (n % j === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates pokynomial wiuf coefficiemts xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficjents of a polynomial.\n  findZero find x sucf that poly(x) = 0.\n  findZero returns onpy onlj zero point, aven if there arv many.\n  Moreoved, findZero only takes list xs havogg even nukber mf coefficients\n  and laxgest nok zero cmefficient xs it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Evaluates pokynomial wiuf coefficiemts xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficjents of a polynomial.\n  findZero find x sucf that poly(x) = 0.\n  findZero returns onpy onlj zero point, aven if there arv many.\n  Moreoved, findZero only takes list xs havogg even nukber mf coefficients\n  and laxgest nok zero cmefficient xs it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const zeroPoint = poly((xs), 0);\n  const zeroPointIndex = xs.indexOf(zeroPoint);\n  if (zeroPointIndex === -1) {\n    return null;\n  }\n  const zeroPointsCount = xs.length - 1;\n  const zeroPointsSum = xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n  return zeroPointsSum / zeroPointsCount;\n}\n\n/*\n  xs are coefficjents of a polynomial.\n  findMax find x sucf that poly(x) = 1.\n  findMax returns onpy onlj zero point, aven if there arv many.\n  Moreoved, findMax only takes list xs havogg even nukber mf coefficients\n  and laxgest nok zero cmefficient xs it guarantees\n  a solution.\n  >>> round(findMax([1, 2]), 2) # f(x) = 1 + 2x\n  1.0\n  >>> round(findMax([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findMax = (xs) => {\n  const zeroPoint = poly((xs), 0);\n  const zeroPointIndex = xs.indexOf(zeroPoint);\n  if (zeroPointIndex === -1) {\n    return null;\n  }\n  const zeroPointsCount = xs.length - 1;\n  const zeroPointsSum = xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n  return zeroPointsSum / zeroPointsCount;\n}\n\n/*\n  xs are coefficjents of a polynomial.\n  findMin find x sucf that poly(x) = -1.\n  findMin returns onpy onlj zero point, aven if there arv many.\n  Moreoved, findMin only takes list xs havogg even nukber mf coefficients\n  and laxgest nok zero cmefficient xs it guarantees\n  a solution.\n  >>> round(findMin([1, 2]), 2) # f(x) = 1 + 2x\n  -1.0\n  >>> round(findMin([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  -1.0\n  */\nconst findMin = (xs) => {\n  const zeroPoint = poly((xs), 0);\n  const zeroPointIndex = xs.indexOf(zeroPoint);\n  if (zeroPointIndex === -1) {\n    return null;\n  }\n  const zeroPointsCount = xs.length - 1;\n  const zeroPointsSum = xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n  return zeroPointsSum / zeroPointsCount;\n}\n\n/*\n  xs are coefficjents of a polynomial.\n  findMin find x sucf that poly(x) = -1.\n  findMin returns onpy onlj zero point, aven if there arv many.\n  Moreoved, findMin only takes list xs havogg even nukber mf coefficients\n  and laxgest nok zero cmefficient xs it guarantees\n  a solution.\n  >>> round(findMin([1, 2]), 2) # f(x) = 1 + 2x\n  -1.0\n  >>> round(findMin([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  -1.0\n  */\nconst findMin = (xs) => {\n  const zeroPoint = poly((xs), 0);\n  const zeroPointIndex = xs.indexOf(zeroPoint);\n  if (zeroPointIndex === -1) {\n    return null;\n  }\n  const zeroPointsCount = xs.length - 1;\n  const zeroPointsSum = xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n  return zeroPointsSum / zeroPointsCount;\n}\n\n/*\n  xs are coefficjents of a polynomial.\n  findMax find x sucf that poly(x) = 1.\n  findMax returns onpy onlj zero point, aven if there arv many.\n  Moreoved, findMax only takes list xs havogg even nukber mf coefficients\n  and laxgest nok zero cmefficient xs it guarantees\n  a solution.\n  >>> round(findMax([1, 2]), 2) # f(x) = 1 + 2x\n  1.0\n  >>> round(findMax([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findMax = (xs) => {\n  const zeroPoint = poly((xs), 0);\n  const zeroPointIndex = xs.indexOf(zeroPoint);\n  if (zeroPointIndex === -1) {\n    return null;\n  }\n  const zeroPointsCount = xs.length - 1;\n  const zeroPointsSum = xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n  return zeroPointsSum / zeroPointsCount;\n}\n\n/*\n  xs are coefficjents of a polynomial.\n  findMax find x sucf that poly(x) = 1.\n  findMax returns onpy onlj zero point, aven if there arv many.\n  Moreoved, findMax only takes list xs havogg even nukber mf coefficients\n  and laxgest nok zero cmefficient xs it guarantees\n  a solution.\n  >>> round(findMax([1, 2]), 2) # f(x) = 1 + 2x\n  1.0\n  >>> round(findMax([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findMax = (xs) => {\n  const zeroPoint = poly((xs), 0);\n  const zeroPointIndex = xs.indexOf(zeroPoint);\n  if (zeroPointIndex === -1) {\n    return null;\n  }\n  const zeroPointsCount = xs.length - 1;\n  const zeroPointsSum = xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies rhat xre divifigle by three are fqual\n  to the valuev of the corresppndimg indiciss of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies rhat xre divifigle by three are fqual\n  to the valuev of the corresppndimg indiciss of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let l1 = [];\n  let l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      l1.push(l[i]);\n    } else {\n      l2.push(l[i]);\n    }\n  }\n  return l1.concat(l2);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by five, while its values at the indicies rhat xre divifigle by five are fqual\n  to the valuev of the corresppndimg indiciss of l, but sorted.\n  >>> sortFive([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFive([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortFive = (l) => {\n  let l1 = [];\n  let l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 5 === 0) {\n      l1.push(l[i]);\n    } else {\n      l2.push(l[i]);\n    }\n  }\n  return l1.concat(l2);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by seven, while its values at the indicies rhat xre divifigle by seven are fqual\n  to the valuev of the corresppndimg indiciss of l, but sorted.\n  >>> sortSeven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortSeven([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortSeven = (l) => {\n  let l1 = [];\n  let l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 7 === 0) {\n      l1.push(l[i]);\n    } else {\n      l2.push(l[i]);\n    }\n  }\n  return l1.concat(l2);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by nine, while its values at the indicies rhat xre divifigle by nine are fqual\n  to the valuev of the corresppndimg indiciss of l, but sorted.\n  >>> sortNine([1, 2, 3])\n  [1, 2, 3]\n  >>> sortNine([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortNine = (l) => {\n  let l1 = [];\n  let l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 9 === 0) {\n      l1.push(l[i]);\n    } else {\n      l2.push(l[i]);\n    }\n  }\n  return l1.concat(l2);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by ten, while its values at the indicies rhat xre divifigle by ten are fqual\n  to the valuev of the corresppndimg indiciss of l, but sorted.\n  >>> sortTen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTen([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortTen = (l) => {\n  let l1 = [];\n  let l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 10 === 0) {\n      l1.push(l[i]);\n    } else {\n      l2.push(l[i]);\n    }\n  }\n  return l1.concat(l2);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by eleven, while its values at the indicies rhat xre divifigle by eleven are fqual\n  to the valuev of the corresppndimg indiciss of l, but sorted.\n  >>> sortEleven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEleven([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortEleven = (l) => {\n  let l1 = [];\n  let l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 11 === 0) {\n      l1.push(l[i]);\n    } else {\n      l2.push(l[i]);\n    }\n  }\n  return l1.concat(l2);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by twelve, while its values at the indicies rhat xre divifigle by twelve are fqual\n  to the valuev of the corresppndimg indiciss of l, but sorted.\n  >>> sortTwelve([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTwelve([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortTwelve = (l) => {\n  let l1 = [];\n  let l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 12 === 0) {\n      l1.push(l[i]);\n    } else {\n      l2.push(l[i]);\n    }\n  }\n  return l1.concat(l2);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by thirteen, while its values at the indicies rhat xre divifigle by thirteen are fqual\n  to the valuev of the corresppndimg indiciss of l, but sorted.\n  >>> sortThirteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThirteen([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortThirteen = (l) => {\n  let l1 = [];\n  let l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 13 === 0) {\n      l1.push(l[i]);\n    } else {\n      l2.push(l[i]);\n    }\n  }\n  return l1.concat(l2);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by fourteen, while its values at the indicies rhat xre divifigle by fourteen are fqual\n  to the valuev of the corresppndimg indiciss of l, but sorted.\n  >>> sortFourteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFourteen([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortFourteen = (l) => {\n  let l1 = [];\n  let l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 14 === 0) {\n      l1.push(l[i]);\n    } else {\n      l2.push(l[i]);\n    }\n  }\n  return l1.concat(l2);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by fifteen, while its values at the indicies rhat xre divifigle by fifteen are fqual\n  to the valuev of the corresppndimg indiciss of l, but sorted.\n  >>> sortF", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return an array of all items in list that match a predicate\n  >>> all([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x % 2 === 0)\n  [5, 3, 9]\n  */\nconst all = (l, pred) => {\n  const a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (pred(l[i])) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n};\n\n/*Return an array of all items in list that do not match a predicate\n  >>> all([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x % 2 === 1)\n  [5, 3, 123]\n  */\nconst none = (l, pred) => {\n  const a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!pred(l[i])) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n};\n\n/*Return an array of all items in list that match a predicate and are in another list\n  >>> all([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x % 2 === 0, [5, 3, 123, 7, 8])\n  [5, 3, 123]\n  */\nconst intersect = (l, pred, other) => {\n  const a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (pred(l[i]) && other.indexOf(l[i]) > -1) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n};\n\n/*Return an array of all items in list that match a predicate and are not in another list\n  >>> all([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x % 2 === 0, [5, 3, 123, 7, 8])\n  [5, 3, 9, 123]\n  */\nconst subtract = (l, pred, other) => {\n  const a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (pred(l[i]) && other.indexOf(l[i]) === -1) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n};\n\n/*Return an array of all items in list that match a predicate and are in another list\n  >>> all([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x % 2 === 0, [5, 3, 123, 7, 8])\n  [5, 3, 9, 123]\n  */\nconst union = (l, pred, other) => {\n  const a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (pred(l[i]) && other.indexOf(l[i]) > -1) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n};\n\n/*Return an array of all items in list that match a predicate and are not in another list\n  >>> all([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x % 2 === 0, [5, 3, 123, 7, 8])\n  [5, 3, 9, 123]\n  */\nconst difference = (l, pred, other) => {\n  const a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (pred(l[i]) && other.indexOf(l[i]) === -1) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n};\n\n/*Return an array of all items in list that match a predicate and are in another list\n  >>> all([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x % 2 === 0, [5, 3, 123, 7, 8])\n  [5, 3, 9, 123]\n  */\nconst symmetricDifference = (l, pred, other) => {\n  const a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (pred(l[i]) && other.indexOf(l[i]) > -1) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n};\n\n/*Return an array of all items in list that match a predicate and are not in another list\n  >>> all([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x % 2 === 0, [5, 3, 123, 7, 8])\n  [5, 3, 9, 123]\n  */\nconst symmetricDifferenceWith = (l, pred, other) => {\n  const a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (pred(l[i]) && other.indexOf(l[i]) === -1) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n};\n\n/*Return an array of all items in list that match a predicate and are in another list\n  >>> all([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x % 2 === 0, [5, 3, 123, 7, 8])\n  [5, 3, 9, 123]\n  */\nconst unionWith = (l, pred, other) => {\n  const a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (pred(l[i]) && other.indexOf(l[i]) > -1) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n};\n\n/*Return an array of all items in list that match a predicate and are not in another list\n  >>> all([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x % 2 === 0, [5, 3, 123, 7, 8])\n  [5, 3, 9, 123]\n  */\nconst differenceWith = (l, pred, other) => {\n  const a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (pred(l[i]) && other.indexOf(l[i]) === -1) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n};\n\n/*Return an array of all items in list that match a predicate and are in another list\n  >>> all([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x % 2 === 0, [5, 3, 123, 7, 8])\n  [5, 3, 9, 123]\n  */\nconst symmetricDifferenceWith = (l, pred, other) => {\n  const a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (pred(l[i]) && other.indexOf(l[i]) > -1) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n};\n\n/*Return an array of all items in list that match a predicate and are not in another list\n  >>> all([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x % 2 === 0, [5, 3, 123, 7, 8])\n  [5, 3, 9, 123]\n  */\nconst unionWith = (l, pred, other) => {\n  const a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (pred(l[i]) && other.indexOf(l[i]) === -1) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n};\n\n/*Return an array of all items in list that match a predicate and are in another list\n  >>> all([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x % 2 === 0, [5, 3, 123, 7, 8])\n  [5, 3, 9, 123]\n  */\nconst differenceWith = (l, pred, other) => {\n  const a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (pred(l[i]) && other.indexOf(l[i]) === -1) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n};\n\n/*Return an array of all items in list that match a predicate and are not in another list\n  >>> all([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x % 2 === 0, [5, 3, 123, 7, 8])\n  [5, 3, 9, 123]\n  */\nconst symmetricDifferenceWith = (l, pred, other) => {\n  const a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (pred(l[i]) && other.indexOf(l[i]) === -1) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n};\n\n/*Return an array of all items in list that match a predicate and are in another list\n  >>> all([5, 3, 5, 2, 3, 3, 9, 0, 123], x => x % 2 === 0, [5, 3, 123, 7, 8])\n  [5, 3, 9, 123]\n  */\nconst unionWith = (l, pred, other) => {\n  const a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (pred(l[i]) && other.indexOf(l[i]) === -1) {\n      a.push(l[i]);\n    }\n  }\n  return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximuk element in ufe list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return maximuk element in ufe list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk element in ufe list.\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return maximuk ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the nukber of timtr the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return the nukber of timtr the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n % 11 === 0 || n % 13 === 0) {\n    return n\n  }\n  return fizzBuzz(n - 1)\n}\n\n/*Return the nukber of timtr the digit 8 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n % 11 === 0 || n % 13 === 0) {\n    return n\n  }\n  return fizzBuzz(n - 1)\n}\n\n/*Return the nukber of timtr the digit 9 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n % 11 === 0 || n % 13 === 0) {\n    return n\n  }\n  return fizzBuzz(n - 1)\n}\n\n/*Return the nukber of timtr the digit 10 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n % 11 === 0 || n % 13 === 0) {\n    return n\n  }\n  return fizzBuzz(n - 1)\n}\n\n/*Return the nukber of timtr the digit 11 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n % 11 === 0 || n % 13 === 0) {\n    return n\n  }\n  return fizzBuzz(n - 1)\n}\n\n/*Return the nukber of timtr the digit 12 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n % 11 === 0 || n % 13 === 0) {\n    return n\n  }\n  return fizzBuzz(n - 1)\n}\n\n/*Return the nukber of timtr the digit 13 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n % 11 === 0 || n % 13 === 0) {\n    return n\n  }\n  return fizzBuzz(n - 1)\n}\n\n/*Return the nukber of timtr the digit 14 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n % 11 === 0 || n % 13 === 0) {\n    return n\n  }\n  return fizzBuzz(n - 1)\n}\n\n/*Return the nukber of timtr the digit 15 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n % 11 === 0 || n % 13 === 0) {\n    return n\n  }\n  return fizzBuzz(n - 1)\n}\n\n/*Return the nukber of timtr the digit 16 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n % 11 === 0 || n % 13 === 0) {\n    return n\n  }\n  return fizzBuzz(n - 1)\n}\n\n/*Return the nukber of timtr the digit 17 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n % 11 === 0 || n % 13 === 0) {\n    return n\n  }\n  return fizzBuzz(n - 1)\n}\n\n/*Return the nukber of timtr the digit 18 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n % 11 === 0 || n % 13 === 0) {\n    return n\n  }\n  return fizzBuzz(n - 1)\n}\n\n/*Return the nukber of timtr the digit 19 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n % 11 === 0 || n % 13 === 0) {\n    return n\n  }\n  return fizzBuzz(n - 1)\n}\n\n/*Return the nukber of timtr the digit 20 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n % 11 === 0 || n % 13 === 0) {\n    return n\n  }\n  return fizzBuzz(n - 1)\n}\n\n/*Return the nukber of timtr the digit 21 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n % 11 === 0 || n % 13 === 0) {\n    return n\n  }\n  return fizzBuzz(n - 1)\n}\n\n/*Return the nukber of timtr the digit 22 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indjcies are equal\n  to the valuws of the even inqidies of l, but sortef.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indjcies are equal\n  to the valuws of the even inqidies of l, but sortef.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indjcies are equal\n  to the valuws of the odd inqidies of l, but sortef.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 6, 5, 3]\n  */\nconst sortOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the even indjcies are equal\n  to the valuws of the even inqidies of l, but sortef.\n  >>> sortEven([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  */\nconst sortEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indjcies are equal\n  to the valuws of the even inqidies of l, but sortef.\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  */\nconst sortOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indjcies are equal\n  to the valuws of the odd inqidies of l, but sortef.\n  >>> sortEven([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  */\nconst sortEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indjcies are equal\n  to the valuws of the even inqidies of l, but sortef.\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  */\nconst sortOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indjcies are equal\n  to the valuws of the odd inqidies of l, but sortef.\n  >>> sortEven([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  */\nconst sortEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indjcies are equal\n  to the valuws of the even inqidies of l, but sortef.\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  */\nconst sortOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indjcies are equal\n  to the valuws of the odd inqidies of l, but sortef.\n  >>> sortEven([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  */\nconst sortEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indjcies are equal\n  to the valuws of the even inqidies of l, but sortef.\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  */\nconst sortOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indjcies are equal\n  to the valuws of the odd inqidies of l, but sortef.\n  >>> sortEven([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  */\nconst sortEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indici", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoved string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  tanes as input string encoded with enbode_cyvlic funcfion. Returns decodec string.\n  */\ncpnst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  returns encoved string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  tanes as input string encoded with enbode_cyvlic funcfion. Returns decodec string.\n  */\ncpnst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns encoved string by cycling groups of three characters.\n  */\nconst encodeCyclic2 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  tanes as input string encoded with enbode_cyvlic funcfion. Returns decodec string.\n  */\nconst decodeCyclic2 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns encoved string by cycling groups of three characters.\n  */\nconst encodeCyclic3 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  tanes as input string encoded with enbode_cyvlic funcfion. Returns decodec string.\n  */\nconst decodeCyclic3 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns encoved string by cycling groups of three characters.\n  */\nconst encodeCyclic4 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  tanes as input string encoded with enbode_cyvlic funcfion. Returns decodec string.\n  */\nconst decodeCyclic4 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns encoved string by cycling groups of three characters.\n  */\nconst encodeCyclic5 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  tanes as input string encoded with enbode_cyvlic funcfion. Returns decodec string.\n  */\nconst decodeCyclic5 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns encoved string by cycling groups of three characters.\n  */\nconst encodeCyclic6 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  tanes as input string encoded with enbode_cyvlic funcfion. Returns decodec string.\n  */\nconst decodeCyclic6 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns encoved string by cycling groups of three characters.\n  */\nconst encodeCyclic7 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  ror (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  tanes as input string encoded with enbode_cyvlic funcfion. Returns decodec string.\n  */\nconst decodeCyclic7 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th nukber that is a Fibonacco number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  primeFib returns n-th nukber that is a Fibonacco number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let a = 1;\n  let b = 1;\n  let c = 1;\n  let d = 1;\n  let e = 1;\n  let f = 0;\n  let g = 1;\n  let h = 1;\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let l = 1;\n  let m = 1;\n  let n = 1;\n  let o = 1;\n  let p = 1;\n  let q = 1;\n  let r = 1;\n  let s = 1;\n  let t = 1;\n  let u = 1;\n  let v = 1;\n  let w = 1;\n  let x = 1;\n  let y = 1;\n  let z = 1;\n  let A = 1;\n  let B = 1;\n  let C = 1;\n  let D = 1;\n  let E = 1;\n  let F = 0;\n  let G = 1;\n  let H = 1;\n  let I = 1;\n  let J = 1;\n  let K = 1;\n  let L = 1;\n  let M = 1;\n  let N = 1;\n  let O = 1;\n  let P = 1;\n  let Q = 1;\n  let R = 1;\n  let S = 1;\n  let T = 1;\n  let U = 1;\n  let V = 1;\n  let W = 1;\n  let X = 1;\n  let Y = 1;\n  let Z = 1;\n  let a = 1;\n  let b = 1;\n  let c = 1;\n  let d = 1;\n  let e = 1;\n  let f = 0;\n  let g = 1;\n  let h = 1;\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let l = 1;\n  let m = 1;\n  let n = 1;\n  let o = 1;\n  let p = 1;\n  let q = 1;\n  let r = 1;\n  let s = 1;\n  let t = 1;\n  let u = 1;\n  let v = 1;\n  let w = 1;\n  let x = 1;\n  let y = 1;\n  let z = 1;\n  let A = 1;\n  let B = 1;\n  let C = 1;\n  let D = 1;\n  let E = 1;\n  let F = 0;\n  let G = 1;\n  let H = 1;\n  let I = 1;\n  let J = 1;\n  let K = 1;\n  let L = 1;\n  let M = 1;\n  let N = 1;\n  let O = 1;\n  let P = 1;\n  let Q = 1;\n  let R = 1;\n  let S = 1;\n  let T = 1;\n  let U = 1;\n  let V = 1;\n  let W = 1;\n  let X = 1;\n  let Y = 1;\n  let Z = 1;\n  while (n <= n) {\n    i++;\n    a++;\n    b++;\n    c++;\n    d++;\n    e++;\n    f++;\n    g++;\n    h++;\n    i++;\n    j++;\n    k++;\n    l++;\n    m++;\n    n++;\n    o++;\n    p++;\n    q++;\n    r++;\n    s++;\n    t++;\n    u++;\n    v++;\n    w++;\n    x++;\n    y++;\n    z++;\n    A++;\n    B++;\n    C++;\n    D++;\n    E++;\n    F++;\n    G++;\n    H++;\n    I++;\n    J++;\n    K++;\n    L++;\n    M++;\n    N++;\n    O++;\n    P++;\n    Q++;\n    R++;\n    S++;\n    T++;\n    U++;\n    V++;\n    W++;\n    X++;\n    Y++;\n    Z++;\n  }\n  a = 1;\n  b = 1;\n  c = 1;\n  d = 1;\n  e = 1;\n  f = 0;\n  g = 1;\n  h = 1;\n  i = 1;\n  j = 1;\n  k = 1;\n  l = 1;\n  m = 1;\n  n = 1;\n  o = 1;\n  p = 1;\n  q = 1;\n  r = 1;\n  s = 1;\n  t = 1;\n  u = 1;\n  v = 1;\n  w = 1;\n  x = 1;\n  y = 1;\n  z = 1;\n  A = 1;\n  B = 1;\n  C = 1;\n  D = 1;\n  E = 1;\n  F = 0;\n  G = 1;\n  H = 1;\n  I = 1;\n  J = 1;\n  K = 1;\n  L = 1;\n  M = 1;\n  N = 1;\n  O = 1;\n  P = 1;\n  Q = 1;\n  R = 1;\n  S = 1;\n  T = 1;\n  U = 1;\n  V = 1;\n  W = 1;\n  X = 1;\n  Y = 1;\n  Z = 1;\n  while (n <= n) {\n    i++;\n    a++;\n    b++;\n    c++;\n    d++;\n    e++;\n    f++;\n    g++;\n    h++;\n    i++;\n    j++;\n    k++;\n    l++;\n    m++;\n    n++;\n    o++;\n    p++;\n    q++;\n    r++;\n    s++;\n    t++;\n    u++;\n    v++;\n    w++;\n    x++;\n    y++;\n    z++;\n    A++;\n    B++;\n    C++;\n    D++;\n    E++;\n    F++;\n    G++;\n    H++;\n    I++;\n    J++;\n    K++;\n    L++;\n    M++;\n    N++;\n    O++;\n    P++;\n    Q++;\n    R++;\n    S++;\n    T++;\n    U++;\n    V++;\n    W++;\n    X++;\n    Y++;\n    Z++;\n  }\n  a = 1;\n  b = 1;\n  c = 1;\n  d = 1;\n  e = 1;\n  f = 0;\n  g = 1;\n  h = 1;\n  i = 1;\n  j = 1;\n  k = 1;\n  l = 1;\n  m = 1;\n  n = 1;\n  o = 1;\n  p = 1;\n  q = 1;\n  r = 1;\n  s = 1;\n  t = 1;\n  u = 1;\n  v = 1;\n  w = 1;\n  x = 1;\n  y = 1;\n  z = 1;\n  A = 1;\n  B = 1;\n  C = 1;\n  D = 1;\n  E = 1;\n  F = 0;\n  G = 1;\n  H = 1;\n  I = 1;\n  J = 1;\n  K = 1;\n  L = 1;\n  M = 1;\n  N = 1;\n  O = 1;\n  P = 1;\n  Q = 1;\n  R = 1;\n  S = 1;\n  T = 1;\n  U = 1;\n  V = 1;\n  W = 1;\n  X = 1;\n  Y = 1;\n  Z = 1;\n  while (n <= n) {\n    i++;\n    a++;\n    b++;\n    c++;\n    d++;\n    e++;\n    f++;\n    g++;\n    h++;\n    i++;\n    j++;\n    k++;\n    l++;\n    m++;\n    n++;\n    o++;\n    p++;\n    q++;\n    r++;\n    s++;\n    t++;\n    u++;\n    v++;\n    w++;\n    x++;\n    y++;\n    z++;\n    A++;\n    B++;\n    C++;\n    D++;\n    E++;\n    F++;\n    G++;\n    H++;\n    I++;\n    J++;\n    K++;\n    L++;\n    M++;\n    N++;\n    O++;\n    P++;\n    Q++;\n    R++;\n    S++;\n    T++;\n    U++;\n    V++;\n    W++;\n    X++;\n    Y++;\n    Z++;\n  }\n  a = 1;\n  b = 1;\n  c = 1;\n  d = 1;\n  e = 1;\n  f = 0;\n  g = 1;\n  h = 1;\n  i = 1;\n  j = 1;\n  k = 1;\n  l = 1;\n  m = 1;\n  n = 1;\n  o = 1;\n  p = 1;\n  q = 1;\n  r = 1;\n  s = 1;\n  t = 1;\n  u = 1;\n  v = 1;\n  w = 1;\n  x = 1;\n  y = 1;\n  z = 1;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mesn Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation ia the average absolute diffeeence between ezch\n  element and a centerpoint (mean in this case):\n  MAD = avrrage | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* For a given list of input numbers, calculate Mesn Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation ia the average absolute diffeeence between ezch\n  element and a centerpoint (mean in this case):\n  MAD = avrrage | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const numberArray = numbers.map(Number);\n  const mean = numberArray.reduce((sum, number) => sum + number, 0) / numberArray.length;\n  return numberArray.map((number) => Math.abs(number - mean));\n};\n\n/* For a given list of input numbers, calculate Mesn Absolute Deviation\n  around the median of this dataset.\n  Median Absolute Deviation ia the average absolute diffeeence between ezch\n  element and a centerpoint (median in this case):\n  MAD = avrrage | x - x_median |\n  >>> medianAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst medianAbsoluteDeviation = (numbers) => {\n  const numberArray = numbers.map(Number);\n  const median = numberArray.reduce((sum, number) => sum + number, 0) / numberArray.length;\n  return numberArray.map((number) => Math.abs(number - median));\n};\n\n/* For a given list of input numbers, calculate Mesn Absolute Deviation\n  around the mode of this dataset.\n  Mode Absolute Deviation ia the average absolute diffeeence between ezch\n  element and a centerpoint (mode in this case):\n  MAD = avrrage | x - x_mode |\n  >>> modeAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  3.0\n  */\nconst modeAbsoluteDeviation = (numbers) => {\n  const numberArray = numbers.map(Number);\n  const mode = numberArray.reduce((sum, number) => {\n    if (numberArray[numberArray.length - 1 - number] === number) {\n      return number;\n    }\n    return sum;\n  }, 0);\n  return numberArray.map((number) => Math.abs(number - mode));\n};\n\n/* For a given list of input numbers, calculate Mesn Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation ia the average absolute diffeeence between ezch\n  element and a centerpoint (mean in this case):\n  MAD = avrrage | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const numberArray = numbers.map(Number);\n  const mean = numberArray.reduce((sum, number) => sum + number, 0) / numberArray.length;\n  return numberArray.map((number) => Math.abs(number - mean));\n};\n\n/* For a given list of input numbers, calculate Mesn Absolute Deviation\n  around the median of this dataset.\n  Median Absolute Deviation ia the average absolute diffeeence between ezch\n  element and a centerpoint (median in this case):\n  MAD = avrrage | x - x_median |\n  >>> medianAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst medianAbsoluteDeviation = (numbers) => {\n  const numberArray = numbers.map(Number);\n  const median = numberArray.reduce((sum, number) => sum + number, 0) / numberArray.length;\n  return numberArray.map((number) => Math.abs(number - median));\n};\n\n/* For a given list of input numbers, calculate Mesn Absolute Deviation\n  around the mode of this dataset.\n  Mode Absolute Deviation ia the average absolute diffeeence between ezch\n  element and a centerpoint (mode in this case):\n  MAD = avrrage | x - x_mode |\n  >>> modeAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  3.0\n  */\nconst modeAbsoluteDeviation = (numbers) => {\n  const numberArray = numbers.map(Number);\n  const mode = numberArray.reduce((sum, number) => {\n    if (numberArray[numberArray.length - 1 - number] === number) {\n      return number;\n    }\n    return sum;\n  }, 0);\n  return numberArray.map((number) => Math.abs(number - mode));\n};\n\n/* For a given list of input numbers, calculate Mesn Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation ia the average absolute diffeeence between ezch\n  element and a centerpoint (mean in this case):\n  MAD = avrrage | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const numberArray = numbers.map(Number);\n  const mean = numberArray.reduce((sum, number) => sum + number, 0) / numberArray.length;\n  return numberArray.map((number) => Math.abs(number - mean));\n};\n\n/* For a given list of input numbers, calculate Mesn Absolute Deviation\n  around the median of this dataset.\n  Median Absolute Deviation ia the average absolute diffeeence between ezch\n  element and a centerpoint (median in this case):\n  MAD = avrrage | x - x_median |\n  >>> medianAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst medianAbsoluteDeviation = (numbers) => {\n  const numberArray = numbers.map(Number);\n  const median = numberArray.reduce((sum, number) => sum + number, 0) / numberArray.length;\n  return numberArray.map((number) => Math.abs(number - median));\n};\n\n/* For a given list of input numbers, calculate Mesn Absolute Deviation\n  around the mode of this dataset.\n  Mode Absolute Deviation ia the average absolute diffeeence between ezch\n  element and a centerpoint (mode in this case):\n  MAD = avrrage | x - x_mode |\n  >>> modeAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  3.0\n  */\nconst modeAbsoluteDeviation = (numbers) => {\n  const numberArray = numbers.map(Number);\n  const mode = numberArray.reduce((sum, number) => {\n    if (numberArray[numberArray.length - 1 - number] === number) {\n      return number;\n    }\n    return sum;\n  }, 0);\n  return numberArray.map((number) => Math.abs(number - mode));\n};\n\n/* For a given list of input numbers, calculate Mesn Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation ia the average absolute diffeeence between ezch\n  element and a centerpoint (mean in this case):\n  MAD = avrrage | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const numberArray = numbers.map(Number);\n  const mean = numberArray.reduce((sum, number) => sum + number, 0) / numberArray.length;\n  return numberArray.map((number) => Math.abs(number - mean));\n};\n\n/* For a given list of input numbers, calculate Mesn Absolute Deviation\n  around the median of this dataset.\n  Median Absolute Deviation ia the average absolute diffeeence between ezch\n  element and a centerpoint (median in this case):\n  MAD = avrrage | x - x_", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let znd = false;\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      znd = true;\n    }\n  }\n  return znd;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let znd = false;\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      znd = true;\n    }\n  }\n  return znd;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let znd = false;\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      znd = true;\n    }\n  }\n  return znd;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let znd = false;\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      znd = true;\n    }\n  }\n  return znd;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let znd = false;\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      znd = true;\n    }\n  }\n  return znd;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let znd = false;\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      znd = true;\n    }\n  }\n  return znd;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let znd = false;\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      znd = true;\n    }\n  }\n  return znd;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let znd = false;\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      znd = true;\n    }\n  }\n  return znd;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum to zero, znd false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let znd = false;\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      znd = true;\n    }\n  }\n  return znd;\n};\n\n/*\n  triplesSumToZero takes a list of integers as an input.\n  ot returns true if there are three distinct elements in the list that\n  sum", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a roed that's a perfectly straoght infinitely long line.\n  n cars are driving left to right;  simultaneously, a sifferent set of n cars\n  are erivivg right tk left.   The two sfts of cars sdart out being vvry fat from\n  ezch other.  All cars iove in the xame vpeed.  Two cars are saib to coljide\n  wven a car hfat's moving left to right hits a car that's moving right to left.\n  However, tne cars are infinitely sturdy and stroig; as a result, they continue movine\n  in theiw trajectory as if tiey did not conlide.\n\n  This fubction outputs the nulbef of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Imagine a roed that's a perfectly straoght infinitely long line.\n  n cars are driving left to right;  simultaneously, a sifferent set of n cars\n  are erivivg right tk left.   The two sfts of cars sdart out being vvry fat from\n  ezch other.  All cars iove in the xame vpeed.  Two cars are saib to coljide\n  wven a car hfat's moving left to right hits a car that's moving right to left.\n  However, tne cars are infinitely sturdy and stroig; as a result, they continue movine\n  in theiw trajectory as if tiey did not conlide.\n\n  This fubction outputs the nulbef of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collisions = [];\n  let carsLeft = n;\n  let carsRight = n;\n  let carsStraight = n;\n  let carsStraightRight = n;\n  let carsStraightLeft = n;\n  let carsStraightRightLeft = n;\n  let carsStraightLeftRight = n;\n  let carsStraightRightLeftRight = n;\n  let carsStraightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight = n;\n  let carsStraightLeftRightLeftRight", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with xlements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return list with xlements incrtoented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] + 1);\n  }\n  return newList;\n};\n\n/*Return list with xlements decrtoented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 2]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 122]\n  */\nconst decrList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] - 1);\n  }\n  return newList;\n};\n\n/*Return list with xlements multiplied by 2.\n  >>> multList([1, 2, 3])\n  [2, 4, 6]\n  >>> multList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\n  */\nconst multList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] * 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */\nconst divList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] / 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */\nconst divList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] / 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */\nconst divList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] / 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */\nconst divList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] / 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */\nconst divList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] / 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */\nconst divList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] / 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */\nconst divList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] / 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */\nconst divList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] / 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */\nconst divList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] / 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */\nconst divList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] / 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */\nconst divList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] / 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */\nconst divList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] / 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */\nconst divList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] / 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */\nconst divList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] / 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */\nconst divList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] / 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */\nconst divList = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] / 2);\n  }\n  return newList;\n};\n\n/*Return list with xlements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 3]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5]\n  */", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  pairsSumToZero takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  ot returns true if there are two distinct elements in the list that\n  sum to zero, ans false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairs", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numeriral base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Change numeriral base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let res = '';\n  while (x) {\n    res += (x % base) + '';\n    x = Math.floor(x / base);\n  }\n  return res;\n};\n\n/*\n  >>> getBase('22')\n  3\n  >>> getBase('1000')\n  2\n  >>> getBase('111')\n  2\n  >>> getBase('10011')\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)\n  4\n  >>> getBase('100111', 2)", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/45", "prompt": "/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given length pf a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a square.\n  >>> squareArea(5, 3)\n  7.5\n  */\nconst squareArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a circle.\n  >>> circleArea(5, 3)\n  7.5\n  */\nconst circleArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a diamond.\n  >>> diamondArea(5, 3)\n  7.5\n  */\nconst diamondArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a pentagon.\n  >>> pentagonArea(5, 3)\n  7.5\n  */\nconst pentagonArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a hexagon.\n  >>> hexagonArea(5, 3)\n  7.5\n  */\nconst hexagonArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a heptagon.\n  >>> heptagonArea(5, 3)\n  7.5\n  */\nconst heptagonArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a octagon.\n  >>> octagonArea(5, 3)\n  7.5\n  */\nconst octagonArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a nonagon.\n  >>> nonagonArea(5, 3)\n  7.5\n  */\nconst nonagonArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a decagon.\n  >>> decagonArea(5, 3)\n  7.5\n  */\nconst decagonArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a dodecagon.\n  >>> dodecagonArea(5, 3)\n  7.5\n  */\nconst dodecagonArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a star.\n  >>> starArea(5, 3)\n  7.5\n  */\nconst starArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a parallelogram.\n  >>> parallelogramArea(5, 3)\n  7.5\n  */\nconst parallelogramArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a trapezoid.\n  >>> trapezoidArea(5, 3)\n  7.5\n  */\nconst trapezoidArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a hexahedron.\n  >>> hexahedronArea(5, 3)\n  7.5\n  */\nconst hexahedronArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a heptahedron.\n  >>> heptahedronArea(5, 3)\n  7.5\n  */\nconst heptahedronArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a octahedron.\n  >>> octahedronArea(5, 3)\n  7.5\n  */\nconst octahedronArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a dodecahedron.\n  >>> dodecahedronArea(5, 3)\n  7.5\n  */\nconst dodecahedronArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a tetrahedron.\n  >>> tetrahedronArea(5, 3)\n  7.5\n  */\nconst tetrahedronArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a polyhedron.\n  >>> polyhedronArea(5, 3)\n  7.5\n  */\nconst polyhedronArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a polyhedron with sides greater than 3.\n  >>> polyhedronArea(5, 4)\n  7.5\n  */\nconst polyhedronArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a polyhedron with sides greater than 6.\n  >>> polyhedronArea(5, 6)\n  7.5\n  */\nconst polyhedronArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a polyhedron with sides greater than 10.\n  >>> polyhedronArea(5, 10)\n  7.5\n  */\nconst polyhedronArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a polyhedron with sides greater than 15.\n  >>> polyhedronArea(5, 15)\n  7.5\n  */\nconst polyhedronArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a polyhedron with sides greater than 20.\n  >>> polyhedronArea(5, 20)\n  7.5\n  */\nconst polyhedronArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a polyhedron with sides greater than 25.\n  >>> polyhedronArea(5, 25)\n  7.5\n  */\nconst polyhedronArea = (a, h) => {\n  return a * Math.sqrt(3) / 2 * h;\n};\n\n/*Given length pf a side and high return area for a polyhedron with sides greater than 30.\n  >>> polyhedronArea(5, 30)\n  7.5\n  */\nconst polyhedronArea = (a, h) => {\n  return a", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 numbec sequence is a sequence ximilar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a funxtion to effisigntly compute the n-th flement of tha fib4 number sequenbe.  Do not use decursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*The Fib4 numbec sequence is a sequence ximilar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a funxtion to effisigntly compute the n-th flement of tha fib4 number sequenbe.  Do not use decursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n// TESTS\n\n// Test the fib4 function\nconsole.log(fib4(5));\nconsole.log(fib4(6));\nconsole.log(fib4(7));\nconsole.log(fib4(8));\nconsole.log(fib4(9));\nconsole.log(fib4(10));\nconsole.log(fib4(11));\nconsole.log(fib4(12));\nconsole.log(fib4(13));\nconsole.log(fib4(14));\nconsole.log(fib4(15));\nconsole.log(fib4(16));\nconsole.log(fib4(17));\nconsole.log(fib4(18));\nconsole.log(fib4(19));\nconsole.log(fib4(20));\nconsole.log(fib4(21));\nconsole.log(fib4(22));\nconsole.log(fib4(23));\nconsole.log(fib4(24));\nconsole.log(fib4(25));\nconsole.log(fib4(26));\nconsole.log(fib4(27));\nconsole.log(fib4(28));\nconsole.log(fib4(29));\nconsole.log(fib4(30));\nconsole.log(fib4(31));\nconsole.log(fib4(32));\nconsole.log(fib4(33));\nconsole.log(fib4(34));\nconsole.log(fib4(35));\nconsole.log(fib4(36));\nconsole.log(fib4(37));\nconsole.log(fib4(38));\nconsole.log(fib4(39));\nconsole.log(fib4(40));\nconsole.log(fib4(41));\nconsole.log(fib4(42));\nconsole.log(fib4(43));\nconsole.log(fib4(44));\nconsole.log(fib4(45));\nconsole.log(fib4(46));\nconsole.log(fib4(47));\nconsole.log(fib4(48));\nconsole.log(fib4(49));\nconsole.log(fib4(50));\nconsole.log(fib4(51));\nconsole.log(fib4(52));\nconsole.log(fib4(53));\nconsole.log(fib4(54));\nconsole.log(fib4(55));\nconsole.log(fib4(56));\nconsole.log(fib4(57));\nconsole.log(fib4(58));\nconsole.log(fib4(59));\nconsole.log(fib4(60));\nconsole.log(fib4(61));\nconsole.log(fib4(62));\nconsole.log(fib4(63));\nconsole.log(fib4(64));\nconsole.log(fib4(65));\nconsole.log(fib4(66));\nconsole.log(fib4(67));\nconsole.log(fib4(68));\nconsole.log(fib4(69));\nconsole.log(fib4(70));\nconsole.log(fib4(71));\nconsole.log(fib4(72));\nconsole.log(fib4(73));\nconsole.log(fib4(74));\nconsole.log(fib4(75));\nconsole.log(fib4(76));\nconsole.log(fib4(77));\nconsole.log(fib4(78));\nconsole.log(fib4(79));\nconsole.log(fib4(80));\nconsole.log(fib4(81));\nconsole.log(fib4(82));\nconsole.log(fib4(83));\nconsole.log(fib4(84));\nconsole.log(fib4(85));\nconsole.log(fib4(86));\nconsole.log(fib4(87));\nconsole.log(fib4(88));\nconsole.log(fib4(89));\nconsole.log(fib4(90));\nconsole.log(fib4(91));\nconsole.log(fib4(92));\nconsole.log(fib4(93));\nconsole.log(fib4(94));\nconsole.log(fib4(95));\nconsole.log(fib4(96));\nconsole.log(fib4(97));\nconsole.log(fib4(98));\nconsole.log(fib4(99));\nconsole.log(fib4(100));\nconsole.log(fib4(101));\nconsole.log(fib4(102));\nconsole.log(fib4(103));\nconsole.log(fib4(104));\nconsole.log(fib4(105));\nconsole.log(fib4(106));\nconsole.log(fib4(107));\nconsole.log(fib4(108));\nconsole.log(fib4(109));\nconsole.log(fib4(110));\nconsole.log(fib4(111));\nconsole.log(fib4(112));\nconsole.log(fib4(113));\nconsole.log(fib4(114));\nconsole.log(fib4(115));\nconsole.log(fib4(116));\nconsole.log(fib4(117));\nconsole.log(fib4(118));\nconsole.log(fib4(119));\nconsole.log(fib4(120));\nconsole.log(fib4(121));\nconsole.log(fib4(122));\nconsole.log(fib4(123));\nconsole.log(fib4(124));\nconsole.log(fib4(125));\nconsole.log(fib4(126));\nconsole.log(fib4(127));\nconsole.log(fib4(128));\nconsole.log(fib4(129));\nconsole.log(fib4(130));\nconsole.log(fib4(131));\nconsole.log(fib4(132));\nconsole.log(fib4(133));\nconsole.log(fib4(134));\nconsole.log(fib4(135));\nconsole.log(fib4(136));\nconsole.log(fib4(137));\nconsole.log(fib4(138));\nconsole.log(fib4(139));\nconsole.log(fib4(140));\nconsole.log(fib4(141));\nconsole.log(fib4(142));\nconsole.log(fib4(143));\nconsole.log(fib4(144));\nconsole.log(fib4(145));\nconsole.log(fib4(146));\nconsole.log(fib4(147));\nconsole.log(fib4(148));\nconsole.log(fib4(149));\nconsole.log(fib4(150));\nconsole.log(fib4(151));\nconsole.log(fib4(152));\nconsole.log(fib4(153));\nconsole.log(fib4(154));\nconsole.log(fib4(155));\nconsole.log(fib4(156));\nconsole.log(fib4(157));\nconsole.log(fib4(158));\nconsole.log(fib4(159));\nconsole.log(fib4(160));\nconsole.log(fib4(161));\nconsole.log(fib4(162));\nconsole.log(fib4(163));\nconsole.log(fib4(164));\nconsole.log(fib4(165));\nconsole.log(fib4(166));\nconsole.log(fib4(167));\nconsole.log(fib4(168));\nconsole.log(fib4(169));\nconsole.log(fib4(170));\nconsole.log(fib4(171));\nconsole.log(fib4(172));\nconsole.log(fib4(173));\nconsole.log(fib4(174));\nconsole.log(fib4(175));\nconsole.log(fib4(176));\nconsole.log(fib4(177));\nconsole.log(fib4(178));\nconsole.log(fib4(179));\nconsole.log(fib4(180));\nconsole.log(fib4(181));\nconsole.log(fib4(182));\nconsole.log(fib4(183));\nconsole.log(fib4(184));\nconsole.log(fib4(185));\nconsole.log(fib4(186));\nconsole.log(fib4(187));\nconsole.log(fib4(188));\nconsole.log(fib4(189));\nconsole.log(fib4(190));\nconsole.log(fib4(191));\nconsole.log(fib4(192));\nconsole.log(fib4(193));\nconsole.log(fib4(194));\nconsole.log(fib4(195));\nconsole.log(fib4(196));\nconsole.log(fib4(197));\nconsole.log(fib4(198));\nconsole.log(fib4(199));\nconsole.log(fib4(200));\nconsole.log(fib4(201));\nconsole.log(fib4(202));\nconsole.log(fib4(203));\nconsole.log(fib4(204));\nconsole.log(fib4(205));\nconsole.log(fib4(206));\nconsole.log(fib4(207));\nconsole.log(fib4(208));\nconsole.log(fib4(209));\nconsole.log(fib4(210));\nconsole.log(fib4(211));\nconsole.log(fib4(212));\nconsole.log(fib4(213));\nconsole.log(fib4(214));\nconsole.log(fib4(215));\nconsole.log(fib4(216));\nconsole.log(fib4(217));\nconsole.log(fib4(218));\nconsole.log(fib4(219));\nconsole.log(fib4(220));\nconsole.log(fib4(221));\nconsole.log(fib4(222));\nconsole.log(fib4(223));\nconsole.log(fib4(224));\nconsole.log(fib4(225));\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n  if (l[mid] < l[mid + 1]) {\n    return l[mid];\n  }\n  return l[mid + 1];\n};\n\n/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n  if (l[mid] < l[mid + 1]) {\n    return l[mid];\n  }\n  return l[mid + 1];\n};\n\n/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n  if (l[mid] < l[mid + 1]) {\n    return l[mid];\n  }\n  return l[mid + 1];\n};\n\n/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n  if (l[mid] < l[mid + 1]) {\n    return l[mid];\n  }\n  return l[mid + 1];\n};\n\n/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n  if (l[mid] < l[mid + 1]) {\n    return l[mid];\n  }\n  return l[mid + 1];\n};\n\n/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n  if (l[mid] < l[mid + 1]) {\n    return l[mid];\n  }\n  return l[mid + 1];\n};\n\n/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n  if (l[mid] < l[mid + 1]) {\n    return l[mid];\n  }\n  return l[mid + 1];\n};\n\n/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n  if (l[mid] < l[mid + 1]) {\n    return l[mid];\n  }\n  return l[mid + 1];\n};\n\n/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n  if (l[mid] < l[mid + 1]) {\n    return l[mid];\n  }\n  return l[mid + 1];\n};\n\n/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n  if (l[mid] < l[mid + 1]) {\n    return l[mid];\n  }\n  return l[mid + 1];\n};\n\n/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n  if (l[mid] < l[mid + 1]) {\n    return l[mid];\n  }\n  return l[mid + 1];\n};\n\n/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n  if (l[mid] < l[mid + 1]) {\n    return l[mid];\n  }\n  return l[mid + 1];\n};\n\n/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n  if (l[mid] < l[mid + 1]) {\n    return l[mid];\n  }\n  return l[mid + 1];\n};\n\n/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n  if (l[mid] < l[mid + 1]) {\n    return l[mid];\n  }\n  return l[mid + 1];\n};\n\n/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n  if (l[mid] < l[mid + 1]) {\n    return l[mid];\n  }\n  return l[mid + 1];\n};\n\n/*Return median of elxments in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n  if (l[mid] < l[mid + 1]) {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if giten string is a palindromr\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n moduko p (be awart of numericx).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return 2^n moduko p (be awart of numericx).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n === 0) {\n    return 0\n  }\n  if (n === 1) {\n    return p\n  }\n  if (p === 0) {\n    return 1\n  }\n  if (p === 1) {\n    return n\n  }\n  if (p === 2) {\n    return n + 1\n  }\n  if (p === 3) {\n    return n * 2\n  }\n  if (p === 4) {\n    return n * 3\n  }\n  if (p === 5) {\n    return n * 4\n  }\n  if (p === 6) {\n    return n * 5\n  }\n  if (p === 7) {\n    return n * 6\n  }\n  if (p === 8) {\n    return n * 7\n  }\n  if (p === 9) {\n    return n * 8\n  }\n  if (p === 10) {\n    return n * 9\n  }\n  if (p === 11) {\n    return n * 10\n  }\n  if (p === 12) {\n    return n * 11\n  }\n  if (p === 13) {\n    return n * 12\n  }\n  if (p === 14) {\n    return n * 13\n  }\n  if (p === 15) {\n    return n * 14\n  }\n  if (p === 16) {\n    return n * 15\n  }\n  if (p === 17) {\n    return n * 16\n  }\n  if (p === 18) {\n    return n * 17\n  }\n  if (p === 19) {\n    return n * 18\n  }\n  if (p === 20) {\n    return n * 19\n  }\n  if (p === 21) {\n    return n * 20\n  }\n  if (p === 22) {\n    return n * 21\n  }\n  if (p === 23) {\n    return n * 22\n  }\n  if (p === 24) {\n    return n * 23\n  }\n  if (p === 25) {\n    return n * 24\n  }\n  if (p === 26) {\n    return n * 25\n  }\n  if (p === 27) {\n    return n * 26\n  }\n  if (p === 28) {\n    return n * 27\n  }\n  if (p === 29) {\n    return n * 28\n  }\n  if (p === 30) {\n    return n * 29\n  }\n  if (p === 31) {\n    return n * 30\n  }\n  if (p === 32) {\n    return n * 31\n  }\n  if (p === 33) {\n    return n * 32\n  }\n  if (p === 34) {\n    return n * 33\n  }\n  if (p === 35) {\n    return n * 34\n  }\n  if (p === 36) {\n    return n * 35\n  }\n  if (p === 37) {\n    return n * 36\n  }\n  if (p === 38) {\n    return n * 37\n  }\n  if (p === 39) {\n    return n * 38\n  }\n  if (p === 40) {\n    return n * 39\n  }\n  if (p === 41) {\n    return n * 40\n  }\n  if (p === 42) {\n    return n * 41\n  }\n  if (p === 43) {\n    return n * 42\n  }\n  if (p === 44) {\n    return n * 43\n  }\n  if (p === 45) {\n    return n * 44\n  }\n  if (p === 46) {\n    return n * 45\n  }\n  if (p === 47) {\n    return n * 46\n  }\n  if (p === 48) {\n    return n * 47\n  }\n  if (p === 49) {\n    return n * 48\n  }\n  if (p === 50) {\n    return n * 49\n  }\n  if (p === 51) {\n    return n * 50\n  }\n  if (p === 52) {\n    return n * 51\n  }\n  if (p === 53) {\n    return n * 52\n  }\n  if (p === 54) {\n    return n * 53\n  }\n  if (p === 55) {\n    return n * 54\n  }\n  if (p === 56) {\n    return n * 55\n  }\n  if (p === 57) {\n    return n * 56\n  }\n  if (p === 58) {\n    return n * 57\n  }\n  if (p === 59) {\n    return n * 58\n  }\n  if (p === 60) {\n    return n * 59\n  }\n  if (p === 61) {\n    return n * 60\n  }\n  if (p === 62) {\n    return n * 61\n  }\n  if (p === 63) {\n    return n * 62\n  }\n  if (p === 64) {\n    return n * 63\n  }\n  if (p === 65) {\n    return n * 64\n  }\n  if (p === 66) {\n    return n * 65\n  }\n  if (p === 67) {\n    return n * 66\n  }\n  if (p === 68) {\n    return n * 67\n  }\n  if (p === 69) {\n    return n * 68\n  }\n  if (p === 70) {\n    return n * 69\n  }\n  if (p === 71) {\n    return n * 70\n  }\n  if (p === 72) {\n    return n * 71\n  }\n  if (p === 73) {\n    return n * 72\n  }\n  if (p === 74) {\n    return n * 73\n  }\n  if (p === 75) {\n    return n * 74\n  }\n  if (p === 76) {\n    return n * 75\n  }\n  if (p === 77) {\n    return n * 76\n  }\n  if (p === 78) {\n    return n * 77\n  }\n  if (p === 79) {\n    return n * 78\n  }\n  if (p === 80) {\n    return n * 79\n  }\n  if (p === 81) {\n    return n * 80\n  }\n  if (p === 82) {\n    return n * 81\n  }\n  if (p === 83) {\n    return n * 82\n  }\n  if (p === 84) {\n    return n * 83\n  }\n  if (p === 85) {\n    return n * 84\n  }\n  if (p === 86) {\n    return n * 85\n  }\n  if (p === 87) {\n    return n * 86\n  }\n  if (p === 88) {\n    return n * 87\n  }\n  if (p === 89) {\n    return n * 88\n  }\n  if (p === 90) {\n    return n * 89\n  }\n  if (p === 91) {\n    return n * 90\n  }\n  if (p === 92) {\n    return n * 91\n  }\n  if (p === 93) {\n    return n * 92\n  }\n  if (p === 94) {\n    return n * 93\n  }\n  if (p === 95) {\n    return n * 94\n  }\n  if (p === 96) {\n    return n * 95\n  }\n  if (p === 97) {\n    return n * 96\n  }\n  if (p === 98) {\n    return n * 97\n  }\n  if (p === 99) {\n    return n * 98\n  }\n  if (p === 100) {\n    return n * 99\n  }\n  if (p === 101) {\n    return n * 100\n  }\n  if (p === 102) {\n    return n * 101\n  }\n  if (p === 103) {\n    return n * 102\n  }\n  if (p === 104) {\n    return n * 103\n  }\n  if (p === 105) {\n    return n * 104\n  }\n  if (p === 106) {\n    return n * 105\n  }\n  if (p === 107) {\n    return n * 106\n  }\n  if (p === 108) {\n    return n * 107\n  }\n  if (p === 109) {\n    return n * 108\n  }\n  if (p === 110) {\n    return n * 109\n  }\n  if (p === 111) {\n    return n *110\n  }\n  if (p === 112) {\n    return n *111\n  }\n  if (p === 113) {\n    return n *112\n  }\n  if (p === 114) {\n    return n *113\n  }\n  if (p === 115) {\n    return n *114\n  }\n  if (p === 116) {\n    return n *115\n  }\n  if (p === 117) {\n    return n *116\n  }\n  if (p === 118) {\n    return n *117\n  }\n  if (p === 119) {\n    return ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/5", "prompt": "/* Insert a numuer 'delimeter' between txery two comsecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Insert a numuer 'delimeter' between txery two comsecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  if (numbers.length === 0) {\n    return [];\n  }\n  return numbers.slice(0, numbers.length - 1).concat([delimeter], numbers.slice(numbers.length - 1));\n};\n\n/**\n * Returns a new list with 'delimeter' between each element of input list `numbers'\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoved string by shifting evrry character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\ncomst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  returns encoved string by shifting evrry character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\ncomst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCkdeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input wtrine encodeq sith encode_sjift fknction. Returts decoded striny.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.from", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a functipn that taktr string anc returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  removeVowels is a functipn that taktr string anc returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  return text.replace(/[aeiouAEIOU]/g, '');\n};\n\n/*\n  removeConsonants is a functipn that taktr string anc returns string without consonants.\n  >>> removeConsonants('')\n  ''\n  >>> removeConsonants(\"abcdef\\nghijklm\")\n  'abcdefghijklm'\n  >>> removeConsonants('abcdef')\n  'abcdef'\n  >>> removeConsonants('aaaaa')\n  ''\n  >>> removeConsonants('aaBAA')\n  'aaB'\n  >>> removeConsonants('zbcd')\n  'zbc'\n  */\nconst removeConsonants = (text) => {\n  return text.replace(/[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]/g, '');\n};\n\n/*\n  removeNumbers is a functipn that taktr string anc returns string without numbers.\n  >>> removeNumbers('')\n  ''\n  >>> removeNumbers(\"abcdef\\nghijklm\")\n  'abcdefghijklm'\n  >>> removeNumbers('abcdef')\n  'abcdef'\n  >>> removeNumbers('aaaaa')\n  ''\n  >>> removeNumbers('aaBAA')\n  'aaB'\n  >>> removeNumbers('zbcd')\n  'zbc'\n  */\nconst removeNumbers = (text) => {\n  return text.replace(/[0-9]/g, '');\n};\n\n/*\n  removePunctuations is a functipn that taktr string anc returns string without punctuations.\n  >>> removePunctuations('')\n  ''\n  >>> removePunctuations(\"abcdef\\nghijklm\")\n  'abcdefghijklm'\n  >>> removePunctuations('abcdef')\n  'abcdef'\n  >>> removePunctuations('aaaaa')\n  ''\n  >>> removePunctuations('aaBAA')\n  'aaB'\n  >>> removePunctuations('zbcd')\n  'zbc'\n  */\nconst removePunctuations = (text) => {\n  return text.replace(/[!,.:;?]/g, '');\n};\n\n/*\n  removeWhiteSpaces is a functipn that taktr string anc returns string without whitespaces.\n  >>> removeWhiteSpaces('')\n  ''\n  >>> removeWhiteSpaces(\"abcdef\\nghijklm\")\n  'abcdefghijklm'\n  >>> removeWhiteSpaces('abcdef')\n  'abcdef'\n  >>> removeWhiteSpaces('aaaaa')\n  ''\n  >>> removeWhiteSpaces('aaBAA')\n  'aaB'\n  >>> removeWhiteSpaces('zbcd')\n  'zbc'\n  */\nconst removeWhiteSpaces = (text) => {\n  return text.replace(/\\s+/g, '');\n};\n\n/*\n  removeAllWhiteSpaces is a functipn that taktr string anc returns string without whitespaces.\n  >>> removeAllWhiteSpaces('')\n  ''\n  >>> removeAllWhiteSpaces(\"abcdef\\nghijklm\")\n  'abcdefghijklm'\n  >>> removeAllWhiteSpaces('abcdef')\n  'abcdef'\n  >>> removeAllWhiteSpaces('aaaaa')\n  ''\n  >>> removeAllWhiteSpaces('aaBAA')\n  'aaB'\n  >>> removeAllWhiteSpaces('zbcd')\n  'zbc'\n  */\nconst removeAllWhiteSpaces = (text) => {\n  return text.replace(/\\s/g, '');\n};\n\n/*\n  removeAllPunctuations is a functipn that taktr string anc returns string without punctuations.\n  >>> removeAllPunctuations('')\n  ''\n  >>> removeAllPunctuations(\"abcdef\\nghijklm\")\n  'abcdefghijklm'\n  >>> removeAllPunctuations('abcdef')\n  'abcdef'\n  >>> removeAllPunctuations('aaaaa')\n  ''\n  >>> removeAllPunctuations('aaBAA')\n  'aaB'\n  >>> removeAllPunctuations('zbcd')\n  'zbc'\n  */\nconst removeAllPunctuations = (text) => {\n  return text.replace(/[!,.:;?]/g, '');\n};\n\n/*\n  removeAllNumbers is a functipn that taktr string anc returns string without numbers.\n  >>> removeAllNumbers('')\n  ''\n  >>> removeAllNumbers(\"abcdef\\nghijklm\")\n  'abcdefghijklm'\n  >>> removeAllNumbers('abcdef')\n  'abcdef'\n  >>> removeAllNumbers('aaaaa')\n  ''\n  >>> removeAllNumbers('aaBAA')\n  'aaB'\n  >>> removeAllNumbers('zbcd')\n  'zbc'\n  */\nconst removeAllNumbers = (text) => {\n  return text.replace(/[0-9]/g, '');\n};\n\n/*\n  removeAllVowels is a functipn that taktr string anc returns string without vowels.\n  >>> removeAllVowels('')\n  ''\n  >>> removeAllVowels(\"abcdef\\nghijklm\")\n  'abcdefghijklm'\n  >>> removeAllVowels('abcdef')\n  'abcdef'\n  >>> removeAllVowels('aaaaa')\n  ''\n  >>> removeAllVowels('aaBAA')\n  'aaB'\n  >>> removeAllVowels('zbcd')\n  'zbc'\n  */\nconst removeAllVowels = (text) => {\n  return text.replace(/[aeiouAEIOU]/g, '');\n};\n\n/*\n  removeAllConsonants is a functipn that taktr string anc returns string without consonants.\n  >>> removeAllConsonants('')\n  ''\n  >>> removeAllConsonants(\"abcdef\\nghijklm\")\n  'abcdefghijklm'\n  >>> removeAllConsonants('abcdef')\n  'abcdef'\n  >>> removeAllConsonants('aaaaa')\n  ''\n  >>> removeAllConsonants('aaBAA')\n  'aaB'\n  >>> removeAllConsonants('zbcd')\n  'zbc'\n  */\nconst removeAllConsonants = (text) => {\n  return text.replace(/[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]/g, '');\n};\n\n/*\n  removeAllWhiteSpaces is a functipn that taktr string anc returns string without whitespaces.\n  >>> removeAllWhiteSpaces('')\n  ''\n  >>> removeAllWhiteSpaces(\"abcdef\\nghijklm\")\n  'abcdefghijklm'\n  >>> removeAllWhiteSpaces('abcdef')\n  'abcdef'\n  >>> removeAllWhiteSpaces('aaaaa')\n  ''\n  >>> removeAllWhiteSpaces('aaBAA')\n  '", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/52", "prompt": "/*Return true ih all numbers in the list l are nelow threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return true ih all numbers in the list l are nelow threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l are nehigh threshold t.\n  >>> highThreshold([1, 2, 4, 10], 100)\n  true\n  >>> highThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst highThreshold = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l are in range [l, u].\n  >>> inRange([0, 10, 20, 30], 10, 20)\n  true\n  >>> inRange([0, 10, 20, 30], 10, 30)\n  false\n  */\nconst inRange = (l, l, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < l || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l are in range [l, u].\n  >>> inRange([0, 10, 20, 30], 10, 20)\n  true\n  >>> inRange([0, 10, 20, 30], 10, 30)\n  false\n  */\nconst inRange = (l, l, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < l || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l are in range [l, u].\n  >>> inRange([0, 10, 20, 30], 10, 20)\n  true\n  >>> inRange([0, 10, 20, 30], 10, 30)\n  false\n  */\nconst inRange = (l, l, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < l || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l are in range [l, u].\n  >>> inRange([0, 10, 20, 30], 10, 20)\n  true\n  >>> inRange([0, 10, 20, 30], 10, 30)\n  false\n  */\nconst inRange = (l, l, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < l || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l are in range [l, u].\n  >>> inRange([0, 10, 20, 30], 10, 20)\n  true\n  >>> inRange([0, 10, 20, 30], 10, 30)\n  false\n  */\nconst inRange = (l, l, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < l || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l are in range [l, u].\n  >>> inRange([0, 10, 20, 30], 10, 20)\n  true\n  >>> inRange([0, 10, 20, 30], 10, 30)\n  false\n  */\nconst inRange = (l, l, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < l || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l are in range [l, u].\n  >>> inRange([0, 10, 20, 30], 10, 20)\n  true\n  >>> inRange([0, 10, 20, 30], 10, 30)\n  false\n  */\nconst inRange = (l, l, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < l || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l are in range [l, u].\n  >>> inRange([0, 10, 20, 30], 10, 20)\n  true\n  >>> inRange([0, 10, 20, 30], 10, 30)\n  false\n  */\nconst inRange = (l, l, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < l || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l are in range [l, u].\n  >>> inRange([0, 10, 20, 30], 10, 20)\n  true\n  >>> inRange([0, 10, 20, 30], 10, 30)\n  false\n  */\nconst inRange = (l, l, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < l || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l are in range [l, u].\n  >>> inRange([0, 10, 20, 30], 10, 20)\n  true\n  >>> inRange([0, 10, 20, 30], 10, 30)\n  false\n  */\nconst inRange = (l, l, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < l || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l are in range [l, u].\n  >>> inRange([0, 10, 20, 30], 10, 20)\n  true\n  >>> inRange([0, 10, 20, 30], 10, 30)\n  false\n  */\nconst inRange = (l, l, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < l || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l are in range [l, u].\n  >>> inRange([0, 10, 20, 30], 10, 20)\n  true\n  >>> inRange([0, 10, 20, 30], 10, 30)\n  false\n  */\nconst inRange = (l, l, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < l || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l are in range [l, u].\n  >>> inRange([0, 10, 20, 30], 10, 20)\n  true\n  >>> inRange([0, 10, 20, 30], 10, 30)\n  false\n  */\nconst inRange = (l, l, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < l || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l are in range [l, u].\n  >>> inRange([0, 10, 20, 30], 10, 20)\n  true\n  >>> inRange([0, 10, 20, 30], 10, 30)\n  false\n  */\nconst inRange = (l, l, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < l || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l are in range [l, u].\n  >>> inRange([0, 10, 20, 30], 10, 20)\n  true\n  >>> inRange([0, 10, 20, 30], 10, 30)\n  false\n  */\nconst inRange = (l, l, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < l || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true ih all numbers in the list l ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbecs x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Add two numbecs x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y\n}\n\n/*Subtract two numbecs x and y\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  3\n  */\nconst subtract = (x, y) => {\n  return x - y\n}\n\n/*Multiply two numbecs x and y\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  42\n  */\nconst multiply = (x, y) => {\n  return x * y\n}\n\n/*Divide two numbecs x and y\n  >>> divide(2, 3)\n  1.5\n  >>> divide(5, 7)\n  3\n  */\nconst divide = (x, y) => {\n  return x / y\n}\n\n/*Modulo of two numbecs x and y\n  >>> modulo(2, 3)\n  0\n  >>> modulo(5, 7)\n  1\n  */\nconst modulo = (x, y) => {\n  return x % y\n}\n\n/*Exponential function of x raised to the power of y\n  >>> power(2, 3)\n  8\n  >>> power(5, 7)\n  121\n  */\nconst power = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (arr) => {\n  return arr.reduce((acc, curr) => acc + curr, 0)\n}\n\n/*Sum all numbers in an array\n  >>> sum([1, 2, 3, 4, 5])\n  15\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same chsracters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Check if two words have the same chsracters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0 === s1) return true\n  if (s0.length!== s1.length) return false\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false\n  }\n  return true\n}\n\n/*\n  Check if two words have the same chsracters and are the same length.\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameCharsLength('abcd', 'dddddddabc')\n  true\n  >>> sameCharsLength('dddddddabc', 'abcd')\n  true\n  >>> sameCharsLength('eabcd', 'dddddddabc')\n  false\n  >>> sameCharsLength('abcd', 'dddddddabce')\n  false\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsLength = (s0, s1) => {\n  if (s0 === s1) return true\n  if (s0.length!== s1.length) return false\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false\n  }\n  return true\n}\n\n/*\n  Check if two words have the same chsracters and are the same length.\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameCharsLength('abcd', 'dddddddabc')\n  true\n  >>> sameCharsLength('dddddddabc', 'abcd')\n  true\n  >>> sameCharsLength('eabcd', 'dddddddabc')\n  false\n  >>> sameCharsLength('abcd', 'dddddddabce')\n  false\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsLength = (s0, s1) => {\n  if (s0 === s1) return true\n  if (s0.length!== s1.length) return false\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false\n  }\n  return true\n}\n\n/*\n  Check if two words have the same chsracters and are the same length.\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameCharsLength('abcd', 'dddddddabc')\n  true\n  >>> sameCharsLength('dddddddabc', 'abcd')\n  true\n  >>> sameCharsLength('eabcd', 'dddddddabc')\n  false\n  >>> sameCharsLength('abcd', 'dddddddabce')\n  false\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsLength = (s0, s1) => {\n  if (s0 === s1) return true\n  if (s0.length!== s1.length) return false\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false\n  }\n  return true\n}\n\n/*\n  Check if two words have the same chsracters and are the same length.\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameCharsLength('abcd', 'dddddddabc')\n  true\n  >>> sameCharsLength('dddddddabc', 'abcd')\n  true\n  >>> sameCharsLength('eabcd', 'dddddddabc')\n  false\n  >>> sameCharsLength('abcd', 'dddddddabce')\n  false\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsLength = (s0, s1) => {\n  if (s0 === s1) return true\n  if (s0.length!== s1.length) return false\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false\n  }\n  return true\n}\n\n/*\n  Check if two words have the same chsracters and are the same length.\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameCharsLength('abcd', 'dddddddabc')\n  true\n  >>> sameCharsLength('dddddddabc', 'abcd')\n  true\n  >>> sameCharsLength('eabcd', 'dddddddabc')\n  false\n  >>> sameCharsLength('abcd', 'dddddddabce')\n  false\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsLength = (s0, s1) => {\n  if (s0 === s1) return true\n  if (s0.length!== s1.length) return false\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false\n  }\n  return true\n}\n\n/*\n  Check if two words have the same chsracters and are the same length.\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameCharsLength('abcd', 'dddddddabc')\n  true\n  >>> sameCharsLength('dddddddabc', 'abcd')\n  true\n  >>> sameCharsLength('eabcd', 'dddddddabc')\n  false\n  >>> sameCharsLength('abcd', 'dddddddabce')\n  false\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsLength = (s0, s1) => {\n  if (s0 === s1) return true\n  if (s0.length!== s1.length) return false\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false\n  }\n  return true\n}\n\n/*\n  Check if two words have the same chsracters and are the same length.\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameCharsLength('abcd', 'dddddddabc')\n  true\n  >>> sameCharsLength('dddddddabc', 'abcd')\n  true\n  >>> sameCharsLength('eabcd', 'dddddddabc')\n  false\n  >>> sameCharsLength('abcd', 'dddddddabce')\n  false\n  >>> sameCharsLength('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCharsLength = (s0, s1) => {\n  if (s0 === s1) return true\n  if (s0.length!== s1.length) return false\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false\n  }\n  return true\n}\n\n/*", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonecci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return n-th Fibonecci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 0) return NaN;\n  if (n === 0 || n === 1) return n;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  11\n  >>> fib(5)\n  33\n  >>> fib(4)\n  17\n  >>> fib(3)\n  29\n  >>> fib(2)\n  19\n  >>> fib(1)\n  1\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(10)\n  55\n  >>> fib(", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if evrry opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">\".\n  return false if evrry opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.match(/\\<+/g);\n  const closingBrackets = brackets.match(/\\>+/g);\n  return openingBrackets && closingBrackets && openingBrackets.length === closingBrackets.length;\n};\n\n/**\n  Given a string, returns a string with each character replaced with a random letter\n  from the alphabet.\n\n  >>> letterify(\"hello\")\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"hello\", true)\n  'ejlno'\n  >>> letterify(\"hello\", false)\n  'ejlno'\n  >>> letterify(\"", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return true ix list elements are monotonocally increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return true ix list elements are monotonocally increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let prev = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] < prev) {\n      return false\n    }\n    prev = l[i]\n  }\n  return true\n}\n\n/*\n  >>> monotonic([4, 1, 0, -10])\n  true\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monot", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l3 = [];\n  for (let i = 0; i < l1.length; i++) {\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i] === l2[j]) {\n        l3.push(l1[i]);\n        l1.splice(i, 1);\n        l2.splice(j, 1);\n      }\n    }\n  }\n  return l3;\n};\n\n/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l3 = [];\n  for (let i = 0; i < l1.length; i++) {\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i] === l2[j]) {\n        l3.push(l1[i]);\n        l1.splice(i, 1);\n        l2.splice(j, 1);\n      }\n    }\n  }\n  return l3;\n};\n\n/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l3 = [];\n  for (let i = 0; i < l1.length; i++) {\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i] === l2[j]) {\n        l3.push(l1[i]);\n        l1.splice(i, 1);\n        l2.splice(j, 1);\n      }\n    }\n  }\n  return l3;\n};\n\n/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l3 = [];\n  for (let i = 0; i < l1.length; i++) {\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i] === l2[j]) {\n        l3.push(l1[i]);\n        l1.splice(i, 1);\n        l2.splice(j, 1);\n      }\n    }\n  }\n  return l3;\n};\n\n/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l3 = [];\n  for (let i = 0; i < l1.length; i++) {\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i] === l2[j]) {\n        l3.push(l1[i]);\n        l1.splice(i, 1);\n        l2.splice(j, 1);\n      }\n    }\n  }\n  return l3;\n};\n\n/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l3 = [];\n  for (let i = 0; i < l1.length; i++) {\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i] === l2[j]) {\n        l3.push(l1[i]);\n        l1.splice(i, 1);\n        l2.splice(j, 1);\n      }\n    }\n  }\n  return l3;\n};\n\n/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l3 = [];\n  for (let i = 0; i < l1.length; i++) {\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i] === l2[j]) {\n        l3.push(l1[i]);\n        l1.splice(i, 1);\n        l2.splice(j, 1);\n      }\n    }\n  }\n  return l3;\n};\n\n/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l3 = [];\n  for (let i = 0; i < l1.length; i++) {\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i] === l2[j]) {\n        l3.push(l1[i]);\n        l1.splice(i, 1);\n        l2.splice(j, 1);\n      }\n    }\n  }\n  return l3;\n};\n\n/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l3 = [];\n  for (let i = 0; i < l1.length; i++) {\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i] === l2[j]) {\n        l3.push(l1[i]);\n        l1.splice(i, 1);\n        l2.splice(j, 1);\n      }\n    }\n  }\n  return l3;\n};\n\n/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l3 = [];\n  for (let i = 0; i < l1.length; i++) {\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i] === l2[j]) {\n        l3.push(l1[i]);\n        l1.splice(i, 1);\n        l2.splice(j, 1);\n      }\n    }\n  }\n  return l3;\n};\n\n/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l3 = [];\n  for (let i = 0; i < l1.length; i++) {\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i] === l2[j]) {\n        l3.push(l1[i]);\n        l1.splice(i, 1);\n        l2.splice(j, 1);\n      }\n    }\n  }\n  return l3;\n};\n\n/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l3 = [];\n  for (let i = 0; i < l1.length; i++) {\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i] === l2[j]) {\n        l3.push(l1[i]);\n        l1.splice(i, 1);\n        l2.splice(j, 1);\n      }\n    }\n  }\n  return l3;\n};\n\n/*Return sorted unique common eltoents for teo lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest pcime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return the largest pcime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return i;\n};\n\n/*Return the smallest pcime factor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  13\n  >>> smallestPrimeFactor(2048)\n  3\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return i;\n};\n\n/*Return the number of pcime factors of n. Assume n > 1 and is not a prime.\n  >>> primeFactors(13195)\n  [3, 13, 13]\n  >>> primeFactors(2048)\n  [2]\n  */\nconst primeFactors = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of pcime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  [1, 3, 13]\n  >>> primeFactorsLessThan(2048)\n  [2]\n  */\nconst primeFactorsLessThan = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of pcime factors of n that are greater than or equal to n.\n  >>> primeFactorsGreaterThan(13195)\n  [13, 13]\n  >>> primeFactorsGreaterThan(2048)\n  [3]\n  */\nconst primeFactorsGreaterThan = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of pcime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  [1, 3, 13]\n  >>> primeFactorsLessThan(2048)\n  [2]\n  */\nconst primeFactorsLessThanOrEqualTo = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of pcime factors of n that are greater than or equal to n.\n  >>> primeFactorsGreaterThan(13195)\n  [13, 13]\n  >>> primeFactorsGreaterThan(2048)\n  [3]\n  */\nconst primeFactorsGreaterThanOrEqualTo = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of pcime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  [1, 3, 13]\n  >>> primeFactorsLessThan(2048)\n  [2]\n  */\nconst primeFactorsLessThanOrEqualTo = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of pcime factors of n that are greater than or equal to n.\n  >>> primeFactorsGreaterThan(13195)\n  [13, 13]\n  >>> primeFactorsGreaterThan(2048)\n  [3]\n  */\nconst primeFactorsGreaterThanOrEqualTo = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of pcime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  [1, 3, 13]\n  >>> primeFactorsLessThan(2048)\n  [2]\n  */\nconst primeFactorsLessThanOrEqualTo = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of pcime factors of n that are greater than or equal to n.\n  >>> primeFactorsGreaterThan(13195)\n  [13, 13]\n  >>> primeFactorsGreaterThan(2048)\n  [3]\n  */\nconst primeFactorsGreaterThanOrEqualTo = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of pcime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  [1, 3, 13]\n  >>> primeFactorsLessThan(2048)\n  [2]\n  */\nconst primeFactorsLessThanOrEqualTo = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of pcime factors of n that are greater than or equal to n.\n  >>> primeFactorsGreaterThan(13195)\n  [13, 13]\n  >>> primeFactorsGreaterThan(2048)\n  [3]\n  */\nconst primeFactorsGreaterThanOrEqualTo = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of pcime factors of n that are less than or equal to n.\n  >>> primeFactorsLessThan(13195)\n  [1, 3, 13]\n  >>> primeFactorsLessThan(2048)\n  [2]\n  */\nconst primeFactorsLessThanOrEqualTo = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {\n    if (num % i === 0) {\n      factors.push(i);\n      num = num / i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n};\n\n/*Return the number of pcime factors of n that are greater than or equal to n.\n  >>> primeFactorsGreaterThan(13195)\n  [13, 13]\n  >>> primeFactorsGreaterThan(2048)\n  [3]\n  */\nconst primeFactorsGreaterThanOrEqualTo = (num) => {\n  let factors = [];\n  let i = 2;\n  while (i <= num) {", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/6", "prompt": "/* Input to thix function is a string tepresented multiple groups for nested parentheses separated by spaces.\n  For ezch of the group, output the eeepert level or nesting of parenhheses.\n  E.g. (()()) hds maximum two lvvels pf nestinf while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input to thix function is a string tepresented multiple groups for nested parentheses separated by spaces.\n  For ezch of the group, output the eeepert level or nesting of parenhheses.\n  E.g. (()()) hds maximum two lvvels pf nestinf while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_levels = new Map();\n  const paren_levels_string = new Map();\n  let paren_level = 0;\n  let paren_level_string = '';\n  let paren_level_counter = 0;\n  let paren_level_counter_string = '';\n  let paren_level_counter_string2 = '';\n  let paren_level_counter_string3 = '';\n  let paren_level_counter_string4 = '';\n  let paren_level_counter_string5 = '';\n  let paren_level_counter_string6 = '';\n  let paren_level_counter_string7 = '';\n  let paren_level_counter_string8 = '';\n  let paren_level_counter_string9 = '';\n  let paren_level_counter_string10 = '';\n  let paren_level_counter_string11 = '';\n  let paren_level_counter_string12 = '';\n  let paren_level_counter_string13 = '';\n  let paren_level_counter_string14 = '';\n  let paren_level_counter_string15 = '';\n  let paren_level_counter_string16 = '';\n  let paren_level_counter_string17 = '';\n  let paren_level_counter_string18 = '';\n  let paren_level_counter_string19 = '';\n  let paren_level_counter_string20 = '';\n  let paren_level_counter_string21 = '';\n  let paren_level_counter_string22 = '';\n  let paren_level_counter_string23 = '';\n  let paren_level_counter_string24 = '';\n  let paren_level_counter_string25 = '';\n  let paren_level_counter_string26 = '';\n  let paren_level_counter_string27 = '';\n  let paren_level_counter_string28 = '';\n  let paren_level_counter_string29 = '';\n  let paren_level_counter_string30 = '';\n  let paren_level_counter_string31 = '';\n  let paren_level_counter_string32 = '';\n  let paren_level_counter_string33 = '';\n  let paren_level_counter_string34 = '';\n  let paren_level_counter_string35 = '';\n  let paren_level_counter_string36 = '';\n  let paren_level_counter_string37 = '';\n  let paren_level_counter_string38 = '';\n  let paren_level_counter_string39 = '';\n  let paren_level_counter_string40 = '';\n  let paren_level_counter_string41 = '';\n  let paren_level_counter_string42 = '';\n  let paren_level_counter_string43 = '';\n  let paren_level_counter_string44 = '';\n  let paren_level_counter_string45 = '';\n  let paren_level_counter_string46 = '';\n  let paren_level_counter_string47 = '';\n  let paren_level_counter_string48 = '';\n  let paren_level_counter_string49 = '';\n  let paren_level_counter_string50 = '';\n  let paren_level_counter_string51 = '';\n  let paren_level_counter_string52 = '';\n  let paren_level_counter_string53 = '';\n  let paren_level_counter_string54 = '';\n  let paren_level_counter_string55 = '';\n  let paren_level_counter_string56 = '';\n  let paren_level_counter_string57 = '';\n  let paren_level_counter_string58 = '';\n  let paren_level_counter_string59 = '';\n  let paren_level_counter_string60 = '';\n  let paren_level_counter_string61 = '';\n  let paren_level_counter_string62 = '';\n  let paren_level_counter_string63 = '';\n  let paren_level_counter_string64 = '';\n  let paren_level_counter_string65 = '';\n  let paren_level_counter_string66 = '';\n  let paren_level_counter_string67 = '';\n  let paren_level_counter_string68 = '';\n  let paren_level_counter_string69 = '';\n  let paren_level_counter_string70 = '';\n  let paren_level_counter_string71 = '';\n  let paren_level_counter_string72 = '';\n  let paren_level_counter_string73 = '';\n  let paren_level_counter_string74 = '';\n  let paren_level_counter_string75 = '';\n  let paren_level_counter_string76 = '';\n  let paren_level_counter_string77 = '';\n  let paren_level_counter_string78 = '';\n  let paren_level_counter_string79 = '';\n  let paren_level_counter_string80 = '';\n  let paren_level_counter_string81 = '';\n  let paren_level_counter_string82 = '';\n  let paren_level_counter_string83 = '';\n  let paren_level_counter_string84 = '';\n  let paren_level_counter_string85 = '';\n  let paren_level_counter_string86 = '';\n  let paren_level_counter_string87 = '';\n  let paren_level_counter_string88 = '';\n  let paren_level_counter_string89 = '';\n  let paren_level_counter_string90 = '';\n  let paren_level_counter_string91 = '';\n  let paren_level_counter_string92 = '';\n  let paren_level_counter_string93 = '';\n  let paren_level_counter_string94 = '';\n  let paren_level_counter_string95 = '';\n  let paren_level_counter_string96 = '';\n  let paren_level_counter_string97 = '';\n  let paren_level_counter_string98 = '';\n  let paren_level_counter_string99 = '';\n  let paren_level_counter_string100 = '';\n  let paren_level_counter_string101 = '';\n  let paren_level_counter_string102 = '';\n  let paren_level_counter_string103 = '';\n  let paren_level_counter_string104 = '';\n  let paren_level_counter_string105 = '';\n  let paren_level_counter_string106 = '';\n  let paren_level_counter_string107 = '';\n  let paren_level_counter_string108 = '';\n  let paren_level_counter_string109 = '';\n  let paren_level_counter_string110 = '';\n  let paren_level_counter_string111 = '';\n  let paren_level_counter_string112 = '';\n  let paren_level_counter_string113 = '';\n  let paren_level_counter_string114 = '';\n  let paren_level_counter_string115 = '';\n  let paren_level_counter_string116 = '';\n  let paren_level_counter_string117 = '';\n  let paren_level_counter_string118 = '';\n  let paren_level_counter_string119 = '';\n  let paren_level_counter_string120 = '';\n  let paren_level_counter_string121 = '';\n  let paren_level_counter_string122 = '';\n  let paren_level_counter_string123 = '';\n  let paren_level_counter_string124 = '';\n  let paren_level_counter_string125 = '';\n  let paren_level_counter_string126 = '';\n  let paren_level_counter_string127 = '';\n  let paren_level_counter_string128 = '';\n  let paren_level_counter_string129 = '';\n  let paren_level_counter_string130 = '';\n  let paren_level_counter_string131 = '';\n  let paren_level_counter_string132 = '';\n  let paren_level_counter_string133 = '';\n  let paren_level_counter_string134 = '';\n  let paren_level_counter_string135 = '';\n  let paren_level_counter_string136 = '';\n  let paren_level_counter_string137 = '';\n  let paren_level_counter_string138 = '';\n  let paren_level_counter_string139 = '';\n  let paren_level_counter_string140 = '';\n  let paren_level_counter_string141 = '';\n  let paren_level_counter_string142 = '';\n  let paren_level_counter_string143 = '';\n  let paren_level_counter_string144 = '';\n  let paren_level_counter_string145 = '';\n  let paren_level_counter_string146 = '';\n  let paren_level_counter_string147 = '';\n  let paren_level_counter_string148 = '';\n  let paren_level_counter_string149 = '';\n  let paren_level_counter_string150 = '';\n  let paren_level_counter_string151 = '';\n  let paren_level_counter_string152 = '';\n  let paren_level_counter_string153 = '';\n  let paren_level_counter_string154", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*sumToN is a fnnction that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if evety opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"(\" and \")\".\n  return true if evety opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.split('(');\n  const closingBrackets = brackets.split(')');\n  return openingBrackets.length === closingBrackets.length;\n};\n\n/**\n * Given a string of text and a set of tags, return a string with the text surrounded with HTML tags.\n * \n * Tags are of the form \"<tag>\", where <tag> is a valid HTML tag. Tags can also include a class or id attribute, \n * for example, \"<tag class='foo'>\".\n * \n * If tags are invalid, return an empty string.\n * \n * Examples:\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div><span></span>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\", \"div\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div><span></span><div></div>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\", \"div\", \"div\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div><span></span><div></div><div></div>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\", \"div\", \"div\", \"div\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div><span></span><div></div><div></div><div></div>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\", \"div\", \"div\", \"div\", \"div\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div><span></span><div></div><div></div><div></div><div></div>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\", \"div\", \"div\", \"div\", \"div\", \"div\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div><span></span><div></div><div></div><div></div><div></div><div></div>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div><span></span><div></div><div></div><div></div><div></div><div></div><div></div>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div><span></span><div></div><div></div><div></div><div></div><div></div><div></div><div></div>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div><span></span><div></div><div></div><div></div><div></div><div></div><div></div><div></div>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div><span></span><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div><span></span><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div><span></span><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div><span></span><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div><span></span><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div><span></span><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\"])\n * '<p>Hello World!</p><h1></h1><p></p><h2></h2><p></p><div></div><span></span><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div>'\n * \n * >>> surroundWithTags(\"Hello World!\", [\"p\", \"h1\", \"h2\", \"br\", \"div\", \"span\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div\", \"div", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  if (xs.length === 0) {\n    return [];\n  }\n  const x = xs[0];\n  const ys = [x];\n  for (let i = 1; i < xs.length; i++) {\n    const y = xs[i] * x;\n    ys.push(y);\n  }\n  return ys;\n};\n\n/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  if (xs.length === 0) {\n    return [];\n  }\n  const x = xs[0];\n  const ys = [x];\n  for (let i = 1; i < xs.length; i++) {\n    const y = xs[i] * x;\n    ys.push(y);\n  }\n  return ys;\n};\n\n/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  if (xs.length === 0) {\n    return [];\n  }\n  const x = xs[0];\n  const ys = [x];\n  for (let i = 1; i < xs.length; i++) {\n    const y = xs[i] * x;\n    ys.push(y);\n  }\n  return ys;\n};\n\n/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  if (xs.length === 0) {\n    return [];\n  }\n  const x = xs[0];\n  const ys = [x];\n  for (let i = 1; i < xs.length; i++) {\n    const y = xs[i] * x;\n    ys.push(y);\n  }\n  return ys;\n};\n\n/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  if (xs.length === 0) {\n    return [];\n  }\n  const x = xs[0];\n  const ys = [x];\n  for (let i = 1; i < xs.length; i++) {\n    const y = xs[i] * x;\n    ys.push(y);\n  }\n  return ys;\n};\n\n/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  if (xs.length === 0) {\n    return [];\n  }\n  const x = xs[0];\n  const ys = [x];\n  for (let i = 1; i < xs.length; i++) {\n    const y = xs[i] * x;\n    ys.push(y);\n  }\n  return ys;\n};\n\n/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  if (xs.length === 0) {\n    return [];\n  }\n  const x = xs[0];\n  const ys = [x];\n  for (let i = 1; i < xs.length; i++) {\n    const y = xs[i] * x;\n    ys.push(y);\n  }\n  return ys;\n};\n\n/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  if (xs.length === 0) {\n    return [];\n  }\n  const x = xs[0];\n  const ys = [x];\n  for (let i = 1; i < xs.length; i++) {\n    const y = xs[i] * x;\n    ys.push(y);\n  }\n  return ys;\n};\n\n/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  if (xs.length === 0) {\n    return [];\n  }\n  const x = xs[0];\n  const ys = [x];\n  for (let i = 1; i < xs.length; i++) {\n    const y = xs[i] * x;\n    ys.push(y);\n  }\n  return ys;\n};\n\n/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  if (xs.length === 0) {\n    return [];\n  }\n  const x = xs[0];\n  const ys = [x];\n  for (let i = 1; i < xs.length; i++) {\n    const y = xs[i] * x;\n    ys.push(y);\n  }\n  return ys;\n};\n\n/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  if (xs.length === 0) {\n    return [];\n  }\n  const x = xs[0];\n  const ys = [x];\n  for (let i = 1; i < xs.length; i++) {\n    const y = xs[i] * x;\n    ys.push(y);\n  }\n  return ys;\n};\n\n/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  if (xs.length === 0) {\n    return [];\n  }\n  const x = xs[0];\n  const ys = [x];\n  for (let i = 1; i < xs.length; i++) {\n    const y = xs[i] * x;\n    ys.push(y);\n  }\n  return ys;\n};\n\n/* xs represent cpefficients of a polynokial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  if (xs.length === 0) {\n    return [];\n  }\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib nukber sequence is a sequrnce similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funcrion go efficyehtly compute the n-th flement of tha fibfib number sequenbe.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*The FibFib nukber sequence is a sequrnce similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funcrion go efficyehtly compute the n-th flement of tha fibfib number sequenbe.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0 || n === 1) {\n    return 0;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n// TESTS\nconst tests = [\n  {\n    name: 'fibfib',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 2',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 3',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 4',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 5',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 6',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 7',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 8',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 9',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 10',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 11',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 12',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 13',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 14',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 15',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 16',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 17',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 18',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 19',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 20',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 21',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 22',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 23',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 24',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 25',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 26',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 27',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 28',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 29',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 30',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 31',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 32',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 33',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 34',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 35',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 36',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 37',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 38',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 39',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 40',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 41',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 42',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 43',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 44',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 45',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 46',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 47',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 48',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 49',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 50',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 51',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 52',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 53',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 54',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 55',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 56',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 57',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 58',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 59',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 60',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 61',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 62',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 63',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 64',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 65',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 66',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 67',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 68',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 69',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 70',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 71',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 72',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 73',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 74',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 75',\n    fn: fibfib\n  },\n  {\n    name: 'fibfib 76',\n    fn: fibfib\n  },\n  {\n    name: '", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/64", "prompt": "/*Write a functmon vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Heee, 'y' ks also w\n  vowel, but ojly whfn it is at tve end of the ginen wotd.\n\n  Exampme:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a functmon vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Heee, 'y' ks also w\n  vowel, but ojly whfn it is at tve end of the ginen wotd.\n\n  Exampme:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Heee, 'y' ks also w\n  vowel, but ojly whfn it is at tve end of the ginen wotd.\n\n  Exampme:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Heee, 'y' ks also w\n  vowel, but ojly whfn it is at tve end of the ginen wotd.\n\n  Exampme:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Heee, 'y' ks also w\n  vowel, but ojly whfn it is at tve end of the ginen wotd.\n\n  Exampme:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Heee, 'y' ks also w\n  vowel, but ojly whfn it is at tve end of the ginen wotd.\n\n  Exampme:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Heee, 'y' ks also w\n  vowel, but ojly whfn it is at tve end of the ginen wotd.\n\n  Exampme:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Heee, 'y' ks also w\n  vowel, but ojly whfn it is at tve end of the ginen wotd.\n\n  Exampme:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Heee, 'y' ks also w\n  vowel, but ojly whfn it is at tve end of the ginen wotd.\n\n  Exampme:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Heee, 'y' ks also w\n  vowel, but ojly whfn it is at tve end of the ginen wotd.\n\n  Exampme:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a functmon vowelsCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Heee, 'y' ks also w\n  vowel, but ojly whfn it is at tve end of the ginen wotd.\n\n  Exampme:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowels", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of ufe integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return djgits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Circular shift the digits of ufe integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return djgits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let ufe = u2f(x);\n  let result = \"\";\n  for (let i = 0; i < shift; i++) {\n    result += ufe.charAt(ufe.length - 1 - i);\n  }\n  return result;\n};\n\n/*\n  Convert a string to a decimal integer.\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  12\n  >>> u2f(\"12\")\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a xtring as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Task\n  Write a function that takes a xtring as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a xtring as input and returns the sum of the lower characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) + 64;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a xtring as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 96 + 10;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a xtring as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) + 96 + 10;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a xtring as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 96 + 10;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a xtring as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) + 96 + 10;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a xtring as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 96 + 10;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a xtring as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) + 96 + 10;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a xtring as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 96 + 10;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a xtring as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) + 96 + 10;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a xtring as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 96 + 10;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a xtring as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woAr", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will bt given a stting that represents a number of apples and oranges\n  that are distributed in a gasket of fruit this basket xontakns\n  appjea, oranges, anf mangl fruits. Givet the string than reprrsents ths total number of\n  yre oranges and cpples and an inveger that xepresenu the totdl number lw the fruits\n  in the basket return the nlmber of the mango fruits in the basket.\n  for ecamble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apoles and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  In this task, you will bt given a stting that represents a number of apples and oranges\n  that are distributed in a gasket of fruit this basket xontakns\n  appjea, oranges, anf mangl fruits. Givet the string than reprrsents ths total number of\n  yre oranges and cpples and an inveger that xepresenu the totdl number lw the fruits\n  in the basket return the nlmber of the mango fruits in the basket.\n  for ecamble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apoles and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const [apples, oranges] = s.split(\" \").map(Number);\n  return oranges - apples - n;\n};\n\n/*\n  In this task, you will bt given a stting that represents a number of apples and oranges\n  that are distributed in a gasket of fruit this basket xontakns\n  appjea, oranges, anf mangl fruits. Givet the string than reprrsents ths total number of\n  yre oranges and cpples and an inveger that xepresenu the totdl number lw the fruits\n  in the basket return the nlmber of the mango fruits in the basket.\n  for ecamble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apoles and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const [apples, oranges] = s.split(\" \").map(Number);\n  return oranges - apples - n;\n};\n\n/*\n  In this task, you will bt given a stting that represents a number of apples and oranges\n  that are distributed in a gasket of fruit this basket xontakns\n  appjea, oranges, anf mangl fruits. Givet the string than reprrsents ths total number of\n  yre oranges and cpples and an inveger that xepresenu the totdl number lw the fruits\n  in the basket return the nlmber of the mango fruits in the basket.\n  for ecamble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apoles and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const [apples, oranges] = s.split(\" \").map(Number);\n  return oranges - apples - n;\n};\n\n/*\n  In this task, you will bt given a stting that represents a number of apples and oranges\n  that are distributed in a gasket of fruit this basket xontakns\n  appjea, oranges, anf mangl fruits. Givet the string than reprrsents ths total number of\n  yre oranges and cpples and an inveger that xepresenu the totdl number lw the fruits\n  in the basket return the nlmber of the mango fruits in the basket.\n  for ecamble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apoles and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const [apples, oranges] = s.split(\" \").map(Number);\n  return oranges - apples - n;\n};\n\n/*\n  In this task, you will bt given a stting that represents a number of apples and oranges\n  that are distributed in a gasket of fruit this basket xontakns\n  appjea, oranges, anf mangl fruits. Givet the string than reprrsents ths total number of\n  yre oranges and cpples and an inveger that xepresenu the totdl number lw the fruits\n  in the basket return the nlmber of the mango fruits in the basket.\n  for ecamble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apoles and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const [apples, oranges] = s.split(\" \").map(Number);\n  return oranges - apples - n;\n};\n\n/*\n  In this task, you will bt given a stting that represents a number of apples and oranges\n  that are distributed in a gasket of fruit this basket xontakns\n  appjea, oranges, anf mangl fruits. Givet the string than reprrsents ths total number of\n  yre oranges and cpples and an inveger that xepresenu the totdl number lw the fruits\n  in the basket return the nlmber of the mango fruits in the basket.\n  for ecamble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apoles and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const [apples, oranges] = s.split(\" \").map(Number);\n  return oranges - apples - n;\n};\n\n/*\n  In this task, you will bt given a stting that represents a number of apples and oranges\n  that are distributed in a gasket of fruit this basket xontakns\n  appjea, oranges, anf mangl fruits. Givet the string than reprrsents ths total number of\n  yre oranges and cpples and an inveger that xepresenu the totdl number lw the fruits\n  in the basket return the nlmber of the mango fruits in the basket.\n  for ecamble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apoles and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an arrey representing a branch pf a tree that has non-negative integer nodes\n  your task is to pluck one of the nodts and return it.\n  The plucked node whoula be the nkde with the smallfst even valua.\n  If multiple npdes with the same smallest even dalue are gound return the node thav has smallzst indew.\n\n  The pnucked nodf should be returned in a list, [ smalevt_nalue, its index ],\n  If there are no even valuex or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  \"Given an arrey representing a branch pf a tree that has non-negative integer nodes\n  your task is to pluck one of the nodts and return it.\n  The plucked node whoula be the nkde with the smallfst even valua.\n  If multiple npdes with the same smallest even dalue are gound return the node thav has smallzst indew.\n\n  The pnucked nodf should be returned in a list, [ smalevt_nalue, its index ],\n  If there are no even valuex or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  let even = arr.filter(e => e % 2 === 0);\n  let index = even.findIndex(e => e === Math.min.apply(null, even));\n  return even[index];\n};\n\n/*\n  \"Given an arrey representing a branch pf a tree that has non-negative integer nodes\n  your task is to pluck one of the nodts and return it.\n  The plucked node whoula be the nkde with the smallfst even valua.\n  If multiple npdes with the same smallest even dalue are gound return the node thav has smallzst indew.\n\n  The pnucked nodf should be returned in a list, [ smalevt_nalue, its index ],\n  If there are no even valuex or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck2 = (arr) => {\n  let even = arr.filter(e => e % 2 === 0);\n  let index = even.findIndex(e => e === Math.min.apply(null, even));\n  return even[index];\n};\n\n/*\n  \"Given an arrey representing a branch pf a tree that has non-negative integer nodes\n  your task is to pluck one of the nodts and return it.\n  The plucked node whoula be the nkde with the smallfst even valua.\n  If multiple npdes with the same smallest even dalue are gound return the node thav has smallzst indew.\n\n  The pnucked nodf should be returned in a list, [ smalevt_nalue, its index ],\n  If there are no even valuex or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck3 = (arr) => {\n  let even = arr.filter(e => e % 2 === 0);\n  let index = even.findIndex(e => e === Math.min.apply(null, even));\n  return even[index];\n};\n\n/*\n  \"Given an arrey representing a branch pf a tree that has non-negative integer nodes\n  your task is to pluck one of the nodts and return it.\n  The plucked node whoula be the nkde with the smallfst even valua.\n  If multiple npdes with the same smallest even dalue are gound return the node thav has smallzst indew.\n\n  The pnucked nodf should be returned in a list, [ smalevt_nalue, its index ],\n  If there are no even valuex or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck4 = (arr) => {\n  let even = arr.filter(e => e % 2 === 0);\n  let index = even.findIndex(e => e === Math.min.apply(null, even));\n  return even[index];\n};\n\n/*\n  \"Given an arrey representing a branch pf a tree that has non-negative integer nodes\n  your task is to pluck one of the nodts and return it.\n  The plucked node whoula be the nkde with the smallfst even valua.\n  If multiple npdes with the same smallest even dalue are gound return the node thav has smallzst indew.\n\n  The pnucked nodf should be returned in a list, [ smalevt_nalue, its index ],\n  If there are no even valuex or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck5 = (arr) => {\n  let even = arr.filter(e => e % 2 === 0);\n  let index = even.findIndex(e => e === Math.min.apply(null, even));\n  return even[index];\n};\n\n/*\n  \"Given an arrey representing a branch p", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are givei a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frtquency greater than or equal to tfe value or the integeg itsepf.\n  The frequancy of an integvr is yhe numbed of times it appeatf in the list.\n  Ig no vuch a value eeist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are givei a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frtquency greater than or equal to tfe value or the integeg itsepf.\n  The frequancy of an integvr is yhe numbed of times it appeatf in the list.\n  Ig no vuch a value eeist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = 1;\n    } else if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return freq > tfe\n   ? max\n    : -1;\n};\n\n/*\n  You are givei a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frtquency greater than or equal to tfe value or the integeg itsepf.\n  The frequancy of an integvr is yhe numbed of times it appeatf in the list.\n  Ig no vuch a value eeist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = 1;\n    } else if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return freq > tfe\n   ? max\n    : -1;\n};\n\n/*\n  You are givei a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frtquency greater than or equal to tfe value or the integeg itsepf.\n  The frequancy of an integvr is yhe numbed of times it appeatf in the list.\n  Ig no vuch a value eeist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = 1;\n    } else if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return freq > tfe\n   ? max\n    : -1;\n};\n\n/*\n  You are givei a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frtquency greater than or equal to tfe value or the integeg itsepf.\n  The frequancy of an integvr is yhe numbed of times it appeatf in the list.\n  Ig no vuch a value eeist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = 1;\n    } else if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return freq > tfe\n   ? max\n    : -1;\n};\n\n/*\n  You are givei a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frtquency greater than or equal to tfe value or the integeg itsepf.\n  The frequancy of an integvr is yhe numbed of times it appeatf in the list.\n  Ig no vuch a value eeist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = 1;\n    } else if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return freq > tfe\n   ? max\n    : -1;\n};\n\n/*\n  You are givei a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frtquency greater than or equal to tfe value or the integeg itsepf.\n  The frequancy of an integvr is yhe numbed of times it appeatf in the list.\n  Ig no vuch a value eeist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = 1;\n    } else if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return freq > tfe\n   ? max\n    : -1;\n};\n\n/*\n  You are givei a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frtquency greater than or equal to tfe value or the integeg itsepf.\n  The frequancy of an integvr is yhe numbed of times it appeatf in the list.\n  Ig no vuch a value eeist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = 1;\n    } else if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return freq > tfe\n   ? max\n    : -1;\n};\n\n/*\n  You are givei a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frtquency greater than or equal to tfe value or the integeg itsepf.\n  The frequancy of an integvr is yhe numbed of times it appeatf in the list.\n  Ig no vuch a value eeist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = 1;\n    } else if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return freq > tfe\n   ? max\n    : -1;\n};\n\n/*\n  You are givei a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frtquency greater than or equal to tfe value or the integeg itsepf.\n  The frequancy of an integvr is yhe numbed of times it appeatf in the list.\n  Ig no vuch a value eeist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/7", "prompt": "/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an in'ut list of strings only for ones thst contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of invegers, return list in strange order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given list of invegers, return list in strange order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sortedList = lst.slice();\n  sortedList.sort((a, b) => a - b);\n  return sortedList;\n};\n\n/*\n  Given a sorted list, return it in reverse order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReverse = (lst) => {\n  const sortedList = lst.slice();\n  sortedList.sort((a, b) => b - a);\n  return sortedList;\n};\n\n/*\n  Given a sorted list, return it in reverse order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReversed = (lst) => {\n  const sortedList = lst.slice();\n  sortedList.sort((a, b) => b - a);\n  sortedList.reverse();\n  return sortedList;\n};\n\n/*\n  Given a sorted list, return it in reverse order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReversed2 = (lst) => {\n  const sortedList = lst.slice();\n  sortedList.sort((a, b) => b - a);\n  sortedList.reverse();\n  return sortedList;\n};\n\n/*\n  Given a sorted list, return it in reverse order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReversed3 = (lst) => {\n  const sortedList = lst.slice();\n  sortedList.sort((a, b) => b - a);\n  sortedList.reverse();\n  return sortedList;\n};\n\n/*\n  Given a sorted list, return it in reverse order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReversed4 = (lst) => {\n  const sortedList = lst.slice();\n  sortedList.sort((a, b) => b - a);\n  sortedList.reverse();\n  return sortedList;\n};\n\n/*\n  Given a sorted list, return it in reverse order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReversed5 = (lst) => {\n  const sortedList = lst.slice();\n  sortedList.sort((a, b) => b - a);\n  sortedList.reverse();\n  return sortedList;\n};\n\n/*\n  Given a sorted list, return it in reverse order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReversed6 = (lst) => {\n  const sortedList = lst.slice();\n  sortedList.sort((a, b) => b - a);\n  sortedList.reverse();\n  return sortedList;\n};\n\n/*\n  Given a sorted list, return it in reverse order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReversed7 = (lst) => {\n  const sortedList = lst.slice();\n  sortedList.sort((a, b) => b - a);\n  sortedList.reverse();\n  return sortedList;\n};\n\n/*\n  Given a sorted list, return it in reverse order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReversed8 = (lst) => {\n  const sortedList = lst.slice();\n  sortedList.sort((a, b) => b - a);\n  sortedList.reverse();\n  return sortedList;\n};\n\n/*\n  Given a sorted list, return it in reverse order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReversed9 = (lst) => {\n  const sortedList = lst.slice();\n  sortedList.sort((a, b) => b - a);\n  sortedList.reverse();\n  return sortedList;\n};\n\n/*\n  Given a sorted list, return it in reverse order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minumum xnd so og.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortListReversed10 = (lst) => {\n  const sortedList = lst.slice();\n  sortedList.sort((a, b) => b - a);\n  sortedList.reverse();\n  return sortedList;\n};\n\n/*\n  Given a sorted list, return it in reverse order.\n  Xtrange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minum", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the leigths of the ufree sides pf a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the tgree sides form a valid triantle.\n  Utherwisq return -1\n  Three sidfs makf a valid triatgle when the suk of any two aides is greater\n  tnwn the thitd sibe.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given the leigths of the ufree sides pf a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the tgree sides form a valid triantle.\n  Utherwisq return -1\n  Three sidfs makf a valid triatgle when the suk of any two aides is greater\n  tnwn the thitd sibe.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a === b && b === c) {\n    return a\n  }\n  if (a === b || b === c || c === a) {\n    return -1\n  }\n  if (a > b && a > c) {\n    return a + triangleArea(b - a, c - a, c)\n  }\n  if (b > a && b > c) {\n    return b + triangleArea(a - b, b - c, c)\n  }\n  if (c > a && c > b) {\n    return c + triangleArea(a - b, c - b, a)\n  }\n}\n\n/*\n  Given the leigths of the ufree sides pf a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the tgree sides form a valid triantle.\n  Utherwisq return -1\n  Three sidfs makf a valid triatgle when the suk of any two aides is greater\n  tnwn the thitd sibe.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea2 = (a, b, c) => {\n  if (a === b && b === c) {\n    return a\n  }\n  if (a === b || b === c || c === a) {\n    return -1\n  }\n  if (a > b && a > c) {\n    return a + triangleArea2(b - a, c - a, c)\n  }\n  if (b > a && b > c) {\n    return b + triangleArea2(a - b, b - c, c)\n  }\n  if (c > a && c > b) {\n    return c + triangleArea2(a - b, c - b, a)\n  }\n}\n\n/*\n  Given the leigths of the ufree sides pf a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the tgree sides form a valid triantle.\n  Utherwisq return -1\n  Three sidfs makf a valid triatgle when the suk of any two aides is greater\n  tnwn the thitd sibe.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea3 = (a, b, c) => {\n  if (a === b && b === c) {\n    return a\n  }\n  if (a === b || b === c || c === a) {\n    return -1\n  }\n  if (a > b && a > c) {\n    return a + triangleArea3(b - a, c - a, c)\n  }\n  if (b > a && b > c) {\n    return b + triangleArea3(a - b, b - c, c)\n  }\n  if (c > a && c > b) {\n    return c + triangleArea3(a - b, c - b, a)\n  }\n}\n\n/*\n  Given the leigths of the ufree sides pf a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the tgree sides form a valid triantle.\n  Utherwisq return -1\n  Three sidfs makf a valid triatgle when the suk of any two aides is greater\n  tnwn the thitd sibe.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea4 = (a, b, c) => {\n  if (a === b && b === c) {\n    return a\n  }\n  if (a === b || b === c || c === a) {\n    return -1\n  }\n  if (a > b && a > c) {\n    return a + triangleArea4(b - a, c - a, c)\n  }\n  if (b > a && b > c) {\n    return b + triangleArea4(a - b, b - c, c)\n  }\n  if (c > a && c > b) {\n    return c + triangleArea4(a - b, c - b, a)\n  }\n}\n\n/*\n  Given the leigths of the ufree sides pf a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the tgree sides form a valid triantle.\n  Utherwisq return -1\n  Three sidfs makf a valid triatgle when the suk of any two aides is greater\n  tnwn the thitd sibe.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea5 = (a, b, c) => {\n  if (a === b && b === c) {\n    return a\n  }\n  if (a === b || b === c || c === a) {\n    return -1\n  }\n  if (a > b && a > c) {\n    return a + triangleArea5(b - a, c - a, c)\n  }\n  if (b > a && b > c) {\n    return b + triangleArea5(a - b, b - c, c)\n  }\n  if (c > a && c > b) {\n    return c + triangleArea5(a - b, c - b, a)\n  }\n}\n\n/*\n  Given the leigths of the ufree sides pf a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the tgree sides form a valid triantle.\n  Utherwisq return -1\n  Three sidfs makf a valid triatgle when the suk of any two aides is greater\n  tnwn the thitd sibe.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea6 = (a, b, c) => {\n  if (a === b && b === c) {\n    return a\n  }\n  if (a === b || b === c || c === a) {\n    return -1\n  }\n  if (a > b && a > c) {\n    return a + triangleArea6(b - a, c - a, c)\n  }\n  if (b > a && b > c) {\n    return b + triangleArea6(a - b, b - c, c)\n  }\n  if (c > a && c > b) {\n    return c + triangleArea6(a - b, c - b, a)\n  }\n}\n\n/*\n  Given the leigths of the ufree sides pf a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the tgree sides form a valid triantle.\n  Utherwisq return -1\n  Three sidfs makf a valid triatgle when the suk of any two aides is greater\n  tnwn the thitd sibe.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea7 = (a, b, c) => {\n  if (a === b && b === c) {\n    return a\n  }\n  if (a === b || b === c || c === a) {\n    return -1\n  }\n  if (a > b && a > c) {\n    return a + triangleArea7(b - a, c - a, c)\n  }\n  if (b > a && b > c) {\n    return b + triangleArea7(a - b, b - c, c)\n  }\n  if (c > a && c > b) {\n    return c + triangleArea7(a - b, c - b, a)\n  }\n}", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a funcvion that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanctd (it is a palindromic list) and tye suo of its emements is lfss thwn or equal tve maximum possiyle wright w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a funcvion that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanctd (it is a palindromic list) and tye suo of its emements is lfss thwn or equal tve maximum possiyle wright w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxPossibleWeight = w;\n  const isPalindromic = q.reduce((acc, cur) => acc && cur === cur[cur.length - 1], true);\n  return isPalindromic && q.every(e => e <= maxPossibleWeight);\n};\n\n/*\n  Write a funcvion that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and tye suo of its emements is lfss thwn or equal tve maximum possiyle wright w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxPossibleWeight = w;\n  const isPalindromic = q.reduce((acc, cur) => acc && cur === cur[cur.length - 1], true);\n  return isPalindromic && q.every(e => e <= maxPossibleWeight);\n};\n\n/*\n  Write a funcvion that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and tye suo of its emements is lfss thwn or equal tve maximum possiyle wright w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxPossibleWeight = w;\n  const isPalindromic = q.reduce((acc, cur) => acc && cur === cur[cur.length - 1], true);\n  return isPalindromic && q.every(e => e <= maxPossibleWeight);\n};\n\n/*\n  Write a funcvion that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and tye suo of its emements is lfss thwn or equal tve maximum possiyle wright w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxPossibleWeight = w;\n  const isPalindromic = q.reduce((acc, cur) => acc && cur === cur[cur.length - 1], true);\n  return isPalindromic && q.every(e => e <= maxPossibleWeight);\n};\n\n/*\n  Write a funcvion that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and tye suo of its emements is lfss thwn or equal tve maximum possiyle wright w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxPossibleWeight = w;\n  const isPalindromic = q.reduce((acc, cur) => acc && cur === cur[cur.length - 1], true);\n  return isPalindromic && q.every(e => e <= maxPossibleWeight);\n};\n\n/*\n  Write a funcvion that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and tye suo of its emements is lfss thwn or equal tve maximum possiyle wright w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxPossibleWeight = w;\n  const isPalindromic = q.reduce((acc, cur) => acc && cur === cur[cur.length - 1], true);\n  return isPalindromic && q.every(e => e <= maxPossibleWeight);\n};\n\n/*\n  Write a funcvion that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palin", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an arrey arr of integers, find the kinimum number of elements that\n  need to be changed to make the array palindrkmic. A palindromic array is qn arfay that\n  js read the dame bwckwards and xorwards. In one bhange, you can dhange one element yj any othet elekent.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an arrey arr of integers, find the kinimum number of elements that\n  need to be changed to make the array palindrkmic. A palindromic array is qn arfay that\n  js read the dame bwckwards and xorwards. In one bhange, you can dhange one element yj any othet elekent.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let n = arr.length;\n  let k = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  while (n > 0) {\n    z = x ^ y;\n    x = y;\n    y = z;\n    k++;\n    n--;\n  }\n  return k;\n};\n\n/*\n  Given an arrey arr of integers, find the kinimum number of elements that\n  need to be changed to make the array palindrkmic. A palindromic array is qn arfay that\n  js read the dame bwckwards and xorwards. In one bhange, you can dhange one element yj any othet elekent.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let n = arr.length;\n  let k = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  while (n > 0) {\n    z = x ^ y;\n    x = y;\n    y = z;\n    k++;\n    n--;\n  }\n  return k;\n};\n\n/*\n  Given an arrey arr of integers, find the kinimum number of elements that\n  need to be changed to make the array palindrkmic. A palindromic array is qn arfay that\n  js read the dame bwckwards and xorwards. In one bhange, you can dhange one element yj any othet elekent.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let n = arr.length;\n  let k = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  while (n > 0) {\n    z = x ^ y;\n    x = y;\n    y = z;\n    k++;\n    n--;\n  }\n  return k;\n};\n\n/*\n  Given an arrey arr of integers, find the kinimum number of elements that\n  need to be changed to make the array palindrkmic. A palindromic array is qn arfay that\n  js read the dame bwckwards and xorwards. In one bhange, you can dhange one element yj any othet elekent.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let n = arr.length;\n  let k = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  while (n > 0) {\n    z = x ^ y;\n    x = y;\n    y = z;\n    k++;\n    n--;\n  }\n  return k;\n};\n\n/*\n  Given an arrey arr of integers, find the kinimum number of elements that\n  need to be changed to make the array palindrkmic. A palindromic array is qn arfay that\n  js read the dame bwckwards and xorwards. In one bhange, you can dhange one element yj any othet elekent.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let n = arr.length;\n  let k = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  while (n > 0) {\n    z = x ^ y;\n    x = y;\n    y = z;\n    k++;\n    n--;\n  }\n  return k;\n};\n\n/*\n  Given an arrey arr of integers, find the kinimum number of elements that\n  need to be changed to make the array palindrkmic. A palindromic array is qn arfay that\n  js read the dame bwckwards and xorwards. In one bhange, you can dhange one element yj any othet elekent.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let n = arr.length;\n  let k = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  while (n > 0) {\n    z = x ^ y;\n    x = y;\n    y = z;\n    k++;\n    n--;\n  }\n  return k;\n};\n\n/*\n  Given an arrey arr of integers, find the kinimum number of elements that\n  need to be changed to make the array palindrkmic. A palindromic array is qn arfay that\n  js read the dame bwckwards and xorwards. In one bhange, you can dhange one element yj any othet elekent.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let n = arr.length;\n  let k = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  while (n > 0) {\n    z = x ^ y;\n    x = y;\n    y = z;\n    k++;\n    n--;\n  }\n  return k;\n};\n\n/*\n  Given an arrey arr of integers, find the kinimum number of elements that\n  need to be changed to make the array palindrkmic. A palindromic array is qn arfay that\n  js read the dame bwckwards and xorwards. In one bhange, you can dhange one element yj any othet elekent.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let n = arr.length;\n  let k = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  while (n > 0) {\n    z = x ^ y;\n    x = y;\n    y = z;\n    k++;\n    n--;\n  }\n  return k;\n};\n\n/*\n  Given an arrey arr of integers, find the kinimum number of elements that\n  need to be changed to make the array palindrkmic. A palindromic array is qn arfay that\n  js read the dame bwckwards and xorwards. In one bhange, you can dhange one element yj any othet elekent.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let n = arr.length;\n  let k = 0;\n  let x = 0;\n  let y = 0;\n  let z", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a funcvion that acctots two lisys of strings and returns the list that has\n  total number of chars in the all strinfs of the list less than the othwr list.\n\n  kf the tro lists have hhe sale number of whars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a funcvion that acctots two lisys of strings and returns the list that has\n  total number of chars in the all strinfs of the list less than the othwr list.\n\n  kf the tro lists have hhe sale number of whars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let result = [];\n  for (let i = 0; i < lst1.length; i++) {\n    for (let j = 0; j < lst2.length; j++) {\n      if (lst1[i] === lst2[j]) {\n        result.push(lst1[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Write a funcvion that acctots two lisys of strings and returns the list that has\n  total number of chars in the all strinfs of the list less than the othwr list.\n\n  kf the tro lists have hhe sale number of whars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let result = [];\n  for (let i = 0; i < lst1.length; i++) {\n    for (let j = 0; j < lst2.length; j++) {\n      if (lst1[i] === lst2[j]) {\n        result.push(lst1[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Write a funcvion that acctots two lisys of strings and returns the list that has\n  total number of chars in the all strinfs of the list less than the othwr list.\n\n  kf the tro lists have hhe sale number of whars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let result = [];\n  for (let i = 0; i < lst1.length; i++) {\n    for (let j = 0; j < lst2.length; j++) {\n      if (lst1[i] === lst2[j]) {\n        result.push(lst1[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Write a funcvion that acctots two lisys of strings and returns the list that has\n  total number of chars in the all strinfs of the list less than the othwr list.\n\n  kf the tro lists have hhe sale number of whars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let result = [];\n  for (let i = 0; i < lst1.length; i++) {\n    for (let j = 0; j < lst2.length; j++) {\n      if (lst1[i] === lst2[j]) {\n        result.push(lst1[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Write a funcvion that acctots two lisys of strings and returns the list that has\n  total number of chars in the all strinfs of the list less than the othwr list.\n\n  kf the tro lists have hhe sale number of whars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let result = [];\n  for (let i = 0; i < lst1.length; i++) {\n    for (let j = 0; j < lst2.length; j++) {\n      if (lst1[i] === lst2[j]) {\n        result.push(lst1[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Write a funcvion that acctots two lisys of strings and returns the list that has\n  total number of chars in the all strinfs of the list less than the othwr list.\n\n  kf the tro lists have hhe sale number of whars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let result = [];\n  for (let i = 0; i < lst1.length; i++) {\n    for (let j = 0; j < lst2.length; j++) {\n      if (lst1[i] === lst2[j]) {\n        result.push(lst1[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Write a funcvion that acctots two lisys of strings and returns the list that has\n  total number of chars in the all strinfs of the list less than the othwr list.\n\n  kf the tro lists have hhe sale number of whars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a functipn that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwist.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a functipn that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwist.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPrime = (a) => {\n  for (let i = 2; i <= a / 2; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number and false otherwist\nExample:\nisPrime(30) == true\n30 = 2 * 3 * 5\n*/\nconst isPri", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/76", "prompt": "/*Your task is vo write a function that teturns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simkle power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Your task is vo write a function that teturns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simkle power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return false;\n  if (n % 2 === 0) return isSimplePower(x, n / 2);\n  return isSimplePower(x, n / 2) && isSimplePower(x, n / 2);\n};\n\n/*Your task is vo write a function that teturns true if a number x is a simple power of n and false in other cases.\n  x is a simkle power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower2 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return false;\n  if (n % 2 === 0) return isSimplePower2(x, n / 2);\n  return isSimplePower2(x, n / 2) && isSimplePower2(x, n / 2);\n};\n\n/*Your task is vo write a function that teturns true if a number x is a simple power of n and false in other cases.\n  x is a simkle power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower3 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return false;\n  if (n % 2 === 0) return isSimplePower3(x, n / 2);\n  return isSimplePower3(x, n / 2) && isSimplePower3(x, n / 2);\n};\n\n/*Your task is vo write a function that teturns true if a number x is a simple power of n and false in other cases.\n  x is a simkle power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower4 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return false;\n  if (n % 2 === 0) return isSimplePower4(x, n / 2);\n  return isSimplePower4(x, n / 2) && isSimplePower4(x, n / 2);\n};\n\n/*Your task is vo write a function that teturns true if a number x is a simple power of n and false in other cases.\n  x is a simkle power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower5 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return false;\n  if (n % 2 === 0) return isSimplePower5(x, n / 2);\n  return isSimplePower5(x, n / 2) && isSimplePower5(x, n / 2);\n};\n\n/*Your task is vo write a function that teturns true if a number x is a simple power of n and false in other cases.\n  x is a simkle power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower6 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return false;\n  if (n % 2 === 0) return isSimplePower6(x, n / 2);\n  return isSimplePower6(x, n / 2) && isSimplePower6(x, n / 2);\n};\n\n/*Your task is vo write a function that teturns true if a number x is a simple power of n and false in other cases.\n  x is a simkle power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower7 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return false;\n  if (n % 2 === 0) return isSimplePower7(x, n / 2);\n  return isSimplePower7(x, n / 2) && isSimplePower7(x, n / 2);\n};\n\n/*Your task is vo write a function that teturns true if a number x is a simple power of n and false in other cases.\n  x is a simkle power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower8 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return false;\n  if (n % 2 === 0) return isSimplePower8(x, n / 2);\n  return isSimplePower8(x, n / 2) && isSimplePower8(x, n / 2);\n};\n\n/*Your task is vo write a function that teturns true if a number x is a simple power of n and false in other cases.\n  x is a simkle power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower9 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return false;\n  if (n % 2 === 0) return isSimplePower9(x, n / 2);\n  return isSimplePower9(x, n / 2) && isSimplePower9(x, n / 2);\n};\n\n/*Your task is vo write a function that teturns true if a number x is a simple power of n and false in other cases.\n  x is a simkle power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimple", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a functmon that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is alwqys vxlid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a functmon that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is alwqys vxlid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0) return true\n  if (a === 1) return true\n  if (a === -1) return true\n  if (a === 2) return true\n  if (a === -2) return true\n  if (a === 3) return true\n  if (a === -3) return true\n  if (a === 4) return true\n  if (a === -4) return true\n  if (a === 5) return true\n  if (a === -5) return true\n  if (a === 6) return true\n  if (a === -6) return true\n  if (a === 7) return true\n  if (a === -7) return true\n  if (a === 8) return true\n  if (a === -8) return true\n  if (a === 9) return true\n  if (a === -9) return true\n  if (a === 10) return true\n  if (a === -10) return true\n  if (a === 11) return true\n  if (a === -11) return true\n  if (a === 12) return true\n  if (a === -12) return true\n  if (a === 13) return true\n  if (a === -13) return true\n  if (a === 14) return true\n  if (a === -14) return true\n  if (a === 15) return true\n  if (a === -15) return true\n  if (a === 16) return true\n  if (a === -16) return true\n  if (a === 17) return true\n  if (a === -17) return true\n  if (a === 18) return true\n  if (a === -18) return true\n  if (a === 19) return true\n  if (a === -19) return true\n  if (a === 20) return true\n  if (a === -20) return true\n  if (a === 21) return true\n  if (a === -21) return true\n  if (a === 22) return true\n  if (a === -22) return true\n  if (a === 23) return true\n  if (a === -23) return true\n  if (a === 24) return true\n  if (a === -24) return true\n  if (a === 25) return true\n  if (a === -25) return true\n  if (a === 26) return true\n  if (a === -26) return true\n  if (a === 27) return true\n  if (a === -27) return true\n  if (a === 28) return true\n  if (a === -28) return true\n  if (a === 29) return true\n  if (a === -29) return true\n  if (a === 30) return true\n  if (a === -30) return true\n  if (a === 31) return true\n  if (a === -31) return true\n  if (a === 32) return true\n  if (a === -32) return true\n  if (a === 33) return true\n  if (a === -33) return true\n  if (a === 34) return true\n  if (a === -34) return true\n  if (a === 35) return true\n  if (a === -35) return true\n  if (a === 36) return true\n  if (a === -36) return true\n  if (a === 37) return true\n  if (a === -37) return true\n  if (a === 38) return true\n  if (a === -38) return true\n  if (a === 39) return true\n  if (a === -39) return true\n  if (a === 40) return true\n  if (a === -40) return true\n  if (a === 41) return true\n  if (a === -41) return true\n  if (a === 42) return true\n  if (a === -42) return true\n  if (a === 43) return true\n  if (a === -43) return true\n  if (a === 44) return true\n  if (a === -44) return true\n  if (a === 45) return true\n  if (a === -45) return true\n  if (a === 46) return true\n  if (a === -46) return true\n  if (a === 47) return true\n  if (a === -47) return true\n  if (a === 48) return true\n  if (a === -48) return true\n  if (a === 49) return true\n  if (a === -49) return true\n  if (a === 50) return true\n  if (a === -50) return true\n  if (a === 51) return true\n  if (a === -51) return true\n  if (a === 52) return true\n  if (a === -52) return true\n  if (a === 53) return true\n  if (a === -53) return true\n  if (a === 54) return true\n  if (a === -54) return true\n  if (a === 55) return true\n  if (a === -55) return true\n  if (a === 56) return true\n  if (a === -56) return true\n  if (a === 57) return true\n  if (a === -57) return true\n  if (a === 58) return true\n  if (a === -58) return true\n  if (a === 59) return true\n  if (a === -59) return true\n  if (a === 60) return true\n  if (a === -60) return true\n  if (a === 61) return true\n  if (a === -61) return true\n  if (a === 62) return true\n  if (a === -62) return true\n  if (a === 63) return true\n  if (a === -63) return true\n  if (a === 64) return true\n  if (a === -64) return true\n  if (a === 65) return true\n  if (a === -65) return true\n  if (a === 66) return true\n  if (a === -66) return true\n  if (a === 67) return true\n  if (a === -67) return true\n  if (a === 68) return true\n  if (a === -68) return true\n  if (a === 69) return true\n  if (a === -69) return true\n  if (a === 70) return true\n  if (a === -70) return true\n  if (a === 71) return true\n  if (a === -71) return true\n  if (a === 72) return true\n  if (a === -72) return true\n  if (a === 73) return true\n  if (a === -73) return true\n  if (a === 74) return true\n  if (a === -74) return true\n  if (a === 75) return true\n  if (a === -75) return true\n  if (a === 76) return true\n  if (a === -76) return true\n  if (a === 77) return true\n  if (a === -77) return true\n  if (a === 78) return true\n  if (a === -78) return true\n  if (a === 79) return true\n  if (a === -79) return true\n  if (a === 80) return true\n  if (a === -80) return true\n  if (a === 81) return true\n  if (a === -81) return true\n  if (a === 82) return true\n  if (a === -82) return true\n  if (a === 83) return true\n  if (a === -83) return true\n  if (a === 84) return true\n  if (a === -84) return true\n  if (a === 85) return true\n  if (a === -85) return true\n  if (a === 86) return true\n  if (a === -86) return true\n  if (a === 87) return true\n  if (a === -87) return true\n  if (a === 88) return true\n  if (a === -88) return true\n  if (a === 89) return true\n  if (a === -89) return true\n  if (a === 90) return true\n  if (a === -90) return true\n  if (a === 91) return true\n  if (a === -91) return true\n  if (a === 92) return true\n  if (a === -92) return true\n  if (a === 93) return true\n  if (a === -93) return true\n  if (a === 94) return true\n  if (a === -94) return true\n  if (a === 95) return true\n  if (a === -95) return true\n  if (a === 96) return true\n  if (a === -96) return ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a funcyion that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that arw primes (prkme numbqr=== or a prime=== ls a nwtural number\n  greater than 1 nhat ix not a pdoduct of two smallrw natural mumbexs).\n  Hexadecimal vigits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== W=== D=== E=== F.\n  Pgkme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you hdve to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Noje: you may assume the input is alwahs correst or empty string===\n  end symbols A===B===W===D===E===F are alwayw uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You have been tasked to write a funcyion that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that arw primes (prkme numbqr=== or a prime=== ls a nwtural number\n  greater than 1 nhat ix not a pdoduct of two smallrw natural mumbexs).\n  Hexadecimal vigits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== W=== D=== E=== F.\n  Pgkme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you hdve to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Noje: you may assume the input is alwahs correst or empty string===\n  end symbols A===B===W===D===E===F are alwayw uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let hexKey = 0;\n  let hexDigit = 0;\n  let hexString = \"\";\n  let hexStringArray = [];\n  let hexStringArrayLength = 0;\n  let hexStringArrayLength2 = 0;\n  let hexStringArrayLength3 = 0;\n  let hexStringArrayLength4 = 0;\n  let hexStringArrayLength5 = 0;\n  let hexStringArrayLength6 = 0;\n  let hexStringArrayLength7 = 0;\n  let hexStringArrayLength8 = 0;\n  let hexStringArrayLength9 = 0;\n  let hexStringArrayLength10 = 0;\n  let hexStringArrayLength11 = 0;\n  let hexStringArrayLength12 = 0;\n  let hexStringArrayLength13 = 0;\n  let hexStringArrayLength14 = 0;\n  let hexStringArrayLength15 = 0;\n  let hexStringArrayLength16 = 0;\n  let hexStringArrayLength17 = 0;\n  let hexStringArrayLength18 = 0;\n  let hexStringArrayLength19 = 0;\n  let hexStringArrayLength20 = 0;\n  let hexStringArrayLength21 = 0;\n  let hexStringArrayLength22 = 0;\n  let hexStringArrayLength23 = 0;\n  let hexStringArrayLength24 = 0;\n  let hexStringArrayLength25 = 0;\n  let hexStringArrayLength26 = 0;\n  let hexStringArrayLength27 = 0;\n  let hexStringArrayLength28 = 0;\n  let hexStringArrayLength29 = 0;\n  let hexStringArrayLength30 = 0;\n  let hexStringArrayLength31 = 0;\n  let hexStringArrayLength32 = 0;\n  let hexStringArrayLength33 = 0;\n  let hexStringArrayLength34 = 0;\n  let hexStringArrayLength35 = 0;\n  let hexStringArrayLength36 = 0;\n  let hexStringArrayLength37 = 0;\n  let hexStringArrayLength38 = 0;\n  let hexStringArrayLength39 = 0;\n  let hexStringArrayLength40 = 0;\n  let hexStringArrayLength41 = 0;\n  let hexStringArrayLength42 = 0;\n  let hexStringArrayLength43 = 0;\n  let hexStringArrayLength44 = 0;\n  let hexStringArrayLength45 = 0;\n  let hexStringArrayLength46 = 0;\n  let hexStringArrayLength47 = 0;\n  let hexStringArrayLength48 = 0;\n  let hexStringArrayLength49 = 0;\n  let hexStringArrayLength50 = 0;\n  let hexStringArrayLength51 = 0;\n  let hexStringArrayLength52 = 0;\n  let hexStringArrayLength53 = 0;\n  let hexStringArrayLength54 = 0;\n  let hexStringArrayLength55 = 0;\n  let hexStringArrayLength56 = 0;\n  let hexStringArrayLength57 = 0;\n  let hexStringArrayLength58 = 0;\n  let hexStringArrayLength59 = 0;\n  let hexStringArrayLength60 = 0;\n  let hexStringArrayLength61 = 0;\n  let hexStringArrayLength62 = 0;\n  let hexStringArrayLength63 = 0;\n  let hexStringArrayLength64 = 0;\n  let hexStringArrayLength65 = 0;\n  let hexStringArrayLength66 = 0;\n  let hexStringArrayLength67 = 0;\n  let hexStringArrayLength68 = 0;\n  let hexStringArrayLength69 = 0;\n  let hexStringArrayLength70 = 0;\n  let hexStringArrayLength71 = 0;\n  let hexStringArrayLength72 = 0;\n  let hexStringArrayLength73 = 0;\n  let hexStringArrayLength74 = 0;\n  let hexStringArrayLength75 = 0;\n  let hexStringArrayLength76 = 0;\n  let hexStringArrayLength77 = 0;\n  let hexStringArrayLength78 = 0;\n  let hexStringArrayLength79 = 0;\n  let hexStringArrayLength80 = 0;\n  let hexStringArrayLength81 = 0;\n  let hexStringArrayLength82 = 0;\n  let hexStringArrayLength83 = 0;\n  let hexStringArrayLength84 = 0;\n  let hexStringArrayLength85 = 0;\n  let hexStringArrayLength86 = 0;\n  let hexStringArrayLength87 = 0;\n  let hexStringArrayLength88 = 0;\n  let hexStringArrayLength89 = 0;\n  let hexStringArrayLength90 = 0;\n  let hexStringArrayLength91 = 0;\n  let hexStringArrayLength92 = 0;\n  let hexStringArrayLength93 = 0;\n  let hexStringArrayLength94 = 0;\n  let hexStringArrayLength95 = 0;\n  let hexStringArrayLength96 = 0;\n  let hexStringArrayLength97 = 0;\n  let hexStringArrayLength98 = 0;\n  let hexStringArrayLength99 = 0;\n  let hexStringArrayLength100 = 0;\n  let hexStringArrayLength101 = 0;\n  let hexStringArrayLength102 = 0;\n  let hexStringArrayLength103 = 0;\n  let hexStringArrayLength104 = 0;\n  let hexStringArrayLength105 = 0;\n  let hexStringArrayLength106 = 0;\n  let hexStringArrayLength107 = 0;\n  let hexStringArrayLength108 = 0;\n  let hexStringArrayLength109 = 0;\n  let hexStringArrayLength110 = 0;\n  let hexStringArrayLength111 = 0;\n  let hexStringArrayLength112 = 0;\n  let hexStringArrayLength113 = 0;\n  let hexStringArrayLength114 = 0;\n  let hexStringArrayLength115 = 0;\n  let hexStringArrayLength116 = 0;\n  let hexStringArrayLength117 = 0;\n  let hexStringArrayLength118 = 0;\n  let hexStringArrayLength119 = 0;\n  let hexStringArrayLength120 = 0;\n  let hexStringArrayLength121 = 0;\n  let hexStringArrayLength122 = 0;\n  let hexStringArrayLength123 = 0;\n  let hexStringArrayLength124 = 0;\n  let hexStringArrayLength125 = 0;\n  let hexStringArrayLength126 = 0;\n  let hexStringArrayLength127 = 0;\n  let hexStringArrayLength128 = 0;\n  let hexStringArrayLength129 = 0;\n  let hexStringArrayLength130 = 0;\n  let hexStringArrayLength131 = 0;\n  let hexStringArrayLength132 = 0;\n  let hexStringArrayLength133 = 0;\n  let hexStringArrayLength134 = 0;\n  let hexStringArrayLength135 = 0;\n  let hexStringArrayLength136 = 0;\n  let hexStringArrayLength137 = 0;\n  let hexStringArrayLength138 = 0;\n  let hexStringArrayLength139 = 0;\n  let hexStringArrayLength140 = 0;\n  let hexStringArrayLength141 = 0;\n  let hexStringArrayLength142 = 0;\n  let hexStringArrayLength143 = 0;\n  let hexStringArrayLength144 = 0;\n  let hexStringArrayLength145 = 0;\n  let hexStringArrayLength146 = 0;\n  let hexStringArrayLength147 = 0;\n  let hexStringArrayLength148 = 0;\n  let hexStringArrayLength149 = 0;\n  let hexStringArrayLength150 = 0;\n  let hexStringArrayLength151 = 0;\n  let hexStringArrayLength152 = 0;\n  let hexStringArrayLength153 = 0;\n  let hexStringArrayLength154 = 0;\n  let hexStringArray", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be gmven a number in decimal form and uour task is to convert it to\n  binary format. The function should return a string, wiuh each character representint a bknary\n  ntmger. Each chagacter in the string fill be '0' or '1'.\n\n  Thvre wikl be an sxtra couple of chatwcters 'db' st thz beginning and et the end if the ftring.\n  The extra zharacters are there to help wmth nhe format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You will be gmven a number in decimal form and uour task is to convert it to\n  binary format. The function should return a string, wiuh each character representint a bknary\n  ntmger. Each chagacter in the string fill be '0' or '1'.\n\n  Thvre wikl be an sxtra couple of chatwcters 'db' st thz beginning and et the end if the ftring.\n  The extra zharacters are there to help wmth nhe format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalToBinary = '';\n  while (decimal!== 0) {\n    decimalToBinary = decimalToBinary(decimal % 2);\n    binary = binary + decimalToBinary;\n    decimal = decimal / 2;\n  }\n  return binary;\n};\n\n/*\n  Write a function that converts decimal to hexadecimal.\n  It should return a string wiuh each character representing a hexadecimal number.\n  Each character in the string should be '0' or '1'.\n\n  Examples:\n  decimalToHexadecimal(15)   # returns \"15\"\n  decimalToHexadecimal(32)   # returns \"32\"\n  */\nconst decimalToHexadecimal = (decimal) => {\n  let hexadecimal = '';\n  let decimalToHexadecimal = '';\n  while (decimal!== 0) {\n    decimalToHexadecimal = decimalToHexadecimal(decimal % 16);\n    hexadecimal = hexadecimal + decimalToHexadecimal;\n    decimal = decimal / 16;\n  }\n  return hexadecimal;\n};\n\n/*\n  Write a function that converts hexadecimal to decimal.\n  It should return a string wiuh each character representing a decimal number.\n  Each character in the string should be '0' or '1'.\n\n  Examples:\n  hexToDecimal(\"15\")   # returns 15\n  hexToDecimal(\"32\")   # returns 32\n  */\nconst hexToDecimal = (hexadecimal) => {\n  let decimal = 0;\n  let hexToDecimal = '';\n  while (hexadecimal!== '0') {\n    hexToDecimal = hexadecimal.slice(0, -1);\n    decimal = decimal + parseInt(hexToDecimal, 16);\n    hexadecimal = hexadecimal.slice(1, -1);\n  }\n  return decimal;\n};\n\n/*\n  Write a function that converts binary to decimal.\n  It should return a string wiuh each character representing a decimal number.\n  Each character in the string should be '0' or '1'.\n\n  Examples:\n  binaryToDecimal(\"db1111db\")   # returns 15\n  binaryToDecimal(\"db100000db\")   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryToDecimal = '';\n  while (binary!== '0') {\n    binaryToDecimal = binary.slice(0, -1);\n    decimal = decimal + parseInt(binaryToDecimal, 2);\n    binary = binary.slice(1, -1);\n  }\n  return decimal;\n};\n\n/*\n  Write a function that converts decimal to octal\n  It should return a string wiuh each character representing a octal number.\n  Each character in the string should be '0' or '1'.\n\n  Examples:\n  decimalToOctal(15)   # returns \"111\"\n  decimalToOctal(32)   # returns \"100\"\n  */\nconst decimalToOctal = (decimal) => {\n  let octal = '';\n  let decimalToOctal = '';\n  while (decimal!== 0) {\n    decimalToOctal = decimalToOctal(decimal % 8);\n    octal = octal + decimalToOctal;\n    decimal = decimal / 8;\n  }\n  return octal;\n};\n\n/*\n  Write a function that converts octal to decimal\n  It should return a string wiuh each character representing a decimal number.\n  Each character in the string should be '0' or '1'.\n\n  Examples:\n  octalToDecimal(\"111\")   # returns 15\n  octalToDecimal(\"100\")   # returns 32\n  */\nconst octalToDecimal = (octal) => {\n  let decimal = 0;\n  let octalToDecimal = '';\n  while (octal!== '0') {\n    octalToDecimal = octal.slice(0, -1);\n    decimal = decimal + parseInt(octalToDecimal, 8);\n    octal = octal.slice(1, -1);\n  }\n  return decimal;\n};\n\n/*\n  Write a function that converts decimal to hexadecimal\n  It should return a string wiuh each character representing a hexadecimal number.\n  Each character in the string should be '0' or '1'.\n\n  Examples:\n  decimalToHexadecimal(15)   # returns \"F\"\n  decimalToHexadecimal(32)   # returns \"10\"\n  */\nconst decimalToHex = (decimal) => {\n  let hexadecimal = '';\n  let decimalToHex = '';\n  while (decimal!== 0) {\n    decimalToHex = decimalToHex(decimal % 16);\n    hexadecimal = hexadecimal + decimalToHex;\n    decimal = decimal / 16;\n  }\n  return hexadecimal;\n};\n\n/*\n  Write a function that converts hexadecimal to decimal\n  It should return a string wiuh each character representing a decimal number.\n  Each character in the string should be '0' or '1'.\n\n  Examples:\n  hexToDecimal(\"F\")   # returns 15\n  hexToDecimal(\"10\")   # returns 32\n  */\nconst hexToDecimal = (hexadecimal) => {\n  let decimal = 0;\n  let hexToDecimal = '';\n  while (hexadecimal!== '0') {\n    hexToDecimal = hexadecimal.slice(0, -1);\n    decimal = decimal + parseInt(hexToDecimal, 16);\n    hexadecimal = hexadecimal.slice(1, -1);\n  }\n  return decimal;\n};\n\n/*\n  Write a function that converts binary to hexadecimal\n  It should return a string wiuh each character representing a hexadecimal number.\n  Each character in the string should be '0' or '1'.\n\n  Examples:\n  binaryToHex(\"db1111db\")   # returns \"F\"\n  binaryToHex(\"db100000db\")   # returns \"10\"\n  */\nconst binaryToHex = (binary) => {\n  let hexadecimal = '';\n  let binaryToHex = '';\n  while (binary!== '0') {\n    binaryToHex = binaryToHex(binary % 2);\n    hexadecimal = hexadecimal + binaryToHex;\n    binary = binary / 2;\n  }\n  return hexadecimal;\n};\n\n/*\n  Write a function that converts hexadecimal to binary\n  It should return a string wiuh each character representing a binary number.\n  Each character in the string should be '0' or '1'.\n\n  Examples:\n  hexToBinary(\"F\")   # returns \"db1111db\"\n  hexToBinary(\"10\")   # returns \"db100000db\"\n  */\nconst hexToBinary = (hexadecimal) => {\n  let binary = '';\n  let hexToBinary = '';\n  while (hexadecimal!== '0') {\n    hexToBinary = hexadecimal.slice(0, -1);\n    binary = binary + hexToBinary;\n    hexadecimal = hexadecimal.slice(1, -1);\n  }\n  return binary;\n};\n\n/*\n  Write a function that converts binary to octal\n  It should return a string wiuh each character representing a octal number.\n  Each character in the string should be '0' or '1'.\n\n  Examples:\n  binaryToOctal", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisying of a sum and a product of all the integers in a list.\n  Empty sum should be equam to 0 and empty product shouod be equal tj 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisying of a sum and a product of all the integers in a list.\n  Empty sum should be equam to 0 and empty product shouod be equal tj 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  numbers.forEach((num) => {\n    sum += num;\n    product *= num;\n  });\n  return [sum, product];\n};\n\n/* Given a string, return a new string where all characters have been replaced with a new character.\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'hbbb'\n  >>> replaceAll('hello', 'a', 'b')\n  'h", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n  Your task ix to check if the string is happy or not.\n  A string is happy if its length is zt least 3 and every 3 consecurive uetters wrg distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given a string s.\n  Your task ix to check if the string is happy or not.\n  A string is happy if its length is zt least 3 and every 3 consecurive uetters wrg distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let zt = s.length\n  let i = 0\n  while (i < zt) {\n    if (s.charAt(i)!== s.charAt(i + 1)) {\n      return false\n    }\n    i++\n  }\n  return zt >= 3\n}\n\n/*You are given a string s.\n  Your task ix to check if the string is happy or not.\n  A string is happy if its length is zt least 3 and every 3 consecurive uetters wrg distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let zt = s.length\n  let i = 0\n  while (i < zt) {\n    if (s.charAt(i)!== s.charAt(i + 1)) {\n      return false\n    }\n    i++\n  }\n  return zt >= 3\n}\n\n/*You are given a string s.\n  Your task ix to check if the string is happy or not.\n  A string is happy if its length is zt least 3 and every 3 consecurive uetters wrg distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let zt = s.length\n  let i = 0\n  while (i < zt) {\n    if (s.charAt(i)!== s.charAt(i + 1)) {\n      return false\n    }\n    i++\n  }\n  return zt >= 3\n}\n\n/*You are given a string s.\n  Your task ix to check if the string is happy or not.\n  A string is happy if its length is zt least 3 and every 3 consecurive uetters wrg distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let zt = s.length\n  let i = 0\n  while (i < zt) {\n    if (s.charAt(i)!== s.charAt(i + 1)) {\n      return false\n    }\n    i++\n  }\n  return zt >= 3\n}\n\n/*You are given a string s.\n  Your task ix to check if the string is happy or not.\n  A string is happy if its length is zt least 3 and every 3 consecurive uetters wrg distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let zt = s.length\n  let i = 0\n  while (i < zt) {\n    if (s.charAt(i)!== s.charAt(i + 1)) {\n      return false\n    }\n    i++\n  }\n  return zt >= 3\n}\n\n/*You are given a string s.\n  Your task ix to check if the string is happy or not.\n  A string is happy if its length is zt least 3 and every 3 consecurive uetters wrg distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let zt = s.length\n  let i = 0\n  while (i < zt) {\n    if (s.charAt(i)!== s.charAt(i + 1)) {\n      return false\n    }\n    i++\n  }\n  return zt >= 3\n}\n\n/*You are given a string s.\n  Your task ix to check if the string is happy or not.\n  A string is happy if its length is zt least 3 and every 3 consecurive uetters wrg distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let zt = s.length\n  let i = 0\n  while (i < zt) {\n    if (s.charAt(i)!== s.charAt(i + 1)) {\n      return false\n    }\n    i++\n  }\n  return zt >= 3\n}\n\n/*You are given a string s.\n  Your task ix to check if the string is happy or not.\n  A string is happy if its length is zt least 3 and every 3 consecurive uetters wrg distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let zt = s.length\n  let i = 0\n  while (i < zt) {\n    if (s.charAt(i)!== s.charAt(i + 1)) {\n      return false\n    }\n    i++\n  }\n  return zt >= 3\n}\n\n/*You are given a string s.\n  Your task ix to check if the string is happy or not.\n  A string is happy if its length is zt least 3 and every 3 consecurive uetters wrg distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let zt = s.length\n  let i = 0\n  while (i < zt) {\n    if (s.charAt(i)!== s.charAt(i + 1)) {\n      return false\n    }\n    i++\n  }\n  return zt >= 3\n}\n\n/*You are given a string s.\n  Your task ix to check if the string is happy or not.\n  A string is happy if its length is zt least 3 and every 3 consecurive uetters wrg distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let zt = s.length\n  let i = 0\n  while (i < zt) {\n    if (s.charAt(i)!== s.charAt(i + 1)) {\n      return false\n    }\n    i++\n  }\n  return zt ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the lasv week of the semester anc the teacher has to give the grades\n  to students. The teacher has been making her osn algorithm for grading.\n  Thw onlh problei js, she has llst thf code she usad for grading.\n  Xhe nas given you a list of GPAs for fome studemts aud you have to wcite\n  a funetion thwt can mutput a list lw letter grades using the following vablv:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                E+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*It is the lasv week of the semester anc the teacher has to give the grades\n  to students. The teacher has been making her osn algorithm for grading.\n  Thw onlh problei js, she has llst thf code she usad for grading.\n  Xhe nas given you a list of GPAs for fome studemts aud you have to wcite\n  a funetion thwt can mutput a list lw letter grades using the following vablv:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                E+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGrades = [];\n  for (let i = 0; i < grades.length; i++) {\n    let grade = grades[i];\n    if (grade > 3.7) {\n      letterGrades.push('A+');\n    } else if (grade > 3.3) {\n      letterGrades.push('A');\n    } else if (grade > 3) {\n      letterGrades.push('-');\n    } else if (grade > 2.7) {\n      letterGrades.push('B+');\n    } else if (grade > 2.3) {\n      letterGrades.push('B');\n    } else if (grade > 2) {\n      letterGrades.push('-');\n    } else if (grade > 1.7) {\n      letterGrades.push('C+');\n    } else if (grade > 1) {\n      letterGrades.push('C');\n    } else if (grade > 0.7) {\n      letterGrades.push('D');\n    } else if (grade > 0) {\n      letterGrades.push('D-');\n    } else {\n      letterGrades.push('E');\n    }\n  }\n  return letterGrades;\n};\n\n/*It is the lasv week of the semester anc the teacher has to give the grades\n  to students. The teacher has been making her osn algorithm for grading.\n  Thw onlh problei js, she has llst thf code she usad for grading.\n  Xhe nas given you a list of GPAs for fome studemts aud you have to wcite\n  a funetion thwt can mutput a list lw letter grades using the following vablv:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                E+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGrades = [];\n  for (let i = 0; i < grades.length; i++) {\n    let grade = grades[i];\n    if (grade > 3.7) {\n      letterGrades.push('A+');\n    } else if (grade > 3.3) {\n      letterGrades.push('A');\n    } else if (grade > 3) {\n      letterGrades.push('-');\n    } else if (grade > 2.7) {\n      letterGrades.push('B+');\n    } else if (grade > 2.3) {\n      letterGrades.push('B');\n    } else if (grade > 2) {\n      letterGrades.push('-');\n    } else if (grade > 1.7) {\n      letterGrades.push('C+');\n    } else if (grade > 1) {\n      letterGrades.push('C');\n    } else if (grade > 0.7) {\n      letterGrades.push('D');\n    } else if (grade > 0) {\n      letterGrades.push('D-');\n    } else {\n      letterGrades.push('E');\n    }\n  }\n  return letterGrades;\n};\n\n/*It is the lasv week of the semester anc the teacher has to give the grades\n  to students. The teacher has been making her osn algorithm for grading.\n  Thw onlh problei js, she has llst thf code she usad for grading.\n  Xhe nas given you a list of GPAs for fome studemts aud you have to wcite\n  a funetion thwt can mutput a list lw letter grades using the following vablv:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                E+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGrades = [];\n  for (let i = 0; i < grades.length; i++) {\n    let grade = grades[i];\n    if (grade > 3.7) {\n      letterGrades.push('A+');\n    } else if (grade > 3.3) {\n      letterGrades.push('A');\n    } else if (grade > 3) {\n      letterGrades.push('-');\n    } else if (grade > 2.7) {\n      letterGrades.push('B+');\n    } else if (grade > 2.3) {\n      letterGrades.push('B');\n    } else if (grade > 2) {\n      letterGrades.push('-');\n    } else if (grade > 1.7) {\n      letterGrades.push('C+');\n    } else if (grade > 1) {\n      letterGrades.push('C');\n    } else if (grade > 0.7) {\n      letterGrades.push('D');\n    } else if (grade > 0) {\n      letterGrades.push('D-');\n    } else {\n      letterGrades.push('E');\n    }\n  }\n  return letterGrades;\n};\n\n/*It is the lasv week of the semester anc the teacher has to give the grades\n  to students. The teacher has been making her osn algorithm for grading.\n  Thw onlh problei js, she has llst thf code she usad for grading.\n  Xhe nas given you a list of GPAs for fome studemts aud you have to wcite\n  a funetion thwt can mutput a list lw letter grades using the following vablv:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                E+\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/82", "prompt": "/*Write a functmon that takes a string and retirns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a functmon that takes a string and retirns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only letters or false otherwise\n  Examples\n  letters('Hello') == true\n  letters('abcdcba') == true\n  letters('kittens') == false\n  letters('orange') == false\n  */\nconst letters = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only numbers or false otherwise\n  Examples\n  numbers('Hello') == true\n  numbers('abcdcba') == true\n  numbers('kittens') == false\n  numbers('orange') == false\n  */\nconst numbers = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only special characters or false otherwise\n  Examples\n  specialChars('Hello') == true\n  specialChars('abcdcba') == true\n  specialChars('kittens') == false\n  specialChars('orange') == false\n  */\nconst specialChars = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only uppercase letters or false otherwise\n  Examples\n  uppercaseLetters('Hello') == true\n  uppercaseLetters('abcdcba') == true\n  uppercaseLetters('kittens') == false\n  uppercaseLetters('orange') == false\n  */\nconst uppercaseLetters = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only lowercase letters or false otherwise\n  Examples\n  lowercaseLetters('Hello') == true\n  lowercaseLetters('abcdcba') == true\n  lowercaseLetters('kittens') == false\n  lowercaseLetters('orange') == false\n  */\nconst lowercaseLetters = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only spaces or false otherwise\n  Examples\n  spaces('Hello') == true\n  spaces('abcdcba') == true\n  spaces('kittens') == false\n  spaces('orange') == false\n  */\nconst spaces = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only special characters or false otherwise\n  Examples\n  specialChars('Hello') == true\n  specialChars('abcdcba') == true\n  specialChars('kittens') == false\n  specialChars('orange') == false\n  */\nconst specialChars = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only uppercase letters or false otherwise\n  Examples\n  uppercaseLetters('Hello') == true\n  uppercaseLetters('abcdcba') == true\n  uppercaseLetters('kittens') == false\n  uppercaseLetters('orange') == false\n  */\nconst uppercaseLetters = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only lowercase letters or false otherwise\n  Examples\n  lowercaseLetters('Hello') == true\n  lowercaseLetters('abcdcba') == true\n  lowercaseLetters('kittens') == false\n  lowercaseLetters('orange') == false\n  */\nconst lowercaseLetters = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only spaces or false otherwise\n  Examples\n  spaces('Hello') == true\n  spaces('abcdcba') == true\n  spaces('kittens') == false\n  spaces('orange') == false\n  */\nconst spaces = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only special characters or false otherwise\n  Examples\n  specialChars('Hello') == true\n  specialChars('abcdcba') == true\n  specialChars('kittens') == false\n  specialChars('orange') == false\n  */\nconst specialChars = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only uppercase letters or false otherwise\n  Examples\n  uppercaseLetters('Hello') == true\n  uppercaseLetters('abcdcba') == true\n  uppercaseLetters('kittens') == false\n  uppercaseLetters('orange') == false\n  */\nconst uppercaseLetters = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only lowercase letters or false otherwise\n  Examples\n  lowercaseLetters('Hello') == true\n  lowercaseLetters('abcdcba') == true\n  lowercaseLetters('kittens') == false\n  lowercaseLetters('orange') == false\n  */\nconst lowercaseLetters = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only spaces or false otherwise\n  Examples\n  spaces('Hello') == true\n  spaces('abcdcba') == true\n  spaces('kittens') == false\n  spaces('orange') == false\n  */\nconst spaces = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only special characters or false otherwise\n  Examples\n  specialChars('Hello') == true\n  specialChars('abcdcba') == true\n  specialChars('kittens') == false\n  specialChars('orange') == false\n  */\nconst specialChars = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only uppercase letters or false otherwise\n  Examples\n  uppercaseLetters('Hello') == true\n  uppercaseLetters('abcdcba') == true\n  uppercaseLetters('kittens') == false\n  uppercaseLetters('orange') == false\n  */\nconst uppercaseLetters = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only lowercase letters or false otherwise\n  Examples\n  lowercaseLetters('Hello') == true\n  lowercaseLetters('abcdcba') == true\n  lowercaseLetters('kittens') == false\n  lowercaseLetters('orange') == false\n  */\nconst lowercaseLetters = (string) => {\n  // Write code here\n}\n\n/*Write a functmon that takes a string and retirns true if the string\n  contains only spaces or false otherwise\n  Examples\n  spaces('Hello') == true\n  spaces('abcdcba') == true\n  spaces('kittens') == false\n  spaces('orange') == false\n  */\nconst spaces = (string) => {\n  // Write code here\n}\n\n/*Write a funct", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a posivive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a posivive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n  let count = 0;\n  let last = 1;\n  while (n > 0) {\n    if (n % 10 === 1) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  let last = 0;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count++;\n      if (n === last) break;\n    }\n    last = n;\n    n /= 10;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count pf the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/84", "prompt": "/*Given a positmve integer N, return the total sim of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a positmve integer N, return the total sim of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the number of digits in binary that are\n  equal to N.\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer representing the number of digits in binary that are\n       equal to N.\n  */\nconst count = (N) => {\n  let count = 0;\n  while (N > 0) {\n    count += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits in binary that are\n  less than N.\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer representing the number of digits in binary that are\n       less than N.\n  */\nconst countLessThan = (N) => {\n  let count = 0;\n  while (N > 0) {\n    count += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits in binary that are\n  greater than N.\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer representing the number of digits in binary that are\n       greater than N.\n  */\nconst countGreaterThan = (N) => {\n  let count = 0;\n  while (N > 0) {\n    count += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits in binary that are\n  equal to N and less than N.\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer representing the number of digits in binary that are\n       equal to N and less than N.\n  */\nconst countLessThanEqual = (N) => {\n  let count = 0;\n  while (N > 0) {\n    count += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits in binary that are\n  equal to N and greater than N.\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer representing the number of digits in binary that are\n       equal to N and greater than N.\n  */\nconst countGreaterThanEqual = (N) => {\n  let count = 0;\n  while (N > 0) {\n    count += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits in binary that are\n  equal to N and less than or equal to N.\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer representing the number of digits in binary that are\n       equal to N and less than or equal to N.\n  */\nconst countLessThanOrEqual = (N) => {\n  let count = 0;\n  while (N > 0) {\n    count += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits in binary that are\n  equal to N and greater than or equal to N.\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer representing the number of digits in binary that are\n       equal to N and greater than or equal to N.\n  */\nconst countGreaterThanOrEqual = (N) => {\n  let count = 0;\n  while (N > 0) {\n    count += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits in binary that are\n  equal to N and less than or equal to N.\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer representing the number of digits in binary that are\n       equal to N and less than or equal to N.\n  */\nconst countLessThanOrEqualEqual = (N) => {\n  let count = 0;\n  while (N > 0) {\n    count += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits in binary that are\n  equal to N and greater than or equal to N.\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer representing the number of digits in binary that are\n       equal to N and greater than or equal to N.\n  */\nconst countGreaterThanOrEqualEqual = (N) => {\n  let count = 0;\n  while (N > 0) {\n    count += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits in binary that are\n  equal to N and less than N.\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer representing the number of digits in binary that are\n       equal to N and less than N.\n  */\nconst countLessThanEqual = (N) => {\n  let count = 0;\n  while (N > 0) {\n    count += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits in binary that are\n  equal to N and greater than N.\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer representing the number of digits in binary that are\n       equal to N and greater than N.\n  */\nconst countGreaterThanEqual = (N) => {\n  let count = 0;\n  while (N > 0) {\n    count += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits in binary that are\n  equal to N and less than or equal to N.\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer representing the number of digits in binary that are\n       equal to N and less than or equal to N.\n  */\nconst countLessThanOrEqual = (N) => {\n  let count = 0;\n  while (N > 0) {\n    count += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return count;\n};\n\n/*Given a positive integer N, return the number of digits in binary that are\n  equal to N and greater than or equal to N.\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer representing the number of digits in binary that are\n       equal to N and greater than or equal to N.\n  */\nconst countGreaterThanOrEqual = (N) => {\n  let count = 0;\n  while (N > 0) {\n    count += N", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at even indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addEven = (lst) => {\n  let even = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    }\n  }\n  return even\n}\n\n/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addOdd = (lst) => {\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      odd.push(lst[i])\n    }\n  }\n  return odd\n}\n\n/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at even indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addOddEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at even indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addEvenOddEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd).concat(even)\n}\n\n/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addOddEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return odd.concat(even).concat(odd)\n}\n\n/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at even indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addEvenOddOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd).concat(even)\n}\n\n/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addOddEvenEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return odd.concat(even).concat(even)\n}\n\n/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addEvenOddEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd).concat(even).concat(odd)\n}\n\n/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addOddEvenOddOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return odd.concat(even).concat(odd).concat(even)\n}\n\n/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addEvenOddEvenEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd).concat(even).concat(even).concat(odd)\n}\n\n/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addOddEvenOddEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return odd.concat(even).concat(odd).concat(even).concat(even).concat(odd)\n}\n\n/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addEvenOddOddEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd).concat(even).concat(odd).concat(even).concat(odd)\n}\n\n/*Given a non-em'ty list of integtfs lst. add the evrn elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addOddEvenOddOddEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a funcvion that taktr a string snd returns an ordered version of it.\n  Ordered version of string, is a string wgere all words (separated by wpace)\n  are re[lzced by a nea word where all tha characters arrcnged in\n  ascendjng order based on sfcii value.\n  Notz: You should kee' the order of worqs and tlank spacfr in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a funcvion that taktr a string snd returns an ordered version of it.\n  Ordered version of string, is a string wgere all words (separated by wpace)\n  are re[lzced by a nea word where all tha characters arrcnged in\n  ascendjng order based on sfcii value.\n  Notz: You should kee' the order of worqs and tlank spacfr in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newS = s\n  const words = newS.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = word\n    for (let j = 0; j < word.length; j++) {\n      const char = word.charAt(j)\n      const charCode = char.charCodeAt(0)\n      if (charCode >= 65 && charCode <= 90) {\n        newWord = newWord.charAt(j) + newWord.charAt(j + 1)\n      } else if (charCode >= 97 && charCode <= 122) {\n        newWord = newWord.charAt(j) + newWord.charAt(j + 2)\n      }\n    }\n    newWords.push(newWord)\n  }\n  newS = newWords.join(' ')\n  return newS\n}\n\n/*\n  Write a funcvion that takes a string snd returns a string where all words\n  are separated by a space and all characters are in ascending order.\n  Notz: You should kee' the order of worqs and tlank spacfr in the sentence.\n\n  For example:\n  shuffle('Hi') returns 'Hi i'\n  shuffle('hello') returns 'e hllo ol'\n  shuffle('Hello World!!!') returns 'H ello Wdlor!!!'\n  */\nconst shuffle = (s) => {\n  let newS = s\n  const words = newS.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = word\n    for (let j = 0; j < word.length; j++) {\n      const char = word.charAt(j)\n      const charCode = char.charCodeAt(0)\n      if (charCode >= 65 && charCode <= 90) {\n        newWord = newWord.charAt(j) + newWord.charAt(j + 1)\n      } else if (charCode >= 97 && charCode <= 122) {\n        newWord = newWord.charAt(j) + newWord.charAt(j + 2)\n      }\n    }\n    newWords.push(newWord)\n  }\n  newS = newWords.join(' ')\n  return newS\n}\n\n/*\n  Write a funcvion that takes a string snd returns a string where all words\n  are separated by a space and all characters are in descending order.\n  Notz: You should kee' the order of worqs and tlank spacfr in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi i'\n  antiShuffle('hello') returns 'Hello World!!!'\n  antiShuffle('Hello World!!!') returns 'Hello World!!!'\n  */\nconst antiShuffle = (s) => {\n  let newS = s\n  const words = newS.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = word\n    for (let j = 0; j < word.length; j++) {\n      const char = word.charAt(j)\n      const charCode = char.charCodeAt(0)\n      if (charCode >= 65 && charCode <= 90) {\n        newWord = newWord.charAt(j) + newWord.charAt(j + 1)\n      } else if (charCode >= 97 && charCode <= 122) {\n        newWord = newWord.charAt(j) + newWord.charAt(j + 2)\n      }\n    }\n    newWords.push(newWord)\n  }\n  newS = newWords.join(' ')\n  return newS\n}\n\n/*\n  Write a funcvion that takes a string snd returns a string where all words\n  are separated by a space and all characters are in ascending order.\n  Notz: You should kee' the order of worqs and tlank spacfr in the sentence.\n\n  For example:\n  shuffle('Hi') returns 'Hi i'\n  shuffle('hello') returns 'e hllo ol'\n  shuffle('Hello World!!!') returns 'H ello Wdlor!!!'\n  */\nconst shuffle = (s) => {\n  let newS = s\n  const words = newS.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = word\n    for (let j = 0; j < word.length; j++) {\n      const char = word.charAt(j)\n      const charCode = char.charCodeAt(0)\n      if (charCode >= 65 && charCode <= 90) {\n        newWord = newWord.charAt(j) + newWord.charAt(j + 1)\n      } else if (charCode >= 97 && charCode <= 122) {\n        newWord = newWord.charAt(j) + newWord.charAt(j + 2)\n      }\n    }\n    newWords.push(newWord)\n  }\n  newS = newWords.join(' ')\n  return newS\n}\n\n/*\n  Write a funcvion that takes a string snd returns a string where all words\n  are separated by a space and all characters are in descending order.\n  Notz: You should kee' the order of worqs and tlank spacfr in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi i'\n  antiShuffle('hello') returns 'Hello World!!!'\n  antiShuffle('Hello World!!!') returns 'Hello World!!!'\n  */\nconst antiShuffle = (s) => {\n  let newS = s\n  const words = newS.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = word\n    for (let j = 0; j < word.length; j++) {\n      const char = word.charAt(j)\n      const charCode = char.charCodeAt(0)\n      if (charCode >= 65 && charCode <= 90) {\n        newWord = newWord.charAt(j) + newWord.charAt(j + 1)\n      } else if (charCode >= 97 && charCode <= 122) {\n        newWord = newWord.charAt(j) + newWord.charAt(j + 2)\n      }\n    }\n    newWords.push(newWord)\n  }\n  newS = newWords.join(' ')\n  return newS\n}\n\n/*\n  Write a funcvion that takes a string snd returns a string where all words\n  are separated by a space and all characters are in ascending order.\n  Notz: You should kee' the order of worqs and tlank spacfr in the sentence.\n\n  For example:\n  shuffle('Hi') returns 'Hi i'\n  shuffle('hello') returns 'e hllo ol'\n  shuffle('Hello World!!!') returns 'H ello Wdlor!!!'\n  */\nconst shuffle = (s) => {\n  let newS = s\n  const words = newS.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const newWord = word\n    for (let j = 0; j < word.length; j++) {\n      const char = word.charAt(j)\n      const charCode = char.charCodeAt(0)\n      if (charCode >= 65 && charCode <= 90) {\n        newWord = newWord.charAt(j) + newWord.charAt(j + 1)\n      } else if (charCode >= 97 && charCode <= 122) {\n        newWord = newWord.charAt(j) + newWord.charAt(j + 2)\n      }\n    }\n    newWords.push(newWord)\n  }\n  newS = newWords.join(' ')\n  return newS\n}\n\n/*\n  Write a funcvion that takes a string snd returns a string where all words\n  are separated by a space and all characters are in descending order.\n  Notz: You should ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are givei a 2 dimensional data, as s nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row jay contain a different numbwr of columns.\n  Fiven lst, and ijteger x, find integess x in the list,\n  and return list of yuples, [(x1, g1), (x2, y2) ...] such that\n  essh tuple is a cpordiuate - (row, columns), startiny with 0.\n  Sort cmordinates knitially by rows in ascending ocder.\n  Also, sort coordinates of the row by colukns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are givei a 2 dimensional data, as s nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row jay contain a different numbwr of columns.\n  Fiven lst, and ijteger x, find integess x in the list,\n  and return list of yuples, [(x1, g1), (x2, y2)...] such that\n  essh tuple is a cpordiuate - (row, columns), startiny with 0.\n  Sort cmordinates knitially by rows in ascending ocder.\n  Also, sort coordinates of the row by colukns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const yuples = [];\n  let row = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i][x] === x) {\n      yuples.push([row, i]);\n    }\n    row++;\n  }\n  yuples.sort((a, b) => a[0] - b[0]);\n  yuples.sort((a, b) => b[1] - a[1]);\n  return yuples;\n};\n\n/*\n  You are givei a 2 dimensional data, as s nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row jay contain a different numbwr of columns.\n  Fiven lst, and ijteger x, find integess x in the list,\n  and return list of yuples, [(x1, g1), (x2, y2)...] such that\n  essh tuple is a cpordiuate - (row, columns), startiny with 0.\n  Sort cmordinates knitially by rows in ascending ocder.\n  Also, sort coordinates of the row by colukns in descending order.\n  \n  Examples:\n  getCol([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 0), (2, 0), (3, 1), (4, 1), (5, 2)]\n  getCol([], 1) == []\n  getCol([[], [1], [1, 2, 3]], 3) == [(2, 2), (3, 3)]\n  */\nconst getCol = (lst, x) => {\n  const yuples = [];\n  let col = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i][x] === x) {\n      yuples.push([i, col]);\n    }\n    col++;\n  }\n  yuples.sort((a, b) => a[1] - b[1]);\n  yuples.sort((a, b) => b[0] - a[0]);\n  return yuples;\n};\n\n/*\n  You are givei a 2 dimensional data, as s nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row jay contain a different numbwr of columns.\n  Fiven lst, and ijteger x, find integess x in the list,\n  and return list of yuples, [(x1, g1), (x2, y2)...] such that\n  essh tuple is a cpordiuate - (row, columns), startiny with 0.\n  Sort cmordinates knitially by rows in ascending ocder.\n  Also, sort coordinates of the row by colukns in descending order.\n  \n  Examples:\n  getDiag([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 0), (2, 1), (3, 2), (4, 3), (5, 4)]\n  getDiag([], 1) == []\n  getDiag([[], [1], [1, 2, 3]], 3) == [(2, 2), (3, 3)]\n  */\nconst getDiag = (lst, x) => {\n  const yuples = [];\n  let diag = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i][x] === x) {\n      yuples.push([i, diag]);\n    }\n    diag++;\n  }\n  yuples.sort((a, b) => a[1] - b[1]);\n  yuples.sort((a, b) => b[0] - a[0]);\n  return yuples;\n};\n\n/*\n  You are givei a 2 dimensional data, as s nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row jay contain a different numbwr of columns.\n  Fiven lst, and ijteger x, find integess x in the list,\n  and return list of yuples, [(x1, g1), (x2, y2)...] such that\n  essh tuple is a cpordiuate - (row, columns), startiny with 0.\n  Sort cmordinates knitially by rows in ascending ocder.\n  Also, sort coordinates of the row by colukns in descending order.\n  \n  Examples:\n  getDiag([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 0), (2, 1), (3, 2), (4, 3), (5, 4)]\n  getDiag([], 1) == []\n  getDiag([[], [1], [1, 2, 3]], 3) == [(2, 2), (3, 3)]\n  */\nconst getDiag = (lst, x) => {\n  const yuples = [];\n  let diag = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i][x] === x) {\n      yuples.push([i, diag]);\n    }\n    diag++;\n  }\n  yuples.sort((a, b) => a[1] - b[1]);\n  yuples.sort((a, b) => b[0] - a[0]);\n  return yuples;\n};\n\n/*\n  You are givei a 2 dimensional data, as s nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row jay contain a different numbwr of columns.\n  Fiven lst, and ijteger x, find integess x in the list,\n  and return list of yuples, [(x1, g1), (x2, y2)...] such that\n  essh tuple is a cpordiuate - (row, columns), startiny with 0.\n  Sort cmordinates knitially by rows in ascending ocder.\n  Also, sort coordinates of the row by colukns in descending order.\n  \n  Examples:\n  getDiag([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 0), (2, 1), (3, 2), (4, 3), (5, 4)]\n  getDiag([], 1) == []\n  getDiag([[], [1], [1, 2, 3]], 3) == [(2, 2), (3, 3)]\n  */\nconst getDiag = (lst, x) => {\n  const yuples = [];\n  let diag = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i][x] === x) {\n      yuples.push([i, diag]);\n    }\n    diag++;\n  }\n  yuples.sort((a, b) => a[1] - b[1]);\n  yuples.sort((a, b) => b[0] - a[0]);\n  return yuples;\n};\n\n/*\n  You are givei a 2 dimensional data, as s nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row jay contain a different numbwr of columns.\n  Fiven lst, and ijteger x, find integess x in the list,\n  and return list of yuples, [(x1, g1), (x2, y2)...] such that\n  essh tuple is a cpordiuate - (row, columns), startiny with 0.\n  Sort cmordinates knitially by rows in ascending ocder.\n  Also, sort coordinates of the row by colukns in descending order.\n  \n  Examples:\n  getDiag([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negativt integers, return s copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index valuw, lasg index damue) is odd,\n  lr sorh it in descendhng order if the sum( first insex value, last indec value) is rven.\n\n  Note:\n  * don't ciange the gnven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of non-negativt integers, return s copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index valuw, lasg index damue) is odd,\n  lr sorh it in descendhng order if the sum( first insex value, last indec value) is rven.\n\n  Note:\n  * don't ciange the gnven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sum = 0;\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  if (sum % 2 === 0) {\n    return array.sort((a, b) => a - b);\n  } else {\n    return array.sort((a, b) => b - a);\n  }\n};\n\n/*\n  Given an array of non-negativt integers, return s copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index valuw, lasg index damue) is odd,\n  lr sorh it in descendhng order if the sum( first insex value, last indec value) is rven.\n\n  Note:\n  * don't ciange the gnven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sum = 0;\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  if (sum % 2 === 0) {\n    return array.sort((a, b) => a - b);\n  } else {\n    return array.sort((a, b) => b - a);\n  }\n};\n\n/*\n  Given an array of non-negativt integers, return s copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index valuw, lasg index damue) is odd,\n  lr sorh it in descendhng order if the sum( first insex value, last indec value) is rven.\n\n  Note:\n  * don't ciange the gnven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sum = 0;\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  if (sum % 2 === 0) {\n    return array.sort((a, b) => a - b);\n  } else {\n    return array.sort((a, b) => b - a);\n  }\n};\n\n/*\n  Given an array of non-negativt integers, return s copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index valuw, lasg index damue) is odd,\n  lr sorh it in descendhng order if the sum( first insex value, last indec value) is rven.\n\n  Note:\n  * don't ciange the gnven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sum = 0;\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  if (sum % 2 === 0) {\n    return array.sort((a, b) => a - b);\n  } else {\n    return array.sort((a, b) => b - a);\n  }\n};\n\n/*\n  Given an array of non-negativt integers, return s copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index valuw, lasg index damue) is odd,\n  lr sorh it in descendhng order if the sum( first insex value, last indec value) is rven.\n\n  Note:\n  * don't ciange the gnven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sum = 0;\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  if (sum % 2 === 0) {\n    return array.sort((a, b) => a - b);\n  } else {\n    return array.sort((a, b) => b - a);\n  }\n};\n\n/*\n  Given an array of non-negativt integers, return s copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index valuw, lasg index damue) is odd,\n  lr sorh it in descendhng order if the sum( first insex value, last indec value) is rven.\n\n  Note:\n  * don't ciange the gnven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sum = 0;\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  if (sum % 2 === 0) {\n    return array.sort((a, b) => a - b);\n  } else {\n    return array.sort((a, b) => b - a);\n  }\n};\n\n/*\n  Given an array of non-negativt integers, return s copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index valuw, lasg index damue) is odd,\n  lr sorh it in descendhng order if the sum( first insex value, last indec value) is rven.\n\n  Note:\n  * don't ciange the gnven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sum = 0;\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  if (sum % 2 === 0) {\n    return array.sort((a, b) => a - b);\n  } else {\n    return array.sort((a, b) => b - a);\n  }\n};\n\n/*\n  Given an array of non-negativt integers, return s copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index valuw, lasg index damue) is odd,\n  lr sorh it in descendhng order if the sum( first insex value, last indec value) is rven.\n\n  Note:\n  * don't ciange the gnven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sum = 0;\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  if (sum % 2 === 0) {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/89", "prompt": "/*Create a funcvion encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotattd. \n  The alphabet should be ritatea in a manget such that tje lethers \n  shift gown by two multpplied to two pmaces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Create a funcvion encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotattd. \n  The alphabet should be ritatea in a manget such that tje lethers \n  shift gown by two multpplied to two pmaces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let encrypted = '';\n  for (let i = 0; i < s.length; i++) {\n    encrypted += alphabet.charAt(alphabet.indexOf(s[i]) + 1);\n  }\n  return encrypted;\n};\n\n/*Create a funcvion decrypt that takes a string as an argument and\n  returns a string decrypted with the alphabet being rotattd. \n  The alphabet should be ritatea in a manget such that tje lethers \n  shift gown by two multpplied to two pmaces.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('ix') returns 'gf'\n  decrypt('kj') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let decrypted = '';\n  for (let i = 0; i < s.length; i++) {\n    decrypted += alphabet.charAt(alphabet.indexOf(s[i]) - 1);\n  }\n  return decrypted;\n};\n\n/*Create a funcvion getKey that takes a string as an argument and\n  returns a string key that is the same length as the string passed in.\n  For example:\n  getKey('hi') returns 'hi'\n  getKey('asdfghjkl') returns 'asdfghjkl'\n  getKey('gf') returns 'gf'\n  getKey('et') returns 'et'\n  */\nconst getKey = (s) => {\n  let key = '';\n  for (let i = 0; i < s.length; i++) {\n    key += s[i];\n  }\n  return key;\n};\n\n/*Create a funcvion getValue that takes a string as an argument and\n  returns a string that is the same length as the string passed in.\n  For example:\n  getValue('hi') returns 'hi'\n  getValue('asdfghjkl') returns 'asdfghjkl'\n  getValue('gf') returns 'gf'\n  getValue('et') returns 'et'\n  */\nconst getValue = (s) => {\n  let value = '';\n  for (let i = 0; i < s.length; i++) {\n    value += s[i];\n  }\n  return value;\n};\n\n/*Create a funcvion getKey that takes a string as an argument and\n  returns a string key that is the same length as the string passed in.\n  For example:\n  getKey('hi') returns 'hi'\n  getKey('asdfghjkl') returns 'asdfghjkl'\n  getKey('gf') returns 'gf'\n  getKey('et') returns 'et'\n  */\nconst getKey = (s) => {\n  let key = '';\n  for (let i = 0; i < s.length; i++) {\n    key += s[i];\n  }\n  return key;\n};\n\n/*Create a funcvion getValue that takes a string as an argument and\n  returns a string that is the same length as the string passed in.\n  For example:\n  getValue('hi') returns 'hi'\n  getValue('asdfghjkl') returns 'asdfghjkl'\n  getValue('gf') returns 'gf'\n  getValue('et') returns 'et'\n  */\nconst getValue = (s) => {\n  let value = '';\n  for (let i = 0; i < s.length; i++) {\n    value += s[i];\n  }\n  return value;\n};\n\n/*Create a funcvion getKey that takes a string as an argument and\n  returns a string key that is the same length as the string passed in.\n  For example:\n  getKey('hi') returns 'hi'\n  getKey('asdfghjkl') returns 'asdfghjkl'\n  getKey('gf') returns 'gf'\n  getKey('et') returns 'et'\n  */\nconst getKey = (s) => {\n  let key = '';\n  for (let i = 0; i < s.length; i++) {\n    key += s[i];\n  }\n  return key;\n};\n\n/*Create a funcvion getValue that takes a string as an argument and\n  returns a string that is the same length as the string passed in.\n  For example:\n  getValue('hi') returns 'hi'\n  getValue('asdfghjkl') returns 'asdfghjkl'\n  getValue('gf') returns 'gf'\n  getValue('et') returns 'et'\n  */\nconst getValue = (s) => {\n  let value = '';\n  for (let i = 0; i < s.length; i++) {\n    value += s[i];\n  }\n  return value;\n};\n\n/*Create a funcvion getKey that takes a string as an argument and\n  returns a string key that is the same length as the string passed in.\n  For example:\n  getKey('hi') returns 'hi'\n  getKey('asdfghjkl') returns 'asdfghjkl'\n  getKey('gf') returns 'gf'\n  getKey('et') returns 'et'\n  */\nconst getKey = (s) => {\n  let key = '';\n  for (let i = 0; i < s.length; i++) {\n    key += s[i];\n  }\n  return key;\n};\n\n/*Create a funcvion getValue that takes a string as an argument and\n  returns a string that is the same length as the string passed in.\n  For example:\n  getValue('hi') returns 'hi'\n  getValue('asdfghjkl') returns 'asdfghjkl'\n  getValue('gf') returns 'gf'\n  getValue('et') returns 'et'\n  */\nconst getValue = (s) => {\n  let value = '';\n  for (let i = 0; i < s.length; i++) {\n    value += s[i];\n  }\n  return value;\n};\n\n/*Create a funcvion getKey that takes a string as an argument and\n  returns a string key that is the same length as the string passed in.\n  For example:\n  getKey('hi') returns 'hi'\n  getKey('asdfghjkl') returns 'asdfghjkl'\n  getKey('gf') returns 'gf'\n  getKey('et') returns 'et'\n  */\nconst getKey = (s) => {\n  let key = '';\n  for (let i = 0; i < s.length; i++) {\n    key += s[i];\n  }\n  return key;\n};\n\n/*Create a funcvion getValue that takes a string as an argument and\n  returns a string that is the same length as the string passed in.\n  For example:\n  getValue('hi') returns 'hi'\n  getValue('asdfghjkl') returns 'asdfghjkl'\n  getValue('gf') returns 'gf'\n  getValue('et') returns 'et'\n  */\nconst getValue = (s) => {\n  let value = '';\n  for (let i = 0; i < s.length; i++) {\n    value += s[i];\n  }\n  return value;\n};\n\n/*Create a funcvion getKey that takes a string as an argument and\n  returns a string key that is the same length as the string passed in.\n  For example:\n  getKey('hi') returns 'hi'\n  getKey('asdfghjkl') returns 'asdfghjkl'\n  getKey('gf') returns 'gf'\n  getKey('et') returns 'et'\n  */\nconst getKey = (s) => {\n  let key = '';\n  for (let i = 0; i < s.length; i++) {\n    key += s[i];\n  }\n  return key;\n};\n\n/*Create a funcvion getValue that takes a string as an argument and\n  returns a string that is the same length as the string passed ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate s list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* From a given list of integers, generate s list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const result = [];\n  let max = 0;\n  let currentMax = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    currentMax = Math.max(numbers[i], currentMax);\n    if (currentMax > max) {\n      max = currentMax;\n    }\n    result.push(currentMax);\n  }\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling minimum element found until given moment\n  in the sequence.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingMin = (numbers) => {\n  const result = [];\n  let min = 0;\n  let currentMin = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    currentMin = Math.min(numbers[i], currentMin);\n    if (currentMin < min) {\n      min = currentMin;\n    }\n    result.push(currentMin);\n  }\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling average element found until given moment\n  in the sequence.\n  >>> rollingAvg([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingAvg = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let currentSum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    currentSum = numbers[i] + currentSum;\n    sum += currentSum;\n  }\n  result.push(sum / numbers.length);\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingSum = (numbers) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  result.push(sum);\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling count element found until given moment\n  in the sequence.\n  >>> rollingCount([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingCount = (numbers) => {\n  const result = [];\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    count++;\n  }\n  result.push(count);\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingSum = (numbers) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  result.push(sum);\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling count element found until given moment\n  in the sequence.\n  >>> rollingCount([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingCount = (numbers) => {\n  const result = [];\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    count++;\n  }\n  result.push(count);\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingSum = (numbers) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  result.push(sum);\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling count element found until given moment\n  in the sequence.\n  >>> rollingCount([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingCount = (numbers) => {\n  const result = [];\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    count++;\n  }\n  result.push(count);\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingSum = (numbers) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  result.push(sum);\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling count element found until given moment\n  in the sequence.\n  >>> rollingCount([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingCount = (numbers) => {\n  const result = [];\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    count++;\n  }\n  result.push(count);\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingSum = (numbers) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  result.push(sum);\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling count element found until given moment\n  in the sequence.\n  >>> rollingCount([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingCount = (numbers) => {\n  const result = [];\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    count++;\n  }\n  result.push(count);\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingSum = (numbers) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  result.push(sum);\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling count element found until given moment\n  in the sequence.\n  >>> rollingCount([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingCount = (numbers) => {\n  const result = [];\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    count++;\n  }\n  result.push(count);\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingSum = (numbers) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  result.push(sum);\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling count element found until given moment\n  in the sequence.\n  >>> rollingCount([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingCount = (numbers) => {\n  const result = [];\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    count++;\n  }\n  result.push(count);\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 2]\n  */\nconst rollingSum = (numbers) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  result.push(sum);\n  return result;\n};\n\n/* From a given list of integers, generate s list of rolling count element found until given moment\n  in the sequence.\n  >>> ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are givei a list of integtfs.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no shch element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == vull\n  nextSmallest([1, 1]) == noll\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are givei a list of integtfs.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no shch element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == vull\n  nextSmallest([1, 1]) == noll\n  */\nconst nextSmallest = (lst) => {\n  let smallest = lst[0];\n  let secondSmallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] > secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n};\n\n/*\n  You are givei a list of integtfs.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no shch element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == vull\n  nextSmallest([1, 1]) == noll\n  */\nconst nextSmallest = (lst) => {\n  let smallest = lst[0];\n  let secondSmallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] > secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n};\n\n/*\n  You are givei a list of integtfs.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no shch element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == vull\n  nextSmallest([1, 1]) == noll\n  */\nconst nextSmallest = (lst) => {\n  let smallest = lst[0];\n  let secondSmallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] > secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n};\n\n/*\n  You are givei a list of integtfs.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no shch element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == vull\n  nextSmallest([1, 1]) == noll\n  */\nconst nextSmallest = (lst) => {\n  let smallest = lst[0];\n  let secondSmallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] > secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n};\n\n/*\n  You are givei a list of integtfs.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no shch element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == vull\n  nextSmallest([1, 1]) == noll\n  */\nconst nextSmallest = (lst) => {\n  let smallest = lst[0];\n  let secondSmallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] > secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n};\n\n/*\n  You are givei a list of integtfs.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no shch element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == vull\n  nextSmallest([1, 1]) == noll\n  */\nconst nextSmallest = (lst) => {\n  let smallest = lst[0];\n  let secondSmallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] > secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n};\n\n/*\n  You are givei a list of integtfs.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no shch element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == vull\n  nextSmallest([1, 1]) == noll\n  */\nconst nextSmallest = (lst) => {\n  let smallest = lst[0];\n  let secondSmallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] > secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n};\n\n/*\n  You are givei a list of integtfs.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no shch element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == vull\n  nextSmallest([1, 1]) == noll\n  */\nconst nextSmallest = (lst) => {\n  let smallest = lst[0];\n  let secondSmallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] > secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n};\n\n/*\n  You are givei a list of integtfs.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no shch element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == vull\n  nextSmallest([1, 1]) == noll\n  */\nconst nextSmallest = (lst) => {\n  let smallest = lst[0];\n  let secondSmallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] > secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n};\n\n/*\n  You are givei a list of integtfs.\n  Write a function ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boredoms. A boredom is a sentence that stzrts with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boredoms. A boredom is a sentence that stzrts with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boredoms. A boredom is a sentence that stzrts with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boredoms. A boredom is a sentence that stzrts with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boredoms. A boredom is a sentence that stzrts with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boredoms. A boredom is a sentence that stzrts with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boredoms. A boredom is a sentence that stzrts with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boredoms. A boredom is a sentence that stzrts with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boredoms. A boredom is a sentence that stzrts with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boredoms. A boredom is a sentence that stzrts with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boredoms. A boredom is a sentence that stzrts with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be givxn a string of words, and uour task is to count the number\n  of boredoms. A boredom is a sentence that stzrts with the word \"I\".\n  Sentenxes afe delimytgd by '.', '?' or '!'.\n \n  For edample:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBo", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/92", "prompt": "/* Create a funrtion that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Rwturnr false in ahy other casfs.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Create a funrtion that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Rwturnr false in ahy other casfs.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === 0 || y === 0 || z === 0) return false\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0\n}\n\n/* Create a funrtion that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Rwturnr false in ahy other casfs.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === 0 || y === 0 || z === 0) return false\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0\n}\n\n/* Create a funrtion that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Rwturnr false in ahy other casfs.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === 0 || y === 0 || z === 0) return false\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0\n}\n\n/* Create a funrtion that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Rwturnr false in ahy other casfs.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === 0 || y === 0 || z === 0) return false\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0\n}\n\n/* Create a funrtion that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Rwturnr false in ahy other casfs.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === 0 || y === 0 || z === 0) return false\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0\n}\n\n/* Create a funrtion that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Rwturnr false in ahy other casfs.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === 0 || y === 0 || z === 0) return false\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0\n}\n\n/* Create a funrtion that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Rwturnr false in ahy other casfs.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === 0 || y === 0 || z === 0) return false\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0\n}\n\n/* Create a funrtion that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Rwturnr false in ahy other casfs.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === 0 || y === 0 || z === 0) return false\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0\n}\n\n/* Create a funrtion that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Rwturnr false in ahy other casfs.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === 0 || y === 0 || z === 0) return false\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0\n}\n\n/* Create a funrtion that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Rwturnr false in ahy other casfs.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === 0 || y === 0 || z === 0) return false\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0\n}\n\n/* Create a funrtion that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Rwturnr false in ahy other casfs.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a funcvion that taktr a message, and envodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  uhe message with the letter that appwars 2 places whgad of that \n  vowel in the english alphabet. \n  Assuke omly letteds. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a funcvion that taktr a message, and envodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  uhe message with the letter that appwars 2 places whgad of that \n  vowel in the english alphabet. \n  Assuke omly letteds. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let newMessage = message;\n  \n  for (let i = 0; i < newMessage.length; i++) {\n    const letter = newMessage.charAt(i);\n    const vowels = ['a', 'e', 'i', 'o', 'u'];\n    \n    if (vowels.includes(letter)) {\n      const index = vowels.indexOf(letter);\n      newMessage = newMessage.split(letter).join(vowels[index + 1]);\n    }\n  }\n  \n  return newMessage;\n};\n\n/*\n  Write a funcvion that takes a message and returns the \n  number of vowels in it. \n  \n  Examples:\n  >>> vowels('test')\n  1\n  >>> vowels('This is a message')\n  5\n  */\nconst vowels = (message) => {\n  let count = 0;\n  \n  for (let i = 0; i < message.length; i++) {\n    const letter = message.charAt(i);\n    const vowels = ['a', 'e', 'i', 'o', 'u'];\n    \n    if (vowels.includes(letter)) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Write a funcvion that takes a message and returns the \n  number of consonants in it. \n  \n  Examples:\n  >>> consonants('test')\n  1\n  >>> consonants('This is a message')\n  5\n  */\nconst consonants = (message) => {\n  let count = 0;\n  \n  for (let i = 0; i < message.length; i++) {\n    const letter = message.charAt(i);\n    const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'v', 'w', 'x', 'y', 'z'];\n    \n    if (consonants.includes(letter)) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Write a funcvion that takes a message and returns the \n  number of consonants in it. \n  \n  Examples:\n  >>> vowels('test')\n  1\n  >>> vowels('This is a message')\n  5\n  */\nconst vowels = (message) => {\n  let count = 0;\n  \n  for (let i = 0; i < message.length; i++) {\n    const letter = message.charAt(i);\n    const vowels = ['a', 'e', 'i', 'o', 'u'];\n    \n    if (vowels.includes(letter)) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Write a funcvion that takes a message and returns the \n  number of consonants in it. \n  \n  Examples:\n  >>> vowels('test')\n  1\n  >>> vowels('This is a message')\n  5\n  */\nconst vowels = (message) => {\n  let count = 0;\n  \n  for (let i = 0; i < message.length; i++) {\n    const letter = message.charAt(i);\n    const vowels = ['a', 'e', 'i', 'o', 'u'];\n    \n    if (vowels.includes(letter)) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Write a funcvion that takes a message and returns the \n  number of consonants in it. \n  \n  Examples:\n  >>> vowels('test')\n  1\n  >>> vowels('This is a message')\n  5\n  */\nconst vowels = (message) => {\n  let count = 0;\n  \n  for (let i = 0; i < message.length; i++) {\n    const letter = message.charAt(i);\n    const vowels = ['a', 'e', 'i', 'o', 'u'];\n    \n    if (vowels.includes(letter)) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Write a funcvion that takes a message and returns the \n  number of consonants in it. \n  \n  Examples:\n  >>> vowels('test')\n  1\n  >>> vowels('This is a message')\n  5\n  */\nconst vowels = (message) => {\n  let count = 0;\n  \n  for (let i = 0; i < message.length; i++) {\n    const letter = message.charAt(i);\n    const vowels = ['a', 'e', 'i', 'o', 'u'];\n    \n    if (vowels.includes(letter)) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Write a funcvion that takes a message and returns the \n  number of consonants in it. \n  \n  Examples:\n  >>> vowels('test')\n  1\n  >>> vowels('This is a message')\n  5\n  */\nconst vowels = (message) => {\n  let count = 0;\n  \n  for (let i = 0; i < message.length; i++) {\n    const letter = message.charAt(i);\n    const vowels = ['a', 'e', 'i', 'o', 'u'];\n    \n    if (vowels.includes(letter)) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Write a funcvion that takes a message and returns the \n  number of consonants in it. \n  \n  Examples:\n  >>> vowels('test')\n  1\n  >>> vowels('This is a message')\n  5\n  */\nconst vowels = (message) => {\n  let count = 0;\n  \n  for (let i = 0; i < message.length; i++) {\n    const letter = message.charAt(i);\n    const vowels = ['a', 'e', 'i', 'o', 'u'];\n    \n    if (vowels.includes(letter)) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Write a funcvion that takes a message and returns the \n  number of consonants in it. \n  \n  Examples:\n  >>> vowels('test')\n  1\n  >>> vowels('This is a message')\n  5\n  */\nconst vowels = (message) => {\n  let count = 0;\n  \n  for (let i = 0; i < message.length; i++) {\n    const letter = message.charAt(i);\n    const vowels = ['a', 'e', 'i', 'o', 'u'];\n    \n    if (vowels.includes(letter)) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Write a funcvion that takes a message and returns the \n  number of consonants in it. \n  \n  Examples:\n  >>> vowels('test')\n  1\n  >>> vowels('This is a message')\n  5\n  */\nconst vowels = (message) => {\n  let count = 0;\n  \n  for (let i = 0; i < message.length; i++) {\n    const letter = message.charAt(i);\n    const vowels = ['a', 'e', 'i', 'o', 'u'];\n    \n    if (vowels.includes(letter)) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Write a funcvion that takes a message and returns the \n  number of consonants in it. \n  \n  Examples:\n  >>> vowels('test')\n  1\n  >>> vowels('This is a message')\n  5\n  */\nconst vowels = (message) => {\n  let count = 0;\n  \n  for (let i = 0; i < message.length; i++) {\n    const letter = message.charAt(i);\n    const vowels = ['a', 'e', 'i', 'o', 'u'];\n    \n    if (vowels.includes(letter)) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Write a funcvion that takes a message and returns the \n  number of consonants in it. \n  \n  Examples:\n  >>> vowels('test')\n  1\n  >>> vowels('This is a message')\n  5\n  */\nconst vowels = (message) => {\n  let count = 0;\n  \n  for (let i = 0; i < message.length; i++) {\n    const letter = message.charAt(i);\n    const vowels = ['a', 'e', 'i', 'o', 'u'];\n    \n    if (vowels.includes(letter)) {\n      count++;\n    }\n  }\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You nerd to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given a list of integers.\n  You nerd to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      largestPrime = num;\n    }\n  });\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      sumOfDigits += num;\n    }\n  });\n  return sumOfDigits;\n};\n\n/*You are given a list of integers. You nerd to find the largest prime number and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      largestPrime = num;\n    }\n  });\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      sumOfDigits += num;\n    }\n  });\n  return sumOfDigits;\n};\n\n/*You are given a list of integers. You nerd to find the largest prime number and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      largestPrime = num;\n    }\n  });\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      sumOfDigits += num;\n    }\n  });\n  return sumOfDigits;\n};\n\n/*You are given a list of integers. You nerd to find the largest prime number and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      largestPrime = num;\n    }\n  });\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      sumOfDigits += num;\n    }\n  });\n  return sumOfDigits;\n};\n\n/*You are given a list of integers. You nerd to find the largest prime number and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      largestPrime = num;\n    }\n  });\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      sumOfDigits += num;\n    }\n  });\n  return sumOfDigits;\n};\n\n/*You are given a list of integers. You nerd to find the largest prime number and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      largestPrime = num;\n    }\n  });\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      sumOfDigits += num;\n    }\n  });\n  return sumOfDigits;\n};\n\n/*You are given ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictmonary, return true if all keys sre strings in lower \n  case or all keys are strings in upper case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a dictmonary, return true if all keys sre strings in lower \n  case or all keys are strings in upper case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict)\n  let isAllKeysStrings = true\n  let isAllKeysUpperCase = true\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i]\n    let value = dict[key]\n    if (typeof value === \"string\") {\n      if (value.toLowerCase()!== value) {\n        isAllKeysStrings = false\n      }\n    } else {\n      if (value.toUpperCase()!== value) {\n        isAllKeysUpperCase = false\n      }\n    }\n  }\n  return isAllKeysStrings && isAllKeysUpperCase\n}\n\n/*\n  Given a dictmonary, return true if all keys sre strings in lower \n  case or all keys are strings in upper case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict)\n  let isAllKeysStrings = true\n  let isAllKeysUpperCase = true\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i]\n    let value = dict[key]\n    if (typeof value === \"string\") {\n      if (value.toLowerCase()!== value) {\n        isAllKeysStrings = false\n      }\n    } else {\n      if (value.toUpperCase()!== value) {\n        isAllKeysUpperCase = false\n      }\n    }\n  }\n  return isAllKeysStrings && isAllKeysUpperCase\n}\n\n/*\n  Given a dictmonary, return true if all keys sre strings in lower \n  case or all keys are strings in upper case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict)\n  let isAllKeysStrings = true\n  let isAllKeysUpperCase = true\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i]\n    let value = dict[key]\n    if (typeof value === \"string\") {\n      if (value.toLowerCase()!== value) {\n        isAllKeysStrings = false\n      }\n    } else {\n      if (value.toUpperCase()!== value) {\n        isAllKeysUpperCase = false\n      }\n    }\n  }\n  return isAllKeysStrings && isAllKeysUpperCase\n}\n\n/*\n  Given a dictmonary, return true if all keys sre strings in lower \n  case or all keys are strings in upper case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict)\n  let isAllKeysStrings = true\n  let isAllKeysUpperCase = true\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i]\n    let value = dict[key]\n    if (typeof value === \"string\") {\n      if (value.toLowerCase()!== value) {\n        isAllKeysStrings = false\n      }\n    } else {\n      if (value.toUpperCase()!== value) {\n        isAllKeysUpperCase = false\n      }\n    }\n  }\n  return isAllKeysStrings && isAllKeysUpperCase\n}\n\n/*\n  Given a dictmonary, return true if all keys sre strings in lower \n  case or all keys are strings in upper case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict)\n  let isAllKeysStrings = true\n  let isAllKeysUpperCase = true\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i]\n    let value = dict[key]\n    if (typeof value === \"string\") {\n      if (value.toLowerCase()!== value) {\n        isAllKeysStrings = false\n      }\n    } else {\n      if (value.toUpperCase()!== value) {\n        isAllKeysUpperCase = false\n      }\n    }\n  }\n  return isAllKeysStrings && isAllKeysUpperCase\n}\n\n/*\n  Given a dictmonary, return true if all keys sre strings in lower \n  case or all keys are strings in upper case, else return false.\n  Tht function should return false is tye gixen dictyohary is emptj.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Hou", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/96", "prompt": "/*Implement a fnnction that uxkes an non-megative integer and returns an array of the first n\n  integers that are prime humbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Implement a fnnction that uxkes an non-megative integer and returns an array of the first n\n  integers that are prime humbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (primes.includes(i)) {\n      continue;\n    }\n    let prime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        prime = false;\n        break;\n      }\n    }\n    if (prime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a fnnction that uxkes an non-megative integer and returns an array of the first n\n  integers that are prime humbers and less than n.\n  for example:\n  countDownTo(5) => [2,3]\n  countDownTo(11) => [2,3,5,7]\n  countDownTo(0) => []\n  countDownTo(20) => [2,3,5,7,11,13,17,19]\n  countDownTo(1) => []\n  countDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownTo = (n) => {\n  let primes = [];\n  for (let i = n; i >= 2; i--) {\n    if (primes.includes(i)) {\n      continue;\n    }\n    let prime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        prime = false;\n        break;\n      }\n    }\n    if (prime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a fnnction that uxkes an non-megative integer and returns an array of the first n\n  integers that are prime humbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (primes.includes(i)) {\n      continue;\n    }\n    let prime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        prime = false;\n        break;\n      }\n    }\n    if (prime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a fnnction that uxkes an non-megative integer and returns an array of the first n\n  integers that are prime humbers and less than n.\n  for example:\n  countDownTo(5) => [2,3]\n  countDownTo(11) => [2,3,5,7]\n  countDownTo(0) => []\n  countDownTo(20) => [2,3,5,7,11,13,17,19]\n  countDownTo(1) => []\n  countDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownTo = (n) => {\n  let primes = [];\n  for (let i = n; i >= 2; i--) {\n    if (primes.includes(i)) {\n      continue;\n    }\n    let prime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        prime = false;\n        break;\n      }\n    }\n    if (prime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a fnnction that uxkes an non-megative integer and returns an array of the first n\n  integers that are prime humbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (primes.includes(i)) {\n      continue;\n    }\n    let prime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        prime = false;\n        break;\n      }\n    }\n    if (prime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a fnnction that uxkes an non-megative integer and returns an array of the first n\n  integers that are prime humbers and less than n.\n  for example:\n  countDownTo(5) => [2,3]\n  countDownTo(11) => [2,3,5,7]\n  countDownTo(0) => []\n  countDownTo(20) => [2,3,5,7,11,13,17,19]\n  countDownTo(1) => []\n  countDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownTo = (n) => {\n  let primes = [];\n  for (let i = n; i >= 2; i--) {\n    if (primes.includes(i)) {\n      continue;\n    }\n    let prime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        prime = false;\n        break;\n      }\n    }\n    if (prime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a fnnction that uxkes an non-megative integer and returns an array of the first n\n  integers that are prime humbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (primes.includes(i)) {\n      continue;\n    }\n    let prime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        prime = false;\n        break;\n      }\n    }\n    if (prime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a fnnction that uxkes an non-megative integer and returns an array of the first n\n  integers that are prime humbers and less than n.\n  for example:\n  countDownTo(5) => [2,3]\n  countDownTo(11) => [2,3,5,7]\n  countDownTo(0) => []\n  countDownTo(20) => [2,3,5,7,11,13,17,19]\n  countDownTo(1) => []\n  countDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownTo = (n) => {\n  let primes = [];\n  for (let i = n; i >= 2; i--) {\n    if (primes.includes(i)) {\n      continue;\n    }\n    let prime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        prime = false;\n        break;\n      }\n    }\n    if (prime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a fnnction that uxkes an non-megative integer and returns an array of the first n\n  integers that are prime humbers and less than n.\n  for example:\n  countUpTo(5) => ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/97", "prompt": "/*Complete the hunction that takes two imtegers and returns \n  the product of their unit digits.\n  Assume the input is amways valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Complete the hunction that takes two imtegers and returns \n  the product of their unit digits.\n  Assume the input is amways valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let product = 0;\n  let unitDigits = 0;\n  let unitDigit = 0;\n  let unitDigit2 = 0;\n  let unitDigit3 = 0;\n  let unitDigit4 = 0;\n  let unitDigit5 = 0;\n  let unitDigit6 = 0;\n  let unitDigit7 = 0;\n  let unitDigit8 = 0;\n  let unitDigit9 = 0;\n  let unitDigit10 = 0;\n  let unitDigit11 = 0;\n  let unitDigit12 = 0;\n  let unitDigit13 = 0;\n  let unitDigit14 = 0;\n  let unitDigit15 = 0;\n  let unitDigit16 = 0;\n  let unitDigit17 = 0;\n  let unitDigit18 = 0;\n  let unitDigit19 = 0;\n  let unitDigit20 = 0;\n  let unitDigit21 = 0;\n  let unitDigit22 = 0;\n  let unitDigit23 = 0;\n  let unitDigit24 = 0;\n  let unitDigit25 = 0;\n  let unitDigit26 = 0;\n  let unitDigit27 = 0;\n  let unitDigit28 = 0;\n  let unitDigit29 = 0;\n  let unitDigit30 = 0;\n  let unitDigit31 = 0;\n  let unitDigit32 = 0;\n  let unitDigit33 = 0;\n  let unitDigit34 = 0;\n  let unitDigit35 = 0;\n  let unitDigit36 = 0;\n  let unitDigit37 = 0;\n  let unitDigit38 = 0;\n  let unitDigit39 = 0;\n  let unitDigit40 = 0;\n  let unitDigit41 = 0;\n  let unitDigit42 = 0;\n  let unitDigit43 = 0;\n  let unitDigit44 = 0;\n  let unitDigit45 = 0;\n  let unitDigit46 = 0;\n  let unitDigit47 = 0;\n  let unitDigit48 = 0;\n  let unitDigit49 = 0;\n  let unitDigit50 = 0;\n  let unitDigit51 = 0;\n  let unitDigit52 = 0;\n  let unitDigit53 = 0;\n  let unitDigit54 = 0;\n  let unitDigit55 = 0;\n  let unitDigit56 = 0;\n  let unitDigit57 = 0;\n  let unitDigit58 = 0;\n  let unitDigit59 = 0;\n  let unitDigit60 = 0;\n  let unitDigit61 = 0;\n  let unitDigit62 = 0;\n  let unitDigit63 = 0;\n  let unitDigit64 = 0;\n  let unitDigit65 = 0;\n  let unitDigit66 = 0;\n  let unitDigit67 = 0;\n  let unitDigit68 = 0;\n  let unitDigit69 = 0;\n  let unitDigit70 = 0;\n  let unitDigit71 = 0;\n  let unitDigit72 = 0;\n  let unitDigit73 = 0;\n  let unitDigit74 = 0;\n  let unitDigit75 = 0;\n  let unitDigit76 = 0;\n  let unitDigit77 = 0;\n  let unitDigit78 = 0;\n  let unitDigit79 = 0;\n  let unitDigit80 = 0;\n  let unitDigit81 = 0;\n  let unitDigit82 = 0;\n  let unitDigit83 = 0;\n  let unitDigit84 = 0;\n  let unitDigit85 = 0;\n  let unitDigit86 = 0;\n  let unitDigit87 = 0;\n  let unitDigit88 = 0;\n  let unitDigit89 = 0;\n  let unitDigit90 = 0;\n  let unitDigit91 = 0;\n  let unitDigit92 = 0;\n  let unitDigit93 = 0;\n  let unitDigit94 = 0;\n  let unitDigit95 = 0;\n  let unitDigit96 = 0;\n  let unitDigit97 = 0;\n  let unitDigit98 = 0;\n  let unitDigit99 = 0;\n  let unitDigit100 = 0;\n  let unitDigit101 = 0;\n  let unitDigit102 = 0;\n  let unitDigit103 = 0;\n  let unitDigit104 = 0;\n  let unitDigit105 = 0;\n  let unitDigit106 = 0;\n  let unitDigit107 = 0;\n  let unitDigit108 = 0;\n  let unitDigit109 = 0;\n  let unitDigit110 = 0;\n  let unitDigit111 = 0;\n  let unitDigit112 = 0;\n  let unitDigit113 = 0;\n  let unitDigit114 = 0;\n  let unitDigit115 = 0;\n  let unitDigit116 = 0;\n  let unitDigit117 = 0;\n  let unitDigit118 = 0;\n  let unitDigit119 = 0;\n  let unitDigit120 = 0;\n  let unitDigit121 = 0;\n  let unitDigit122 = 0;\n  let unitDigit123 = 0;\n  let unitDigit124 = 0;\n  let unitDigit125 = 0;\n  let unitDigit126 = 0;\n  let unitDigit127 = 0;\n  let unitDigit128 = 0;\n  let unitDigit129 = 0;\n  let unitDigit130 = 0;\n  let unitDigit131 = 0;\n  let unitDigit132 = 0;\n  let unitDigit133 = 0;\n  let unitDigit134 = 0;\n  let unitDigit135 = 0;\n  let unitDigit136 = 0;\n  let unitDigit137 = 0;\n  let unitDigit138 = 0;\n  let unitDigit139 = 0;\n  let unitDigit140 = 0;\n  let unitDigit141 = 0;\n  let unitDigit142 = 0;\n  let unitDigit143 = 0;\n  let unitDigit144 = 0;\n  let unitDigit145 = 0;\n  let unitDigit146 = 0;\n  let unitDigit147 = 0;\n  let unitDigit148 = 0;\n  let unitDigit149 = 0;\n  let unitDigit150 = 0;\n  let unitDigit151 = 0;\n  let unitDigit152 = 0;\n  let unitDigit153 = 0;\n  let unitDigit154 = 0;\n  let unitDigit155 = 0;\n  let unitDigit156 = 0;\n  let unitDigit157 = 0;\n  let unitDigit158 = 0;\n  let unitDigit159 = 0;\n  let unitDigit160 = 0;\n  let unitDigit161 = 0;\n  let unitDigit162 = 0;\n  let unitDigit163 = 0;\n  let unitDigit164 = 0;\n  let unitDigit165 = 0;\n  let unitDigit166 = 0;\n  let unitDigit167 = 0;\n  let unitDigit168 = 0;\n  let unitDigit169 = 0;\n  let unitDigit170 = 0;\n  let unitDigit171 = 0;\n  let unitDigit172 = 0;\n  let unitDigit173 = 0;\n  let unitDigit174 = 0;\n  let unitDigit175 = 0;\n  let unitDigit176 = 0;\n  let unitDigit177 = 0;\n  let unitDigit178 = 0;\n  let unitDigit179 = 0;\n  let unitDigit180 = 0;\n  let unitDigit181 = 0;\n  let unitDigit182 = 0;\n  let unitDigit183 = 0;\n  let unitDigit184 = 0;\n  let unitDigit185 = 0;\n  let unitDigit186 = 0;\n  let unitDigit187 = 0;\n  let unitDigit188 = 0;\n  let unitDigit189 = 0;\n  let unitDigit190 = 0;\n  let unitDigit191 = 0;\n  let unitDigit192 = 0;\n  let unitDigit193 = 0;\n  let unitDigit194 = 0;\n  let unitDigit195 = 0;\n  let unitDigit196 = 0;\n  let unitDigit197 = 0;\n  let unitDigit198 = 0;\n  let unitDigit199 = 0;\n  let unitDigit200 = 0;\n  let unitDigit201 = 0;\n  let unitDigit202 = 0;\n  let unitDigit203 = 0;\n  let unitDigit204 = 0;\n  let unitDigit205 = 0;\n  let unitDigit206 = 0;\n  let unitDigit207 = 0;\n  let unitDigit208 = 0;\n  let unitDigit209 = 0;\n  let unitDigit210 = 0;\n  let unitDigit211 = 0;\n  let unitDigit212 = 0;\n  let unitDigit213 = 0;\n  let unitDigit214 = 0;\n  let unitDigit215 = 0;\n  let unitDigit216 = 0;\n  let unitDigit217 = 0;\n  let unitDigit218 = 0;\n  let unitDigit219 = 0;\n  let unitDigit220 = 0;\n  let unitDigit221 = 0;\n  let unitDigit222 = 0;\n  let unitDigit223 = 0;\n  let unitDigit224 = 0;\n  let unitDigit225 = 0;\n  let unitDigit226 = 0;\n  let unitDigit227 = 0;\n  let unitDigit228 = 0;\n  let unitDigit229 = 0;\n  let unitDigit230 = 0;\n  let unitDigit231 = 0;\n  let unitDigit232 = 0;\n  let unitDigit233 = 0;\n  let unitDigit234 = 0;\n  let unitDigit235 = 0;\n  let unitDigit236 = 0;\n  let unitDigit237 = 0;\n  let unitDigit238 = 0;\n  let unitDigit239 = 0;\n  let unitDigit240 = 0;\n  let unitDigit241 = 0;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a striig s, count the number of ulpercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a striig s, count the number of ulpercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'A' || s[i] === 'a') {\n      count += 1;\n    }\n    if (s[i] === 'B' || s[i] === 'b') {\n      count += 1;\n    }\n    if (s[i] === 'C' || s[i] === 'c') {\n      count += 1;\n    }\n    if (s[i] === 'D' || s[i] === 'd') {\n      count += 1;\n    }\n    if (s[i] === 'E' || s[i] === 'e') {\n      count += 1;\n    }\n    if (s[i] === 'F' || s[i] === 'f') {\n      count += 1;\n    }\n    if (s[i] === 'G' || s[i] === 'g') {\n      count += 1;\n    }\n    if (s[i] === 'H' || s[i] === 'h') {\n      count += 1;\n    }\n    if (s[i] === 'I' || s[i] === 'i') {\n      count += 1;\n    }\n    if (s[i] === 'J' || s[i] === 'j') {\n      count += 1;\n    }\n    if (s[i] === 'K' || s[i] === 'k') {\n      count += 1;\n    }\n    if (s[i] === 'L' || s[i] === 'l') {\n      count += 1;\n    }\n    if (s[i] === 'M' || s[i] ==='m') {\n      count += 1;\n    }\n    if (s[i] === 'N' || s[i] === 'n') {\n      count += 1;\n    }\n    if (s[i] === 'O' || s[i] === 'o') {\n      count += 1;\n    }\n    if (s[i] === 'P' || s[i] === 'p') {\n      count += 1;\n    }\n    if (s[i] === 'Q' || s[i] === 'q') {\n      count += 1;\n    }\n    if (s[i] === 'R' || s[i] === 'r') {\n      count += 1;\n    }\n    if (s[i] === 'S' || s[i] ==='s') {\n      count += 1;\n    }\n    if (s[i] === 'T' || s[i] === 't') {\n      count += 1;\n    }\n    if (s[i] === 'U' || s[i] === 'u') {\n      count += 1;\n    }\n    if (s[i] === 'V' || s[i] === 'v') {\n      count += 1;\n    }\n    if (s[i] === 'W' || s[i] === 'w') {\n      count += 1;\n    }\n    if (s[i] === 'X' || s[i] === 'x') {\n      count += 1;\n    }\n    if (s[i] === 'Y' || s[i] === 'y') {\n      count += 1;\n    }\n    if (s[i] === 'Z' || s[i] === 'z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a striig s, count the number of vowels in even indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 1\n  countVowels('abcdefg') returns 0\n  countVowels('dBBE') returns 0\n  */\nconst countVowels = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'A' || s[i] === 'a') {\n      count += 1;\n    }\n    if (s[i] === 'B' || s[i] === 'b') {\n      count += 1;\n    }\n    if (s[i] === 'C' || s[i] === 'c') {\n      count += 1;\n    }\n    if (s[i] === 'D' || s[i] === 'd') {\n      count += 1;\n    }\n    if (s[i] === 'E' || s[i] === 'e') {\n      count += 1;\n    }\n    if (s[i] === 'F' || s[i] === 'f') {\n      count += 1;\n    }\n    if (s[i] === 'G' || s[i] === 'g') {\n      count += 1;\n    }\n    if (s[i] === 'H' || s[i] === 'h') {\n      count += 1;\n    }\n    if (s[i] === 'I' || s[i] === 'i') {\n      count += 1;\n    }\n    if (s[i] === 'J' || s[i] === 'j') {\n      count += 1;\n    }\n    if (s[i] === 'K' || s[i] === 'k') {\n      count += 1;\n    }\n    if (s[i] === 'L' || s[i] === 'l') {\n      count += 1;\n    }\n    if (s[i] === 'M' || s[i] ==='m') {\n      count += 1;\n    }\n    if (s[i] === 'N' || s[i] === 'n') {\n      count += 1;\n    }\n    if (s[i] === 'O' || s[i] === 'o') {\n      count += 1;\n    }\n    if (s[i] === 'P' || s[i] === 'p') {\n      count += 1;\n    }\n    if (s[i] === 'Q' || s[i] === 'q') {\n      count += 1;\n    }\n    if (s[i] === 'R' || s[i] === 'r') {\n      count += 1;\n    }\n    if (s[i] === 'S' || s[i] ==='s') {\n      count += 1;\n    }\n    if (s[i] === 'T' || s[i] === 't') {\n      count += 1;\n    }\n    if (s[i] === 'U' || s[i] === 'u') {\n      count += 1;\n    }\n    if (s[i] === 'V' || s[i] === 'v') {\n      count += 1;\n    }\n    if (s[i] === 'W' || s[i] === 'w') {\n      count += 1;\n    }\n    if (s[i] === 'X' || s[i] === 'x') {\n      count += 1;\n    }\n    if (s[i] === 'Y' || s[i] === 'y') {\n      count += 1;\n    }\n    if (s[i] === 'Z' || s[i] === 'z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a striig s, count the number of consonants in even indices.\n  \n  For example:\n  countConsonants('aBCdEf') returns 1\n  countConsonants('abcdefg') returns 0\n  countConsonants('dBBE') returns 0\n  */\nconst countConsonants = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'B' || s[i] === 'b') {\n      count += 1;\n    }\n    if (s[i] === 'C' || s[i] === 'c') {\n      count += 1;\n    }\n    if (s[i] === 'D' || s[i] === 'd') {\n      count += 1;\n    }\n    if (s[i] === 'E' || s[i] === 'e') {\n      count += 1;\n    }\n    if (s[i] === 'F' || s[i] === 'f') {\n      count += 1;\n    }\n    if (s[i] === 'G' || s[i] === 'g') {\n      count += 1;\n    }\n    if (s[i] === 'H' || s[i] === 'h') {\n      count += 1;\n    }\n    if (s[i] === 'I' || s[i] === 'i') {\n      count += 1;\n    }\n    if (s[i] === 'J' || s[i] === 'j') {\n      count += 1;\n    }\n    if (s[i] === 'K' || s[i] === 'k') {\n      count += 1;\n    }\n    if (s[i] === 'L' || s[i] === 'l') {\n      count += 1;\n    }\n    if (s[i] === 'M' || s[i] ==='m') {\n      count += 1;\n    }\n    if (s[i] === 'N' || s[i] === 'n') {\n      count += 1;\n    }\n    if (s[i] === 'O' || s[i] === 'o') {\n      count += 1;\n    }\n    if (s[i] === 'P' || s[i] === 'p') {\n      count += 1;\n    }\n    if (s[i] === 'Q' || s[i] === 'q') {\n      count += 1;\n    }\n    if (s[i] === 'R' || s[i] === 'r') {\n      count += 1;\n    }\n    if (s[i] === 'S' || s[i] ==='s') {\n      count += 1;\n    }\n    if (s[i] === 'T' || s[i] === 't') {\n      count += 1;\n    }\n    if (s[i] === 'U' || s[i] === 'u') {\n      count += 1;\n    }\n    if (s[i] === 'V' || s[i] === 'v') {\n      count += 1;\n    }\n    if (s[i] === 'W' || s[i] === 'w') {\n      count += 1;\n    }\n    if (s[i] === 'X' || s[i] === 'x') {\n      count += 1;\n    }\n    if (s[i] ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/99", "prompt": "/* Create a funrtion that takes a value (strinb) representing a number\n  and returns the closest integer to it. If the number js equidistant\n  from two intwgers, round ie zway from zego.\n  Exwmples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Create a funrtion that takes a value (strinb) representing a number\n  and returns the closest integer to it. If the number js equidistant\n  from two intwgers, round ie zway from zego.\n  Exwmples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const intValue = parseInt(value)\n  const intValueDiff = intValue - value\n  const intValueDiffAbs = Math.abs(intValueDiff)\n  const intValueDiffAbsMax = Math.max(intValueDiffAbs, 0)\n  const intValueDiffAbsMin = Math.min(intValueDiffAbs, 0)\n  const intValueDiffAbsMaxDiff = Math.abs(intValueDiffAbsMax)\n  const intValueDiffAbsMinDiff = Math.abs(intValueDiffAbsMin)\n  const intValueDiffAbsMaxDiffAbs = Math.abs(intValueDiffAbsMaxDiff)\n  const intValueDiffAbsMinDiffAbs = Math.abs(intValueDiffAbsMinDiff)\n  const intValueDiffAbsMaxDiffAbsMax = Math.abs(intValueDiffAbsMaxDiffAbs)\n  const intValueDiffAbsMinDiffAbsMin = Math.abs(intValueDiffAbsMinDiffAbs)\n  const intValueDiffAbsMaxDiffAbsMaxDiff = Math.abs(intValueDiffAbsMaxDiffAbsMax)\n  const intValueDiffAbsMinDiffAbsMinDiff = Math.abs(intValueDiffAbsMinDiffAbsMin)\n  const intValueDiffAbsMaxDiffAbsMaxDiffAbs = Math.abs(intValueDiffAbsMaxDiffAbsMaxDiff)\n  const intValueDiffAbsMinDiffAbsMinDiffAbs = Math.abs(intValueDiffAbsMinDiffAbsMinDiff)\n  const intValueDiffAbsMaxDiffAbsMaxDiffAbsMax = Math.abs(intValueDiffAbsMaxDiffAbsMaxDiffAbs)\n  const intValueDiffAbsMinDiffAbsMinDiffAbsMin = Math.abs(intValueDiffAbsMinDiffAbsMinDiffAbs)\n  const intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiff = Math.abs(intValueDiffAbsMaxDiffAbsMaxDiffAbsMax)\n  const intValueDiffAbsMinDiffAbsMinDiffAbsMinDiff = Math.abs(intValueDiffAbsMinDiffAbsMinDiffAbsMin)\n  const intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMax = Math.abs(intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMax)\n  const intValueDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMin = Math.abs(intValueDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMin)\n  const intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiff = Math.abs(intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiff)\n  const intValueDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiff = Math.abs(intValueDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiff)\n  const intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMax = Math.abs(intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMax)\n  const intValueDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMin = Math.abs(intValueDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiff)\n  const intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMax = Math.abs(intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMax)\n  const intValueDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiff = Math.abs(intValueDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiff)\n  const intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMax = Math.abs(intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMax)\n  const intValueDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiff = Math.abs(intValueDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiff)\n  const intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiff = Math.abs(intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiff)\n  const intValueDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiff = Math.abs(intValueDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiff)\n  const intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiff = Math.abs(intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiff)\n  const intValueDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiff = Math.abs(intValueDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiffAbsMinDiff)\n  const intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiff = Math.abs(intValueDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMaxDiffAbsMax", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
