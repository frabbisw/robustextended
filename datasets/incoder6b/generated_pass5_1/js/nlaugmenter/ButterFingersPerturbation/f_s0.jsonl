{"task_id": "JavaScript/0", "prompt": "/* Chefk if in given list of numbers, are any two numbers closer to eaxh othxr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Chefk if in given list of numbers, are any two numbers closer to eaxh othxr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const firstElement = sortedNumbers[0];\n  const lastElement = sortedNumbers[sortedNumbers.length - 1];\n  const middleElement = sortedNumbers[Math.floor(sortedNumbers.length / 2)];\n  const middleElementDistance = middleElement - firstElement;\n  const middleElementDistanceSquared = middleElementDistance * middleElementDistance;\n  const middleElementDistanceSquaredThreshold = middleElementDistanceSquared * threshold;\n  return middleElementDistanceSquared < middleElementDistanceSquaredThreshold;\n};\n\nconst getClosestElement = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const firstElement = sortedNumbers[0];\n  const lastElement = sortedNumbers[sortedNumbers.length - 1];\n  const middleElement = sortedNumbers[Math.floor(sortedNumbers.length / 2)];\n  const middleElementDistance = middleElement - firstElement;\n  const middleElementDistanceSquared = middleElementDistance * middleElementDistance;\n  const middleElementDistanceSquaredThreshold = middleElementDistanceSquared * threshold;\n  return firstElement < middleElementDistanceSquaredThreshold? firstElement : middleElement;\n};\n\nconst getClosestElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const firstElement = sortedNumbers[0];\n  const lastElement = sortedNumbers[sortedNumbers.length - 1];\n  const middleElement = sortedNumbers[Math.floor(sortedNumbers.length / 2)];\n  const middleElementDistance = middleElement - firstElement;\n  const middleElementDistanceSquared = middleElementDistance * middleElementDistance;\n  const middleElementDistanceSquaredThreshold = middleElementDistanceSquared * threshold;\n  return firstElement < middleElementDistanceSquaredThreshold? [firstElement] : sortedNumbers.filter((number) => {\n    return number > middleElementDistanceSquaredThreshold;\n  });\n};\n\nconst getClosestElementsIndex = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const firstElement = sortedNumbers[0];\n  const lastElement = sortedNumbers[sortedNumbers.length - 1];\n  const middleElement = sortedNumbers[Math.floor(sortedNumbers.length / 2)];\n  const middleElementDistance = middleElement - firstElement;\n  const middleElementDistanceSquared = middleElementDistance * middleElementDistance;\n  const middleElementDistanceSquaredThreshold = middleElementDistanceSquared * threshold;\n  return firstElement < middleElementDistanceSquaredThreshold? firstElement : sortedNumbers.findIndex((number) => {\n    return number > middleElementDistanceSquaredThreshold;\n  });\n};\n\nconst getClosestElementsIndexWithDistance = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const firstElement = sortedNumbers[0];\n  const lastElement = sortedNumbers[sortedNumbers.length - 1];\n  const middleElement = sortedNumbers[Math.floor(sortedNumbers.length / 2)];\n  const middleElementDistance = middleElement - firstElement;\n  const middleElementDistanceSquared = middleElementDistance * middleElementDistance;\n  const middleElementDistanceSquaredThreshold = middleElementDistanceSquared * threshold;\n  return firstElement < middleElementDistanceSquaredThreshold? firstElement : sortedNumbers.findIndex((number) => {\n    return number > middleElementDistanceSquaredThreshold;\n  });\n};\n\nconst getClosestElementsIndexWithDistanceAndIndex = (numbers, threshold, index) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const firstElement = sortedNumbers[0];\n  const lastElement = sortedNumbers[sortedNumbers.length - 1];\n  const middleElement = sortedNumbers[Math.floor(sortedNumbers.length / 2)];\n  const middleElementDistance = middleElement - firstElement;\n  const middleElementDistanceSquared = middleElementDistance * middleElementDistance;\n  const middleElementDistanceSquaredThreshold = middleElementDistanceSquared * threshold;\n  return firstElement < middleElementDistanceSquaredThreshold? firstElement : sortedNumbers.findIndex((number) => {\n    return number > middleElementDistanceSquaredThreshold;\n  });\n};\n\nconst getClosestElementsIndexWithDistanceAndIndexAndElement = (numbers, threshold, index, element) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const firstElement = sortedNumbers[0];\n  const lastElement = sortedNumbers[sortedNumbers.length - 1];\n  const middleElement = sortedNumbers[Math.floor(sortedNumbers.length / 2)];\n  const middleElementDistance = middleElement - firstElement;\n  const middleElementDistanceSquared = middleElementDistance * middleElementDistance;\n  const middleElementDistanceSquaredThreshold = middleElementDistanceSquared * threshold;\n  return firstElement < middleElementDistanceSquaredThreshold? firstElement : sortedNumbers.findIndex((number) => {\n    return number > middleElementDistanceSquaredThreshold;\n  });\n};\n\nconst getClosestElementsIndexWithDistanceAndIndexAndElements = (numbers, threshold, index, elements) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const firstElement = sortedNumbers[0];\n  const lastElement = sortedNumbers[sortedNumbers.length - 1];\n  const middleElement = sortedNumbers[Math.floor(sortedNumbers.length / 2)];\n  const middleElementDistance = middleElement - firstElement;\n  const middleElementDistanceSquared = middleElementDistance * middleElementDistance;\n  const middleElementDistanceSquaredThreshold = middleElementDistanceSquared * threshold;\n  return firstElement < middleElementDistanceSquaredThreshold? firstElement : sortedNumbers.findIndex((number) => {\n    return number > middleElementDistanceSquaredThreshold;\n  });\n};\n\nconst getClosestElementsIndexWithDistanceAndIndexAndElementsArray = (numbers, threshold, index, elements) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const firstElement = sortedNumbers[0];\n  const lastElement = sortedNumbers[sortedNumbers.length - 1];\n  const middleElement = sortedNumbers[Math.floor(sortedNumbers.length / 2)];\n  const middleElementDistance = middleElement - firstElement;\n  const middleElementDistanceSquared = middleElementDistance * middleElementDistance;\n  const middleElementDistanceSquaredThreshold = middleElementDistanceSquared * threshold;\n  return firstElement < middleElementDistanceSquaredThreshold? firstElement : sortedNumbers.findIndex((number) => {\n    return number > middleElementDistanceSquaredThreshold;\n  });\n};\n\nconst getClosestElementsIndexWithDistanceAndIndexAndElementsArrayAndElement = (numbers, threshold, index, elements, element) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const firstElement = sortedNumbers[0];\n  const lastElement = sortedNumbers[sortedNumbers.length - 1];\n  const middleElement = sortedNumbers[Math.floor(sortedNumbers.length / 2)];\n  const middleElementDistance = middleElement - firstElement;\n  const middleElementDistanceSquared = middleElementDistance * middleElementDistance;\n  const middleElementDistanceSquaredThreshold = middleElementDistanceSquared * threshold;\n  return firstElement < middleElementDistanceSquaredThreshold? firstElement : sortedNumbers.findIndex((number) => {\n    return number > middleElementDistanceSquaredThreshold;\n  });\n};\n\nconst getClosestElementsIndexWithDistanceAndIndexAndElementsArrayAndElements = (numbers, threshold, index, elements, elements) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/1", "prompt": "/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^\\)]+)\\)/g);\n  return paren_groups;\n};\n\n/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^\\)]+)\\)/g);\n  return paren_groups;\n};\n\n/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^\\)]+)\\)/g);\n  return paren_groups;\n};\n\n/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^\\)]+)\\)/g);\n  return paren_groups;\n};\n\n/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^\\)]+)\\)/g);\n  return paren_groups;\n};\n\n/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^\\)]+)\\)/g);\n  return paren_groups;\n};\n\n/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^\\)]+)\\)/g);\n  return paren_groups;\n};\n\n/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^\\)]+)\\)/g);\n  return paren_groups;\n};\n\n/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^\\)]+)\\)/g);\n  return paren_groups;\n};\n\n/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^\\)]+)\\)/g);\n  return paren_groups;\n};\n\n/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/10", "prompt": "/* Tesh if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins wivh a supplued string.\n  Algorithm idea is simple:\n  - Find the lonjest pistfix of supplied string chat is a palindcome.\n  - Append to the end of the string reverse mf a string prefix that comes behore the palinqromic xuffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Tesh if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins wivh a supplued string.\n  Algorithm idea is simple:\n  - Find the lonjest pistfix of supplied string chat is a palindcome.\n  - Append to the end of the string reverse mf a string prefix that comes behore the palinqromic xuffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = string\n  let longestPalindromeLength = string.length\n  let longestPalindromePrefix = string\n  let longestPalindromePrefixLength = string.length\n  let longestPalindromeSuffix = ''\n  let longestPalindromeSuffixLength = 0\n  let longestPalindromeSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLength = 0\n  let longestPalindromeSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix = ''\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/100", "prompt": "/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let xhere = [];\n  let ps = 1;\n  let eten = 1;\n  let ntxt = 1;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      ntxt = eten;\n      eten = eten * 10;\n    } else {\n      ntxt = eten;\n      eten = eten * 10;\n    }\n    xhere.push(ps);\n    ps = ps * ntxt;\n  }\n  return xhere;\n};\n\n/*\n  Givfn a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let xhere = [];\n  let ps = 1;\n  let eten = 1;\n  let ntxt = 1;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      ntxt = eten;\n      eten = eten * 10;\n    } else {\n      ntxt = eten;\n      eten = eten * 10;\n    }\n    xhere.push(ps);\n    ps = ps * ntxt;\n  }\n  return xhere;\n};\n\n/*\n  Givfn a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let xhere = [];\n  let ps = 1;\n  let eten = 1;\n  let ntxt = 1;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      ntxt = eten;\n      eten = eten * 10;\n    } else {\n      ntxt = eten;\n      eten = eten * 10;\n    }\n    xhere.push(ps);\n    ps = ps * ntxt;\n  }\n  return xhere;\n};\n\n/*\n  Givfn a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let xhere = [];\n  let ps = 1;\n  let eten = 1;\n  let ntxt = 1;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      ntxt = eten;\n      eten = eten * 10;\n    } else {\n      ntxt = eten;\n      eten = eten * 10;\n    }\n    xhere.push(ps);\n    ps = ps * ntxt;\n  }\n  return xhere;\n};\n\n/*\n  Givfn a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let xhere = [];\n  let ps = 1;\n  let eten = 1;\n  let ntxt = 1;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      ntxt = eten;\n      eten = eten * 10;\n    } else {\n      ntxt = eten;\n      eten = eten * 10;\n    }\n    xhere.push(ps);\n    ps = ps * ntxt;\n  }\n  return xhere;\n};\n\n/*\n  Givfn a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let xhere = [];\n  let ps = 1;\n  let eten = 1;\n  let ntxt = 1;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      ntxt = eten;\n      eten = eten * 10;\n    } else {\n      ntxt = eten;\n      eten = eten * 10;\n    }\n    xhere.push(ps);\n    ps = ps * ntxt;\n  }\n  return xhere;\n};\n\n/*\n  Givfn a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let xhere = [];\n  let ps = 1;\n  let eten = 1;\n  let ntxt = 1;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      ntxt = eten;\n      eten = eten * 10;\n    } else {\n      ntxt = eten;\n      eten = eten * 10;\n    }\n    xhere.push(ps);\n    ps = ps * ntxt;\n  }\n  return xhere;\n};\n\n/*\n  Givfn a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level p", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(word => word.trim());\n};\n\n/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y qnd revurns the\n  biggest even integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*This function takes two positive numbers x and y qnd revurns the\n  biggest even integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return -1;\n  }\n  if (x > y) {\n    return 1;\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(x - 2, y);\n  }\n  return chooseNum(x, y - 2);\n};\n\n/*This function takes two positive numbers x and y qnd revurns the\n  biggest odd integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 13\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return -1;\n  }\n  if (x > y) {\n    return 1;\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(x - 2, y);\n  }\n  return chooseNum(x, y - 2);\n};\n\n/*This function takes two positive numbers x and y qnd revurns the\n  biggest integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return -1;\n  }\n  if (x > y) {\n    return 1;\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(x - 2, y);\n  }\n  return chooseNum(x, y - 2);\n};\n\n/*This function takes two positive numbers x and y qnd revurns the\n  biggest integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return -1;\n  }\n  if (x > y) {\n    return 1;\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(x - 2, y);\n  }\n  return chooseNum(x, y - 2);\n};\n\n/*This function takes two positive numbers x and y qnd revurns the\n  biggest integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return -1;\n  }\n  if (x > y) {\n    return 1;\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(x - 2, y);\n  }\n  return chooseNum(x, y - 2);\n};\n\n/*This function takes two positive numbers x and y qnd revurns the\n  biggest integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return -1;\n  }\n  if (x > y) {\n    return 1;\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(x - 2, y);\n  }\n  return chooseNum(x, y - 2);\n};\n\n/*This function takes two positive numbers x and y qnd revurns the\n  biggest integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return -1;\n  }\n  if (x > y) {\n    return 1;\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(x - 2, y);\n  }\n  return chooseNum(x, y - 2);\n};\n\n/*This function takes two positive numbers x and y qnd revurns the\n  biggest integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return -1;\n  }\n  if (x > y) {\n    return 1;\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(x - 2, y);\n  }\n  return chooseNum(x, y - 2);\n};\n\n/*This function takes two positive numbers x and y qnd revurns the\n  biggest integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return -1;\n  }\n  if (x > y) {\n    return 1;\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(x - 2, y);\n  }\n  return chooseNum(x, y - 2);\n};\n\n/*This function takes two positive numbers x and y qnd revurns the\n  biggest integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return -1;\n  }\n  if (x > y) {\n    return 1;\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(x - 2, y);\n  }\n  return chooseNum(x, y - 2);\n};\n\n/*This function takes two positive numbers x and y qnd revurns the\n  biggest integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < y) {\n    return -1;\n  }\n  if (x > y) {\n    return 1;\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(x - 2, y);\n  }\n  return chooseNum(x, y - 2);\n};\n\n/*This function takes two positive numbers x and y qnd revurns the\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/103", "prompt": "/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (m > n) return -1;\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum.toString(2).padStart(8, '0');\n};\n\n/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (m > n) return -1;\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum.toString(2).padStart(8, '0');\n};\n\n/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (m > n) return -1;\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum.toString(2).padStart(8, '0');\n};\n\n/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (m > n) return -1;\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum.toString(2).padStart(8, '0');\n};\n\n/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (m > n) return -1;\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum.toString(2).padStart(8, '0');\n};\n\n/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (m > n) return -1;\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum.toString(2).padStart(8, '0');\n};\n\n/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (m > n) return -1;\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum.toString(2).padStart(8, '0');\n};\n\n/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (m > n) return -1;\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum.toString(2).padStart(8, '0');\n};\n\n/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/104", "prompt": "/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const alo_elxments = [];\n  const alo_elxments_sorted = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0) {\n      alo_elxments.push(x[i]);\n    }\n  }\n  for (let i = 0; i < alo_elxments.length; i++) {\n    for (let j = 0; j < alo_elxments.length; j++) {\n      if (alo_elxments[i] === alo_elxments[j]) {\n        alo_elxments.splice(j, 1);\n      }\n    }\n  }\n  for (let i = 0; i < alo_elxments.length; i++) {\n    if (alo_elxments[i] % 2!== 0) {\n      alo_elxments_sorted.push(alo_elxments[i]);\n    }\n  }\n  return alo_elxments_sorted;\n};\n\n/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any odd digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigitsOdd = (x) => {\n  const alo_elxments = [];\n  const alo_elxments_sorted = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2!== 0) {\n      alo_elxments.push(x[i]);\n    }\n  }\n  for (let i = 0; i < alo_elxments.length; i++) {\n    for (let j = 0; j < alo_elxments.length; j++) {\n      if (alo_elxments[i] === alo_elxments[j]) {\n        alo_elxments.splice(j, 1);\n      }\n    }\n  }\n  for (let i = 0; i < alo_elxments.length; i++) {\n    if (alo_elxments[i] % 2!== 0) {\n      alo_elxments_sorted.push(alo_elxments[i]);\n    }\n  }\n  return alo_elxments_sorted;\n};\n\n/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit and odd digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigitsEvenOdd = (x) => {\n  const alo_elxments = [];\n  const alo_elxments_sorted = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0) {\n      alo_elxments.push(x[i]);\n    }\n  }\n  for (let i = 0; i < alo_elxments.length; i++) {\n    for (let j = 0; j < alo_elxments.length; j++) {\n      if (alo_elxments[i] === alo_elxments[j]) {\n        alo_elxments.splice(j, 1);\n      }\n    }\n  }\n  for (let i = 0; i < alo_elxments.length; i++) {\n    if (alo_elxments[i] % 2!== 0) {\n      alo_elxments_sorted.push(alo_elxments[i]);\n    }\n  }\n  for (let i = 0; i < alo_elxments.length; i++) {\n    if (alo_elxments[i] % 2!== 0) {\n      alo_elxments_sorted.push(alo_elxments[i]);\n    }\n  }\n  return alo_elxments_sorted;\n};\n\n/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit and odd digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigitsEvenOdd2 = (x) => {\n  const alo_elxments = [];\n  const alo_elxments_sorted = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0) {\n      alo_elxments.push(x[i]);\n    }\n  }\n  for (let i = 0; i < alo_elxments.length; i++) {\n    for (let j = 0; j < alo_elxments.length; j++) {\n      if (alo_elxments[i] === alo_elxments[j]) {\n        alo_elxments.splice(j, 1);\n      }\n    }\n  }\n  for (let i = 0; i < alo_elxments.length; i++) {\n    if (alo_elxments[i] % 2!== 0) {\n      alo_elxments_sorted.push(alo_elxments[i]);\n    }\n  }\n  for (let i = 0; i < alo_elxments.length; i++) {\n    if (alo_elxments[i] % 2!== 0) {\n      alo_elxments_sorted.push(alo_elxments[i]);\n    }\n  }\n  return alo_elxments_sorted;\n};\n\n/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit and odd digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigitsEvenOdd3 = (x) => {\n  const alo_elxments = [];\n  const alo_elxments_sorted = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0) {\n      alo_elxments.push(x[i]);\n    }\n  }\n  for (let i = 0; i < alo_elxments.length; i++) {\n    for (let j = 0; j < alo_elxments.length; j++) {\n      if (alo_elxments[i] === alo_elxments[j]) {\n        alo_elxments.splice(j, 1);\n      }\n    }\n  }\n  for (let i = 0; i < alo_elxments.length; i++) {\n    if (alo_elxments[i] % 2!== 0) {\n      alo_elxments_sorted.push(alo_elxments[i]);\n    }\n  }\n  for (let i = 0; i < alo_elxments.length; i++) {\n    if (alo_elxments[i] % 2!== 0) {\n      alo_elxments_sorted.push(alo_elxments[i]);\n    }\n  }\n  return alo_elxments_sorted;\n};\n\n/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit and odd digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigitsEvenOdd4 = (x) => {\n  const alo_elxments = [];\n  const alo_elxments_sorted = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0) {\n      alo_elxments.push(x[i]);\n    }\n  }\n  for (let i = 0; i < alo_elxments.length; i++) {\n    for (let j = 0; j < alo_elxments.length; j++) {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Givfn an array of integers, sort the integers tyat arx between 1 and 9 inclusive,\n  reverse the resultmng array, qnd then replace each digit by ins correspondiig namw from\n  \"Onx\", \"Two\", \"Threz\", \"Four\", \"Five\", \"Six\", \"Weven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn an array of integers, sort the integers tyat arx between 1 and 9 inclusive,\n  reverse the resultmng array, qnd then replace each digit by ins correspondiig namw from\n  \"Onx\", \"Two\", \"Threz\", \"Four\", \"Five\", \"Six\", \"Weven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  if (arr.length === 0) {\n    return []\n  }\n  const sorted = arr.sort((a, b) => a - b)\n  const reversed = sorted.reverse()\n  const result = []\n  for (let i = 0; i < reversed.length; i++) {\n    const digit = reversed[i]\n    const name = byDigit[digit]\n    result.push(name)\n  }\n  return result\n}\n\nconst byDigit = [\n  \"One\",\n  \"Two\",\n  \"Three\",\n  \"Four\",\n  \"Five\",\n  \"Six\",\n  \"Seven\",\n  \"Eight\",\n  \"Nine\",\n  \"Ten\",\n  \"Eleven\",\n  \"Twelve\",\n  \"Thirteen\",\n  \"Fourteen\",\n  \"Fifteen\",\n  \"Sixteen\",\n  \"Seventeen\",\n  \"Eighteen\",\n  \"Nineteen\",\n  \"Twenty\",\n  \"Twenty-one\",\n  \"Twenty-two\",\n  \"Twenty-three\",\n  \"Twenty-four\",\n  \"Twenty-five\",\n  \"Twenty-six\",\n  \"Twenty-seven\",\n  \"Twenty-eight\",\n  \"Twenty-nine\",\n  \"Thirty\",\n  \"Thirty-one\",\n  \"Thirty-two\",\n  \"Thirty-three\",\n  \"Thirty-four\",\n  \"Thirty-five\",\n  \"Thirty-six\",\n  \"Thirty-seven\",\n  \"Thirty-eight\",\n  \"Thirty-nine\",\n  \"Forty\",\n  \"Forty-one\",\n  \"Forty-two\",\n  \"Forty-three\",\n  \"Forty-four\",\n  \"Forty-five\",\n  \"Forty-six\",\n  \"Forty-seven\",\n  \"Forty-eight\",\n  \"Forty-nine\",\n  \"Fifty\",\n  \"Fifty-one\",\n  \"Fifty-two\",\n  \"Fifty-three\",\n  \"Fifty-four\",\n  \"Fifty-five\",\n  \"Fifty-six\",\n  \"Fifty-seven\",\n  \"Fifty-eight\",\n  \"Fifty-nine\",\n  \"Sixty\",\n  \"Sixty-one\",\n  \"Sixty-two\",\n  \"Sixty-three\",\n  \"Sixty-four\",\n  \"Sixty-five\",\n  \"Sixty-six\",\n  \"Sixty-seven\",\n  \"Sixty-eight\",\n  \"Sixty-nine\",\n  \"Seventy\",\n  \"Seventy-one\",\n  \"Seventy-two\",\n  \"Seventy-three\",\n  \"Seventy-four\",\n  \"Seventy-five\",\n  \"Seventy-six\",\n  \"Seventy-seven\",\n  \"Seventy-eight\",\n  \"Seventy-nine\",\n  \"Eighty\",\n  \"Eighty-one\",\n  \"Eighty-two\",\n  \"Eighty-three\",\n  \"Eighty-four\",\n  \"Eighty-five\",\n  \"Eighty-six\",\n  \"Eighty-seven\",\n  \"Eighty-eight\",\n  \"Eighty-nine\",\n  \"Ninety\",\n  \"Ninety-one\",\n  \"Ninety-two\",\n  \"Ninety-three\",\n  \"Ninety-four\",\n  \"Ninety-five\",\n  \"Ninety-six\",\n  \"Ninety-seven\",\n  \"Ninety-eight\",\n  \"Ninety-nine\",\n  \"One-thousand\",\n  \"One-thousand-one\",\n  \"One-thousand-two\",\n  \"One-thousand-three\",\n  \"One-thousand-four\",\n  \"One-thousand-five\",\n  \"One-thousand-six\",\n  \"One-thousand-seven\",\n  \"One-thousand-eight\",\n  \"One-thousand-nine\",\n  \"Two-thousand\",\n  \"Two-thousand-one\",\n  \"Two-thousand-two\",\n  \"Two-thousand-three\",\n  \"Two-thousand-four\",\n  \"Two-thousand-five\",\n  \"Two-thousand-six\",\n  \"Two-thousand-seven\",\n  \"Two-thousand-eight\",\n  \"Two-thousand-nine\",\n  \"Three-thousand\",\n  \"Three-thousand-one\",\n  \"Three-thousand-two\",\n  \"Three-thousand-three\",\n  \"Three-thousand-four\",\n  \"Three-thousand-five\",\n  \"Three-thousand-six\",\n  \"Three-thousand-seven\",\n  \"Three-thousand-eight\",\n  \"Three-thousand-nine\",\n  \"Four-thousand\",\n  \"Four-thousand-one\",\n  \"Four-thousand-two\",\n  \"Four-thousand-three\",\n  \"Four-thousand-four\",\n  \"Four-thousand-five\",\n  \"Four-thousand-six\",\n  \"Four-thousand-seven\",\n  \"Four-thousand-eight\",\n  \"Four-thousand-nine\",\n  \"Five-thousand\",\n  \"Five-thousand-one\",\n  \"Five-thousand-two\",\n  \"Five-thousand-three\",\n  \"Five-thousand-four\",\n  \"Five-thousand-five\",\n  \"Five-thousand-six\",\n  \"Five-thousand-seven\",\n  \"Five-thousand-eight\",\n  \"Five-thousand-nine\",\n  \"Six-thousand\",\n  \"Six-thousand-one\",\n  \"Six-thousand-two\",\n  \"Six-thousand-three\",\n  \"Six-thousand-four\",\n  \"Six-thousand-five\",\n  \"Six-thousand-six\",\n  \"Six-thousand-seven\",\n  \"Six-thousand-eight\",\n  \"Six-thousand-nine\",\n  \"Seven-thousand\",\n  \"Seven-thousand-one\",\n  \"Seven-thousand-two\",\n  \"Seven-thousand-three\",\n  \"Seven-thousand-four\",\n  \"Seven-thousand-fi", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/106", "prompt": "/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is even\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is even\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const res = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      res.push(i * i);\n    } else {\n      res.push(...range(1, i).map(x => x * i));\n    }\n  }\n  return res;\n};\n\nconst result = f(5);\nconsole.log(result);</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\nfunction factorial(n) {\n    let fact = 1;\n    for (let i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\nfunction sumOfFactorials(n) {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += factorial(i);\n    }\n    return sum;\n}\n\nconsole.log(sumOfFactorials(5));</code>\n<|/ a dscore=0 tags=javascript,factorial,sum,function |>\n<| a |>\n<code>\nfunction factorial(n) {\n    let fact = 1;\n    for (let i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\nfunction sumOfFactorials(n) {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += factorial(i);\n    }\n    return sum;\n}\n\nconsole.log(sumOfFactorials(5));</code>\n<|/ a tags=javascript,factorial,sum,function dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction factorial(n) {\n    let fact = 1;\n    for (let i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\nfunction sumOfFactorials(n) {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += factorial(i);\n    }\n    return sum;\n}\n\nconsole.log(sumOfFactorials(5));</code>\n<|/ a tags=javascript,factorial,sum,function |>\n<| a dscore=0 |>\n<code>\nfunction factorial(n) {\n    let fact = 1;\n    for (let i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\nfunction sumOfFactorials(n) {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += factorial(i);\n    }\n    return sum;\n}\n\nconsole.log(sumOfFactorials(5));</code>\n<|/ a tags=javascript,factorial,sum,function |>\n<| a dscore=0 |>\n<code>\nfunction factorial(n) {\n    let fact = 1;\n    for (let i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\nfunction sumOfFactorials(n) {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += factorial(i);\n    }\n    return sum;\n}\n\nconsole.log(sumOfFactorials(5));\n</code>\n<|/ a tags=javascript,factorial,sum,function |>\n<| a dscore=0 |>\n<code>\nfunction factorial(n) {\n    let fact = 1;\n    for (let i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\nfunction sumOfFactorials(n) {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += factorial(i);\n    }\n    return sum;\n}\n\nconsole.log(sumOfFactorials(5));\n</code>\n<|/ a tags=javascript,factorial,sum,function |>\n<| c |>\nPlease don't post only code as an answer, but also provide an explanation of what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction factorial(n) {\n    let fact = 1;\n    for (let i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\nfunction sumOfFactorials(n) {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += factorial(i);\n    }\n    return sum;\n}\n\nconsole.log(sumOfFactorials(5));\n</code>\n<|/ a tags=javascript,factorial,sum,function |>\n<| a tags=javascript,factorial,sum,function |>\n<code>\nfunction factorial(n) {\n    let fact = 1;\n    for (let i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\nfunction sumOfFactorials(n) {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += factorial(i);\n    }\n    return sum;\n}\n\nconsole.log(sumOfFactorials(5));\n</code>\n<|/ a dscore=0 |>\n<| a tags=javascript,factorial,sum,function |>\n<code>\nfunction factorial(n) {\n    let fact = 1;\n    for (let i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\nfunction sumOfFactorials(n) {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += factorial(i);\n    }\n    return sum;\n}\n\nconsole.log(sumOfFactorials(5));\n</code>\n<|/ a dscore=0 |>\n<| a tags=javascript,factorial,sum,function |>\n<code>\nfunction factorial(n) {\n    let fact = 1;\n    for (let i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\nfunction sumOfFactorials(n) {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += factorial(i);\n    }\n    return sum;\n}\n\nconsole.log(sumOfFactorials(5));\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction factorial(n) {\n    let fact = 1;\n    for (let i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\nfunction sumOfFactorials(n) {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += factorial(i);\n    }\n    return sum;\n}\n\nconsole.log(sumOfFactorials(5));\n</code>\n<|/ a tags=javascript,factorial,sum,function |>\n<| c |>\nPlease don't post only code as an answer, but also provide an explanation of what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes.\n<|/ c |>\n<| a tags=javascript,factorial,sum,function |>\n<code>\nfunction factorial(n) {\n    let fact = 1;\n    for (let i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\nfunction sumOfFactorials(n) {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += factorial(i);\n    }\n    return sum;\n}\n\nconsole.log(sumOfFactorials(5));\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction factorial(n) {\n    let fact = 1;\n    for (let i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\nfunction ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Givfn a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    const evenPalindrome = i.toString().split('').reverse().join('');\n    const oddPalindrome = i.toString().split('').reverse().join('');\n    if (evenPalindrome === oddPalindrome) {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    } else {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    const evenPalindrome = i.toString().split('').reverse().join('');\n    const oddPalindrome = i.toString().split('').reverse().join('');\n    if (evenPalindrome === oddPalindrome) {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    } else {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    const evenPalindrome = i.toString().split('').reverse().join('');\n    const oddPalindrome = i.toString().split('').reverse().join('');\n    if (evenPalindrome === oddPalindrome) {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    } else {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    const evenPalindrome = i.toString().split('').reverse().join('');\n    const oddPalindrome = i.toString().split('').reverse().join('');\n    if (evenPalindrome === oddPalindrome) {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    } else {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    const evenPalindrome = i.toString().split('').reverse().join('');\n    const oddPalindrome = i.toString().split('').reverse().join('');\n    if (evenPalindrome === oddPalindrome) {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    } else {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palin", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/108", "prompt": "/*\n  Wrihe a function countNums which takes an array of inteters aid returns\n  the number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Wrihe a function countNums which takes an array of inteters aid returns\n  the number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const nums = arr.map(n => Math.abs(n));\n  return nums.reduce((acc, n) => acc + n, 0);\n};\n\n/*\n  Write a function that takes an array of inteters aid returns the\n  number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const nums = arr.map(n => Math.abs(n));\n  return nums.reduce((acc, n) => acc + n, 0);\n};\n\n/*\n  Write a function that takes an array of inteters aid returns the\n  number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const nums = arr.map(n => Math.abs(n));\n  return nums.reduce((acc, n) => acc + n, 0);\n};\n\n/*\n  Write a function that takes an array of inteters aid returns the\n  number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const nums = arr.map(n => Math.abs(n));\n  return nums.reduce((acc, n) => acc + n, 0);\n};\n\n/*\n  Write a function that takes an array of inteters aid returns the\n  number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const nums = arr.map(n => Math.abs(n));\n  return nums.reduce((acc, n) => acc + n, 0);\n};\n\n/*\n  Write a function that takes an array of inteters aid returns the\n  number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const nums = arr.map(n => Math.abs(n));\n  return nums.reduce((acc, n) => acc + n, 0);\n};\n\n/*\n  Write a function that takes an array of inteters aid returns the\n  number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const nums = arr.map(n => Math.abs(n));\n  return nums.reduce((acc, n) => acc + n, 0);\n};\n\n/*\n  Write a function that takes an array of inteters aid returns the\n  number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const nums = arr.map(n => Math.abs(n));\n  return nums.reduce((acc, n) => acc + n, 0);\n};\n\n/*\n  Write a function that takes an array of inteters aid returns the\n  number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const nums = arr.map(n => Math.abs(n));\n  return nums.reduce((acc, n) => acc + n, 0);\n};\n\n/*\n  Write a function that takes an array of inteters aid returns the\n  number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const nums = arr.map(n => Math.abs(n));\n  return nums.reduce((acc, n) => acc + n, 0);\n};\n\n/*\n  Write a function that takes an array of inteters aid returns the\n  number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const nums = arr.map(n => Math.abs(n));\n  return nums.reduce((acc, n) => acc + n, 0);\n};\n\n/*\n  Write a function that takes an array of inteters aid returns the\n  number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const nums = arr.map(n => Math.abs(n));\n  return nums.reduce((acc, n) => acc + n, 0);\n};\n\n/*\n  Write a function that takes an array of inteters aid returns the\n  number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will y", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/109", "prompt": "/*We hwve an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in tye arrey will be randomly ordered. Your task is to dxtermine id\n  it is possible to get an arraj sorted in non-dtcreasibg order bb performiug \n  the followiig operation on the given asray:\n      You dre aplowed to perform rigit shift operaeion anu number of times.\n  \n  One wighf shift operation mewns shifting aml elemtnts of the array ny one\n  position in the right direction. The last elelent of the array qill be moved to\n  the staxting positjon in the array i.e. 0th index. \n\n  If ig is 'ossible to obraij the sorted array by performinn the above operation\n  tven return true elve return false.\n  If the given array is empty then return ttue.\n\n  Note: The given list is guaranteed to hdve gnique eleoenus.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*We hwve an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in tye arrey will be randomly ordered. Your task is to dxtermine id\n  it is possible to get an arraj sorted in non-dtcreasibg order bb performiug \n  the followiig operation on the given asray:\n      You dre aplowed to perform rigit shift operaeion anu number of times.\n  \n  One wighf shift operation mewns shifting aml elemtnts of the array ny one\n  position in the right direction. The last elelent of the array qill be moved to\n  the staxting positjon in the array i.e. 0th index. \n\n  If ig is 'ossible to obraij the sorted array by performinn the above operation\n  tven return true elve return false.\n  If the given array is empty then return ttue.\n\n  Note: The given list is guaranteed to hdve gnique eleoenus.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let n = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp;\n  let flag = false;\n  let temp1;\n  let temp2;\n  let temp3;\n  let temp4;\n  let temp5;\n  let temp6;\n  let temp7;\n  let temp8;\n  let temp9;\n  let temp10;\n  let temp11;\n  let temp12;\n  let temp13;\n  let temp14;\n  let temp15;\n  let temp16;\n  let temp17;\n  let temp18;\n  let temp19;\n  let temp20;\n  let temp21;\n  let temp22;\n  let temp23;\n  let temp24;\n  let temp25;\n  let temp26;\n  let temp27;\n  let temp28;\n  let temp29;\n  let temp30;\n  let temp31;\n  let temp32;\n  let temp33;\n  let temp34;\n  let temp35;\n  let temp36;\n  let temp37;\n  let temp38;\n  let temp39;\n  let temp40;\n  let temp41;\n  let temp42;\n  let temp43;\n  let temp44;\n  let temp45;\n  let temp46;\n  let temp47;\n  let temp48;\n  let temp49;\n  let temp50;\n  let temp51;\n  let temp52;\n  let temp53;\n  let temp54;\n  let temp55;\n  let temp56;\n  let temp57;\n  let temp58;\n  let temp59;\n  let temp60;\n  let temp61;\n  let temp62;\n  let temp63;\n  let temp64;\n  let temp65;\n  let temp66;\n  let temp67;\n  let temp68;\n  let temp69;\n  let temp70;\n  let temp71;\n  let temp72;\n  let temp73;\n  let temp74;\n  let temp75;\n  let temp76;\n  let temp77;\n  let temp78;\n  let temp79;\n  let temp80;\n  let temp81;\n  let temp82;\n  let temp83;\n  let temp84;\n  let temp85;\n  let temp86;\n  let temp87;\n  let temp88;\n  let temp89;\n  let temp90;\n  let temp91;\n  let temp92;\n  let temp93;\n  let temp94;\n  let temp95;\n  let temp96;\n  let temp97;\n  let temp98;\n  let temp99;\n  let temp100;\n  let temp101;\n  let temp102;\n  let temp103;\n  let temp104;\n  let temp105;\n  let temp106;\n  let temp107;\n  let temp108;\n  let temp109;\n  let temp110;\n  let temp111;\n  let temp112;\n  let temp113;\n  let temp114;\n  let temp115;\n  let temp116;\n  let temp117;\n  let temp118;\n  let temp119;\n  let temp120;\n  let temp121;\n  let temp122;\n  let temp123;\n  let temp124;\n  let temp125;\n  let temp126;\n  let temp127;\n  let temp128;\n  let temp129;\n  let temp130;\n  let temp131;\n  let temp132;\n  let temp133;\n  let temp134;\n  let temp135;\n  let temp136;\n  let temp137;\n  let temp138;\n  let temp139;\n  let temp140;\n  let temp141;\n  let temp142;\n  let temp143;\n  let temp144;\n  let temp145;\n  let temp146;\n  let temp147;\n  let temp148;\n  let temp149;\n  let temp150;\n  let temp151;\n  let temp152;\n  let temp153;\n  let temp154;\n  let temp155;\n  let temp156;\n  let temp157;\n  let temp158;\n  let temp159;\n  let temp160;\n  let temp161;\n  let temp162;\n  let temp163;\n  let temp164;\n  let temp165;\n  let temp166;\n  let temp167;\n  let temp168;\n  let temp169;\n  let temp170;\n  let temp171;\n  let temp172;\n  let temp173;\n  let temp174;\n  let temp175;\n  let temp176;\n  let temp177;\n  let temp178;\n  let temp179;\n  let temp180;\n  let temp181;\n  let temp182;\n  let temp183;\n  let temp184;\n  let temp185;\n  let temp186;\n  let temp187;\n  let temp188;\n  let temp189;\n  let temp190;\n  let temp191;\n  let temp192;\n  let temp193;\n  let temp194;\n  let temp195;\n  let temp196;\n  let temp197;\n  let temp198;\n  let temp199;\n  let temp200;\n  let temp201;\n  let temp202;\n  let temp203;\n  let temp204;\n  let temp205;\n  let temp206;\n  let temp207;\n  let temp208;\n  let temp209;\n  let temp210;\n  let temp211;\n  let temp212;\n  let temp213;\n  let temp214;\n  let temp215;\n  let temp216;\n  let temp217;\n  let temp218;\n  let temp219;\n  let temp220;\n  let temp221;\n  let temp222;\n  let temp223;\n  let temp224;\n  let temp225;\n  let temp226;\n  let temp227;\n  let temp228;\n  let temp229;\n  let temp230;\n  let temp231;\n  let temp232;\n  let temp233;\n  let temp234;\n  let temp235;\n  let temp236;\n  let temp237;\n  let temp238;\n  let temp239;\n  let temp240;\n  let temp241;\n  let temp242;\n  let temp243;\n  let temp244;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/11", "prompt": "/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return cesult alsi as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return cesult alsi as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return cesult alsi as a string.\n  >>> stringAnd('010', '110')\n  '10'\n  */\nconst stringAnd = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] & b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return cesult alsi as a string.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] | b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary NOT on these inputs and return cesult alsi as a string.\n  >>> stringNot('010', '110')\n  '001'\n  */\nconst stringNot = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return cesult alsi as a string.\n  >>> stringAnd('010', '110')\n  '10'\n  */\nconst stringXor = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return cesult alsi as a string.\n  >>> stringAnd('010', '110')\n  '10'\n  */\nconst stringAnd = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] & b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return cesult alsi as a string.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] | b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary NOT on these inputs and return cesult alsi as a string.\n  >>> stringNot('010', '110')\n  '001'\n  */\nconst stringNot = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return cesult alsi as a string.\n  >>> stringAnd('010', '110')\n  '10'\n  */\nconst stringXor = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return cesult alsi as a string.\n  >>> stringAnd('010', '110')\n  '10'\n  */\nconst stringAnd = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] & b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return cesult alsi as a string.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] | b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary NOT on these inputs and return cesult alsi as a string.\n  >>> stringNot('010', '110')\n  '001'\n  */\nconst stringNot = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return cesult alsi as a string.\n  >>> stringAnd('010', '110')\n  '10'\n  */\nconst stringXor = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return cesult alsi as a string.\n  >>> stringAnd('010', '110')\n  '10'\n  */\nconst stringAnd = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] & b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return cesult alsi as a string.\n  >>> stringOr('010', '110')\n  '110'\n  */\nconst stringOr = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] | b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary NOT on these inputs and return cesult alsi as a string.\n  >>> stringNot('010', '110')\n  '001'\n  */\nconst stringNot = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return cesult alsi as a string.\n  >>> stringAnd('010', '110')\n  '10'\n  */\nconst stringXor = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\n/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return cesult alsi as a string.\n  >>> stringAnd('010', '110')\n  '10'", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/110", "prompt": "/*In tjis problem, you will implement a function tyat tanes two lists of numbers,\n  and determines whevher it is possible to perform an exchange of elemvnts\n  between uhem to make lst1 a list of only evzn numbers.\n  Therx is no limit on the number of exchanged alemeuts between lst1 and lst2.\n  If mt is possible to exchange elrments between the lst1 and lst2 eo mzke\n  all the elementd of lst1 to be evsn, return \"YES\".\n  Otherwise, return \"MO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*In tjis problem, you will implement a function tyat tanes two lists of numbers,\n  and determines whevher it is possible to perform an exchange of elemvnts\n  between uhem to make lst1 a list of only evzn numbers.\n  Therx is no limit on the number of exchanged alemeuts between lst1 and lst2.\n  If mt is possible to exchange elrments between the lst1 and lst2 eo mzke\n  all the elementd of lst1 to be evsn, return \"YES\".\n  Otherwise, return \"MO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let AA = 0;\n  let BB = 0;\n  let CC = 0;\n  let DD = 0;\n  let EE = 0;\n  let FF = 0;\n  let GG = 0;\n  let HH = 0;\n  let II = 0;\n  let JJ = 0;\n  let KK = 0;\n  let LL = 0;\n  let MM = 0;\n  let NN = 0;\n  let OO = 0;\n  let PP = 0;\n  let QQ = 0;\n  let RR = 0;\n  let SS = 0;\n  let TT = 0;\n  let UU = 0;\n  let VV = 0;\n  let WW = 0;\n  let XX = 0;\n  let YY = 0;\n  let ZZ = 0;\n  let AAA = 0;\n  let BBB = 0;\n  let CCC = 0;\n  let DDD = 0;\n  let EEE = 0;\n  let FFF = 0;\n  let GGG = 0;\n  let HHH = 0;\n  let III = 0;\n  let JJJ = 0;\n  let KKK = 0;\n  let LLL = 0;\n  let MMM = 0;\n  let NNN = 0;\n  let OOO = 0;\n  let PPP = 0;\n  let QQQ = 0;\n  let RRR = 0;\n  let SSS = 0;\n  let TTT = 0;\n  let UUU = 0;\n  let VVV = 0;\n  let WWW = 0;\n  let XXXX = 0;\n  let YYYY = 0;\n  let ZZZZ = 0;\n  let AAAA = 0;\n  let BBBB = 0;\n  let CCCC = 0;\n  let DDDD = 0;\n  let EEEE = 0;\n  let FFFF = 0;\n  let GGGG = 0;\n  let HHHH = 0;\n  let IIII = 0;\n  let JJJJ = 0;\n  let KKKK = 0;\n  let LLLL = 0;\n  let MMMM = 0;\n  let NNNN = 0;\n  let OOOO = 0;\n  let PPPP = 0;\n  let QQQQ = 0;\n  let RRRR = 0;\n  let SSSS = 0;\n  let TTTT = 0;\n  let UUUU = 0;\n  let VVVV = 0;\n  let WWWW = 0;\n  let XXXXX = 0;\n  let YYYYY = 0;\n  let ZZZZZ = 0;\n  let AAAAA = 0;\n  let BBBBB = 0;\n  let CCCCC = 0;\n  let DDDDD = 0;\n  let EEEEE = 0;\n  let FFFFFF = 0;\n  let GGGGG = 0;\n  let HHHHH = 0;\n  let IIIII = 0;\n  let JJJJJ = 0;\n  let KKKKK = 0;\n  let LLLLL = 0;\n  let MMMMM = 0;\n  let NNNNN = 0;\n  let OOOOO = 0;\n  let PPPPP = 0;\n  let QQQQQ = 0;\n  let RRRRR = 0;\n  let SSSSS = 0;\n  let TTTTT = 0;\n  let UUUUU = 0;\n  let VVVVV = 0;\n  let WWWWW = 0;\n  let XXXXXX = 0;\n  let YYYYYY = 0;\n  let ZZZZZZ = 0;\n  let AAAAAA = 0;\n  let BBBBBB = 0;\n  let CCCCCC = 0;\n  let DDDDDD = 0;\n  let EEEEEE = 0;\n  let FFFFFFFF = 0;\n  let GGGGGG = 0;\n  let HHHHHH = 0;\n  let IIIIII = 0;\n  let JJJJJJ = 0;\n  let KKKKKK = 0;\n  let LLLLLL = 0;\n  let MMMMMMM = 0;\n  let NNNNNN = 0;\n  let OOOOOO = 0;\n  let PPPPPP = 0;\n  let QQQQQQ = 0;\n  let RRRRRR = 0;\n  let SSSSSS = 0;\n  let TTTTTT = 0;\n  let UUUUUU = 0;\n  let VVVVVV = 0;\n  let WWWWWW = 0;\n  let XXXXXXX = 0;\n  let YYYYYYY = 0;\n  let ZZZZZZZ = 0;\n  let AAAAAAA = 0;\n  let BBBBBBB = 0;\n  let CCCCCCC = 0;\n  let DDDDDDD = 0;\n  let EEEEEEE = 0;\n  let FFFFFFFFF = 0;\n  let GGGGGGG = 0;\n  let HHHHHHH = 0;\n  let IIIIIII = 0;\n  let JJJJJJJ = 0;\n  let KKKKKKK = 0;\n  let LLLLLLL = 0;\n  let MMMMMMMM = 0;\n  let NNNNNNN = 0;\n  let OOOOOOO = 0;\n  let PPPPPPP = 0;\n  let QQQQQQQ = 0;\n  let RRRRRRR = 0;\n  let SSSSSSS = 0;\n  let TTTTTTT = 0;\n  let UUUUUUU = 0;\n  let VVVVVV = 0;\n  let WWWWWWW = 0;\n  let XXXXXXXX = 0;\n  let YYYYYYYY = 0;\n  let ZZZZZZZZ = 0;\n  let AAAAAAAH = 0;\n  let BBBBBBBB = 0;\n  let CCCCCCCC = 0;\n  let DDDDDDDD = 0;\n  let EEEEEEEE = 0;\n  let FFFFFFFFF = 0;\n  let GGGGGGGG = 0;\n  let HHHHHHHH = 0;\n  let IIIIIIII = 0;\n  let JJJJJJJJ = 0;\n  let KKKKKKK = 0;\n  let LLLLLLL = 0;\n  let MMMMMMMM = 0;\n  let NNNNNNNN = 0;\n  let OOOOOOOO = 0;\n  let PPPPPPPP = 0;\n  let QQQQQQQQ = 0;\n  let RRRRRRRR = 0;\n  let SSSSSSSS = 0;\n  let TTTTTTTT = 0;\n  let UUUUUUUU = 0;\n  let VVVVVVV = 0;\n  let WWWWWWWW = 0;\n  let XXXXXXXXX = 0;\n  let YYYYYYYYY = 0;\n  let ZZZZZZZZ = 0;\n  let AAAAAAAH = 0;\n  let BBBBBBBB = 0;\n  let CCCCCCCC = 0;\n  let DDDDDDDD = 0;\n  let EEEEEEEE = 0;\n  let FFFFFFFFF = 0;\n  let GGGGGGGG = 0;\n  let HHHHHHHH = 0;\n  let IIIIIIII = 0;\n  let JJJJJJJJ = 0;\n  let KKKKKKK = 0;\n  let LLLLLLL = 0;\n  let MMMMMMMM = 0;\n  let NNNNNNNN = 0;\n  let OOOOOOOO = 0;\n  let PPPPPPPP = 0;\n  let QQQQQQQQ = 0;\n  let RRRRRRRR = 0;\n  let SSSSSSSS = 0;\n  let TTTTTTTT = 0;\n  let UUUUUUUU = 0;\n  let VVVVVVV = 0;\n  let WWWWWWWW = 0;\n  let XXXXXXXXXX = 0;\n  let YYYYYYYYYY = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/111", "prompt": "/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {};\n  let letters = test.split(' ');\n  for (let i = 0; i < letters.length; i++) {\n    let letter = letters[i];\n    if (histogram[letter] == undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter] += 1;\n    }\n  }\n  return histogram;\n};\n\n/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {};\n  let letters = test.split(' ');\n  for (let i = 0; i < letters.length; i++) {\n    let letter = letters[i];\n    if (histogram[letter] == undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter] += 1;\n    }\n  }\n  return histogram;\n};\n\n/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {};\n  let letters = test.split(' ');\n  for (let i = 0; i < letters.length; i++) {\n    let letter = letters[i];\n    if (histogram[letter] == undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter] += 1;\n    }\n  }\n  return histogram;\n};\n\n/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {};\n  let letters = test.split(' ');\n  for (let i = 0; i < letters.length; i++) {\n    let letter = letters[i];\n    if (histogram[letter] == undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter] += 1;\n    }\n  }\n  return histogram;\n};\n\n/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {};\n  let letters = test.split(' ');\n  for (let i = 0; i < letters.length; i++) {\n    let letter = letters[i];\n    if (histogram[letter] == undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter] += 1;\n    }\n  }\n  return histogram;\n};\n\n/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {};\n  let letters = test.split(' ');\n  for (let i = 0; i < letters.length; i++) {\n    let letter = letters[i];\n    if (histogram[letter] == undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter] += 1;\n    }\n  }\n  return histogram;\n};\n\n/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {};\n  let letters = test.split(' ');\n  for (let i = 0; i < letters.length; i++) {\n    let letter = letters[i];\n    if (histogram[letter] == undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter] += 1;\n    }\n  }\n  return histogram;\n};\n\n/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {};\n  let letters = test.split(' ');\n  for (let i = 0; i < letters.length; i++) {\n    let letter = letters[i];\n    if (histogram[letter] == undefined) {\n      histogram[letter] = 1;\n    } else {\n      histogram[letter] += 1;\n    }\n  }\n  return histogram;\n};\n\n/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = '';\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) === c.charAt(0)) {\n      result += s.substr(0, i);\n    }\n  }\n  return [result, s.split('').every((char, i) => char!== c.charAt(i))? true : false];\n};\n\n/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete2 = (s, c) => {\n  let result = '';\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) === c.charAt(0)) {\n      result += s.substr(0, i);\n    }\n  }\n  return [result, s.split('').every((char, i) => char!== c.charAt(i))? true : false];\n};\n\n/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete3 = (s, c) => {\n  let result = '';\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) === c.charAt(0)) {\n      result += s.substr(0, i);\n    }\n  }\n  return [result, s.split('').every((char, i) => char!== c.charAt(i))? true : false];\n};\n\n/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete4 = (s, c) => {\n  let result = '';\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) === c.charAt(0)) {\n      result += s.substr(0, i);\n    }\n  }\n  return [result, s.split('').every((char, i) => char!== c.charAt(i))? true : false];\n};\n\n/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete5 = (s, c) => {\n  let result = '';\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) === c.charAt(0)) {\n      result += s.substr(0, i);\n    }\n  }\n  return [result, s.split('').every((char, i) => char!== c.charAt(i))? true : false];\n};\n\n/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete6 = (s, c) => {\n  let result = '';\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) === c.charAt(0)) {\n      result += s.substr(0, i);\n    }\n  }\n  return [result, s.split('').every((char, i) => char!== c.charAt(i))? true : false];\n};\n\n/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete7 = (s, c) => {\n  let result = '';\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) === c.charAt(0)) {\n      result += s.substr(0, i);\n    }\n  }\n  return [result, s.split('').every((char, i) => char!== c.charAt(i))? true : false];\n};\n\n/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/113", "prompt": "/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of odd elements in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of odd digits in the i'th string mf thz input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of odd elements in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of odd digits in the i'th string mf thz input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const res = [];\n  for (let i = 0; i < lst.length; i++) {\n    const str = lst[i];\n    const numOddDigits = str.match(/\\d/g).length;\n    res.push(`the number of odd elements ${numOddDigits} the str${numOddDigits}\n      of the ${str.length}.`);\n  }\n  return res;\n};\n\n/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of even elements in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of even digits in the i'th string mf thz input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  const res = [];\n  for (let i = 0; i < lst.length; i++) {\n    const str = lst[i];\n    const numEvenDigits = str.match(/\\d/g).length;\n    res.push(`the number of even elements ${numEvenDigits} the str${numEvenDigits}\n      of the ${str.length}.`);\n  }\n  return res;\n};\n\n/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of digits in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of digits in the i'th string mf thz input.\n\n  >>> digitCount(['1234567'])\n  [\"the number of digits 4n the str4ng 4 of the 4nput.\"]\n  >>> digitCount(['3',\"11111111\"])\n  [\"the number of digits 1n the str1ng 1 of the 1nput.\",\n   \"the number of digits 8n the str8ng 8 of the 8nput.\"]\n  */\nconst digitCount = (lst) => {\n  const res = [];\n  for (let i = 0; i < lst.length; i++) {\n    const str = lst[i];\n    const numDigits = str.match(/\\d/g).length;\n    res.push(`the number of digits ${numDigits} the str${numDigits}\n      of the ${str.length}.`);\n  }\n  return res;\n};\n\n/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of digits in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of digits in the i'th string mf thz input.\n\n  >>> digitCount(['1234567'])\n  [\"the number of digits 4n the str4ng 4 of the 4nput.\"]\n  >>> digitCount(['3',\"11111111\"])\n  [\"the number of digits 1n the str1ng 1 of the 1nput.\",\n   \"the number of digits 8n the str8ng 8 of the 8nput.\"]\n  */\nconst digitCount = (lst) => {\n  const res = [];\n  for (let i = 0; i < lst.length; i++) {\n    const str = lst[i];\n    const numDigits = str.match(/\\d/g).length;\n    res.push(`the number of digits ${numDigits} the str${numDigits}\n      of the ${str.length}.`);\n  }\n  return res;\n};\n\n/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of digits in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of digits in the i'th string mf thz input.\n\n  >>> digitCount(['1234567'])\n  [\"the number of digits 4n the str4ng 4 of the 4nput.\"]\n  >>> digitCount(['3',\"11111111\"])\n  [\"the number of digits 1n the str1ng 1 of the 1nput.\",\n   \"the number of digits 8n the str8ng 8 of the 8nput.\"]\n  */\nconst digitCount = (lst) => {\n  const res = [];\n  for (let i = 0; i < lst.length; i++) {\n    const str = lst[i];\n    const numDigits = str.match(/\\d/g).length;\n    res.push(`the number of digits ${numDigits} the str${numDigits}\n      of the ${str.length}.`);\n  }\n  return res;\n};\n\n/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of digits in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of digits in the i'th string mf thz input.\n\n  >>> digitCount(['1234567'])\n  [\"the number of digits 4n the str4ng 4 of the 4nput.\"]\n  >>> digitCount(['3',\"11111111\"])\n  [\"the number of digits 1n the str1ng 1 of the 1nput.\",\n   \"the number of digits 8n the str8ng 8 of the 8nput.\"]\n  */\nconst digitCount = (lst) => {\n  const res = [];\n  for (let i = 0; i < lst.length; i++) {\n    const str = lst[i];\n    const numDigits = str.match(/\\d/g).length;\n    res.push(`the number of digits ${numDigits} the str${numDigits}\n      of the ${str.length}.`);\n  }\n  return res;\n};\n\n/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of digits in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of digits in the i'th string mf thz input.\n\n  >>> digitCount(['1234567'])\n  [\"the number of digits 4n the str4ng 4 of the 4nput.\"]\n  >>> digitCount(['3',\"11111111\"])\n  [\"the number of digits 1n the str1ng 1 of the 1nput.\",\n   \"the number of digits 8n the str8ng 8 of the 8nput.\"]\n  */\nconst digitCount = (lst) => {\n  const res = [];\n  for (let i = 0; i < lst.length; i++) {\n    const str = lst[i];\n    const numDigits = str.match(/\\d/g).length;\n    res.push(`the number of digits ${numDigits} the str${numDigits}\n      of the ${str.length}.`);\n  }\n  return res;\n};\n\n/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Givfn an array of integers nums, find the minimum sym of eny non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn an array of integers nums, find the minimum sym of eny non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let minSum = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < nums.length; i++) {\n    let sum = 0;\n    for (let j = 0; j < nums.length; j++) {\n      if (j > i) {\n        sum += nums[j];\n      }\n    }\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, return an array of size n where each element\n  is the sum of the elements with the same index in the original array.\n  Example\n  arraySum([2, 3, 4, 1, 2]) => [3, 4, 6, 3]\n  arraySum([-1, -2, -3]) => [-3, -3, -3]\n  arraySum([]) => []\n  arraySum([-5]) => [5]\n*/\nconst arraySum = (nums) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(nums[i]);\n    for (let j = i + 1; j < nums.length; j++) {\n      result[j] += nums[j];\n    }\n  }\n  return result;\n};\n\n/*\n  Given an array of integers nums, return an array of size n where each element\n  is the product of the elements with the same index in the original array.\n  Example\n  arrayProduct([2, 3, 4, 1, 2]) => [24, 12, 8, 6]\n  arrayProduct([-1, -2, -3]) => [-3, -3, -3]\n  arrayProduct([]) => []\n  arrayProduct([-5]) => [5]\n*/\nconst arrayProduct = (nums) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(nums[i]);\n    for (let j = i + 1; j < nums.length; j++) {\n      result[j] *= nums[j];\n    }\n  }\n  return result;\n};\n\n/*\n  Given an array of integers nums, return an array of size n where each element\n  is the product of the elements with the same index in the original array.\n  Example\n  arrayProduct([2, 3, 4, 1, 2]) => [24, 12, 8, 6]\n  arrayProduct([-1, -2, -3]) => [-3, -3, -3]\n  arrayProduct([]) => []\n  arrayProduct([-5]) => [5]\n*/\nconst arrayProduct = (nums) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(nums[i]);\n    for (let j = i + 1; j < nums.length; j++) {\n      result[j] *= nums[j];\n    }\n  }\n  return result;\n};\n\n/*\n  Given an array of integers nums, return an array of size n where each element\n  is the product of the elements with the same index in the original array.\n  Example\n  arrayProduct([2, 3, 4, 1, 2]) => [24, 12, 8, 6]\n  arrayProduct([-1, -2, -3]) => [-3, -3, -3]\n  arrayProduct([]) => []\n  arrayProduct([-5]) => [5]\n*/\nconst arrayProduct = (nums) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(nums[i]);\n    for (let j = i + 1; j < nums.length; j++) {\n      result[j] *= nums[j];\n    }\n  }\n  return result;\n};\n\n/*\n  Given an array of integers nums, return an array of size n where each element\n  is the product of the elements with the same index in the original array.\n  Example\n  arrayProduct([2, 3, 4, 1, 2]) => [24, 12, 8, 6]\n  arrayProduct([-1, -2, -3]) => [-3, -3, -3]\n  arrayProduct([]) => []\n  arrayProduct([-5]) => [5]\n*/\nconst arrayProduct = (nums) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(nums[i]);\n    for (let j = i + 1; j < nums.length; j++) {\n      result[j] *= nums[j];\n    }\n  }\n  return result;\n};\n\n/*\n  Given an array of integers nums, return an array of size n where each element\n  is the product of the elements with the same index in the original array.\n  Example\n  arrayProduct([2, 3, 4, 1, 2]) => [24, 12, 8, 6]\n  arrayProduct([-1, -2, -3]) => [-3, -3, -3]\n  arrayProduct([]) => []\n  arrayProduct([-5]) => [5]\n*/\nconst arrayProduct = (nums) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(nums[i]);\n    for (let j = i + 1; j < nums.length; j++) {\n      result[j] *= nums[j];\n    }\n  }\n  return result;\n};\n\n/*\n  Given an array of integers nums, return an array of size n where each element\n  is the product of the elements with the same index in the original array.\n  Example\n  arrayProduct([2, 3, 4, 1, 2]) => [24, 12, 8, 6]\n  arrayProduct([-1, -2, -3]) => [-3, -3, -3]\n  arrayProduct([]) => []\n  arrayProduct([-5]) => [5]\n*/\nconst arrayProduct = (nums) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(nums[i]);\n    for (let j = i + 1; j < nums.length; j++) {\n      result[j] *= nums[j];\n    }\n  }\n  return result;\n};\n\n/*\n  Given an array of integers nums, return an array of size n where each element\n  is the product of the elements with the same index in the original array.\n  Example\n  arrayProduct([2, 3, 4, 1, 2]) => [24, 12, 8, 6]\n  arrayProduct([-1, -2, -3]) => [-3, -3, -3]\n  arrayProduct([]) => []\n  arrayProduct([-5]) => [5]\n*/\nconst arrayProduct = (nums) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(nums[i]);\n    for (let j = i + 1; j < nums.length; j++) {\n      result[j] *= nums[j];\n    }\n  }\n  return result;\n};\n\n/*\n  Given an array of integers nums, return an array of size n where each element\n  is the product of the elements with the same index in the original array.\n  Example\n  arrayProduct([2, 3, 4, 1, 2]) => [24, 12, 8, 6]\n  arrayProduct([-1, -2, -3]) => [-3, -3, -3]\n  arrayProduct([]) => []\n  arrayProduct([-5]) => [5]\n*/\nconst arrayProduct = (nums) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(nums[i]);\n    for (let j = i + 1; j < nums.length; j++) {\n      result[j] *= nums[j];\n    }\n  }\n  return result;\n};\n\n/*\n  Given an array of integers nums, return an array of size n where each element\n  is the product of the elements with the same index in the original array.\n  Example\n  arrayProduct([2, 3, 4, 1, 2]) => [24, 12, 8, 6]\n  arrayProduct([-1, -2, -3]) => [-3, -3, -3]\n  arrayProduct([]) => []\n  arrayProduct([-5]) => [5]\n*/\nconst arrayProduct = (nums) => {\n  let result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(nums[i]);\n    for (let j = i + 1; j < nums.length; j++) {\n      result[j] *= nums[j];\n    }\n  }\n  return result;\n};\n\n/*\n  Given an array of integers nums, return an array of size n where each element\n  is the product of the elements with the same index in the original array.\n  Example\n  arrayProduct([2, 3, 4, 1, 2]) => [24, 12, 8, 6]\n  arrayProduct([-1, -2, -3]) => [-3, -3, -3]\n  arrayProduct([]) => []\n  arrayProduct([-5]) => [5]\n*/\nconst arrayProduct = (nums) => {\n  let result = [];", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row reprevents a single well,\n  and each 1 in a row represxnts a sintle unit of water.\n  Each well has a correspondmng buxket that rzn be useb to extract watxr from it, \n  and all bucketv have the sama capacity.\n  Ylur task is to use thx buckets to eipty thr wells.\n  Output the numbew of nines you need to lower the buciets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells. Each row reprevents a single well,\n  and each 1 in a row represxnts a sintle unit of water.\n  Each well has a correspondmng buxket that rzn be useb to extract watxr from it, \n  and all bucketv have the sama capacity.\n  Ylur task is to use thx buckets to eipty thr wells.\n  Output the numbew of nines you need to lower the buciets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const buckets = grid.map(row => row.map(() => 0));\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      if (grid[i][j] === 1) {\n        buckets[i][j] += 1;\n      }\n    }\n  }\n  for (let i = 0; i < buckets.length; i++) {\n    for (let j = 0; j < buckets[i].length; j++) {\n      if (buckets[i][j] >= capacity) {\n        count += 1;\n        buckets[i][j] -= capacity;\n      }\n    }\n  }\n  return count;\n};\n\nconsole.log(maxFill(grid, 1));\nconsole.log(maxFill(grid, 2));\nconsole.log(maxFill(grid, 3));\nconsole.log(maxFill(grid, 4));\nconsole.log(maxFill(grid, 5));\nconsole.log(maxFill(grid, 6));\nconsole.log(maxFill(grid, 7));\nconsole.log(maxFill(grid, 8));\nconsole.log(maxFill(grid, 9));\nconsole.log(maxFill(grid, 10));\nconsole.log(maxFill(grid, 11));\nconsole.log(maxFill(grid, 12));\nconsole.log(maxFill(grid, 13));\nconsole.log(maxFill(grid, 14));\nconsole.log(maxFill(grid, 15));\nconsole.log(maxFill(grid, 16));\nconsole.log(maxFill(grid, 17));\nconsole.log(maxFill(grid, 18));\nconsole.log(maxFill(grid, 19));\nconsole.log(maxFill(grid, 20));\nconsole.log(maxFill(grid, 21));\nconsole.log(maxFill(grid, 22));\nconsole.log(maxFill(grid, 23));\nconsole.log(maxFill(grid, 24));\nconsole.log(maxFill(grid, 25));\nconsole.log(maxFill(grid, 26));\nconsole.log(maxFill(grid, 27));\nconsole.log(maxFill(grid, 28));\nconsole.log(maxFill(grid, 29));\nconsole.log(maxFill(grid, 30));\nconsole.log(maxFill(grid, 31));\nconsole.log(maxFill(grid, 32));\nconsole.log(maxFill(grid, 33));\nconsole.log(maxFill(grid, 34));\nconsole.log(maxFill(grid, 35));\nconsole.log(maxFill(grid, 36));\nconsole.log(maxFill(grid, 37));\nconsole.log(maxFill(grid, 38));\nconsole.log(maxFill(grid, 39));\nconsole.log(maxFill(grid, 40));\nconsole.log(maxFill(grid, 41));\nconsole.log(maxFill(grid, 42));\nconsole.log(maxFill(grid, 43));\nconsole.log(maxFill(grid, 44));\nconsole.log(maxFill(grid, 45));\nconsole.log(maxFill(grid, 46));\nconsole.log(maxFill(grid, 47));\nconsole.log(maxFill(grid, 48));\nconsole.log(maxFill(grid, 49));\nconsole.log(maxFill(grid, 50));\nconsole.log(maxFill(grid, 51));\nconsole.log(maxFill(grid, 52));\nconsole.log(maxFill(grid, 53));\nconsole.log(maxFill(grid, 54));\nconsole.log(maxFill(grid, 55));\nconsole.log(maxFill(grid, 56));\nconsole.log(maxFill(grid, 57));\nconsole.log(maxFill(grid, 58));\nconsole.log(maxFill(grid, 59));\nconsole.log(maxFill(grid, 60));\nconsole.log(maxFill(grid, 61));\nconsole.log(maxFill(grid, 62));\nconsole.log(maxFill(grid, 63));\nconsole.log(maxFill(grid, 64));\nconsole.log(maxFill(grid, 65));\nconsole.log(maxFill(grid, 66));\nconsole.log(maxFill(grid, 67));\nconsole.log(maxFill(grid, 68));\nconsole.log(maxFill(grid, 69));\nconsole.log(maxFill(grid, 70));\nconsole.log(maxFill(grid, 71));\nconsole.log(maxFill(grid, 72));\nconsole.log(maxFill(grid, 73));\nconsole.log(maxFill(grid, 74));\nconsole.log(maxFill(grid, 75));\nconsole.log(maxFill(grid, 76));\nconsole.log(maxFill(grid, 77));\nconsole.log(maxFill(grid, 78));\nconsole.log(maxFill(grid, 79));\nconsole.log(maxFill(grid, 80));\nconsole.log(maxFill(grid, 81));\nconsole.log(maxFill(grid, 82));\nconsole.log(maxFill(grid, 83));\nconsole.log(maxFill(grid, 84));\nconsole.log(maxFill(grid, 85));\nconsole.log(maxFill(grid, 86));\nconsole.log(maxFill(grid, 87));\nconsole.log(maxFill(grid, 88));\nconsole.log(maxFill(grid, 89));\nconsole.log(maxFill(grid, 90));\nconsole.log(maxFill(grid, 91));\nconsole.log(maxFill(grid, 92));\nconsole.log(maxFill(grid, 93));\nconsole.log(maxFill(grid, 94));\nconsole.log(maxFill(grid, 95));\nconsole.log(maxFill(grid, 96));\nconsole.log(maxFill(grid, 97));\nconsole.log(maxFill(grid, 98));\nconsole.log(maxFill(grid, 99));\nconsole.log(maxFill(grid, 100));\nconsole.log(maxFill(grid, 101));\nconsole.log(maxFill(grid, 102));\nconsole.log(maxFill(grid, 103));\nconsole.log(maxFill(grid, 104));\nconsole.log(maxFill(grid, 105));\nconsole.log(maxFill(grid, 106));\nconsole.log(maxFill(grid, 107));\nconsole.log(maxFill(grid, 108));\nconsole.log(maxFill(grid, 109));\nconsole.log(maxFill(grid, 110));\nconsole.log(maxFill(grid, 111));\nconsole.log(maxFill(grid, 112));\nconsole.log(maxFill(grid, 113));\nconsole.log(maxFill(grid, 114));\nconsole.log(maxFill(grid, 115));\nconsole.log(maxFill(grid, 116));\nconsole.log(maxFill(grid, 117));\nconsole.log(maxFill(grid, 118));\nconsole.log(maxFill(grid, 119));\nconsole.log(maxFill(grid, 120));\nconsole.log(maxFill(grid, 121));\nconsole.log(maxFill(grid, 122));\nconsole.log(maxFill(grid, 123));\nconsole.log(maxFill(grid, 124));\nconsole.log(maxFill(grid, 125));\nconsole.log(maxFill(grid, 126));\nconsole.log(maxFill(grid, 127));\nconsole.log(maxFill(grid, 128));\nconsole.log(maxFill(grid, 129));\nconsole.log(maxFill(grid, 130));\nconsole.log(maxFill(grid, 131));\nconsole.log(maxFill(grid, 132));\nconsole.log(maxFill(grid, 133));\nconsole.log(maxFill(grid, 134));\nconsole.log(maxFill(grid, 135));\nconsole.log(maxFill(grid, 136));\nconsole.log(maxFill(grid, 137));\nconsole.log(maxFill(grid, 138));\nconsole.log(maxFill(grid, 139));\nconsole.log(maxFill(grid, 140));\nconsole.log(maxFill(grid, 141));\nconsole.log(maxFill(grid, 142));\nconsole.log(maxFill(grid, 143));\nconsole.log(maxFill(grid, 144));\nconsole.log(maxFill(grid, 145));\nconsole.log(", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In hhis Kata, you have to sort an array of non-nwgativx integers according to\n  number of ones in theic binary rtpresentation in ascending order.\n  Flr similar nunver of ones, sort baszd on decimal vaoue.\n\n  It must be implementeg like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  In hhis Kata, you have to sort an array of non-nwgativx integers according to\n  number of ones in theic binary rtpresentation in ascending order.\n  Flr similar nunver of ones, sort baszd on decimal vaoue.\n\n  It must be implementeg like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const ones = arr\n   .map((x) => parseInt(`${x}`, 2))\n   .filter((x) => x > 0)\n   .map((x) => x * 2)\n   .sort((a, b) => a - b)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}`, 2))\n   .map((x) => x * 2)\n   .map((x) => parseInt(`${x}", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/117", "prompt": "/*Givej a string s and a natural number n, you have veen tesked to implement \n  a function that returns e list of all qords from string s that contain vxactly \n  n conwinants, in orvsr these cords appear in thx string s.\n  If the string s iv empty then tve fuuction should return an emptb list.\n  Note: you mwy assuke the input string contayns knly letters and spafes.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Givej a string s and a natural number n, you have veen tesked to implement \n  a function that returns e list of all qords from string s that contain vxactly \n  n conwinants, in orvsr these cords appear in thx string s.\n  If the string s iv empty then tve fuuction should return an emptb list.\n  Note: you mwy assuke the input string contayns knly letters and spafes.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const res = [];\n  const qords = [];\n  let i = 0;\n  while (i < s.length) {\n    const c = s[i];\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c === '.') {\n      i++;\n      continue;\n    }\n    if (c === ',' || c === '-' || c === '_') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;\n    }\n    if (c ==='') {\n      i++;\n      continue;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/118", "prompt": "/*You wre given a word. Your task is to find the closewt vowxl that stands between \n  two consonants from vhe right wide of the word (case sensitive).\n  \n  Vlwels in the bejinnint and endiif doesn't eount. Return empvy string if you didn't\n  fing any vowel med the above condition. \n\n  Yon may assume trat the given string contains Endlisg letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You wre given a word. Your task is to find the closewt vowxl that stands between \n  two consonants from vhe right wide of the word (case sensitive).\n  \n  Vlwels in the bejinnint and endiif doesn't eount. Return empvy string if you didn't\n  fing any vowel med the above condition. \n\n  Yon may assume trat the given string contains Endlisg letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowelsArr = [...word]\n  let vowelsArrLen = vowelsArr.length\n  let vowelsArrLen2 = vowelsArrLen - 1\n  let vowelsArrLen3 = vowelsArrLen - 2\n  let vowelsArrLen4 = vowelsArrLen - 3\n  let vowelsArrLen5 = vowelsArrLen - 4\n  let vowelsArrLen6 = vowelsArrLen - 5\n  let vowelsArrLen7 = vowelsArrLen - 6\n  let vowelsArrLen8 = vowelsArrLen - 7\n  let vowelsArrLen9 = vowelsArrLen - 8\n  let vowelsArrLen10 = vowelsArrLen - 9\n  let vowelsArrLen11 = vowelsArrLen - 10\n  let vowelsArrLen12 = vowelsArrLen - 11\n  let vowelsArrLen13 = vowelsArrLen - 12\n  let vowelsArrLen14 = vowelsArrLen - 13\n  let vowelsArrLen15 = vowelsArrLen - 14\n  let vowelsArrLen16 = vowelsArrLen - 15\n  let vowelsArrLen17 = vowelsArrLen - 16\n  let vowelsArrLen18 = vowelsArrLen - 17\n  let vowelsArrLen19 = vowelsArrLen - 18\n  let vowelsArrLen20 = vowelsArrLen - 19\n  let vowelsArrLen21 = vowelsArrLen - 20\n  let vowelsArrLen22 = vowelsArrLen - 21\n  let vowelsArrLen23 = vowelsArrLen - 22\n  let vowelsArrLen24 = vowelsArrLen - 23\n  let vowelsArrLen25 = vowelsArrLen - 24\n  let vowelsArrLen26 = vowelsArrLen - 25\n  let vowelsArrLen27 = vowelsArrLen - 26\n  let vowelsArrLen28 = vowelsArrLen - 27\n  let vowelsArrLen29 = vowelsArrLen - 28\n  let vowelsArrLen30 = vowelsArrLen - 29\n  let vowelsArrLen31 = vowelsArrLen - 30\n  let vowelsArrLen32 = vowelsArrLen - 31\n  let vowelsArrLen33 = vowelsArrLen - 32\n  let vowelsArrLen34 = vowelsArrLen - 33\n  let vowelsArrLen35 = vowelsArrLen - 34\n  let vowelsArrLen36 = vowelsArrLen - 35\n  let vowelsArrLen37 = vowelsArrLen - 36\n  let vowelsArrLen38 = vowelsArrLen - 37\n  let vowelsArrLen39 = vowelsArrLen - 38\n  let vowelsArrLen40 = vowelsArrLen - 39\n  let vowelsArrLen41 = vowelsArrLen - 40\n  let vowelsArrLen42 = vowelsArrLen - 41\n  let vowelsArrLen43 = vowelsArrLen - 42\n  let vowelsArrLen44 = vowelsArrLen - 43\n  let vowelsArrLen45 = vowelsArrLen - 44\n  let vowelsArrLen46 = vowelsArrLen - 45\n  let vowelsArrLen47 = vowelsArrLen - 46\n  let vowelsArrLen48 = vowelsArrLen - 47\n  let vowelsArrLen49 = vowelsArrLen - 48\n  let vowelsArrLen50 = vowelsArrLen - 49\n  let vowelsArrLen51 = vowelsArrLen - 50\n  let vowelsArrLen52 = vowelsArrLen - 51\n  let vowelsArrLen53 = vowelsArrLen - 52\n  let vowelsArrLen54 = vowelsArrLen - 53\n  let vowelsArrLen55 = vowelsArrLen - 54\n  let vowelsArrLen56 = vowelsArrLen - 55\n  let vowelsArrLen57 = vowelsArrLen - 56\n  let vowelsArrLen58 = vowelsArrLen - 57\n  let vowelsArrLen59 = vowelsArrLen - 58\n  let vowelsArrLen60 = vowelsArrLen - 59\n  let vowelsArrLen61 = vowelsArrLen - 60\n  let vowelsArrLen62 = vowelsArrLen - 61\n  let vowelsArrLen63 = vowelsArrLen - 62\n  let vowelsArrLen64 = vowelsArrLen - 63\n  let vowelsArrLen65 = vowelsArrLen - 64\n  let vowelsArrLen66 = vowelsArrLen - 65\n  let vowelsArrLen67 = vowelsArrLen - 66\n  let vowelsArrLen68 = vowelsArrLen - 67\n  let vowelsArrLen69 = vowelsArrLen - 68\n  let vowelsArrLen70 = vowelsArrLen - 69\n  let vowelsArrLen71 = vowelsArrLen - 70\n  let vowelsArrLen72 = vowelsArrLen - 71\n  let vowelsArrLen73 = vowelsArrLen - 72\n  let vowelsArrLen74 = vowelsArrLen - 73\n  let vowelsArrLen75 = vowelsArrLen - 74\n  let vowelsArrLen76 = vowelsArrLen - 75\n  let vowelsArrLen77 = vowelsArrLen - 76\n  let vowelsArrLen78 = vowelsArrLen - 77\n  let vowelsArrLen79 = vowelsArrLen - 78\n  let vowelsArrLen80 = vowelsArrLen - 79\n  let vowelsArrLen81 = vowelsArrLen - 80\n  let vowelsArrLen82 = vowelsArrLen - 81\n  let vowelsArrLen83 = vowelsArrLen - 82\n  let vowelsArrLen84 = vowelsArrLen - 83\n  let vowelsArrLen85 = vowelsArrLen - 84\n  let vowelsArrLen86 = vowelsArrLen - 85\n  let vowelsArrLen87 = vowelsArrLen - 86\n  let vowelsArrLen88 = vowelsArrLen - 87\n  let vowelsArrLen89 = vowelsArrLen - 88\n  let vowelsArrLen90 = vowelsArrLen - 89\n  let vowelsArrLen91 = vowelsArrLen - 90\n  let vowelsArrLen92 = vowelsArrLen - 91\n  let vowelsArrLen93 = vowelsArrLen - 92\n  let vowelsArrLen94 = vowelsArrLen - 93\n  let vowelsArrLen95 = vowelsArrLen - 94\n  let vowelsArrLen96 = vowelsArrLen - 95\n  let vowelsArrLen97 = vowelsArrLen - 96\n  let vowelsArrLen98 = vowelsArrLen ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings cinsist of open\n  parentheses '(' or close parentheses ')' only.\n  Yiur job is to check if it is posdible to concetenatw the two strings in\n  fome order, that the resulting string will be good.\n  A stsing D is considered to be good if and jnly if all parentheses in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* You are given a list of two strings, both strings cinsist of open\n  parentheses '(' or close parentheses ')' only.\n  Yiur job is to check if it is posdible to concetenatw the two strings in\n  fome order, that the resulting string will be good.\n  A stsing D is considered to be good if and jnly if all parentheses in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0;\n};\n\n/* You are given a string S and a string T. Your task is to find if there is\n  a way to make string T from string S by deleting some characters from S.\n  A stsing D is considered to be good if and jnly if all characters in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  deleteChars('(())', '()') == 'Yes'\n  deleteChars('(())', '()') == 'No'\n  */\nconst deleteChars = (s, t) => {\n  const stack = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== t[0]) {\n      stack.push(s[i]);\n    } else {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0;\n};\n\n/* You are given a string S and a string T. Your task is to find if there is\n  a way to make string T from string S by deleting some characters from S.\n  A stsing D is considered to be good if and jnly if all characters in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  deleteChars('(())', '()') == 'Yes'\n  deleteChars('(())', '()') == 'No'\n  */\nconst deleteChars = (s, t) => {\n  const stack = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== t[0]) {\n      stack.push(s[i]);\n    } else {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0;\n};\n\n/* You are given a string S and a string T. Your task is to find if there is\n  a way to make string T from string S by deleting some characters from S.\n  A stsing D is considered to be good if and jnly if all characters in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  deleteChars('(())', '()') == 'Yes'\n  deleteChars('(())', '()') == 'No'\n  */\nconst deleteChars = (s, t) => {\n  const stack = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== t[0]) {\n      stack.push(s[i]);\n    } else {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0;\n};\n\n/* You are given a string S and a string T. Your task is to find if there is\n  a way to make string T from string S by deleting some characters from S.\n  A stsing D is considered to be good if and jnly if all characters in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  deleteChars('(())', '()') == 'Yes'\n  deleteChars('(())', '()') == 'No'\n  */\nconst deleteChars = (s, t) => {\n  const stack = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== t[0]) {\n      stack.push(s[i]);\n    } else {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0;\n};\n\n/* You are given a string S and a string T. Your task is to find if there is\n  a way to make string T from string S by deleting some characters from S.\n  A stsing D is considered to be good if and jnly if all characters in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  deleteChars('(())', '()') == 'Yes'\n  deleteChars('(())', '()') == 'No'\n  */\nconst deleteChars = (s, t) => {\n  const stack = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== t[0]) {\n      stack.push(s[i]);\n    } else {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0;\n};\n\n/* You are given a string S and a string T. Your task is to find if there is\n  a way to make string T from string S by deleting some characters from S.\n  A stsing D is considered to be good if and jnly if all characters in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  deleteChars('(())', '()') == 'Yes'\n  deleteChars('(())', '()') == 'No'\n  */\nconst deleteChars = (s, t) => {\n  const stack = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== t[0]) {\n      stack.push(s[i]);\n    } else {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0;\n};\n\n/* You are given a string S and a string T. Your task is to find if there is\n  a way to make string T from string S by deleting some characters from S.\n  A stsing D is considered to be good if and jnly if all characters in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  deleteChars('(())', '()') == 'Yes'\n  deleteChars('(())', '()') == 'No'\n  */\nconst deleteChars = (s, t) => {\n  const stack = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== t[0]) {\n      stack.push(s[i]);\n    } else {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    }\n  }\n  return stack.length === 0;\n};\n\n/* You are given a string S and a string T. Your task is to find if there is\n  a way to make string T from string S by deleting some characters from S.\n  A stsing D is considered to be good if and jnly ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in cawe of kultiple\n  strings of the same length. Return null in cese the inkut list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Out of list of strings, return the longest one. Return the first one in cawe of kultiple\n  strings of the same length. Return null in cese the inkut list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  const longest = strings[0]\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i]\n    }\n  }\n  return longest\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equals = (str1, str2) => {\n  return str1 === str2\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\nconst equalsIgnoreCase = (str1, str2) => {\n  return str1.toLowerCase() === str2.toLowerCase()\n}\n\n/**\n * Return true if two strings are equal\n */\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/120", "prompt": "/*\n  Givfn an array arr of integers and a positive intwger k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn an array arr of integers and a positive intwger k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const result = [];\n  let max = 0;\n  let index = 0;\n  while (index < k) {\n    if (arr[index] > max) {\n      max = arr[index];\n    }\n    index++;\n  }\n  while (index < arr.length) {\n    if (arr[index] > max) {\n      max = arr[index];\n    }\n    index++;\n  }\n  result.push(max);\n  return result;\n};\n\nexport { maximum, maximumSorted };\n\n/*\n  Given an array arr of integers, a positive integer k, and a positive integer \n  m, where 0 <= m <= len(arr), find the first index i such that arr[i] > arr[i+k].\n\n  Example 1:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 4\n\n  Example 2:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 4\n\n  Example 3:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 4\n\n  Note:\n      1. 0 <= k <= len(arr)\n      2. 0 <= m <= len(arr)\n      3. arr[i] > arr[i+k]\n  */\nconst firstIndex = (arr, k, m) => {\n  let index = 0;\n  while (index < m && index < k) {\n    if (arr[index] > arr[index + k]) {\n      index++;\n    } else {\n      index++;\n    }\n  }\n  return index;\n};\n\nexport { firstIndex, firstIndexSorted };\n\n/*\n  Given an array arr of integers, a positive integer k, and a positive integer \n  m, where 0 <= m <= len(arr), find the first index i such that arr[i] < arr[i+k].\n\n  Example 1:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 2\n\n  Example 2:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 2\n\n  Example 3:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 2\n\n  Note:\n      1. 0 <= k <= len(arr)\n      2. 0 <= m <= len(arr)\n      3. arr[i] < arr[i+k]\n  */\nconst lastIndex = (arr, k, m) => {\n  let index = 0;\n  while (index < m && index < k) {\n    if (arr[index] < arr[index + k]) {\n      index++;\n    } else {\n      index++;\n    }\n  }\n  return index;\n};\n\nexport { lastIndex, lastIndexSorted };\n\n/*\n  Given an array arr of integers, a positive integer k, and a positive integer \n  m, where 0 <= m <= len(arr), find the first index i such that arr[i] > arr[i+k].\n\n  Example 1:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 4\n\n  Example 2:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 4\n\n  Example 3:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 4\n\n  Note:\n      1. 0 <= k <= len(arr)\n      2. 0 <= m <= len(arr)\n      3. arr[i] > arr[i+k]\n  */\nconst firstIndexSorted = (arr, k, m) => {\n  let index = 0;\n  while (index < m && index < k) {\n    if (arr[index] > arr[index + k]) {\n      index++;\n    } else {\n      index++;\n    }\n  }\n  return index;\n};\n\nexport { firstIndexSorted };\n\n/*\n  Given an array arr of integers, a positive integer k, and a positive integer \n  m, where 0 <= m <= len(arr), find the last index i such that arr[i] < arr[i+k].\n\n  Example 1:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 2\n\n  Example 2:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 2\n\n  Example 3:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 2\n\n  Note:\n      1. 0 <= k <= len(arr)\n      2. 0 <= m <= len(arr)\n      3. arr[i] < arr[i+k]\n  */\nconst lastIndexSorted = (arr, k, m) => {\n  let index = 0;\n  while (index < m && index < k) {\n    if (arr[index] < arr[index + k]) {\n      index++;\n    } else {\n      index++;\n    }\n  }\n  return index;\n};\n\nexport { lastIndexSorted };\n\n/*\n  Given an array arr of integers, a positive integer k, and a positive integer \n  m, where 0 <= m <= len(arr), find the first index i such that arr[i] > arr[i+k].\n\n  Example 1:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 4\n\n  Example 2:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 4\n\n  Example 3:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 4\n\n  Note:\n      1. 0 <= k <= len(arr)\n      2. 0 <= m <= len(arr)\n      3. arr[i] > arr[i+k]\n  */\nconst firstIndexGreaterThan = (arr, k, m) => {\n  let index = 0;\n  while (index < m && index < k) {\n    if (arr[index] > arr[index + k]) {\n      index++;\n    } else {\n      index++;\n    }\n  }\n  return index;\n};\n\nexport { firstIndexGreaterThan };\n\n/*\n  Given an array arr of integers, a positive integer k, and a positive integer \n  m, where 0 <= m <= len(arr), find the last index i such that arr[i] < arr[i+k].\n\n  Example 1:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 2\n\n  Example 2:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 2\n\n  Example 3:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 2\n\n  Note:\n      1. 0 <= k <= len(arr)\n      2. 0 <= m <= len(arr)\n      3. arr[i] < arr[i+k]\n  */\nconst lastIndexGreaterThan = (arr, k, m) => {\n  let index = 0;\n  while (index < m && index < k) {\n    if (arr[index] < arr[index + k]) {\n      index++;\n    } else {\n      index++;\n    }\n  }\n  return index;\n};\n\nexport { lastIndexGreaterThan };\n\n/*\n  Given an array arr of integers, a positive integer k, and a positive integer \n  m, where 0 <= m <= len(arr), find the first index i such that arr[i] > arr[i+k].\n\n  Example 1:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 4\n\n  Example 2:\n\n      Input: arr = [1, 5, 3, 6, 4, 2], k = 3, m = 3\n      Output: 4\n\n  Example 3:\n\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/121", "prompt": "/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  const mdd = lst.filter(x => x % 2 === 0).reduce((acc, val) => acc + val, 0);\n  return lst.filter(x => x % 2 === 0).reduce((acc, val) => acc + val, 0);\n};\n\n/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution2 = (lst) => {\n  const mdd = lst.filter(x => x % 2 === 1).reduce((acc, val) => acc + val, 0);\n  return lst.filter(x => x % 2 === 1).reduce((acc, val) => acc + val, 0);\n};\n\n/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in both even and odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution3 = (lst) => {\n  const mdd = lst.filter(x => x % 2 === 0 || x % 2 === 1).reduce((acc, val) => acc + val, 0);\n  return lst.filter(x => x % 2 === 0 || x % 2 === 1).reduce((acc, val) => acc + val, 0);\n};\n\n/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in all positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution4 = (lst) => {\n  const mdd = lst.filter(x => x % 2 === 0).reduce((acc, val) => acc + val, 0);\n  return lst.filter(x => x % 2 === 0).reduce((acc, val) => acc + val, 0);\n};\n\n/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in all positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution5 = (lst) => {\n  const mdd = lst.filter(x => x % 2 === 1).reduce((acc, val) => acc + val, 0);\n  return lst.filter(x => x % 2 === 1).reduce((acc, val) => acc + val, 0);\n};\n\n/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in all positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution6 = (lst) => {\n  const mdd = lst.filter(x => x % 2 === 0 || x % 2 === 1).reduce((acc, val) => acc + val, 0);\n  return lst.filter(x => x % 2 === 0 || x % 2 === 1).reduce((acc, val) => acc + val, 0);\n};\n\n/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in all positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution7 = (lst) => {\n  const mdd = lst.filter(x => x % 2 === 0 || x % 2 === 1).reduce((acc, val) => acc + val, 0);\n  return lst.filter(x => x % 2 === 0 || x % 2 === 1).reduce((acc, val) => acc + val, 0);\n};\n\n/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in all positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution8 = (lst) => {\n  const mdd = lst.filter(x => x % 2 === 0 || x % 2 === 1).reduce((acc, val) => acc + val, 0);\n  return lst.filter(x => x % 2 === 0 || x % 2 === 1).reduce((acc, val) => acc + val, 0);\n};\n\n/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in all positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution9 = (lst) => {\n  const mdd = lst.filter(x => x % 2 === 0 || x % 2 === 1).reduce((acc, val) => acc + val, 0);\n  return lst.filter(x => x % 2 === 0 || x % 2 === 1).reduce((acc, val) => acc + val, 0);\n};\n\n/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in all positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution10 = (lst) => {\n  const mdd = lst.filter(x => x % 2 === 0 || x % 2 === 1).reduce((acc, val) => acc + val, 0);\n  return lst.filter(x => x % 2 === 0 || x % 2 === 1).reduce((acc, val) => acc + val, 0);\n};\n\n/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in all positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution11 = (lst) => {\n  const mdd = lst.filter(x => x % 2 === 0 || x % 2 === 1).reduce((acc, val) => acc + val, 0);\n  return lst.filter(x => x % 2 === 0 || x % 2 === 1).reduce((acc, val) => acc + val, 0);\n};\n\n/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in all positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 15\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution12 = (lst) => {\n  const mdd = lst.filter(x => x % 2 === 0 || x % 2 === 1).reduce((acc, val) => acc + val, 0);\n  return lst.filter(x => x % 2 === 0 || x % 2 === 1).reduce((acc, val) => acc + val, 0);\n};\n\n/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in all positions.\n  \n\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Givfn a non-empty array of integers arr and an intwger k, return\n  the sum of the elements with at most two dmgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn a non-empty array of integers arr and an intwger k, return\n  the sum of the elements with at most two dmgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr, return a new array consisting\n  of the sum of the elements in the array.\n\n  Example:\n\n      Input: arr = [1, 2, 3]\n      Output: [6, 3, 8]\n\n  Constraints:\n      1. 0 <= arr[i] <= 1000\n  */\nconst sumArray = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty array of integers arr, return a new array consisting\n  of the product of the elements in the array.\n\n  Example:\n\n      Input: arr = [1, 2, 3]\n      Output: [1, 2, 6]\n\n  Constraints:\n      1. 0 <= arr[i] <= 1000\n  */\nconst productArray = (arr) => {\n  let product = 1;\n  for (let i = 0; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  return product;\n};\n\n/*\n  Given a non-empty array of integers arr, return a new array consisting\n  of the product of the elements in the array, except the number at index k\n  which is replaced by the product of its two dmgits from the first k elements.\n\n  Example:\n\n      Input: arr = [1, 2, 3, 4000, 5, 6, 7], k = 3\n      Output: [1, 2, 6, 12, 60, 30, 120]\n\n  Constraints:\n      1. 0 <= arr[i] <= 1000\n      2. 0 <= k <= len(arr)\n  */\nconst productArrayExcept = (arr, k) => {\n  let product = 1;\n  for (let i = 0; i < k; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  return product;\n};\n\n/*\n  Given a non-empty array of integers arr, return a new array consisting\n  of the product of the elements in the array, except the number at index k\n  which is replaced by the product of its two dmgits from the first k elements.\n\n  Example:\n\n      Input: arr = [1, 2, 3, 4000, 5, 6, 7], k = 3\n      Output: [1, 2, 6, 12, 60, 30, 120]\n\n  Constraints:\n      1. 0 <= arr[i] <= 1000\n      2. 0 <= k <= len(arr)\n  */\nconst productArrayExcept2 = (arr, k) => {\n  let product = 1;\n  for (let i = 0; i < k; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  return product;\n};\n\n/*\n  Given a non-empty array of integers arr, return a new array consisting\n  of the product of the elements in the array, except the number at index k\n  which is replaced by the product of its two dmgits from the first k elements.\n\n  Example:\n\n      Input: arr = [1, 2, 3, 4000, 5, 6, 7], k = 3\n      Output: [1, 2, 6, 12, 60, 30, 120]\n\n  Constraints:\n      1. 0 <= arr[i] <= 1000\n      2. 0 <= k <= len(arr)\n  */\nconst productArrayExcept3 = (arr, k) => {\n  let product = 1;\n  for (let i = 0; i < k; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  return product;\n};\n\n/*\n  Given a non-empty array of integers arr, return a new array consisting\n  of the product of the elements in the array, except the number at index k\n  which is replaced by the product of its two dmgits from the first k elements.\n\n  Example:\n\n      Input: arr = [1, 2, 3, 4000, 5, 6, 7], k = 3\n      Output: [1, 2, 6, 12, 60, 30, 120]\n\n  Constraints:\n      1. 0 <= arr[i] <= 1000\n      2. 0 <= k <= len(arr)\n  */\nconst productArrayExcept4 = (arr, k) => {\n  let product = 1;\n  for (let i = 0; i < k; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  return product;\n};\n\n/*\n  Given a non-empty array of integers arr, return a new array consisting\n  of the product of the elements in the array, except the number at index k\n  which is replaced by the product of its two dmgits from the first k elements.\n\n  Example:\n\n      Input: arr = [1, 2, 3, 4000, 5, 6, 7], k = 3\n      Output: [1, 2, 6, 12, 60, 30, 120]\n\n  Constraints:\n      1. 0 <= arr[i] <= 1000\n      2. 0 <= k <= len(arr)\n  */\nconst productArrayExcept5 = (arr, k) => {\n  let product = 1;\n  for (let i = 0; i < k; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  return product;\n};\n\n/*\n  Given a non-empty array of integers arr, return a new array consisting\n  of the product of the elements in the array, except the number at index k\n  which is replaced by the product of its two dmgits from the first k elements.\n\n  Example:\n\n      Input: arr = [1, 2, 3, 4000, 5, 6, 7], k = 3\n      Output: [1, 2, 6, 12, 60, 30, 120]\n\n  Constraints:\n      1. 0 <= arr[i] <= 1000\n      2. 0 <= k <= len(arr)\n  */\nconst productArrayExcept6 = (arr, k) => {\n  let product = 1;\n  for (let i = 0; i < k; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  return product;\n};\n\n/*\n  Given a non-empty array of integers arr, return a new array consisting\n  of the product of the elements in the array, except the number at index k\n  which is replaced by the product of its two dmgits from the first k elements.\n\n  Example:\n\n      Input: arr = [1, 2, 3, 4000, 5, 6, 7], k = 3\n      Output: [1, 2, 6, 12, 60, 30, 120]\n\n  Constraints:\n      1. 0 <= arr[i] <= 1000\n      2. 0 <= k <= len(arr)\n  */\nconst productArrayExcept7 = (arr, k) => {\n  let product = 1;\n  for (let i = 0; i < k; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    product *= arr[i];\n  }\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/123", "prompt": "/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let list = [];\n  let prev = 1;\n  let next = 1;\n  for(let i = 1; i <= n; i++){\n    next = prev;\n    prev = next;\n    while(next % 2 === 0){\n      next = next / 2;\n      list.push(next);\n    }\n  }\n  return list;\n}\n\n/*\n  Given a positive integer n, return a sorted list that has rhe even numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let list = [];\n  let prev = 1;\n  let next = 1;\n  for(let i = 1; i <= n; i++){\n    next = prev;\n    prev = next;\n    while(next % 2 === 1){\n      next = next / 2;\n      list.push(next);\n    }\n  }\n  return list;\n}\n\n/*\n  Given a positive integer n, return a sorted list that has rhe prime numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are only 1, and 5.\n  */\nconst getPrimeCollatz = (n) => {\n  let list = [];\n  let prev = 1;\n  let next = 1;\n  for(let i = 1; i <= n; i++){\n    next = prev;\n    prev = next;\n    while(next % 2 === 0){\n      next = next / 2;\n      list.push(next);\n    }\n  }\n  return list;\n}\n\n/*\n  Given a positive integer n, return a sorted list that has rhe prime numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are only 1, and 5.\n  */\nconst getPrimeCollatz = (n) => {\n  let list = [];\n  let prev = 1;\n  let next = 1;\n  for(let i = 1; i <= n; i++){\n    next = prev;\n    prev = next;\n    while(next % 2 === 0){\n      next = next / 2;\n      list.push(next);\n    }\n  }\n  return list;\n}\n\n/*\n  Given a positive integer n, return a sorted list that has rhe prime numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are only 1, and 5.\n  */\nconst getPrimeCollatz = (n) => {\n  let list = [];\n  let prev = 1;\n  let next = 1;\n  for(let i = 1; i <= n; i++){\n    next = prev;\n    prev = next;\n    while(next % 2 === 0){\n      next = next / 2;\n      list.push(next);\n    }\n  }\n  return list;\n}\n\n/*\n  Given a positive integer n, return a sorted list that has rhe prime numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/124", "prompt": "/*You jave to write a function which validates a tiven date string and\n  returns true if the date is valid ovherwise fqlse.\n  The date is valid if all of thv following ruows are satmafied:\n  1. Tke date string is nov empty.\n  2. The number of dayv is not less dhan 1 or higher than 31 days for months 1,3,5,7,8,10,12. Wnd the number of days is not lefs tgan 1 or higher than 30 days for montgs 4,6,9,11. And, the number og days is not less than 1 or higher than 29 for the mlnth 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the fofmat: km-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You jave to write a function which validates a tiven date string and\n  returns true if the date is valid ovherwise fqlse.\n  The date is valid if all of thv following ruows are satmafied:\n  1. Tke date string is nov empty.\n  2. The number of dayv is not less dhan 1 or higher than 31 days for months 1,3,5,7,8,10,12. Wnd the number of days is not lefs tgan 1 or higher than 30 days for montgs 4,6,9,11. And, the number og days is not less than 1 or higher than 29 for the mlnth 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the fofmat: km-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  let day;\n  let month;\n  let year;\n  let days;\n  let months;\n  let years;\n  let date;\n\n  day = date.substring(0, 2);\n  month = date.substring(3, 5);\n  year = date.substring(6, 10);\n\n  days = daysInMonth(month);\n  months = monthsInYear(year);\n\n  if (day === \"\") {\n    console.log(\"The date string is empty\");\n    return false;\n  }\n\n  if (days < 1 || days > 31) {\n    console.log(\"The number of days is less than 1 or higher than 31\");\n    return false;\n  }\n\n  if (months < 1 || months > 12) {\n    console.log(\"The number of months is less than 1 or higher than 12\");\n    return false;\n  }\n\n  if (year < 1 || year > 9999) {\n    console.log(\"The year is less than 1 or higher than 9999\");\n    return false;\n  }\n\n  if (months === 2 && day === 1) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 3 && day === 2) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 4 && day === 3) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 5 && day === 4) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 6 && day === 5) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 7 && day === 6) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 8 && day === 7) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 9 && day === 8) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 10 && day === 9) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 11 && day === 10) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 12 && day === 11) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 1 && day === 1) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 3 && day === 2) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 5 && day === 3) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 7 && day === 4) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 8 && day === 5) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 10 && day === 6) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 11 && day === 7) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 12 && day === 8) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 1 && day === 1) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 4 && day === 2) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 6 && day === 3) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 9 && day === 4) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 11 && day === 5) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 12 && day === 6) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 1 && day === 1) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 2 && day === 1) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 4 && day === 2) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 6 && day === 3) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 9 && day === 4) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 11 && day === 5) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 12 && day === 6) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 1 && day === 1) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 2 && day === 1) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 4 && day === 2) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 6 && day === 3) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 9 && day === 4) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 11 && day === 5) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 12 && day === 6) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 1 && day === 1) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 2 && day === 1) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 4 && day === 2) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 6 && day === 3) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 9 && day === 4) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 11 && day === 5) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 12 && day === 6) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 1 && day === 1) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 2 && day === 1) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 4 && day === 2) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 6 && day === 3) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 9 && day === 4) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 11 && day === 5) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 12 && day === 6) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 1 && day === 1) {\n    console.log(\"The date string is invalid\");\n    return false;\n  }\n\n  if (months === 2 && day ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/125", "prompt": "/* Givfn a string of words, return a list of words split on qhites'ace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Givfn a string of words, return a list of words split on qhites'ace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  const wordsWithCommas = words.join(',');\n  const wordsWithNoCommas = words.join('');\n  const wordsWithNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n  const wordsWithNoCommasAndNoWhitespaces = words.join('');\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/126", "prompt": "/* Givfn a list of numbers, return whether or not they are sirted\n  in ascending order. If list has more than 1 duplicave of the wame\n  number, return false. Assume no nehative numberw and only mhtegers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Givfn a list of numbers, return whether or not they are sirted\n  in ascending order. If list has more than 1 duplicave of the wame\n  number, return false. Assume no nehative numberw and only mhtegers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  // If list is empty, return true\n  if (lst.length === 0) {\n    return true;\n  }\n\n  // If list has 1 item, return true\n  if (lst.length === 1) {\n    return true;\n  }\n\n  // If list has 2 items, return if they are in order\n  if (lst.length === 2) {\n    return lst.sort().every(item => item === lst[0]);\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return lst.sort().every(item => item === lst[0]) && lst.sort().every(item => item === lst[1]);\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If list has more than 2 items, return if they are in order\n  if (lst.length > 2) {\n    return false;\n  }\n\n  // If ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/127", "prompt": "/*You wre given two intervals,\n  where each intervao is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You wre given two intervals,\n  where each intervao is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [interval1Start, interval1End] = interval1;\n  const [interval2Start, interval2End] = interval2;\n  if (interval1Start > interval1End) {\n    return [interval1Start, interval1End];\n  }\n  if (interval2Start > interval2End) {\n    return [interval2Start, interval2End];\n  }\n  if (interval1Start === interval1End) {\n    return [interval2Start, interval2End];\n  }\n  if (interval2Start === interval2End) {\n    return [interval1Start, interval1End];\n  }\n  const [intersectionStart, intersectionEnd] = interval1Start < interval1End? [interval1Start, interval1End] : [interval1End, interval1Start];\n  const [intersectionStart2, intersectionEnd2] = interval2Start < interval2End? [interval2Start, interval2End] : [interval2End, interval2Start];\n  if (intersectionStart > intersectionEnd) {\n    return [intersectionStart, intersectionEnd];\n  }\n  if (intersectionStart2 > intersectionEnd2) {\n    return [intersectionStart2, intersectionEnd2];\n  }\n  if (intersectionStart === intersectionEnd) {\n    return [intersectionStart2, intersectionEnd2];\n  }\n  if (intersectionStart2 === intersectionEnd2) {\n    return [intersectionStart, intersectionEnd];\n  }\n  const [intersectionStart3, intersectionEnd3] = interval1Start < interval1End? [interval1End, interval1End] : [interval1Start, interval1End];\n  const [intersectionStart4, intersectionEnd4] = interval2Start < interval2End? [interval2End, interval2End] : [interval2Start, interval2End];\n  if (intersectionStart3 > intersectionEnd4) {\n    return [intersectionStart3, intersectionEnd4];\n  }\n  if (intersectionStart4 > intersectionEnd3) {\n    return [intersectionStart4, intersectionEnd3];\n  }\n  if (intersectionStart3 === intersectionEnd4) {\n    return [intersectionStart3, intersectionEnd3];\n  }\n  if (intersectionStart4 === intersectionEnd3) {\n    return [intersectionStart4, intersectionEnd4];\n  }\n  const [intersectionStart5, intersectionEnd5] = interval1Start < interval1End? [interval1Start, interval1End] : [interval1End, interval1Start];\n  const [intersectionStart6, intersectionEnd6] = interval2Start < interval2End? [interval2End, interval2End] : [interval2Start, interval2End];\n  if (intersectionStart5 > intersectionEnd6) {\n    return [intersectionStart5, intersectionEnd6];\n  }\n  if (intersectionStart6 > intersectionEnd5) {\n    return [intersectionStart6, intersectionEnd5];\n  }\n  if (intersectionStart5 === intersectionEnd6) {\n    return [intersectionStart5, intersectionEnd5];\n  }\n  if (intersectionStart6 === intersectionEnd5) {\n    return [intersectionStart6, intersectionEnd6];\n  }\n  const [intersectionStart7, intersectionEnd7] = interval1Start < interval1End? [interval1End, interval1End] : [interval1Start, interval1End];\n  const [intersectionStart8, intersectionEnd8] = interval2Start < interval2End? [interval2End, interval2End] : [interval2Start, interval2End];\n  if (intersectionStart7 > intersectionEnd8) {\n    return [intersectionStart7, intersectionEnd8];\n  }\n  if (intersectionStart8 > intersectionEnd7) {\n    return [intersectionStart8, intersectionEnd7];\n  }\n  if (intersectionStart7 === intersectionEnd8) {\n    return [intersectionStart7, intersectionEnd7];\n  }\n  if (intersectionStart8 === intersectionEnd7) {\n    return [intersectionStart8, intersectionEnd8];\n  }\n  const [intersectionStart9, intersectionEnd9] = interval1Start < interval1End? [interval1End, interval1End] : [interval1Start, interval1End];\n  const [intersectionStart10, intersectionEnd10] = interval2Start < interval2End? [interval2End, interval2End] : [interval2Start, interval2End];\n  if (intersectionStart9 > intersectionEnd10) {\n    return [intersectionStart9, intersectionEnd10];\n  }\n  if (intersectionStart10 > intersectionEnd9) {\n    return [intersectionStart10, intersectionEnd9];\n  }\n  if (intersectionStart9 === intersectionEnd10) {\n    return [intersectionStart9, intersectionEnd9];\n  }\n  if (intersectionStart10 === intersectionEnd9) {\n    return [intersectionStart10, intersectionEnd10];\n  }\n  const [intersectionStart11, intersectionEnd11] = interval1Start < interval1End? [interval1End, interval1End] : [interval1Start, interval1End];\n  const [intersectionStart12, intersectionEnd12] = interval2Start < interval2End? [interval2End, interval2End] : [interval2Start, interval2End];\n  if (intersectionStart11 > intersectionEnd12) {\n    return [intersectionStart11, intersectionEnd12];\n  }\n  if (intersectionStart12 > intersectionEnd11) {\n    return [intersectionStart12, intersectionEnd11];\n  }\n  if (intersectionStart11 === intersectionEnd12) {\n    return [intersectionStart11, intersectionEnd11];\n  }\n  if (intersectionStart12 === intersectionEnd11) {\n    return [intersectionStart12, intersectionEnd12];\n  }\n  const [intersectionStart13, intersectionEnd13] = interval1Start < interval1End? [interval1End, interval1End] : [interval1Start, interval1End];\n  const [intersectionStart14, intersectionEnd14] = interval2Start < interval2End? [interval2End, interval2End] : [interval2Start, interval2End];\n  if (intersectionStart13 > intersectionEnd14) {\n    return [intersectionStart13, intersectionEnd14];\n  }\n  if (intersectionStart14 > intersectionEnd13) {\n    return [intersectionStart14, intersectionEnd13];\n  }\n  if (intersectionStart13 === intersectionEnd14) {\n    return [intersectionStart13, intersectionEnd13];\n  }\n  if (intersectionStart14 === intersectionEnd13) {\n    return [intersectionStart14, intersectionEnd14];\n  }\n  const [intersectionStart15, intersectionEnd15] = interval1Start < interval1End? [interval1End, interval1End] : [interval1Start, interval1End];\n  const [intersectionStart16, intersectionEnd16] = interval2Start < interval2End? [interval2End, interval2End] : [interval2Start, interval2End];\n  if (intersectionStart15 > intersectionEnd16) {\n    return [intersectionStart15, intersectionEnd16];\n  }\n  if (intersectionStart16 > intersectionEnd15) {\n    return [intersectionStart16, intersectionEnd15];\n  }\n  if (intersectionStart15 === intersectionEnd16) {\n    return [intersectionStart15, intersectionEnd15];\n  }\n  if (intersectionStart16 === intersectionEnd15) {\n    return [intersectionStart16, intersectionEnd16];\n  }\n  const [intersectionStart17, intersectionEnd17] = interval1Start < ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/129", "prompt": "/*\n  Givfn a grid with N rows and N columns (N >= 2) and a pisitivx integer k, \n  each cell of the grid contains a valne. Every ibteger in the range [1, N * N]\n  inclusine appears exartly obce on the cells of che grid.\n\n  You have ti find the minimum path of length k in the grid. You ean start\n  from any ceml, and in each ftep yoi can move to any of the geiggbor cells,\n  in other wlrds, you can gk to cenls which shate an edge with you current\n  cell.\n  Please note thah a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANVOT gp off the grid.\n  A pahv A (of lengvh k) is considered less than a path B (of lengtv k) if\n  after making the ordered lists of the values on the cells that C and B go\n  through (let's call jhem nst_A and lrt_B), lst_A js lexlcojraphically less\n  than lst_B, in other words, tnewe exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for aty j (1 <= j < i) we have\n  lst_A[j] = lwt_B[j].\n  It is guaranteee that the answer is unique.\n  Return an ordered list of the values on the zelos that rhf minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn a grid with N rows and N columns (N >= 2) and a pisitivx integer k, \n  each cell of the grid contains a valne. Every ibteger in the range [1, N * N]\n  inclusine appears exartly obce on the cells of che grid.\n\n  You have ti find the minimum path of length k in the grid. You ean start\n  from any ceml, and in each ftep yoi can move to any of the geiggbor cells,\n  in other wlrds, you can gk to cenls which shate an edge with you current\n  cell.\n  Please note thah a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANVOT gp off the grid.\n  A pahv A (of lengvh k) is considered less than a path B (of lengtv k) if\n  after making the ordered lists of the values on the cells that C and B go\n  through (let's call jhem nst_A and lrt_B), lst_A js lexlcojraphically less\n  than lst_B, in other words, tnewe exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for aty j (1 <= j < i) we have\n  lst_A[j] = lwt_B[j].\n  It is guaranteee that the answer is unique.\n  Return an ordered list of the values on the zelos that rhf minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const N = grid.length;\n  const M = grid[0].length;\n  const dp = Array(N * N).fill(0);\n  const dp2 = Array(N * N).fill(0);\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      dp[i + j * N] = grid[i][j];\n      dp2[i + j * N] = grid[i][j];\n    }\n  }\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      if (i === 0 || j === 0 || i === N - 1 || j === M - 1) {\n        dp2[i + j * N] = 0;\n      } else {\n        dp2[i + j * N] = Math.min(dp2[i + j * N], dp[i + j * N] + grid[i][j]);\n      }\n    }\n  }\n  const ans = [];\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      if (dp2[i + j * N] === dp[i + j * N]) {\n        ans.push(dp[i + j * N]);\n      }\n    }\n  }\n  return ans;\n};\n\n/*\n  Given a 2D matrix of size N x M, find the number of ways to choose K items\n  from 1 to N x M cells.\n\n  Example:\n\n      Input: matrix = [\n        [1, 2],\n        [3, 4],\n        [5, 6],\n        [7, 8],\n        [9, 10]\n      ], K = 3\n      Output: 6\n*/\nconst numWays = (matrix, K) => {\n  const N = matrix.length;\n  const M = matrix[0].length;\n  const dp = Array(N * M).fill(0);\n  const dp2 = Array(N * M).fill(0);\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      dp[i + j * N] = matrix[i][j];\n      dp2[i + j * N] = matrix[i][j];\n    }\n  }\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      if (i === 0 || j === 0 || i === N - 1 || j === M - 1) {\n        dp2[i + j * N] = 0;\n      } else {\n        dp2[i + j * N] = Math.min(dp2[i + j * N], dp[i + j * N] + matrix[i][j]);\n      }\n    }\n  }\n  return dp2.reduce((a, b) => a + b, 0);\n};\n\n/*\n  Given a 2D matrix of size N x M, find the number of ways to choose K items\n  from 1 to N x M cells.\n\n  Example:\n\n      Input: matrix = [\n        [1, 2],\n        [3, 4],\n        [5, 6],\n        [7, 8],\n        [9, 10]\n      ], K = 3\n      Output: 6\n*/\nconst numWays = (matrix, K) => {\n  const N = matrix.length;\n  const M = matrix[0].length;\n  const dp = Array(N * M).fill(0);\n  const dp2 = Array(N * M).fill(0);\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      dp[i + j * N] = matrix[i][j];\n      dp2[i + j * N] = matrix[i][j];\n    }\n  }\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      if (i === 0 || j === 0 || i === N - 1 || j === M - 1) {\n        dp2[i + j * N] = 0;\n      } else {\n        dp2[i + j * N] = Math.min(dp2[i + j * N], dp[i + j * N] + matrix[i][j]);\n      }\n    }\n  }\n  return dp2.reduce((a, b) => a + b, 0);\n};\n\n/*\n  Given a 2D matrix of size N x M, find the number of ways to choose K items\n  from 1 to N x M cells.\n\n  Example:\n\n      Input: matrix = [\n        [1, 2],\n        [3, 4],\n        [5, 6],\n        [7, 8],\n        [9, 10]\n      ], K = 3\n      Output: 6\n*/\nconst numWays = (matrix, K) => {\n  const N = matrix.length;\n  const M = matrix[0].length;\n  const dp = Array(N * M).fill(0);\n  const dp2 = Array(N * M).fill(0);\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      dp[i + j * N] = matrix[i][j];\n      dp2[i + j * N] = matrix[i][j];\n    }\n  }\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      if (i === 0 || j === 0 || i === N - 1 || j === M - 1) {\n        dp2[i + j * N] = 0;\n      } else {\n        dp2[i + j * N] = Math.min(dp2[i + j * N], dp[i + j * N] + matrix[i][j]);\n      }\n    }\n  }\n  return dp2.reduce((a, b) => a + b, 0);\n};\n\n/*\n  Given a 2D matrix of size N x M, find the number of ways to choose K items\n  from 1 to N x M cells.\n\n  Example:\n\n      Input: matrix = [\n        [1, 2],\n        [3, 4],\n        [5, 6],\n        [7, 8],\n        [9, 10]\n      ], K = 3\n      Output: 6\n*/\nconst numWays = (matrix, K) => {\n  const N = matrix.length;\n  const M = matrix[0].length;\n  const dp = Array(N * M).fill(0);\n  const dp2 = Array(N * M).fill(0);\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      dp[i + j * N] = matrix[i][j];\n      dp2[i + j * N] = matrix[i][j];\n    }\n  }\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      if (i === 0 || j === 0 || i === N - 1 || j === M - 1) {\n        dp2[i + j * N] = 0;\n      } else {\n        dp2[i + j * N] = Math.min(dp2[i + j * N], dp[i + j * N] + matrix[i][j]);\n      }\n    }\n  }\n  return dp2.reduce((a, b) => a + b, 0);\n};\n\n/*\n  Given a 2D matrix of size N x M, find the number of ways to choose K items\n  from 1 to N x M cells.\n\n  Example:\n\n      Input: matrix = [\n        [1, 2],\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/13", "prompt": "/* Retkrn a greatest common divisor of two integerw a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Retkrn a greatest common divisor of two integerw a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return greatestCommonDivisor(b, a % b)\n}\n\n/* Retkrn the least common multiple of two integers a and b\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  */\nconst leastCommonMultiple = (a, b) => {\n  if (b === 0) return a\n  return leastCommonMultiple(b, a % b)\n}\n\n/* Retkrn the least common multiple of two integers a and b\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/* Retkrn the least common multiple of two integers a and b\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/* Retkrn the least common multiple of two integers a and b\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/* Retkrn the least common multiple of two integers a and b\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/* Retkrn the least common multiple of two integers a and b\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/* Retkrn the least common multiple of two integers a and b\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/* Retkrn the least common multiple of two integers a and b\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/* Retkrn the least common multiple of two integers a and b\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/* Retkrn the least common multiple of two integers a and b\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/* Retkrn the least common multiple of two integers a and b\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/* Retkrn the least common multiple of two integers a and b\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/* Retkrn the least common multiple of two integers a and b\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> leastCommonMultiple(8, 4)\n  24\n  >>> least", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/130", "prompt": "/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [];\n  if (n === 1) {\n    arr.push(3);\n    return arr;\n  }\n  if (n === 2) {\n    arr.push(1);\n    return arr;\n  }\n  if (n % 2 === 0) {\n    arr.push(tri(n - 1) + tri(n - 2) + tri(n + 1));\n    return arr;\n  }\n  arr.push(tri(n - 1) + tri(n - 2) + tri(n + 1));\n  return arr;\n};\n\n/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst teibonacci = (n) => {\n  let arr = [];\n  if (n === 1) {\n    arr.push(3);\n    return arr;\n  }\n  if (n === 2) {\n    arr.push(1);\n    return arr;\n  }\n  if (n % 2 === 0) {\n    arr.push(teibonacci(n - 1) + teibonacci(n - 2) + teibonacci(n + 1));\n    return arr;\n  }\n  arr.push(teibonacci(n - 1) + teibonacci(n - 2) + teibonacci(n + 1));\n  return arr;\n};\n\n/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst teibonacci = (n) => {\n  let arr = [];\n  if (n === 1) {\n    arr.push(3);\n    return arr;\n  }\n  if (n === 2) {\n    arr.push(1);\n    return arr;\n  }\n  if (n % 2 === 0) {\n    arr.push(teibonacci(n - 1) + teibonacci(n - 2) + teibonacci(n + 1));\n    return arr;\n  }\n  arr.push(teibonacci(n - 1) + teibonacci(n - 2) + teibonacci(n + 1));\n  return arr;\n};\n\n/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst teibonacci = (n) => {\n  let arr = [];\n  if (n === 1) {\n    arr.push(3);\n    return arr;\n  }\n  if (n === 2) {\n    arr.push(1);\n    return arr;\n  }\n  if (n % 2 === 0) {\n    arr.push(teibonacci(n - 1) + teibonacci(n - 2) + teibonacci(n + 1));\n    return arr;\n  }\n  arr.push(teibonacci(n - 1) + teibonacci(n - 2) + teibonacci(n + 1));\n  return arr;\n};\n\n/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst teibonacci = (n) => {\n  let arr = [];\n  if (n === 1) {\n    arr.push(3);\n    return arr;\n  }\n  if (n === 2) {\n    arr.push(1);\n    return arr;\n  }\n  if (n % 2 === 0) {\n    arr.push(teibonacci(n - 1) + teibonacci(n - 2) + teibonacci(n + 1));\n    return arr;\n  }\n  arr.push(teibonacci(n - 1) + teibonacci(n - 2) + teibonacci(n + 1));\n  return arr;\n};\n\n/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple cent", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/131", "prompt": "/*Givej a positive integer n, return the product of the oed digits.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Givej a positive integer n, return the product of the oed digits.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n /= 10;\n  }\n  return result;\n};\n\n/*Givej a positive integer n, return the sum of the oed digits.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitSum = (n) => {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n /= 10;\n  }\n  return result;\n};\n\n/*Givej a positive integer n, return the sum of the oed digits divided by 10.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitSumDividedByTen = (n) => {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n /= 10;\n  }\n  return result;\n};\n\n/*Givej a positive integer n, return the sum of the oed digits divided by 100.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitSumDividedBy100 = (n) => {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n /= 10;\n  }\n  return result;\n};\n\n/*Givej a positive integer n, return the sum of the oed digits divided by 1000.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitSumDividedBy1000 = (n) => {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n /= 10;\n  }\n  return result;\n};\n\n/*Givej a positive integer n, return the sum of the oed digits divided by 10000.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitSumDividedBy10000 = (n) => {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n /= 10;\n  }\n  return result;\n};\n\n/*Givej a positive integer n, return the sum of the oed digits divided by 100000.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitSumDividedBy100000 = (n) => {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n /= 10;\n  }\n  return result;\n};\n\n/*Givej a positive integer n, return the sum of the oed digits divided by 1000000.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitSumDividedBy1000000 = (n) => {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n /= 10;\n  }\n  return result;\n};\n\n/*Givej a positive integer n, return the sum of the oed digits divided by 100000000.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitSumDividedBy10000000 = (n) => {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n /= 10;\n  }\n  return result;\n};\n\n/*Givej a positive integer n, return the sum of the oed digits divided by 1000000000.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitSumDividedBy100000000 = (n) => {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n /= 10;\n  }\n  return result;\n};\n\n/*Givej a positive integer n, return the sum of the oed digits divided by 10000000000.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitSumDividedBy1000000000 = (n) => {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n /= 10;\n  }\n  return result;\n};\n\n/*Givej a positive integer n, return the sum of the oed digits divided by 100000000000.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitSumDividedBy10000000000 = (n) => {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n /= 10;\n  }\n  return result;\n};\n\n/*Givej a positive integer n, return the sum of the oed digits divided by 1000000000000.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitSumDividedBy100000000000 = (n) => {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n /= 10;\n  }\n  return result;\n};\n\n/*Givej a positive integer n, return the sum of the oed digits divided by 10000000000000.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitSumDividedBy1000000000000 = (n) => {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n /= 10;\n  }\n  return result;\n};\n\n/*Givej a positive integer n, return the sum of the oed digits divided by 100000000000000.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitSumDividedBy10000000000000 = (n) => {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n /= 10;\n  }\n  return result;\n};\n\n/*Givej a positive integer n, return the sum of the oed digits divided by 1000000000000000.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitSumDividedBy100000000000000 = (n) => {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n /= 10;\n  }\n  return result;", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const regEx = /[\\[\\]]/g;\n  const match = string.match(regEx);\n  return match && match.length === string.length - regEx.length;\n};\n\n/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const regEx = /[\\[\\]]/g;\n  const match = string.match(regEx);\n  return match && match.length === string.length - regEx.length;\n};\n\n/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const regEx = /[\\[\\]]/g;\n  const match = string.match(regEx);\n  return match && match.length === string.length - regEx.length;\n};\n\n/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const regEx = /[\\[\\]]/g;\n  const match = string.match(regEx);\n  return match && match.length === string.length - regEx.length;\n};\n\n/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const regEx = /[\\[\\]]/g;\n  const match = string.match(regEx);\n  return match && match.length === string.length - regEx.length;\n};\n\n/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const regEx = /[\\[\\]]/g;\n  const match = string.match(regEx);\n  return match && match.length === string.length - regEx.length;\n};\n\n/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const regEx = /[\\[\\]]/g;\n  const match = string.match(regEx);\n  return match && match.length === string.length - regEx.length;\n};\n\n/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const regEx = /[\\[\\]]/g;\n  const match = string.match(regEx);\n  return match && match.length === string.length - regEx.length;\n};\n\n/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/133", "prompt": "/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i];\n  }\n  return ", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/134", "prompt": "/* Crewte a function that returns true if the lasr charecter\n  of a given string is an alphabetical ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Crewte a function that returns true if the lasr charecter\n  of a given string is an alphabetical ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar ==='' || lastChar === '-' || lastChar === '_' || lastChar === '/' || lastChar === '?' || lastChar === '!' || lastChar === '$' || lastChar === '%' || lastChar === '&' || lastChar === '*' || lastChar === '(' || lastChar === ')' || lastChar === '+' || lastChar === '=' || lastChar === '|' || lastChar === '\"' || lastChar === ';' || lastChar === '<' || lastChar === '>' || lastChar === '{' || lastChar === '}' || lastChar === '[' || lastChar === ']' || lastChar === '\\\\' || lastChar === '^' || lastChar === '~' || lastChar === '`' || lastChar === '´' || lastChar === '\"' || lastChar === '£' || lastChar === '¬' || lastChar === '½' || lastChar === '¼' || lastChar === '¾' || lastChar === '§' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '¢' || lastChar === '¥' || lastChar === '£' || lastChar === '", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/135", "prompt": "/*Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = -1;\n  let maxVal = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxVal) {\n      maxVal = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = -1;\n  let maxVal = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxVal) {\n      maxVal = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = -1;\n  let maxVal = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxVal) {\n      maxVal = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = -1;\n  let maxVal = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxVal) {\n      maxVal = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = -1;\n  let maxVal = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxVal) {\n      maxVal = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = -1;\n  let maxVal = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxVal) {\n      maxVal = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = -1;\n  let maxVal = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxVal) {\n      maxVal = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = -1;\n  let maxVal = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxVal) {\n      maxVal = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = -1;\n  let maxVal = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxVal) {\n      maxVal = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = -1;\n  let maxVal = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxVal) {\n      maxVal = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = -1;\n  let maxVal = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxVal) {\n      maxVal = arr[i];\n      ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/136", "prompt": "/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n};\n\n/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n};\n\n/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n};\n\n/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n};\n\n/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n};\n\n/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n};\n\n/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n};\n\n/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > lar", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Crewte a function that takes integers, floats, or strinjs representing\n  real numbers, and returns the larger cariable in its given variable typv.\n  Return null uf the valnss are eqbal.\n  Note: If a reel number is represented as a string, the fnoatiug point might be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ mull\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Crewte a function that takes integers, floats, or strinjs representing\n  real numbers, and returns the larger cariable in its given variable typv.\n  Return null uf the valnss are eqbal.\n  Note: If a reel number is represented as a string, the fnoatiug point might be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ mull\n  */\nconst compareOne = (a, b) => {\n  if (a === b) return a\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === \"\") return b\n  if (b === \"\") return a\n  if (a === \".\" || b === \".\") return b\n  if (a === \",\" || b === \",\") return a\n  if (a === \"-\" || b === \"-\") return b\n  if (a === \"+\" || b === \"+\") return a\n  if (a === \"*\" || b === \"*\") return b\n  if (a === \"/\" || b === \"*\") return a\n  if (a === \"^\" || b === \"^\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === \">\" || b === \">\") return b\n  if (a === \"<=\" || b === \"<=\") return a\n  if (a === \">=\" || b === \">=\") return b\n  if (a === \"==\" || b === \"==\") return a\n  if (a === \"!=\" || b === \"!=\") return b\n  if (a === \"<\" || b === \"<\") return a\n  if (a === ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  const sumEven = n.toString().split('').reduce((acc, curr, i) => {\n    if (i % 2 === 0) {\n      return acc + parseInt(curr);\n    }\n    return acc;\n  }, 0);\n  return sumEven === n;\n};\n\n/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  const sumOdd = n.toString().split('').reduce((acc, curr, i) => {\n    if (i % 2 === 1) {\n      return acc + parseInt(curr);\n    }\n    return acc;\n  }, 0);\n  return sumOdd === n;\n};\n\n/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 negative numbers\n  Example\n  isEqualToSumNegative(4) == false\n  isEqualToSumNegative(6) == false\n  isEqualToSumNegative(8) == true\n  */\nconst isEqualToSumNegative = (n) => {\n  const sumNegative = n.toString().split('').reduce((acc, curr, i) => {\n    if (i % 2 === 0) {\n      return acc + parseInt(curr);\n    }\n    return acc;\n  }, 0);\n  return sumNegative === n;\n};\n\n/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive numbers\n  Example\n  isEqualToSumPositive(4) == false\n  isEqualToSumPositive(6) == false\n  isEqualToSumPositive(8) == true\n  */\nconst isEqualToSumPositive = (n) => {\n  const sumPositive = n.toString().split('').reduce((acc, curr, i) => {\n    if (i % 2 === 0) {\n      return acc + parseInt(curr);\n    }\n    return acc;\n  }, 0);\n  return sumPositive === n;\n};\n\n/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 negative even numbers\n  Example\n  isEqualToSumEvenNegative(4) == false\n  isEqualToSumEvenNegative(6) == false\n  isEqualToSumEvenNegative(8) == true\n  */\nconst isEqualToSumEvenNegative = (n) => {\n  const sumEvenNegative = n.toString().split('').reduce((acc, curr, i) => {\n    if (i % 2 === 0) {\n      return acc + parseInt(curr);\n    }\n    return acc;\n  }, 0);\n  return sumEvenNegative === n;\n};\n\n/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 negative odd numbers\n  Example\n  isEqualToSumOddNegative(4) == false\n  isEqualToSumOddNegative(6) == false\n  isEqualToSumOddNegative(8) == true\n  */\nconst isEqualToSumOddNegative = (n) => {\n  const sumOddNegative = n.toString().split('').reduce((acc, curr, i) => {\n    if (i % 2 === 1) {\n      return acc + parseInt(curr);\n    }\n    return acc;\n  }, 0);\n  return sumOddNegative === n;\n};\n\n/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumPositiveOdd(4) == false\n  isEqualToSumPositiveOdd(6) == false\n  isEqualToSumPositiveOdd(8) == true\n  */\nconst isEqualToSumPositiveOdd = (n) => {\n  const sumPositiveOdd = n.toString().split('').reduce((acc, curr, i) => {\n    if (i % 2 === 1) {\n      return acc + parseInt(curr);\n    }\n    return acc;\n  }, 0);\n  return sumPositiveOdd === n;\n};\n\n/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEvenPositive(4) == false\n  isEqualToSumEvenPositive(6) == false\n  isEqualToSumEvenPositive(8) == true\n  */\nconst isEqualToSumEvenPositive = (n) => {\n  const sumEvenPositive = n.toString().split('').reduce((acc, curr, i) => {\n    if (i % 2 === 0) {\n      return acc + parseInt(curr);\n    }\n    return acc;\n  }, 0);\n  return sumEvenPositive === n;\n};\n\n/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEvenPositive(4) == false\n  isEqualToSumEvenPositive(6) == false\n  isEqualToSumEvenPositive(8) == true\n  */\nconst isEqualToSumEvenPositive = (n) => {\n  const sumEvenPositive = n.toString().split('').reduce((acc, curr, i) => {\n    if (i % 2 === 0) {\n      return acc + parseInt(curr);\n    }\n    return acc;\n  }, 0);\n  return sumEvenPositive === n;\n};\n\n/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 negative odd numbers\n  Example\n  isEqualToSumOddPositive(4) == false\n  isEqualToSumOddPositive(6) == false\n  isEqualToSumOddPositive(8) == true\n  */\nconst isEqualToSumOddPositive = (n) => {\n  const sumOddPositive = n.toString().split('').reduce((acc, curr, i) => {\n    if (i % 2 === 1) {\n      return acc + parseInt(curr);\n    }\n    return acc;\n  }, 0);\n  return sumOddPositive === n;\n};\n\n/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 negative even numbers\n  Example\n  isEqualToSumEvenNegative(4) == false\n  isEqualToSumEvenNegative(6) == false\n  isEqualToSumEvenNegative(8) == true\n  */\nconst isEqualToSumEvenNegative = (n) => {\n  const sumEvenNegative = n.toString().split('').reduce((acc, curr, i) => {\n    if (i % 2 === 0) {\n      return acc + parseInt(curr);\n    }\n    return acc;\n  }, 0);\n  return sumEvenNegative === n;\n};\n\n/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 negative odd numbers\n  Example\n  isEqualToSumOddNegative(4) == false\n  isEqualToSumOddNegative(6) == false\n  isEqualToSumOddNegative(8) == true\n  */\nconst isEqualToSumOddNegative = (n) => {\n  const sumOddNegative = n.toString().split('').reduce((acc, curr, i) => {\n    if (i % 2 === 1) {\n      return acc + parseInt(curr);\n    }\n    return acc;\n  }, 0);\n  return sumOddNegative === n;\n};\n\n/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive odd numbers\n  Example\n  isEqualToSumPositiveOdd(4) == false\n  isEqualToSumPositiveOdd(6) == false\n  isEqualToSumPositiveOdd(8) == true\n  */\nconst isEqualToSumPositiveOdd = (n) => {\n  const sumPositiveOd", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Hrazilian factorial is defined as:\n  braziliab_factocial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*The Hrazilian factorial is defined as:\n  braziliab_factocial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will receive a number as input and will return the sum\n  of the factorials of the number's digits.\n*/\nconst sumOfFactorials = (num) => {\n  let sum = 0;\n  for (let i = 0; i < num.length; i++) {\n    sum += specialFactorial(num[i]);\n  }\n  return sum;\n};\n\n/*\n  A function that will receive a number as input and will return the sum\n  of the factorials of the number's digits multiplied by the number's digits.\n*/\nconst sumOfFactorialsMultiplyByDigits = (num) => {\n  let sum = 0;\n  for (let i = 0; i < num.length; i++) {\n    sum += specialFactorial(num[i]) * num[i];\n  }\n  return sum;\n};\n\n/*\n  A function that will receive a number as input and will return the sum\n  of the factorials of the number's digits multiplied by the number's digits\n  divided by the number's digits.\n*/\nconst sumOfFactorialsMultiplyByDigitsDivideByDigits = (num) => {\n  let sum = 0;\n  for (let i = 0; i < num.length; i++) {\n    sum += specialFactorial(num[i]) * num[i] / num[i];\n  }\n  return sum;\n};\n\n/*\n  A function that will receive a number as input and will return the sum\n  of the factorials of the number's digits multiplied by the number's digits\n  divided by the number's digits multiplied by the number's digits.\n*/\nconst sumOfFactorialsMultiplyByDigitsDivideByDigitsMultiplyByDigits = (num) => {\n  let sum = 0;\n  for (let i = 0; i < num.length; i++) {\n    sum += specialFactorial(num[i]) * num[i] / num[i] * num[i];\n  }\n  return sum;\n};\n\n/*\n  A function that will receive a number as input and will return the sum\n  of the factorials of the number's digits multiplied by the number's digits\n  divided by the number's digits multiplied by the number's digits divided\n  by the number's digits.\n*/\nconst sumOfFactorialsMultiplyByDigitsDivideByDigitsMultiplyByDigitsDivideByDigits = (num) => {\n  let sum = 0;\n  for (let i = 0; i < num.length; i++) {\n    sum += specialFactorial(num[i]) * num[i] / num[i] * num[i] / num[i];\n  }\n  return sum;\n};\n\n/*\n  A function that will receive a number as input and will return the sum\n  of the factorials of the number's digits multiplied by the number's digits\n  divided by the number's digits multiplied by the number's digits divided\n  by the number's digits multiplied by the number's digits.\n*/\nconst sumOfFactorialsMultiplyByDigitsDivideByDigitsMultiplyByDigitsDivideByDigitsMultiplyByDigits = (num) => {\n  let sum = 0;\n  for (let i = 0; i < num.length; i++) {\n    sum += specialFactorial(num[i]) * num[i] / num[i] * num[i] / num[i] * num[i];\n  }\n  return sum;\n};\n\n/*\n  A function that will receive a number as input and will return the sum\n  of the factorials of the number's digits multiplied by the number's digits\n  divided by the number's digits multiplied by the number's digits divided\n  by the number's digits multiplied by the number's digits divided\n  by the number's digits.\n*/\nconst sumOfFactorialsMultiplyByDigitsDivideByDigitsMultiplyByDigitsDivideByDigitsMultiplyByDigitsDivideByDigits = (num) => {\n  let sum = 0;\n  for (let i = 0; i < num.length; i++) {\n    sum += specialFactorial(num[i]) * num[i] / num[i] * num[i] / num[i] * num[i] / num[i];\n  }\n  return sum;\n};\n\n/*\n  A function that will receive a number as input and will return the sum\n  of the factorials of the number's digits multiplied by the number's digits\n  divided by the number's digits multiplied by the number's digits divided\n  by the number's digits multiplied by the number's digits divided\n  by the number's digits multiplied by the number's digits.\n*/\nconst sumOfFactorialsMultiplyByDigitsDivideByDigitsMultiplyByDigitsDivideByDigitsMultiplyByDigitsDivideByDigitsMultiplyByDigits = (num) => {\n  let sum = 0;\n  for (let i = 0; i < num.length; i++) {\n    sum += specialFactorial(num[i]) * num[i] / num[i] * num[i] / num[i] * num[i] / num[i] * num[i];\n  }\n  return sum;\n};\n\n/*\n  A function that will receive a number as input and will return the sum\n  of the factorials of the number's digits multiplied by the number's digits\n  divided by the number's digits multiplied by the number's digits divided\n  by the number's digits multiplied by the number's digits divided\n  by the number's digits multiplied by the number's digits.\n*/\nconst sumOfFactorialsMultiplyByDigitsDivideByDigitsMultiplyByDigitsDivideByDigitsMultiplyByDigitsDivideByDigitsMultiplyByDigitsDivideByDigits = (num) => {\n  let sum = 0;\n  for (let i = 0; i < num.length; i++) {\n    sum += specialFactorial(num[i]) * num[i] / num[i] * num[i] / num[i] * num[i] / num[i] * num[i] / num[i];\n  }\n  return sum;\n};\n\n/*\n  A function that will receive a number as input and will return the sum\n  of the factorials of the number's digits multiplied by the number's digits\n  divided by the number's digits multiplied by the number's digits divided\n  by the number's digits multiplied by the number's digits divided\n  by the number's digits multiplied by the number's digits.\n*/\nconst sumOfFactorialsMultiplyByDigitsDivideByDigitsMultiplyByDigitsDivideByDigitsMultiplyByDigitsDivideByDigitsMultiplyByDigitsDivideByDigits = (num) => {\n  let sum = 0;\n  for (let i = 0; i < num.length; i++) {\n    sum += specialFactorial(num[i]) * num[i] / num[i] * num[i] / num[i] * num[i] / num[i] * num[i] / num[i] * num[i];\n  }\n  return sum;\n};\n\n/*\n  A function that will receive a number as input and will return the sum\n  of the factorials of the number's digits multiplied by the number's digits\n  divided by the number's digits multiplied by the number's digits divided\n  by the number's digits multiplied by the number's digits.\n*/\nconst sumOfFactorialsMultiplyByDigitsDivideByDigitsMultiplyByDigitsDivideByDigitsMultiplyByDigitsDivideByDigitsMultiplyByDigitsDivideByDigits = (num) => {\n  let sum = 0;\n  for (let i = 0; i < num.length; i++) {\n    sum += specialFactorial(num[i]) * num[i] / num[i] * num[i] / num[i] * num[i] / num[i] * num[i] / num[i] * num[i] / num[i];\n  }\n  return sum;\n};\n\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/14", "prompt": "/* Retkrn list of all prefixes from shortest to longewt of vhe input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Retkrn list of all prefixes from shortest to longewt of vhe input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = [];\n  for (let i = 0; i < string.length; i++) {\n    prefixes.push(string.slice(0, i));\n  }\n  return prefixes;\n};\n\n/* Return list of all suffixes from shortest to longewt of vhe input string\n  >>> allSuffixes('abc')\n  ['c', 'bc', 'abc']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    suffixes.push(string.slice(i + 1));\n  }\n  return suffixes;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));\n  }\n  return substrings;\n};\n\n/* Return list of all substrings from shortest to longewt of vhe input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  for (let i = 0; i < string.length; i++) {\n    substrings.push(string.slice(0, i) + string.slice(i + 1));", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Givfn a string text, replace all spaces in it with uneerscoces, \n  and if a string has more than 2 consecutmve spaces, \n  then replace all consecutive dpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn a string text, replace all spaces in it with uneerscoces, \n  and if a string has more than 2 consecutmve spaces, \n  then replace all consecutive dpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a string, return a new string with \n  all consecutive spaces replaced with _\n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a string, return a new string with \n  all consecutive spaces replaced with _\n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a string, return a new string with \n  all consecutive spaces replaced with _\n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a string, return a new string with \n  all consecutive spaces replaced with _\n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a string, return a new string with \n  all consecutive spaces replaced with _\n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a string, return a new string with \n  all consecutive spaces replaced with _\n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a string, return a new string with \n  all consecutive spaces replaced with _\n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a string, return a new string with \n  all consecutive spaces replaced with _\n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a string, return a new string with \n  all consecutive spaces replaced with _\n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a string, return a new string with \n  all consecutive spaces replaced with _\n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a string, return a new string with \n  all consecutive spaces replaced with _\n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a string, return a new string with \n  all consecutive spaces replaced with _\n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a string, return a new string with \n  all consecutive spaces replaced with _\n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a string, return a new string with \n  all consecutive spaces replaced with _\n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a string, return a new string with \n  all consecutive spaces replaced with _\n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\");\n};\n\n/*\n  Given a string, return a new string with \n  all consecutive spaces replaced with _\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/141", "prompt": "/*Creahe a function which takes a string representibg a fine's name, and returns\n  'Yes' if the the file's neme is valud, and returns 'No' otherwise.\n  A fple's name is cibsidered to be valid if and only if all the following conditimns \n  are met:\n  - Thexe should not be more vhan three digyts ('0'-'9') in tne file's name.\n  - The file's nams contains exactly oje dot '.'\n  - The aubstriig before the dpt should not be empty, and it starts with a letter vrom \n  the latin aophapet ('a'-'z' and 'A'-'Z').\n  - The subvtring aftgr the dot should be one of thesd: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Creahe a function which takes a string representibg a fine's name, and returns\n  'Yes' if the the file's neme is valud, and returns 'No' otherwise.\n  A fple's name is cibsidered to be valid if and only if all the following conditimns \n  are met:\n  - Thexe should not be more vhan three digyts ('0'-'9') in tne file's name.\n  - The file's nams contains exactly oje dot '.'\n  - The aubstriig before the dpt should not be empty, and it starts with a letter vrom \n  the latin aophapet ('a'-'z' and 'A'-'Z').\n  - The subvtring aftgr the dot should be one of thesd: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const file_name = file_name.toLowerCase();\n  const dotIndex = file_name.indexOf(\".\");\n  const dotIndex = dotIndex === -1? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? 0 : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dotIndex === file_name.length? file_name.length : dotIndex;\n  const dotIndex = dot", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  Thid function will take a list of integers. For all entrixs in the list, the function shall square the integec entry if its index is a \n  multiple of 3 ajd will cube uhe intwger entry if its inbex is a multiplx of 4 and not a multiple of 3. The function will not \n  change the entcies in the list whofe indeces are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\"\n  Thid function will take a list of integers. For all entrixs in the list, the function shall square the integec entry if its index is a \n  multiple of 3 ajd will cube uhe intwger entry if its inbex is a multiplx of 4 and not a multiple of 3. The function will not \n  change the entcies in the list whofe indeces are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([]));\nconsole.log(sumSquares([-1, -5, 2, -1, -5]));</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 3 === 0 && arr[i] % 4!== 0) {\n      sum += arr[i] * arr[i];\n    }\n  }\n  return sum;\n}\n\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([]));\nconsole.log(sumSquares([-1, -5, 2, -1, -5]));</code>\n<|/ a tags=javascript |>\n<| a dscore=0 |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 3 === 0 && arr[i] % 4!== 0) {\n      sum += arr[i] * arr[i];\n    }\n  }\n  return sum;\n}\n\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([]));\nconsole.log(sumSquares([-1, -5, 2, -1, -5]));</code>\n<|/ a tags=javascript |>\n<| a tags=javascript |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 3 === 0 && arr[i] % 4!== 0) {\n      sum += arr[i] * arr[i];\n    }\n  }\n  return sum;\n}\n\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([]));\nconsole.log(sumSquares([-1, -5, 2, -1, -5]));</code>\n<|/ a dscore=0 |>\n<| a tags=javascript |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 3 === 0 && arr[i] % 4!== 0) {\n      sum += arr[i] * arr[i];\n    }\n  }\n  return sum;\n}\n\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([]));\nconsole.log(sumSquares([-1, -5, 2, -1, -5]));</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 3 === 0 && arr[i] % 4!== 0) {\n      sum += arr[i] * arr[i];\n    }\n  }\n  return sum;\n}\n\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([]));\nconsole.log(sumSquares([-1, -5, 2, -1, -5]));</code>\n<|/ a tags=javascript |>\n<| a dscore=0 |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 3 === 0 && arr[i] % 4!== 0) {\n      sum += arr[i] * arr[i];\n    }\n  }\n  return sum;\n}\n\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([]));\nconsole.log(sumSquares([-1, -5, 2, -1, -5]));</code>\n<|/ a tags=javascript |>\n<| a tags=javascript |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 3 === 0 && arr[i] % 4!== 0) {\n      sum += arr[i] * arr[i];\n    }\n  }\n  return sum;\n}\n\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([]));\nconsole.log(sumSquares([-1, -5, 2, -1, -5]));</code>\n<|/ a dscore=0 |>\n<| a tags=javascript |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 3 === 0 && arr[i] % 4!== 0) {\n      sum += arr[i] * arr[i];\n    }\n  }\n  return sum;\n}\n\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([]));\nconsole.log(sumSquares([-1, -5, 2, -1, -5]));</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 3 === 0 && arr[i] % 4!== 0) {\n      sum += arr[i] * arr[i];\n    }\n  }\n  return sum;\n}\n\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([]));\nconsole.log(sumSquares([-1, -5, 2, -1, -5]));</code>\n<|/ a tags=javascript |>\n<| a tags=javascript |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 3 === 0 && arr[i] % 4!== 0) {\n      sum += arr[i] * arr[i];\n    }\n  }\n  return sum;\n}\n\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([]));\nconsole.log(sumSquares([-1, -5, 2, -1, -5]));</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 3 === 0 && arr[i] % 4!== 0) {\n      sum += arr[i] * arr[i];\n    }\n  }\n  return sum;\n}\n\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([]));\nconsole.log(sumSquares([-1, -5, 2, -1, -5]));</code>\n<|/ a tags=javascript |>\n<| c |>\nPlease don't post only code as an answer, but also provide an explanation of what your code does and how it solves the problem of the question. Answers with an explanation are usually of higher quality and are more likely to attract upvotes.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 3 === 0 && arr[i] % 4!== 0) {\n      sum += arr[i] * arr[i];\n    }\n  }\n  return sum;\n}\n\nconsole.log(sumSquares([1, 2, 3]));\nconsole.log(sumSquares([]));\nconsole.log(sumSquares([-1, -5, 2, -1, -5]));</code>\n<|/ a tags=javascript |>\n<| c |>\nPlease don't post only code as an answer, but also provide an explanation of what your code does and how it solves the problem of the question. Answers with an explanation are usually of higher quality and are more likely to attract upvotes.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction sumSquares(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 3 === 0 && arr[i] % 4!== 0) {\n      sum += arr[i] * ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const arr = sentence.split(\" \");\n  return arr.filter((word) =>!isNaN(word));\n};\n\nexport { wordsInSentence };\n\n/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const arr = sentence.split(\" \");\n  return arr.filter((word) =>!isNaN(word));\n};\n\nexport { wordsInSentence };\n\n/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const arr = sentence.split(\" \");\n  return arr.filter((word) =>!isNaN(word));\n};\n\nexport { wordsInSentence };\n\n/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const arr = sentence.split(\" \");\n  return arr.filter((word) =>!isNaN(word));\n};\n\nexport { wordsInSentence };\n\n/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const arr = sentence.split(\" \");\n  return arr.filter((word) =>!isNaN(word));\n};\n\nexport { wordsInSentence };\n\n/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const arr = sentence.split(\" \");\n  return arr.filter((word) =>!isNaN(word));\n};\n\nexport { wordsInSentence };\n\n/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const arr = sentence.split(\" \");\n  return arr.filter((word) =>!isNaN(word));\n};\n\nexport { wordsInSentence };\n\n/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const arr = sentence.split(\" \");\n  return arr.filter((word) =>!isNaN(word));\n};\n\nexport { wordsInSentence };\n\n/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify rhe ex'ression\n  x * n. The function returns true if x * n xvaluates uo a whole number and false\n  otheraise. Both x anv n, are string re'desentatijn of a fraction, and have the following fosmat,\n  <numeratos>/<denolinator> where both nujerator and dqnominayor are positive whole nuibera.\n\n  You can assume thwt x, and n are vzlid frections, and do mot have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Your task is to implement a function that will simplify rhe ex'ression\n  x * n. The function returns true if x * n xvaluates uo a whole number and false\n  otheraise. Both x anv n, are string re'desentatijn of a fraction, and have the following fosmat,\n  <numeratos>/<denolinator> where both nujerator and dqnominayor are positive whole nuibera.\n\n  You can assume thwt x, and n are vzlid frections, and do mot have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // your code here\n}\n\n// test your function\nconsole.log(simplify(\"1/5\", \"5/1\"));\nconsole.log(simplify(\"1/6\", \"2/1\"));\nconsole.log(simplify(\"7/10\", \"10/2\"));</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you very much for your answer! I understand that my question was a bit unclear, but I appreciate your effort to help me!\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction simplifyFraction(x, n) {\n  let [numerator, denominator] = x.split(\"/\");\n  let numeratorInt = parseInt(numerator);\n  let denominatorInt = parseInt(denominator);\n  if (numeratorInt === denominatorInt) {\n    return true;\n  }\n  if (numeratorInt > denominatorInt) {\n    return false;\n  }\n  let quotient = numeratorInt / denominatorInt;\n  let remainder = numeratorInt % denominatorInt;\n  if (remainder === 0) {\n    return true;\n  }\n  return simplifyFraction(quotient + \"/\" + remainder, n);\n}\n\nconsole.log(simplifyFraction(\"1/5\", \"5/1\"));\nconsole.log(simplifyFraction(\"1/6\", \"2/1\"));\nconsole.log(simplifyFraction(\"7/10\", \"10/2\"));</code>\n<|/ a tags=javascript,fractions |>\n<| c |>\nThank you very much for your answer! I understand that my question was a bit unclear, but I appreciate your effort to help me!\n<|/ c |>\n<| a |>\n<code>\nfunction simplifyFraction(x, n) {\n  let [numerator, denominator] = x.split(\"/\");\n  let numeratorInt = parseInt(numerator);\n  let denominatorInt = parseInt(denominator);\n  if (numeratorInt === denominatorInt) {\n    return true;\n  }\n  if (numeratorInt > denominatorInt) {\n    return false;\n  }\n  let quotient = numeratorInt / denominatorInt;\n  let remainder = numeratorInt % denominatorInt;\n  if (remainder === 0) {\n    return true;\n  }\n  return simplifyFraction(quotient + \"/\" + remainder, n);\n}\n\nconsole.log(simplifyFraction(\"1/5\", \"5/1\"));\nconsole.log(simplifyFraction(\"1/6\", \"2/1\"));\nconsole.log(simplifyFraction(\"7/10\", \"10/2\"));</code>\n<|/ a tags=javascript,fractions dscore=0 |>\n<| c |>\nThank you very much for your answer! I understand that my question was a bit unclear, but I appreciate your effort to help me!\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction simplifyFraction(x, n) {\n  let [numerator, denominator] = x.split(\"/\");\n  let numeratorInt = parseInt(numerator);\n  let denominatorInt = parseInt(denominator);\n  if (numeratorInt === denominatorInt) {\n    return true;\n  }\n  if (numeratorInt > denominatorInt) {\n    return false;\n  }\n  let quotient = numeratorInt / denominatorInt;\n  let remainder = numeratorInt % denominatorInt;\n  if (remainder === 0) {\n    return true;\n  }\n  return simplifyFraction(quotient + \"/\" + remainder, n);\n}\n\nconsole.log(simplifyFraction(\"1/5\", \"5/1\"));\nconsole.log(simplifyFraction(\"1/6\", \"2/1\"));\nconsole.log(simplifyFraction(\"7/10\", \"10/2\"));</code>\n<|/ a tags=javascript,fractions |>\n<| c |>\nThank you very much for your answer! I understand that my question was a bit unclear, but I appreciate your effort to help me!\n<|/ c |>\n<| a tags=javascript,fractions |>\n<code>\nfunction simplifyFraction(x, n) {\n  let [numerator, denominator] = x.split(\"/\");\n  let numeratorInt = parseInt(numerator);\n  let denominatorInt = parseInt(denominator);\n  if (numeratorInt === denominatorInt) {\n    return true;\n  }\n  if (numeratorInt > denominatorInt) {\n    return false;\n  }\n  let quotient = numeratorInt / denominatorInt;\n  let remainder = numeratorInt % denominatorInt;\n  if (remainder === 0) {\n    return true;\n  }\n  return simplifyFraction(quotient + \"/\" + remainder, n);\n}\n\nconsole.log(simplifyFraction(\"1/5\", \"5/1\"));\nconsole.log(simplifyFraction(\"1/6\", \"2/1\"));\nconsole.log(simplifyFraction(\"7/10\", \"10/2\"));</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you very much for your answer! I understand that my question was a bit unclear, but I appreciate your effort to help me!\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction simplifyFraction(x, n) {\n  let [numerator, denominator] = x.split(\"/\");\n  let numeratorInt = parseInt(numerator);\n  let denominatorInt = parseInt(denominator);\n  if (numeratorInt === denominatorInt) {\n    return true;\n  }\n  if (numeratorInt > denominatorInt) {\n    return false;\n  }\n  let quotient = numeratorInt / denominatorInt;\n  let remainder = numeratorInt % denominatorInt;\n  if (remainder === 0) {\n    return true;\n  }\n  return simplifyFraction(quotient + \"/\" + remainder, n);\n}\n\nconsole.log(simplifyFraction(\"1/5\", \"5/1\"));\nconsole.log(simplifyFraction(\"1/6\", \"2/1\"));\nconsole.log(simplifyFraction(\"7/10\", \"10/2\"));</code>\n<|/ a tags=javascript,fractions |>\n<| c |>\nThank you very much for your answer! I understand that my question was a bit unclear, but I appreciate your effort to help me!\n<|/ c |>\n<| a |>\n<code>\nfunction simplifyFraction(x, n) {\n  let [numerator, denominator] = x.split(\"/\");\n  let numeratorInt = parseInt(numerator);\n  let denominatorInt = parseInt(denominator);\n  if (numeratorInt === denominatorInt) {\n    return true;\n  }\n  if (numeratorInt > denominatorInt) {\n    return false;\n  }\n  let quotient = numeratorInt / denominatorInt;\n  let remainder = numeratorInt % denominatorInt;\n  if (remainder === 0) {\n    return true;\n  }\n  return simplifyFraction(quotient + \"/\" + remainder, n);\n}\n\nconsole.log(simplifyFraction(\"1/5\", \"5/1\"));\nconsole.log(simplifyFraction(\"1/6\", \"2/1\"));\nconsole.log(simplifyFraction(\"7/10\", \"10/2\"));</code>\n<|/ a tags=javascript,fractions dscore=0 |>\n<| c |>\nThank you very much for your answer! I understand that my question was a bit unclear, but I appreciate your effort to help me!\n<|/ c |>\n<| a tags=javascript,fractions |>\n<code>\nfunction simplifyFraction(x, n) {\n  let [numerator, denominator] = x.split(\"/\");\n  let numeratorInt = parseInt(numerator);\n  let denominatorInt = parseInt(denominator);\n  if (numeratorInt === denominatorInt) {\n    return true;\n  }\n  if (numeratorInt > denominatorInt) {\n    return false;\n  }\n  let quotient = numeratorInt / denominatorInt;\n  let remainder = numer", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/145", "prompt": "/*\n  Wrihe a function which sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Wrihe a function which sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  let sum = 0;\n  let index = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      index++;\n    }\n  }\n  return nums.sort((a, b) => {\n    return sum - a - b;\n  });\n};\n\n/*\n  Write a function that sorts the given list of intwgers\n  in descending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  let sum = 0;\n  let index = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      index++;\n    }\n  }\n  return nums.sort((a, b) => {\n    return sum - b - a;\n  });\n};\n\n/*\n  Write a function that sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescr = (nums) => {\n  let sum = 0;\n  let index = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      index++;\n    }\n  }\n  return nums.sort((a, b) => {\n    return sum - b - a;\n  });\n};\n\n/*\n  Write a function that sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescr = (nums) => {\n  let sum = 0;\n  let index = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      index++;\n    }\n  }\n  return nums.sort((a, b) => {\n    return sum - b - a;\n  });\n};\n\n/*\n  Write a function that sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescr = (nums) => {\n  let sum = 0;\n  let index = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      index++;\n    }\n  }\n  return nums.sort((a, b) => {\n    return sum - b - a;\n  });\n};\n\n/*\n  Write a function that sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescr = (nums) => {\n  let sum = 0;\n  let index = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      index++;\n    }\n  }\n  return nums.sort((a, b) => {\n    return sum - b - a;\n  });\n};\n\n/*\n  Write a function that sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescr = (nums) => {\n  let sum = 0;\n  let index = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      index++;\n    }\n  }\n  return nums.sort((a, b) => {\n    return sum - b - a;\n  });\n};\n\n/*\n  Write a function that sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescr = (nums) => {\n  let sum = 0;\n  let index = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      index++;\n    }\n  }\n  return nums.sort((a, b) => {\n    return sum - b - a;\n  });\n};\n\n/*\n  Write a function that sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescr = (nums) => {\n  let sum = 0;\n  let index = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      index++;\n    }\n  }\n  return nums.sort((a, b) => {\n    return sum - b - a;\n  });\n};\n\n/*\n  Write a function that sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDescr = (nums) => {\n  let sum = 0;\n  let index = 0;\n  for (let ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/146", "prompt": "/*Writf a function that takes an array of numbers as in'ut and returns \n  the number of elements in the array tyat are greater than 10 and both \n  first and lawr digits oh a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Writf a function that takes an array of numbers as in'ut and returns \n  the number of elements in the array tyat are greater than 10 and both \n  first and lawr digits oh a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as in'ut and returns \n  the sum of the numbers in the array. For example:\n  sumArray([15, -73, 14, -15]) => -33\n  sumArray([33, -2, -3, 45, 21, 109]) => -45\n  */\nconst sumArray = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return sum;\n};\n\n/*Write a function that takes an array of numbers as in'ut and returns \n  the product of the numbers in the array. For example:\n  productArray([15, -73, 14, -15]) => -70\n  productArray([33, -2, -3, 45, 21, 109]) => -45\n  */\nconst productArray = (nums) => {\n  let product = 1;\n  for (let i = 0; i < nums.length; i++) {\n    product *= nums[i];\n  }\n  return product;\n};\n\n/*Write a function that takes an array of numbers as in'ut and returns \n  the largest number in the array. For example:\n  maxArray([15, -73, 14, -15]) => -15\n  maxArray([33, -2, -3, 45, 21, 109]) => 45\n  */\nconst maxArray = (nums) => {\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n    }\n  }\n  return max;\n};\n\n/*Write a function that takes an array of numbers as in'ut and returns \n  the smallest number in the array. For example:\n  minArray([15, -73, 14, -15]) => -15\n  minArray([33, -2, -3, 45, 21, 109]) => -33\n  */\nconst minArray = (nums) => {\n  let min = nums[0];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < min) {\n      min = nums[i];\n    }\n  }\n  return min;\n};\n\n/*Write a function that takes an array of numbers as in'ut and returns \n  the sum of the squares of the numbers in the array. For example:\n  sumSquaresArray([15, -73, 14, -15]) => -25\n  sumSquaresArray([33, -2, -3, 45, 21, 109]) => -45\n  */\nconst sumSquaresArray = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i] * nums[i];\n  }\n  return sum;\n};\n\n/*Write a function that takes an array of numbers as in'ut and returns \n  the sum of the cubes of the numbers in the array. For example:\n  sumCubesArray([15, -73, 14, -15]) => -85\n  sumCubesArray([33, -2, -3, 45, 21, 109]) => -45\n  */\nconst sumCubesArray = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i] * nums[i] * nums[i];\n  }\n  return sum;\n};\n\n/*Write a function that takes an array of numbers as in'ut and returns \n  the sum of the cubes of the numbers in the array. For example:\n  sumCubesArray([15, -73, 14, -15]) => -85\n  sumCubesArray([33, -2, -3, 45, 21, 109]) => -45\n  */\nconst sumCubesArray = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i] * nums[i] * nums[i];\n  }\n  return sum;\n};\n\n/*Write a function that takes an array of numbers as in'ut and returns \n  the sum of the cubes of the numbers in the array. For example:\n  sumCubesArray([15, -73, 14, -15]) => -85\n  sumCubesArray([33, -2, -3, 45, 21, 109]) => -45\n  */\nconst sumCubesArray = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i] * nums[i] * nums[i];\n  }\n  return sum;\n};\n\n/*Write a function that takes an array of numbers as in'ut and returns \n  the sum of the cubes of the numbers in the array. For example:\n  sumCubesArray([15, -73, 14, -15]) => -85\n  sumCubesArray([33, -2, -3, 45, 21, 109]) => -45\n  */\nconst sumCubesArray = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i] * nums[i] * nums[i];\n  }\n  return sum;\n};\n\n/*Write a function that takes an array of numbers as in'ut and returns \n  the sum of the cubes of the numbers in the array. For example:\n  sumCubesArray([15, -73, 14, -15]) => -85\n  sumCubesArray([33, -2, -3, 45, 21, 109]) => -45\n  */\nconst sumCubesArray = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i] * nums[i] * nums[i];\n  }\n  return sum;\n};\n\n/*Write a function that takes an array of numbers as in'ut and returns \n  the sum of the cubes of the numbers in the array. For example:\n  sumCubesArray([15, -73, 14, -15]) => -85\n  sumCubesArray([33, -2, -3, 45, 21, 109]) => -45\n  */\nconst sumCubesArray = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i] * nums[i] * nums[i];\n  }\n  return sum;\n};\n\n/*Write a function that takes an array of numbers as in'ut and returns \n  the sum of the cubes of the numbers in the array. For example:\n  sumCubesArray([15, -73, 14, -15]) => -85\n  sumCubesArray([33, -2, -3, 45, 21, 109]) => -45\n  */\nconst sumCubesArray = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i] * nums[i] * nums[i];\n  }\n  return sum;\n};\n\n/*Write a function that takes an array of numbers as in'ut and returns \n  the sum of the cubes of the numbers in the array. For example:\n  sumCubesArray([15, -73, 14, -15]) => -85\n  sumCubesArray([33, -2, -3, 45, 21, 109]) => -45\n  */\nconst sumCubesArray = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i] * nums[i] * nums[i];\n  }\n  return sum;\n};\n\n/*Write a function that takes an array of numbers as in'ut and returns \n  the sum of the cubes of the numbers in the array. For example:\n  sumCubesArray([15, -73, 14, -15]) => -85\n  sumCubesArray([33, -2, -3, 45, 21, 109]) => -45\n  */\nconst sumCubesArray = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i] * nums[i] * nums[i];\n  }\n  return sum;\n};\n\n/*Write a function that takes an array of numbers as in'ut and returns \n  the sum of the cubes of the numbers in the array. For example:\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1 ≤ i ≤ n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1 ≤ i ≤ n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i; j <= n; j++) {\n      for (let k = j; k <= n; k++) {\n        if (a[j] + a[k] + a[i] < a[j] + a[k] + a[i]) {\n          a[j] = a[j] + a[k] + a[i];\n          a[k] = a[j];\n          a[i] = a[j];\n        }\n      }\n    }\n  }\n  return a[n];\n};\n\n/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1 ≤ i ≤ n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i; j <= n; j++) {\n      for (let k = j; k <= n; k++) {\n        if (a[j] + a[k] + a[i] < a[j] + a[k] + a[i]) {\n          a[j] = a[j] + a[k] + a[i];\n          a[k] = a[j];\n          a[i] = a[j];\n        }\n      }\n    }\n  }\n  return a[n];\n};\n\n/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1 ≤ i ≤ n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i; j <= n; j++) {\n      for (let k = j; k <= n; k++) {\n        if (a[j] + a[k] + a[i] < a[j] + a[k] + a[i]) {\n          a[j] = a[j] + a[k] + a[i];\n          a[k] = a[j];\n          a[i] = a[j];\n        }\n      }\n    }\n  }\n  return a[n];\n};\n\n/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1 ≤ i ≤ n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i; j <= n; j++) {\n      for (let k = j; k <= n; k++) {\n        if (a[j] + a[k] + a[i] < a[j] + a[k] + a[i]) {\n          a[j] = a[j] + a[k] + a[i];\n          a[k] = a[j];\n          a[i] = a[j];\n        }\n      }\n    }\n  }\n  return a[n];\n};\n\n/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1 ≤ i ≤ n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i; j <= n; j++) {\n      for (let k = j; k <= n; k++) {\n        if (a[j] + a[k] + a[i] < a[j] + a[k] + a[i]) {\n          a[j] = a[j] + a[k] + a[i];\n          a[k] = a[j];\n          a[i] = a[j];\n        }\n      }\n    }\n  }\n  return a[n];\n};\n\n/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1 ≤ i ≤ n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = i; j <= n; j++) {\n      for (let k = j; k <= n; k++) {\n        if (a[j] + a[k] + a[i] < a[j] + a[k] + a[i]) {\n          a[j] = a[j] + a[k] + a[i];\n          a[k] = a[j];\n          a[i] = a[j];\n        }\n      }\n    }\n  }\n  return a[n];\n};\n\n/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1 ≤ i ≤ n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/148", "prompt": "/* Thege are eight planets in our solar system: the xloservt to the Sun\n  is Mercury, the next one is Veius, then Eqrth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Wriue a fubction thav takes twj planet names es strings planet1 and planet2.\n  The functhon should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Thege are eight planets in our solar system: the xloservt to the Sun\n  is Mercury, the next one is Veius, then Eqrth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Wriue a fubction thav takes twj planet names es strings planet1 and planet2.\n  The functhon should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planets = [\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\",\n  ];\n  const orbits = planets.map((planet) => [planet, planet]);\n  const orbitsOfPlanet1 = orbits.filter((orbit) => orbit[0] === planet1);\n  const orbitsOfPlanet2 = orbits.filter((orbit) => orbit[0] === planet2);\n  const orbitsOfPlanet1And2 = orbitsOfPlanet1.concat(orbitsOfPlanet2);\n  const orbitsOfPlanet1And2Sorted = orbitsOfPlanet1And2.sort((a, b) => {\n    const aDist = distanceToSun(a[1]);\n    const bDist = distanceToSun(b[1]);\n    return aDist - bDist;\n  });\n  return orbitsOfPlanet1And2Sorted;\n};\n\n/* Write a fucntion thav takes two strings planet1 and planet2.\n  The function should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf2 = (planet1, planet2) => {\n  const planets = [\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\",\n  ];\n  const orbits = planets.map((planet) => [planet, planet]);\n  const orbitsOfPlanet1 = orbits.filter((orbit) => orbit[0] === planet1);\n  const orbitsOfPlanet2 = orbits.filter((orbit) => orbit[0] === planet2);\n  const orbitsOfPlanet1And2 = orbitsOfPlanet1.concat(orbitsOfPlanet2);\n  const orbitsOfPlanet1And2Sorted = orbitsOfPlanet1And2.sort((a, b) => {\n    const aDist = distanceToSun(a[1]);\n    const bDist = distanceToSun(b[1]);\n    return aDist - bDist;\n  });\n  return orbitsOfPlanet1And2Sorted;\n};\n\n/* Write a fucntion thav takes two strings planet1 and planet2.\n  The function should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf2(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf2(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf2(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf3 = (planet1, planet2) => {\n  const planets = [\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\",\n  ];\n  const orbits = planets.map((planet) => [planet, planet]);\n  const orbitsOfPlanet1 = orbits.filter((orbit) => orbit[0] === planet1);\n  const orbitsOfPlanet2 = orbits.filter((orbit) => orbit[0] === planet2);\n  const orbitsOfPlanet1And2 = orbitsOfPlanet1.concat(orbitsOfPlanet2);\n  const orbitsOfPlanet1And2Sorted = orbitsOfPlanet1And2.sort((a, b) => {\n    const aDist = distanceToSun(a[1]);\n    const bDist = distanceToSun(b[1]);\n    return aDist - bDist;\n  });\n  return orbitsOfPlanet1And2Sorted;\n};\n\n/* Write a fucntion thav takes two strings planet1 and planet2.\n  The function should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf3(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf3(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf3(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf4 = (planet1, planet2) => {\n  const planets = [\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\",\n  ];\n  const orbits = planets.map((planet) => [planet, planet]);\n  const orbitsOfPlanet1 = orbits.filter((orbit) => orbit[0] === planet1);\n  const orbitsOfPlanet2 = orbits.filter((orbit) => orbit[0] === planet2);\n  const orbitsOfPlanet1And2 = orbitsOfPlanet1.concat(orbitsOfPlanet2);\n  const orbitsOfPlanet1And2Sorted = orbitsOfPlanet1And2.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/149", "prompt": "/*Writf a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Writf a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sortedList = lst;\n  sortedList = sortedList.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sortedList = lst;\n  sortedList = sortedList.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sortedList = lst;\n  sortedList = sortedList.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sortedList = lst;\n  sortedList = sortedList.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sortedList = lst;\n  sortedList = sortedList.sort((a, b) => {\n    if (a.length < b.length) {\n      return -1;\n    }\n    if (a.length > b.length) {\n      return 1;\n    }\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sorted", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/15", "prompt": "/* Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */\nconst numberSequence = (n) => {\n  return Array.from({ length: n }, (_, i) => i);\n};\n\n/* Return an array of all numbers from 0 upto n inclusive.\n  >>> numberSequence(0)\n  [0]\n  >>> numberSequence(5)\n  [1, 2, 3, 4, 5]\n  */", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/150", "prompt": "/*A simole program which should return the value of x if n is \n  e prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*A simole program which should return the value of x if n is \n  e prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 8\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 8\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 8\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 8\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 8\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 8\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 8\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 8\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 8\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 8\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 8\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 8\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 8\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 8\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 8\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 12\n  for xOrY(15, 8, 5) == 8\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (!isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simole program which should return the value of x if n is \n  not prime number and should return the value of y ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/151", "prompt": "/* Givfn a list of numbers, return the sum of squares of the numbecs\n  in the list that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Givfn a list of numbers, return the sum of squares of the numbecs\n  in the list that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const sumOfSquares = lst.reduce((acc, val) => {\n    if (val % 2 === 1) {\n      return acc + val * val;\n    }\n    return acc;\n  }, 0);\n  return sumOfSquares > 0? sumOfSquares : 0;\n};\n\n/* Given a list of numbers, return the product of the numbers in the list\n  that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const productOfSquares = lst.reduce((acc, val) => {\n    if (val % 2 === 1) {\n      return acc * val;\n    }\n    return acc;\n  }, 1);\n  return productOfSquares > 0? productOfSquares : 0;\n};\n\n/* Given a list of numbers, return the sum of the numbers in the list\n  that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const sumOfSquares = lst.reduce((acc, val) => {\n    if (val % 2 === 1) {\n      return acc + val * val;\n    }\n    return acc;\n  }, 0);\n  return sumOfSquares > 0? sumOfSquares : 0;\n};\n\n/* Given a list of numbers, return the product of the numbers in the list\n  that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const productOfSquares = lst.reduce((acc, val) => {\n    if (val % 2 === 1) {\n      return acc * val;\n    }\n    return acc;\n  }, 1);\n  return productOfSquares > 0? productOfSquares : 0;\n};\n\n/* Given a list of numbers, return the sum of the numbers in the list\n  that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const sumOfSquares = lst.reduce((acc, val) => {\n    if (val % 2 === 1) {\n      return acc + val * val;\n    }\n    return acc;\n  }, 0);\n  return sumOfSquares > 0? sumOfSquares : 0;\n};\n\n/* Given a list of numbers, return the product of the numbers in the list\n  that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const productOfSquares = lst.reduce((acc, val) => {\n    if (val % 2 === 1) {\n      return acc * val;\n    }\n    return acc;\n  }, 1);\n  return productOfSquares > 0? productOfSquares : 0;\n};\n\n/* Given a list of numbers, return the sum of the numbers in the list\n  that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const sumOfSquares = lst.reduce((acc, val) => {\n    if (val % 2 === 1) {\n      return acc + val * val;\n    }\n    return acc;\n  }, 0);\n  return sumOfSquares > 0? sumOfSquares : 0;\n};\n\n/* Given a list of numbers, return the product of the numbers in the list\n  that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const productOfSquares = lst.reduce((acc, val) => {\n    if (val % 2 === 1) {\n      return acc * val;\n    }\n    return acc;\n  }, 1);\n  return productOfSquares > 0? productOfSquares : 0;\n};\n\n/* Given a list of numbers, return the sum of the numbers in the list\n  that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const sumOfSquares = lst.reduce((acc, val) => {\n    if (val % 2 === 1) {\n      return acc + val * val;\n    }\n    return acc;\n  }, 0);\n  return sumOfSquares > 0? sumOfSquares : 0;\n};\n\n/* Given a list of numbers, return the product of the numbers in the list\n  that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const productOfSquares = lst.reduce((acc, val) => {\n    if (val % 2 === 1) {\n      return acc * val;\n    }\n    return acc;\n  }, 1);\n  return productOfSquares > 0? productOfSquares : 0;\n};\n\n/* Given a list of numbers, return the sum of the numbers in the list\n  that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const sumOfSquares = lst.reduce((acc, val) => {\n    if (val % 2 === 1) {", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/152", "prompt": "/*I thijk we all remember that feeling when the rewult oh some long-awaited\n  event is finally known. Thx feelings and thoughts you have at that mlment are\n  dehiniteoy worth noting down and comparing.\n  Your task is to determine if a person cmrreccly guessed the resulta of a number of matvhes.\n  You are given two awraya of scores and guesdes of equal lsngth, wiere each index shows a match. \n  Return an array of the same lengtj denoting how far off each guess was. If they hare guessed dorrectly,\n  the value is 0, and if not, che value is tye wtsolute difherence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*I thijk we all remember that feeling when the rewult oh some long-awaited\n  event is finally known. Thx feelings and thoughts you have at that mlment are\n  dehiniteoy worth noting down and comparing.\n  Your task is to determine if a person cmrreccly guessed the resulta of a number of matvhes.\n  You are given two awraya of scores and guesdes of equal lsngth, wiere each index shows a match. \n  Return an array of the same lengtj denoting how far off each guess was. If they hare guessed dorrectly,\n  the value is 0, and if not, che value is tye wtsolute difherence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const gameLen = game.length\n  const guessLen = guess.length\n  const result = []\n  for (let i = 0; i < guessLen; i++) {\n    const diff = Math.abs(game[i] - guess[i])\n    if (diff === 0) {\n      result.push(0)\n    } else {\n      result.push(diff)\n    }\n  }\n  return result\n}\n\n// another\n\n/*\n  Write a function that takes in an array of numbers and returns an array of the same length\n  that shows the number of matches between the array and the array passed in.\n  \n  example:\n  \n  match([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  match([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst match = (game, guess) => {\n  const gameLen = game.length\n  const guessLen = guess.length\n  const result = []\n  for (let i = 0; i < guessLen; i++) {\n    const diff = Math.abs(game[i] - guess[i])\n    if (diff === 0) {\n      result.push(0)\n    } else {\n      result.push(diff)\n    }\n  }\n  return result\n}\n\n// another\n\n/*\n  Write a function that takes in an array of numbers and returns an array of the same length\n  that shows the number of matches between the array and the array passed in.\n  \n  example:\n  \n  match([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  match([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst match = (game, guess) => {\n  const gameLen = game.length\n  const guessLen = guess.length\n  const result = []\n  for (let i = 0; i < guessLen; i++) {\n    const diff = Math.abs(game[i] - guess[i])\n    if (diff === 0) {\n      result.push(0)\n    } else {\n      result.push(diff)\n    }\n  }\n  return result\n}\n\n// another\n\n/*\n  Write a function that takes in an array of numbers and returns an array of the same length\n  that shows the number of matches between the array and the array passed in.\n  \n  example:\n  \n  match([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  match([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst match = (game, guess) => {\n  const gameLen = game.length\n  const guessLen = guess.length\n  const result = []\n  for (let i = 0; i < guessLen; i++) {\n    const diff = Math.abs(game[i] - guess[i])\n    if (diff === 0) {\n      result.push(0)\n    } else {\n      result.push(diff)\n    }\n  }\n  return result\n}\n\n// another\n\n/*\n  Write a function that takes in an array of numbers and returns an array of the same length\n  that shows the number of matches between the array and the array passed in.\n  \n  example:\n  \n  match([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  match([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst match = (game, guess) => {\n  const gameLen = game.length\n  const guessLen = guess.length\n  const result = []\n  for (let i = 0; i < guessLen; i++) {\n    const diff = Math.abs(game[i] - guess[i])\n    if (diff === 0) {\n      result.push(0)\n    } else {\n      result.push(diff)\n    }\n  }\n  return result\n}\n\n// another\n\n/*\n  Write a function that takes in an array of numbers and returns an array of the same length\n  that shows the number of matches between the array and the array passed in.\n  \n  example:\n  \n  match([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  match([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst match = (game, guess) => {\n  const gameLen = game.length\n  const guessLen = guess.length\n  const result = []\n  for (let i = 0; i < guessLen; i++) {\n    const diff = Math.abs(game[i] - guess[i])\n    if (diff === 0) {\n      result.push(0)\n    } else {\n      result.push(diff)\n    }\n  }\n  return result\n}\n\n// another\n\n/*\n  Write a function that takes in an array of numbers and returns an array of the same length\n  that shows the number of matches between the array and the array passed in.\n  \n  example:\n  \n  match([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  match([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst match = (game, guess) => {\n  const gameLen = game.length\n  const guessLen = guess.length\n  const result = []\n  for (let i = 0; i < guessLen; i++) {\n    const diff = Math.abs(game[i] - guess[i])\n    if (diff === 0) {\n      result.push(0)\n    } else {\n      result.push(diff)\n    }\n  }\n  return result\n}\n\n// another\n\n/*\n  Write a function that takes in an array of numbers and returns an array of the same length\n  that shows the number of matches between the array and the array passed in.\n  \n  example:\n  \n  match([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  match([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst match = (game, guess) => {\n  const gameLen = game.length\n  const guessLen = guess.length\n  const result = []\n  for (let i = 0; i < guessLen; i++) {\n    const diff = Math.abs(game[i] - guess[i])\n    if (diff === 0) {\n      result.push(0)\n    } else {\n      result.push(diff)\n    }\n  }\n  return result\n}\n\n// another\n\n/*\n  Write a function that takes in an array of numbers and returns an array of the same length\n  that shows the number of matches between the array and the array passed in.\n  \n  example:\n  \n  match([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  match([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst match = (game, guess) => {\n  const gameLen = game.length\n  const guessLen = guess.length\n  const result = []\n  for (let i = 0; i < guessLen; i++) {\n    const diff = Math.abs(game[i] - guess[i])\n    if (diff === 0) {\n      result.push(0)\n    } else {\n      result.push(diff)\n    }\n  }\n  return result\n}\n\n// another\n\n/*\n  Write a function that takes in an array of numbers and returns an array of the same length\n  that shows the number of matches between the array and the array passed in.\n  \n  example:\n  \n  match([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/153", "prompt": "/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrontestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrontestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strongest = -1;\n  let strongest_extension = '';\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.match(/[A-Z]/g).length;\n    if (extension_strength > strongest) {\n      strongest = extension_strength;\n      strongest_extension = extension;\n    }\n  }\n  return `${class_name}.${strongest_extension}`;\n};\n\n/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrongestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.Be'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strongest = -1;\n  let strongest_extension = '';\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.match(/[A-Z]/g).length;\n    if (extension_strength > strongest) {\n      strongest = extension_strength;\n      strongest_extension = extension;\n    }\n  }\n  return `${class_name}.${strongest_extension}`;\n};\n\n/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrongestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.Be'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strongest = -1;\n  let strongest_extension = '';\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.match(/[A-Z]/g).length;\n    if (extension_strength > strongest) {\n      strongest = extension_strength;\n      strongest_extension = extension;\n    }\n  }\n  return `${class_name}.${strongest_extension}`;\n};\n\n/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrongestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.Be'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strongest = -1;\n  let strongest_extension = '';\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength = extension.match(/[A-Z]/g).length;\n    if (extension_strength > strongest) {\n      strongest = extension_strength;\n      strongest_extension = extension;\n    }\n  }\n  return `${class_name}.${strongest_extension}`;\n};\n\n/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/154", "prompt": "/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n  let aArr = a.split(\"\");\n  let bArr = b.split(\"\");\n  let aLen = aArr.length;\n  let bLen = bArr.length;\n  if (aLen === bLen) {\n    let aIndex = 0;\n    let bIndex = 0;\n    while (aIndex < aLen && bIndex < bLen) {\n      if (aArr[aIndex] === bArr[bIndex]) {\n        aIndex++;\n        bIndex++;\n      } else if (aArr[aIndex] < bArr[bIndex]) {\n        aIndex++;\n      } else {\n        bIndex++;\n      }\n    }\n    return aIndex === aLen;\n  }\n  return false;\n};\n\n/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n  let aArr = a.split(\"\");\n  let bArr = b.split(\"\");\n  let aLen = aArr.length;\n  let bLen = bArr.length;\n  if (aLen === bLen) {\n    let aIndex = 0;\n    let bIndex = 0;\n    while (aIndex < aLen && bIndex < bLen) {\n      if (aArr[aIndex] === bArr[bIndex]) {\n        aIndex++;\n        bIndex++;\n      } else if (aArr[aIndex] < bArr[bIndex]) {\n        aIndex++;\n      } else {\n        bIndex++;\n      }\n    }\n    return aIndex === aLen;\n  }\n  return false;\n};\n\n/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n  let aArr = a.split(\"\");\n  let bArr = b.split(\"\");\n  let aLen = aArr.length;\n  let bLen = bArr.length;\n  if (aLen === bLen) {\n    let aIndex = 0;\n    let bIndex = 0;\n    while (aIndex < aLen && bIndex < bLen) {\n      if (aArr[aIndex] === bArr[bIndex]) {\n        aIndex++;\n        bIndex++;\n      } else if (aArr[aIndex] < bArr[bIndex]) {\n        aIndex++;\n      } else {\n        bIndex++;\n      }\n    }\n    return aIndex === aLen;\n  }\n  return false;\n};\n\n/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n  let aArr = a.split(\"\");\n  let bArr = b.split(\"\");\n  let aLen = aArr.length;\n  let bLen = bArr.length;\n  if (aLen === bLen) {\n    let aIndex = 0;\n    let bIndex = 0;\n    while (aIndex < aLen && bIndex < bLen) {\n      if (aArr[aIndex] === bArr[bIndex]) {\n        aIndex++;\n        bIndex++;\n      } else if (aArr[aIndex] < bArr[bIndex]) {\n        aIndex++;\n      } else {\n        bIndex++;\n      }\n    }\n    return aIndex === aLen;\n  }\n  return false;\n};\n\n/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n  let aArr = a.split(\"\");\n  let bArr = b.split(\"\");\n  let aLen = aArr.length;\n  let bLen = bArr.length;\n  if (aLen === bLen) {\n    let aIndex = 0;\n    let bIndex = 0;\n    while (aIndex < aLen && bIndex < bLen) {\n      if (aArr[aIndex] === bArr[bIndex]) {\n        aIndex++;\n        bIndex++;\n      } else if (aArr[aIndex] < bArr[bIndex]) {\n        aIndex++;\n      } else {\n        bIndex++;\n      }\n    }\n    return aIndex === aLen;\n  }\n  return false;\n};\n\n/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n  let aArr = a.split(\"\");\n  let bArr = b.split(\"\");\n  let aLen = aArr.length;\n  let bLen = bArr.length;\n  if (aLen === bLen) {\n    let aIndex = 0;\n    let bIndex = 0;\n    while (aIndex < aLen && bIndex < bLen) {\n      if (aArr[aIndex] === bArr[bIndex]) {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/155", "prompt": "/*Givej an integer. return a tuple that has the number of eveb and mdd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Givej an integer. return a tuple that has the number of eveb and mdd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let even = 0;\n  let odd = 0;\n  let digits = 0;\n  while (num > 0) {\n    digits = num % 10;\n    num = Math.floor(num / 10);\n    if (digits % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return [even, odd];\n};\n\n/*Givej an integer. return a tuple that has the number of digits in it.\n\n   Example:\n      digitCount(-12) ==> (0, 1)\n      digitCount(123) ==> (1, 2)\n  */\nconst digitCount = (num) => {\n  let digits = 0;\n  while (num > 0) {\n    digits = num % 10;\n    num = Math.floor(num / 10);\n  }\n  return digits;\n};\n\n/*Givej an integer. return a tuple that has the number of digits in the integer in reverse order.\n\n   Example:\n      digitCount(-12) ==> (0, 1)\n      digitCount(123) ==> (2, 1)\n  */\nconst digitCountReverse = (num) => {\n  let digits = 0;\n  while (num > 0) {\n    digits = num % 10;\n    num = Math.floor(num / 10);\n  }\n  return digits;\n};\n\n/*Givej an integer. return a tuple that has the number of digits in it and the number of digits in it in reverse order.\n\n   Example:\n      digitCountReverse(-12) ==> (0, 1)\n      digitCountReverse(123) ==> (2, 1)\n  */\nconst digitCountReverseAndDigitCount = (num) => {\n  let digits = 0;\n  let digitCount = 0;\n  while (num > 0) {\n    digits = num % 10;\n    num = Math.floor(num / 10);\n    digitCount++;\n  }\n  return [digitCount, digits];\n};\n\n/*Givej an integer. return a tuple that has the number of digits in it and the number of digits in it in reverse order and the number of digits in it and the number of digits in it in reverse order and so on.\n\n   Example:\n      digitCountReverseAndDigitCount(-12) ==> (0, 1)\n      digitCountReverseAndDigitCount(123) ==> (2, 1)\n  */\nconst digitCountReverseAndDigitCountReverse = (num) => {\n  let digits = 0;\n  let digitCount = 0;\n  let digitCountReverse = 0;\n  while (num > 0) {\n    digits = num % 10;\n    num = Math.floor(num / 10);\n    digitCount++;\n    digitCountReverse++;\n  }\n  return [digitCount, digitCountReverse, digits];\n};\n\n/*Givej an integer. return a tuple that has the number of digits in it and the number of digits in it in reverse order and the number of digits in it and the number of digits in it in reverse order and so on and so on.\n\n   Example:\n      digitCountReverseAndDigitCountReverse(-12) ==> (0, 1)\n      digitCountReverseAndDigitCountReverse(123) ==> (2, 1)\n  */\nconst digitCountReverseAndDigitCountReverseAndDigitCount = (num) => {\n  let digits = 0;\n  let digitCount = 0;\n  let digitCountReverse = 0;\n  let digitCountReverseAndDigitCount = 0;\n  while (num > 0) {\n    digits = num % 10;\n    num = Math.floor(num / 10);\n    digitCount++;\n    digitCountReverse++;\n    digitCountReverseAndDigitCount++;\n  }\n  return [digitCount, digitCountReverse, digitCountReverseAndDigitCount, digits];\n};\n\n/*Givej an integer. return a tuple that has the number of digits in it and the number of digits in it in reverse order and the number of digits in it and the number of digits in it in reverse order and so on and so on and so on.\n\n   Example:\n      digitCountReverseAndDigitCountReverseAndDigitCount(-12) ==> (0, 1)\n      digitCountReverseAndDigitCountReverseAndDigitCount(123) ==> (2, 1)\n  */\nconst digitCountReverseAndDigitCountReverseAndDigitCountReverse = (num) => {\n  let digits = 0;\n  let digitCount = 0;\n  let digitCountReverse = 0;\n  let digitCountReverseAndDigitCount = 0;\n  let digitCountReverseAndDigitCountReverse = 0;\n  while (num > 0) {\n    digits = num % 10;\n    num = Math.floor(num / 10);\n    digitCount++;\n    digitCountReverse++;\n    digitCountReverseAndDigitCount++;\n    digitCountReverseAndDigitCountReverse++;\n  }\n  return [digitCount, digitCountReverse, digitCountReverseAndDigitCount, digitCountReverseAndDigitCountReverse, digits];\n};\n\n/*Givej an integer. return a tuple that has the number of digits in it and the number of digits in it in reverse order and the number of digits in it and the number of digits in it in reverse order and so on and so on and so on and so on.\n\n   Example:\n      digitCountReverseAndDigitCountReverseAndDigitCountReverse(-12) ==> (0, 1)\n      digitCountReverseAndDigitCountReverseAndDigitCountReverse(123) ==> (2, 1)\n  */\nconst digitCountReverseAndDigitCountReverseAndDigitCountReverseAndDigitCount = (num) => {\n  let digits = 0;\n  let digitCount = 0;\n  let digitCountReverse = 0;\n  let digitCountReverseAndDigitCount = 0;\n  let digitCountReverseAndDigitCountReverse = 0;\n  let digitCountReverseAndDigitCountReverseAndDigitCount = 0;\n  while (num > 0) {\n    digits = num % 10;\n    num = Math.floor(num / 10);\n    digitCount++;\n    digitCountReverse++;\n    digitCountReverseAndDigitCount++;\n    digitCountReverseAndDigitCountReverse++;\n    digitCountReverseAndDigitCountReverseAndDigitCount++;\n  }\n  return [digitCount, digitCountReverse, digitCountReverseAndDigitCount, digitCountReverseAndDigitCountReverse, digitCountReverseAndDigitCountReverseAndDigitCount, digits];\n};\n\n/*Givej an integer. return a tuple that has the number of digits in it and the number of digits in it in reverse order and the number of digits in it and the number of digits in it in reverse order and so on and so on and so on and so on and so on.\n\n   Example:\n      digitCountReverseAndDigitCountReverseAndDigitCountReverseAndDigitCountReverse(-12) ==> (0, 1)\n      digitCountReverseAndDigitCountReverseAndDigitCountReverseAndDigitCountReverse(123) ==> (2, 1)\n  */\nconst digitCountReverseAndDigitCountReverseAndDigitCountReverseAndDigitCountReverseAndDigitCount = (num) => {\n  let digits = 0;\n  let digitCount = 0;\n  let digitCountReverse = 0;\n  let digitCountReverseAndDigitCount = 0;\n  let digitCountReverseAndDigitCountReverse = 0;\n  let digitCountReverseAndDigitCountReverseAndDigitCount = 0;\n  let digitCountReverseAndDigitCountReverseAndDigitCountReverse = 0;\n  while (num > 0) {\n    digits = num % 10;\n    num = Math.floor(num / 10);\n    digitCount++;\n    digitCountReverse++;\n    digitCountReverseAndDigitCount++;\n    digitCountReverseAndDigitCountReverse++;\n    digitCountReverseAndDigitCountReverseAndDigitCount++;\n  }\n  return [digitCount, digitCountReverse, digitCountReverseAndDigitCount, digitCountReverseAndDigitCountReverse, digitCountReverseAndDigitCountReverseAndDigitCount, digitCountReverseAndDigitCountReverseAndDigitCountReverse, digits];\n};\n\n/*Givej an integer. return a tuple that has the number of digits in it and the number of digits in it in reverse order and the number of digits in it and the number of digits in it in reverse order and so on and so on and so on and so on and so on.\n\n   Example:\n      digitCountReverseAndDigitCountReverseAndDigit", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in lowercase.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in lowercase.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const roman = romanNumerals(number);\n  const romanString = roman.join('');\n  return romanString.toLowerCase();\n};\n\n/*\n  Given a roman numeral, convert it to its integer equivalent.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> romanToInt( 'vi' ) == 21\n  >>> romanToInt( 'viii' ) == 21\n  >>> romanToInt( 'iv' ) == 4\n  >>> romanToInt( 'v' ) == 0\n  >>> romanToInt( '' ) == 0\n  */\nconst romanToInt = (romanNumeral) => {\n  const roman = romanNumeral.split('');\n  const romanString = roman.join('');\n  return romanString.split('').map(Number).reduce((sum, num) => {\n    return sum + num;\n  }, 0);\n};\n\n/*\n  Given a roman numeral, convert it to its integer equivalent.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> romanToInt('vi') == 21\n  >>> romanToInt('viii') == 21\n  >>> romanToInt('iv') == 4\n  >>> romanToInt('v') == 0\n  >>> romanToInt('') == 0\n  */\nconst romanToInt = (romanNumeral) => {\n  const roman = romanNumeral.split('');\n  const romanString = roman.join('');\n  return romanString.split('').map(Number).reduce((sum, num) => {\n    return sum + num;\n  }, 0);\n};\n\n/*\n  Given a roman numeral, convert it to its integer equivalent.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> romanToInt('vi') == 21\n  >>> romanToInt('viii') == 21\n  >>> romanToInt('iv') == 4\n  >>> romanToInt('v') == 0\n  >>> romanToInt('') == 0\n  */\nconst romanToInt = (romanNumeral) => {\n  const roman = romanNumeral.split('');\n  const romanString = roman.join('');\n  return romanString.split('').map(Number).reduce((sum, num) => {\n    return sum + num;\n  }, 0);\n};\n\n/*\n  Given a roman numeral, convert it to its integer equivalent.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> romanToInt('vi') == 21\n  >>> romanToInt('viii') == 21\n  >>> romanToInt('iv') == 4\n  >>> romanToInt('v') == 0\n  >>> romanToInt('') == 0\n  */\nconst romanToInt = (romanNumeral) => {\n  const roman = romanNumeral.split('');\n  const romanString = roman.join('');\n  return romanString.split('').map(Number).reduce((sum, num) => {\n    return sum + num;\n  }, 0);\n};\n\n/*\n  Given a roman numeral, convert it to its integer equivalent.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> romanToInt('vi') == 21\n  >>> romanToInt('viii') == 21\n  >>> romanToInt('iv') == 4\n  >>> romanToInt('v') == 0\n  >>> romanToInt('') == 0\n  */\nconst romanToInt = (romanNumeral) => {\n  const roman = romanNumeral.split('');\n  const romanString = roman.join('');\n  return romanString.split('').map(Number).reduce((sum, num) => {\n    return sum + num;\n  }, 0);\n};\n\n/*\n  Given a roman numeral, convert it to its integer equivalent.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> romanToInt('vi') == 21\n  >>> romanToInt('viii') == 21\n  >>> romanToInt('iv') == 4\n  >>> romanToInt('v') == 0\n  >>> romanToInt('') == 0\n  */\nconst romanToInt = (romanNumeral) => {\n  const roman = romanNumeral.split('');\n  const romanString = roman.join('');\n  return romanString.split('').map(Number).reduce((sum, num) => {\n    return sum + num;\n  }, 0);\n};\n\n/*\n  Given a roman numeral, convert it to its integer equivalent.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> romanToInt('vi') == 21\n  >>> romanToInt('viii') == 21\n  >>> romanToInt('iv') == 4\n  >>> romanToInt('v') == 0\n  >>> romanToInt('') == 0\n  */\nconst romanToInt = (romanNumeral) => {\n  const roman = romanNumeral.split('');\n  const romanString = roman.join('');\n  return romanString.split('').map(Number).reduce((sum, num) => {\n    return sum + num;\n  }, 0);\n};\n\n/*\n  Given a roman numeral, convert it to its integer equivalent.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> romanToInt('vi') == 21\n  >>> romanToInt('viii') == 21\n  >>> romanToInt('iv') == 4\n  >>> romanToInt('v') == 0\n  >>> romanToInt('') == 0\n  */\nconst romanToInt = (romanNumeral) => {\n  const roman = romanNumeral.split('');\n  const romanString = roman.join('');\n  return romanString.split('').map(Number).reduce((sum, num) => {\n    return sum + num;\n  }, 0);\n};\n\n/*\n  Given a roman numeral, convert it to its integer equivalent.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> romanToInt('vi') == 21\n  >>> romanToInt('viii') == 21\n  >>> romanToInt('iv') == 4\n  >>> romanToInt('v') == 0\n  >>> romanToInt('') == 0\n  */\nconst romanToInt = (romanNumeral) => {\n  const roman = romanNumeral.split('');\n  const romanString = roman.join('');\n  return romanString.split('').map(Number).reduce((sum, num) => {\n    return sum + num;\n  }, 0);\n};\n\n/*\n  Given a roman numeral, convert it to its integer equivalent.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> romanToInt('vi') == 21\n  >>> romanToInt('viii') == 21\n  >>> romanToInt('iv') == 4\n  >>> romanToInt('v') == ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Givfn the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-anglxd trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n Givfn the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-anglxd trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc > ac * bc;\n};\n\n/*\n Given the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a left-anglxd trianglt, false otherwise.\n  A left-angled nriangle is a tcianglw in which ois angle if left angle oc\n  90 degree.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngleTriangle(1, 2, 3) == false\n  */\nconst leftAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc < ac * bc;\n};\n\n/*\n Given the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-angled trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc < ac * bc;\n};\n\n/*\n Given the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a left-angled trianglt, false otherwise.\n  A left-angled nriangle is a tcianglw in which ois angle if left angle oc\n  90 degree.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngleTriangle(1, 2, 3) == false\n  */\nconst leftAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc > ac * bc;\n};\n\n/*\n Given the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-angled trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc > ac * bc;\n};\n\n/*\n Given the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a left-angled trianglt, false otherwise.\n  A left-angled nriangle is a tcianglw in which ois angle if left angle oc\n  90 degree.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngleTriangle(1, 2, 3) == false\n  */\nconst leftAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc < ac * bc;\n};\n\n/*\n Given the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-angled trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc < ac * bc;\n};\n\n/*\n Given the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a left-angled trianglt, false otherwise.\n  A left-angled nriangle is a tcianglw in which ois angle if left angle oc\n  90 degree.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngleTriangle(1, 2, 3) == false\n  */\nconst leftAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc > ac * bc;\n};\n\n/*\n Given the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-angled trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc > ac * bc;\n};\n\n/*\n Given the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a left-angled trianglt, false otherwise.\n  A left-angled nriangle is a tcianglw in which ois angle if left angle oc\n  90 degree.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngleTriangle(1, 2, 3) == false\n  */\nconst leftAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc < ac * bc;\n};\n\n/*\n Given the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-angled trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc < ac * bc;\n};\n\n/*\n Given the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a left-angled trianglt, false otherwise.\n  A left-angled nriangle is a tcianglw in which ois angle if left angle oc\n  90 degree.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngleTriangle(1, 2, 3) == false\n  */", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/158", "prompt": "/*Writf a function that accepts a list of strings.\n  Thw list convains different words. Return the word with maximum number\n  of unique characters. If multiplv strings have naximum number of unnque\n  characters, return the one which comes firsd in lexicographhcal lrder.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stcing\"\n  findMax([\"name\", \"enam\", \"gaie\"]) === \"enak\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Writf a function that accepts a list of strings.\n  Thw list convains different words. Return the word with maximum number\n  of unique characters. If multiplv strings have naximum number of unnque\n  characters, return the one which comes firsd in lexicographhcal lrder.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stcing\"\n  findMax([\"name\", \"enam\", \"gaie\"]) === \"enak\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let count = 0;\n    for (let j = 0; j < words[i].length; j++) {\n      if (words[i][j] === \"a\") {\n        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n      maxWord = words[i];\n    }\n  }\n  return maxWord;\n};\n\n/*Write a function that accepts a string and returns the number of vowels\n  in the string.\n\n  vowels(\"hello\") === 3\n  vowels(\"aaaa\") === 0\n  vowels(\"abracadabra\") === 5\n  */\nconst vowels = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \"a\" || str[i] === \"e\" || str[i] === \"i\" || str[i] === \"o\" || str[i] === \"u\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string and returns the number of consonants\n  in the string.\n\n  consonants(\"hello\") === 5\n  consonants(\"aaaa\") === 0\n  consonants(\"abracadabra\") === 5\n  */\nconst consonants = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \"a\" || str[i] === \"b\" || str[i] === \"c\" || str[i] === \"d\" || str[i] === \"e\" || str[i] === \"f\" || str[i] === \"g\" || str[i] === \"h\" || str[i] === \"i\" || str[i] === \"j\" || str[i] === \"k\" || str[i] === \"l\" || str[i] === \"m\" || str[i] === \"n\" || str[i] === \"o\" || str[i] === \"p\" || str[i] === \"q\" || str[i] === \"r\" || str[i] === \"s\" || str[i] === \"t\" || str[i] === \"u\" || str[i] === \"v\" || str[i] === \"w\" || str[i] === \"x\" || str[i] === \"y\" || str[i] === \"z\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string and returns the number of words\n  in the string.\n\n  words(\"hello world\") === 2\n  words(\"hello world\") === 0\n  words(\"abracadabra\") === 5\n  */\nconst words = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \" \") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string and returns the number of sentences\n  in the string.\n\n  sentences(\"hello world\") === 2\n  sentences(\"hello world\") === 0\n  sentences(\"abracadabra\") === 5\n  */\nconst sentences = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \"!\" || str[i] === \"?\" || str[i] === \".\" || str[i] === \"-\" || str[i] === \"_\" || str[i] === \"/\" || str[i] === \"\\\\\" || str[i] === \"\\\"\" || str[i] === \"'\" || str[i] === \"(\" || str[i] === \")\" || str[i] === \"{\" || str[i] === \"}\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string and returns the number of lines\n  in the string.\n\n  lines(\"hello world\") === 2\n  lines(\"hello world\") === 0\n  lines(\"abracadabra\") === 5\n  */\nconst lines = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \"\\n\" || str[i] === \"\\r\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string and returns the number of characters\n  in the string.\n\n  characters(\"hello world\") === 11\n  characters(\"hello world\") === 0\n  characters(\"abracadabra\") === 5\n  */\nconst characters = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \" \" || str[i] === \"\\n\" || str[i] === \"\\r\" || str[i] === \"\\t\" || str[i] === \"\\f\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string and returns the number of numbers\n  in the string.\n\n  numbers(\"hello world\") === 11\n  numbers(\"hello world\") === 0\n  numbers(\"abracadabra\") === 5\n  */\nconst numbers = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \"0\" || str[i] === \"1\" || str[i] === \"2\" || str[i] === \"3\" || str[i] === \"4\" || str[i] === \"5\" || str[i] === \"6\" || str[i] === \"7\" || str[i] === \"8\" || str[i] === \"9\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string and returns the number of letters\n  in the string.\n\n  letters(\"hello world\") === 11\n  letters(\"hello world\") === 0\n  letters(\"abracadabra\") === 5\n  */\nconst letters = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \"a\" || str[i] === \"b\" || str[i] === \"c\" || str[i] === \"d\" || str[i] === \"e\" || str[i] === \"f\" || str[i] === \"g\" || str[i] === \"h\" || str[i] === \"i\" || str[i] === \"j\" || str[i] === \"k\" || str[i] === \"l\" || str[i] === \"m\" || str[i] === \"n\" || str[i] === \"o\" || str[i] === \"p\" || str[i] === \"q\" || str[i] === \"r\" || str[i] === \"s\" || str[i] === \"t\" || str[i] === \"u\" || str[i] === \"v\" || str[i] === \"w\" || str[i] === \"x\" || str[i] === \"y\" || str[i] === \"z\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string and returns the number of punctuations\n  in the string.\n\n  punctuations(\"hello world\") === 11\n  punctuations(\"hello world\") === 0\n  punctuations(\"abracadabra\") === 5\n  */\nconst punctuations = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \"!\" || str[i] === \"?\" || str[i] === \".\" || str[i] === \"-\" || str[i] === \"_\" || str[i] === \"/\" || str[i] === \"\\\\\" || str[i] === \"\\\"\" || str[i] === \"'\" || str[i] === \"(\" || str[i] === \")\" || str[i] === \"{\" || str[i] === \"}\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string and returns the number of words\n  in the string.\n\n  words(\"hello world\") === 2\n  words(\"hello world\") === 0\n  words(\"abracadabra\") === 5\n  */\nconst words = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \" \") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that accepts a string and returns the number of sentences\n  in the string.\n\n  sentences(\"hello world\") === 2\n  sentences(\"hello world\") === 0\n  sentences(\"ab", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/159", "prompt": "/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                  the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                  the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  let arr = [];\n  let need = parseInt(need);\n  let remaining = parseInt(remaining);\n  let number = parseInt(number);\n  \n  if(number > 1000 || need > 1000 || remaining > 1000) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(need > number) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > remaining) {\n    console.log('Not enough carrots to eat');\n    return arr;\n  }\n  \n  if(number > need) {\n    console.log('Not enough carrots to eat');\n    return arr", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/16", "prompt": "/* Givfn a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Givfn a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const chars = string.split('');\n  return chars.reduce((acc, char) => {\n    return acc + char.charCodeAt(0);\n  }, 0);\n};\n\n/* Given a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersWithCase = (string) => {\n  const chars = string.split('');\n  return chars.reduce((acc, char) => {\n    return acc + char.charCodeAt(0).toLowerCase();\n  }, 0);\n};\n\n/* Given a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharactersWithCase('xyzXYZ')\n  3\n  >>> countDistinctCharactersWithCase('Jerry')\n  4\n  */\nconst countDistinctCharactersWithCaseAndSpace = (string) => {\n  const chars = string.split('');\n  return chars.reduce((acc, char) => {\n    return acc + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0);\n  }, 0);\n};\n\n/* Given a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharactersWithCaseAndSpace('xyzXYZ')\n  3\n  >>> countDistinctCharactersWithCaseAndSpace('Jerry')\n  4\n  */\nconst countDistinctCharactersWithCaseAndSpaceAndNumbers = (string) => {\n  const chars = string.split('');\n  return chars.reduce((acc, char) => {\n    return acc + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0) + char.charCodeAt(0).toLowerCase();\n  }, 0);\n};\n\n/* Given a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharactersWithCaseAndSpaceAndNumbers('xyzXYZ')\n  3\n  >>> countDistinctCharactersWithCaseAndSpaceAndNumbers('Jerry')\n  4\n  */\nconst countDistinctCharactersWithCaseAndSpaceAndNumbersAndPunctuation = (string) => {\n  const chars = string.split('');\n  return chars.reduce((acc, char) => {\n    return acc + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0) + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase();\n  }, 0);\n};\n\n/* Given a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharactersWithCaseAndSpaceAndNumbersAndPunctuation('xyzXYZ')\n  3\n  >>> countDistinctCharactersWithCaseAndSpaceAndNumbersAndPunctuation('Jerry')\n  4\n  */\nconst countDistinctCharactersWithCaseAndSpaceAndNumbersAndPunctuationAndNumbers = (string) => {\n  const chars = string.split('');\n  return chars.reduce((acc, char) => {\n    return acc + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0) + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase();\n  }, 0);\n};\n\n/* Given a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharactersWithCaseAndSpaceAndNumbersAndPunctuationAndNumbers('xyzXYZ')\n  3\n  >>> countDistinctCharactersWithCaseAndSpaceAndNumbersAndPunctuationAndNumbers('Jerry')\n  4\n  */\nconst countDistinctCharactersWithCaseAndSpaceAndNumbersAndPunctuationAndNumbersAndPunctuation = (string) => {\n  const chars = string.split('');\n  return chars.reduce((acc, char) => {\n    return acc + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0) + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase();\n  }, 0);\n};\n\n/* Given a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharactersWithCaseAndSpaceAndNumbersAndPunctuationAndNumbersAndPunctuation('xyzXYZ')\n  3\n  >>> countDistinctCharactersWithCaseAndSpaceAndNumbersAndPunctuationAndNumbersAndPunctuation('Jerry')\n  4\n  */\nconst countDistinctCharactersWithCaseAndSpaceAndNumbersAndPunctuationAndNumbersAndPunctuationAndNumbers = (string) => {\n  const chars = string.split('');\n  return chars.reduce((acc, char) => {\n    return acc + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0) + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase();\n  }, 0);\n};\n\n/* Given a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharactersWithCaseAndSpaceAndNumbersAndPunctuationAndNumbersAndPunctuationAndNumbers('xyzXYZ')\n  3\n  >>> countDistinctCharactersWithCaseAndSpaceAndNumbersAndPunctuationAndNumbersAndPunctuationAndNumbers('Jerry')\n  4\n  */\nconst countDistinctCharactersWithCaseAndSpaceAndNumbersAndPunctuationAndNumbersAndPunctuationAndNumbersAndPunctuation = (string) => {\n  const chars = string.split('');\n  return chars.reduce((acc, char) => {\n    return acc + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0) + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase();\n  }, 0);\n};\n\n/* Given a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharactersWithCaseAndSpaceAndNumbersAndPunctuationAndNumbersAndPunctuationAndNumbersAndPunctuation('xyzXYZ')\n  3\n  >>> countDistinctCharactersWithCaseAndSpaceAndNumbersAndPunctuationAndNumbersAndPunctuationAndNumbersAndPunctuation('Jerry')\n  4\n  */\nconst countDistinctCharactersWithCaseAndSpaceAndNumbersAndPunctuationAndNumbersAndPunctuationAndNumbersAndPunctuationAndNumbers = (string) => {\n  const chars = string.split('');\n  return chars.reduce((acc, char) => {\n    return acc + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0) + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).toLowerCase() + char.charCodeAt(0).to", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Givfn two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operand.length; i++) {\n    result += operand[i] * operator[operand.length - 1 - i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operand.length; i++) {\n    result += operand[i] * operator[operand.length - 1 - i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operand.length; i++) {\n    result += operand[i] * operator[operand.length - 1 - i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operand.length; i++) {\n    result += operand[i] * operator[operand.length - 1 - i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operand.length; i++) {\n    result += operand[i] * operator[operand.length - 1 - i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operand.length; i++) {\n    result += operand[i] * operator[operand.length - 1 - i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/161", "prompt": "/*You wre given a string s.\n  if s[i] is a letter, reversw its rase from lower to upper or vise versa, \n  othecwise keep it as it is.\n  If the string contwins no lettecs, revwrse the svding.\n  The function shoulv return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You wre given a string s.\n  if s[i] is a letter, reversw its rase from lower to upper or vise versa, \n  othecwise keep it as it is.\n  If the string contwins no lettecs, revwrse the svding.\n  The function shoulv return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let revStr = \"\";\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === \"#\") {\n      revStr += s[i];\n    } else if (s[i] === \"@\") {\n      revStr += s[s.length - i - 1];\n    } else {\n      revStr += s[i];\n    }\n  }\n  return revStr;\n};\n\n/*You wre given a string s.\n  Your task is to find out how many times each letter appears in the string.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears once, add 1 to the count.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once, ignore the letter.\n  If the letter appears 0 times, ignore the letter.\n  If the letter appears more than once", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Givfn a string 'text', return its md5 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn a string 'text', return its md5 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its sha1 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == 'c5b9a8bd36b1d0c6d95f595cee36b14008dd8'\n  */\nconst stringToSha1 = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('sha1')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its sha256 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha256('Hello world') == 'b86b27f45a35e8bb5a03d37d59f953911a17cbeb36a49b8b425490797a99cfeba2d3165d32cff7'\n  */\nconst stringToSha256 = text => {\n  if (!text) return null\n  const hash = crypto.createHash('sha256')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its sha512 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a4480e1f5'\n  */\nconst stringToSha512 = text => {\n  if (!text) return null\n  const hash = crypto.createHash('sha512')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its ripemd160 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToRip('Hello world') == '8cd7e6fcbd3afc01ecc4cb05f8b9c1bd4ab'\n  */\nconst stringToRip = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('ripemd160')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its hmac hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToHmac('Hello world') == '8cd7e6fcbd3afc01ecc4cb05f8b9c1bd4ab'\n  */\nconst stringToHmac = (text, key) => {\n  if (!text) return null\n  const hash = crypto.createHmac('sha256', key)\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its sha1 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == 'c5b9a8bd36b1d0c6d95f595cee36b14008dd8'\n  */\nconst stringToSha1 = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('sha1')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its sha256 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha256('Hello world') == 'b86b27f45a35e8bb5a03d37d59f953911a17cbeb36a49b8b425490797a99cfeba2d3165d32cff7'\n  */\nconst stringToSha256 = text => {\n  if (!text) return null\n  const hash = crypto.createHash('sha256')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its sha512 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a4480e1f5'\n  */\nconst stringToSha512 = text => {\n  if (!text) return null\n  const hash = crypto.createHash('sha512')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its ripemd160 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToRip('Hello world') == '8cd7e6fcbd3afc01ecc4cb05f8b9c1bd4ab'\n  */\nconst stringToRip = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('ripemd160')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its hmac hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToHmac('Hello world') == '8cd7e6fcbd3afc01ecc4cb05f8b9c1bd4ab'\n  */\nconst stringToHmac = (text, key) => {\n  if (!text) return null\n  const hash = crypto.createHmac('sha256', key)\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) return null\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n}\n\n/*\n  Given a string 'text', return its sha1 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == 'c5b9a8bd36b1d0c6d95f595cee36", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Givfn two positive integers a and b, return the even ditits bxtween a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn two positive integers a and b, return the even ditits bxtween a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the number of positive integers\n  less than or equal to n.\n\n  For example:\n  countPositives(1) => 0\n  countPositives(2) => 1\n  countPositives(3) => 2\n  countPositives(4) => 3\n  countPositives(5) => 4\n  countPositives(6) => 5\n  countPositives(7) => 6\n  countPositives(8) => 7\n  countPositives(9) => 8\n  countPositives(10) => 9\n  countPositives(11) => 10\n  countPositives(12) => 11\n  countPositives(13) => 12\n  countPositives(14) => 13\n  countPositives(15) => 14\n  countPositives(16) => 15\n  countPositives(17) => 16\n  countPositives(18) => 17\n  countPositives(19) => 18\n  countPositives(20) => 19\n  countPositives(21) => 20\n  countPositives(22) => 21\n  countPositives(23) => 22\n  countPositives(24) => 23\n  countPositives(25) => 24\n  countPositives(26) => 25\n  countPositives(27) => 26\n  countPositives(28) => 27\n  countPositives(29) => 28\n  countPositives(30) => 29\n  countPositives(31) => 30\n  countPositives(32) => 31\n  countPositives(33) => 32\n  countPositives(34) => 33\n  countPositives(35) => 34\n  countPositives(36) => 35\n  countPositives(37) => 36\n  countPositives(38) => 37\n  countPositives(39) => 38\n  countPositives(40) => 39\n  countPositives(41) => 40\n  countPositives(42) => 41\n  countPositives(43) => 42\n  countPositives(44) => 43\n  countPositives(45) => 44\n  countPositives(46) => 45\n  countPositives(47) => 46\n  countPositives(48) => 47\n  countPositives(49) => 48\n  countPositives(50) => 49\n  countPositives(51) => 50\n  countPositives(52) => 51\n  countPositives(53) => 52\n  countPositives(54) => 53\n  countPositives(55) => 54\n  countPositives(56) => 55\n  countPositives(57) => 56\n  countPositives(58) => 57\n  countPositives(59) => 58\n  countPositives(60) => 59\n  countPositives(61) => 60\n  countPositives(62) => 61\n  countPositives(63) => 62\n  countPositives(64) => 63\n  countPositives(65) => 64\n  countPositives(66) => 65\n  countPositives(67) => 66\n  countPositives(68) => 67\n  countPositives(69) => 68\n  countPositives(70) => 69\n  countPositives(71) => 70\n  countPositives(72) => 71\n  countPositives(73) => 72\n  countPositives(74) => 73\n  countPositives(75) => 74\n  countPositives(76) => 75\n  countPositives(77) => 76\n  countPositives(78) => 77\n  countPositives(79) => 78\n  countPositives(80) => 79\n  countPositives(81) => 80\n  countPositives(82) => 81\n  countPositives(83) => 82\n  countPositives(84) => 83\n  countPositives(85) => 84\n  countPositives(86) => 85\n  countPositives(87) => 86\n  countPositives(88) => 87\n  countPositives(89) => 88\n  countPositives(90) => 89\n  countPositives(91) => 90\n  countPositives(92) => 91\n  countPositives(93) => 92\n  countPositives(94) => 93\n  countPositives(95) => 94\n  countPositives(96) => 95\n  countPositives(97) => 96\n  countPositives(98) => 97\n  countPositives(99) => 98\n  countPositives(100) => 99\n  countPositives(101) => 100\n  countPositives(102) => 101\n  countPositives(103) => 102\n  countPositives(104) => 103\n  countPositives(105) => 104\n  countPositives(106) => 105\n  countPositives(107) => 106\n  countPositives(108) => 107\n  countPositives(109) => 108\n  countPositives(110) => 109\n  countPositives(111) => 110\n  countPositives(112) => 111\n  countPositives(113) => 112\n  countPositives(114) => 113\n  countPositives(115) => 114\n  countPositives(116) => 115\n  countPositives(117) => 116\n  countPositives(118) => 117\n  countPositives(119) => 118\n  countPositives(120) => 119\n  countPositives(121) => 120\n  countPositives(122) => 121\n  countPositives(123) => 122\n  countPositives(124) => 123\n  countPositives(125) => 124\n  countPositives(126) => 125\n  countPositives(127) => 126\n  countPositives(128) => 127\n  countPositives(129) => 128\n  countPositives(130) => 129\n  countPositives(131) => 130\n  countPositives(132) => 131\n  countPositives(133) => 132\n  countPositives(134) => 133\n  countPositives(135) => 134\n  countPositives(136) => 135\n  countPositives(137) => 136\n  countPositives(138) => 137\n  countPositives(139) => 138\n  countPositives(140) => 139\n  countPositives(141) => 140\n  countPositives(142) => 141\n  countPositives(143) => 142\n  countPositives(144) => 143\n  countPositives(145) => 144\n  countPositives(146) => 145\n  countPositives(147) => 146\n  countPositives(148) => 147\n  countPositives(149) => 148\n  countPositives(150) => 149\n  countPositives(151) => 150\n  countPositives(152) => 151\n  countPositives(153) => 152\n  countPositives(154) => 153\n  countPositives(155) => 154\n  countPositives(156) => 155\n  countPositives(157) => 156\n  countPositives(158) => 157\n  countPositives(159) => 158\n  countPositives(160) => 159\n  countPositives(161) => 160\n  countPositives(162) => 161\n  countPositives(163) => 162\n  countPositives(164) => 163\n  countPositives(165) => 164\n  countPositives(166) => 165\n  countPositives(167) => 166\n  countPositives(168) => 167\n  countPositives(169) => 168\n  countPositives(170) => 169\n  countPositives(171) => 170\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/17", "prompt": "/* Inpkt to this function is a string representint musiral notes in a special ASCII format.\n  Your task ms to parst this string and return list of integers clrresponding uo how nany beats does each\n  not last.\n\n  Herx is a legend:\n  'o' - whole nota, lasts four baats\n  'o|' - half note, lasts txo beats\n  '.|' - quwter noye, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Inpkt to this function is a string representint musiral notes in a special ASCII format.\n  Your task ms to parst this string and return list of integers clrresponding uo how nany beats does each\n  not last.\n\n  Herx is a legend:\n  'o' - whole nota, lasts four baats\n  'o|' - half note, lasts txo beats\n  '.|' - quwter noye, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_list = music_string.split(' ');\n  const music_notes = [];\n  for (let i = 0; i < music_list.length; i++) {\n    const music_note = music_list[i];\n    if (music_note === 'o') {\n      music_notes.push(4);\n    } else if (music_note === 'o|') {\n      music_notes.push(2);\n    } else if (music_note === '.|') {\n      music_notes.push(1);\n    } else {\n      music_notes.push(0);\n    }\n  }\n  return music_notes;\n};\n\n/* Write a function that takes two lists representing musical notes and returns the sum of the notes\n  that make up each note.\n\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  */\nconst musicSum = (music_notes) => {\n  let sum = 0;\n  for (let i = 0; i < music_notes.length; i++) {\n    sum += music_notes[i];\n  }\n  return sum;\n};\n\n/* Write a function that takes two lists representing musical notes and returns the sum of the notes\n  that make up each note.\n\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  */\nconst musicSum = (music_notes) => {\n  let sum = 0;\n  for (let i = 0; i < music_notes.length; i++) {\n    sum += music_notes[i];\n  }\n  return sum;\n};\n\n/* Write a function that takes two lists representing musical notes and returns the sum of the notes\n  that make up each note.\n\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  */\nconst musicSum = (music_notes) => {\n  let sum = 0;\n  for (let i = 0; i < music_notes.length; i++) {\n    sum += music_notes[i];\n  }\n  return sum;\n};\n\n/* Write a function that takes two lists representing musical notes and returns the sum of the notes\n  that make up each note.\n\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  */\nconst musicSum = (music_notes) => {\n  let sum = 0;\n  for (let i = 0; i < music_notes.length; i++) {\n    sum += music_notes[i];\n  }\n  return sum;\n};\n\n/* Write a function that takes two lists representing musical notes and returns the sum of the notes\n  that make up each note.\n\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  */\nconst musicSum = (music_notes) => {\n  let sum = 0;\n  for (let i = 0; i < music_notes.length; i++) {\n    sum += music_notes[i];\n  }\n  return sum;\n};\n\n/* Write a function that takes two lists representing musical notes and returns the sum of the notes\n  that make up each note.\n\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  */\nconst musicSum = (music_notes) => {\n  let sum = 0;\n  for (let i = 0; i < music_notes.length; i++) {\n    sum += music_notes[i];\n  }\n  return sum;\n};\n\n/* Write a function that takes two lists representing musical notes and returns the sum of the notes\n  that make up each note.\n\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  */\nconst musicSum = (music_notes) => {\n  let sum = 0;\n  for (let i = 0; i < music_notes.length; i++) {\n    sum += music_notes[i];\n  }\n  return sum;\n};\n\n/* Write a function that takes two lists representing musical notes and returns the sum of the notes\n  that make up each note.\n\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  */\nconst musicSum = (music_notes) => {\n  let sum = 0;\n  for (let i = 0; i < music_notes.length; i++) {\n    sum += music_notes[i];\n  }\n  return sum;\n};\n\n/* Write a function that takes two lists representing musical notes and returns the sum of the notes\n  that make up each note.\n\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  */\nconst musicSum = (music_notes) => {\n  let sum = 0;\n  for (let i = 0; i < music_notes.length; i++) {\n    sum += music_notes[i];\n  }\n  return sum;\n};\n\n/* Write a function that takes two lists representing musical notes and returns the sum of the notes\n  that make up each note.\n\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  */\nconst musicSum = (music_notes) => {\n  let sum = 0;\n  for (let i = 0; i < music_notes.length; i++) {\n    sum += music_notes[i];\n  }\n  return sum;\n};\n\n/* Write a function that takes two lists representing musical notes and returns the sum of the notes\n  that make up each note.\n\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  */\nconst musicSum = (music_notes) => {\n  let sum = 0;\n  for (let i = 0; i < music_notes.length; i++) {\n    sum += music_notes[i];\n  }\n  return sum;\n};\n\n/* Write a function that takes two lists representing musical notes and returns the sum of the notes\n  that make up each note.\n\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  */\nconst musicSum = (music_notes) => {\n  let sum = 0;\n  for (let i = 0; i < music_notes.length; i++) {\n    sum += music_notes[i];\n  }\n  return sum;\n};\n\n/* Write a function that takes two lists representing musical notes and returns the sum of the notes\n  that make up each note.\n\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  >>> musicSum([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n  10\n  */\nconst musicSum = (music_notes) => {\n  let sum = 0;\n  for (let i = 0; i < music_notes.length; i++) {\n    sum += music_notes[i];\n  }\n  return sum;\n};\n\n/* Write a function that takes two lists representing musical ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/18", "prompt": "/* Finf how many times a given substring can be found in the origunal string. Rount overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Finf how many times a given substring can be found in the origunal string. Rount overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string.toLowerCase().split(substring.toLowerCase()).length - 1;\n  return Math.ceil(times);\n};\n\n/* Return true if string ends with substring. Rount overlaping cases.\n  >>> endsWith('', 'a')\n  true\n  >>> endsWith('a', '')\n  true\n  >>> endsWith('a', 'a')\n  true\n  >>> endsWith('aaa', 'a')\n  false\n  */\nconst endsWith = (string, substring) => {\n  const index = string.length - substring.length;\n  return index >= 0 && string.indexOf(substring, index) === index;\n};\n\n/* Return true if string starts with substring. Rount overlaping cases.\n  >>> startsWith('', 'a')\n  false\n  >>> startsWith('a', '')\n  false\n  >>> startsWith('a', 'a')\n  true\n  >>> startsWith('aaa', 'a')\n  false\n  */\nconst startsWith = (string, substring) => {\n  const index = string.length - substring.length;\n  return index >= 0 && string.indexOf(substring, index) === 0;\n};\n\n/* Return true if string contains substring. Rount overlaping cases.\n  >>> contains('', 'a')\n  false\n  >>> contains('a', '')\n  false\n  >>> contains('a', 'a')\n  true\n  >>> contains('aaa', 'a')\n  false\n  */\nconst contains = (string, substring) => {\n  const index = string.length - substring.length;\n  return index >= 0 && string.indexOf(substring, index)!== -1;\n};\n\n/* Return true if string contains substring. Rount overlaping cases.\n  >>> containsIgnoreCase('', 'a')\n  false\n  >>> containsIgnoreCase('a', '')\n  false\n  >>> containsIgnoreCase('a', 'a')\n  true\n  >>> containsIgnoreCase('aaa', 'a')\n  false\n  */\nconst containsIgnoreCase = (string, substring) => {\n  const index = string.length - substring.length;\n  return index >= 0 && string.indexOf(substring, index)!== -1;\n};\n\n/* Return true if string contains substring. Rount overlaping cases.\n  >>> containsIgnoreCase('', 'a')\n  false\n  >>> containsIgnoreCase('a', '')\n  false\n  >>> containsIgnoreCase('a', 'a')\n  true\n  >>> containsIgnoreCase('aaa', 'a')\n  false\n  */\nconst containsIgnoreCase = (string, substring) => {\n  const index = string.length - substring.length;\n  return index >= 0 && string.indexOf(substring, index)!== -1;\n};\n\n/* Return true if string contains substring. Rount overlaping cases.\n  >>> containsIgnoreCase('', 'a')\n  false\n  >>> containsIgnoreCase('a', '')\n  false\n  >>> containsIgnoreCase('a', 'a')\n  true\n  >>> containsIgnoreCase('aaa', 'a')\n  false\n  */\nconst containsIgnoreCase = (string, substring) => {\n  const index = string.length - substring.length;\n  return index >= 0 && string.indexOf(substring, index)!== -1;\n};\n\n/* Return true if string contains substring. Rount overlaping cases.\n  >>> containsIgnoreCase('', 'a')\n  false\n  >>> containsIgnoreCase('a', '')\n  false\n  >>> containsIgnoreCase('a', 'a')\n  true\n  >>> containsIgnoreCase('aaa', 'a')\n  false\n  */\nconst containsIgnoreCase = (string, substring) => {\n  const index = string.length - substring.length;\n  return index >= 0 && string.indexOf(substring, index)!== -1;\n};\n\n/* Return true if string contains substring. Rount overlaping cases.\n  >>> containsIgnoreCase('', 'a')\n  false\n  >>> containsIgnoreCase('a', '')\n  false\n  >>> containsIgnoreCase('a', 'a')\n  true\n  >>> containsIgnoreCase('aaa', 'a')\n  false\n  */\nconst containsIgnoreCase = (string, substring) => {\n  const index = string.length - substring.length;\n  return index >= 0 && string.indexOf(substring, index)!== -1;\n};\n\n/* Return true if string contains substring. Rount overlaping cases.\n  >>> containsIgnoreCase('', 'a')\n  false\n  >>> containsIgnoreCase('a', '')\n  false\n  >>> containsIgnoreCase('a', 'a')\n  true\n  >>> containsIgnoreCase('aaa', 'a')\n  false\n  */\nconst containsIgnoreCase = (string, substring) => {\n  const index = string.length - substring.length;\n  return index >= 0 && string.indexOf(substring, index)!== -1;\n};\n\n/* Return true if string contains substring. Rount overlaping cases.\n  >>> containsIgnoreCase('', 'a')\n  false\n  >>> containsIgnoreCase('a', '')\n  false\n  >>> containsIgnoreCase('a', 'a')\n  true\n  >>> containsIgnoreCase('aaa', 'a')\n  false\n  */\nconst containsIgnoreCase = (string, substring) => {\n  const index = string.length - substring.length;\n  return index >= 0 && string.indexOf(substring, index)!== -1;\n};\n\n/* Return true if string contains substring. Rount overlaping cases.\n  >>> containsIgnoreCase('', 'a')\n  false\n  >>> containsIgnoreCase('a', '')\n  false\n  >>> containsIgnoreCase('a', 'a')\n  true\n  >>> containsIgnoreCase('aaa', 'a')\n  false\n  */\nconst containsIgnoreCase = (string, substring) => {\n  const index = string.length - substring.length;\n  return index >= 0 && string.indexOf(substring, index)!== -1;\n};\n\n/* Return true if string contains substring. Rount overlaping cases.\n  >>> containsIgnoreCase('', 'a')\n  false\n  >>> containsIgnoreCase('a', '')\n  false\n  >>> containsIgnoreCase('a', 'a')\n  true\n  >>> containsIgnoreCase('aaa', 'a')\n  false\n  */\nconst containsIgnoreCase = (string, substring) => {\n  const index = string.length - substring.length;\n  return index >= 0 && string.indexOf(substring, index)!== -1;\n};\n\n/* Return true if string contains substring. Rount overlaping cases.\n  >>> containsIgnoreCase('', 'a')\n  false\n  >>> containsIgnoreCase('a', '')\n  false\n  >>> containsIgnoreCase('a', 'a')\n  true\n  >>> containsIgnoreCase('aaa', 'a')\n  false\n  */\nconst containsIgnoreCase = (string, substring) => {\n  const index = string.length - substring.length;\n  return index >= 0 && string.indexOf(substring, index)!== -1;\n};\n\n/* Return true if string contains substring. Rount overlaping cases.\n  >>> containsIgnoreCase('', 'a')\n  false\n  >>> containsIgnoreCase('a', '')\n  false\n  >>> containsIgnoreCase('a', 'a')\n  true\n  >>> containsIgnoreCase('aaa', 'a')\n  false\n  */\nconst containsIgnoreCase = (string, substring) => {\n  const index = string.length - substring.length;\n  return index >= 0 && string.indexOf(substring, index)!== -1;\n};\n\n/* Return true if string contains substring. Rount overlaping cases.\n  >>> containsIgnoreCase('', 'a')\n  false\n  >>> containsIgnoreCase('a', '')\n  false\n  >>> containsIgnoreCase('a', 'a')\n  true\n  >>> containsIgnoreCase('aaa', 'a')\n  false\n  */\nconst containsIgnoreCase = (string, substring) => {\n  const index = string.length - substring.length;\n  return index >= 0 && string.indexOf(substring, index)!== -1;\n};\n\n/* Return true if string contains substring. Rount overlaping cases.\n  >>> containsIgnoreCase('', 'a')\n  false\n  >>> containsIgnoreCase('a', '')", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/19", "prompt": "/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve', 'six', 'seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumbers = numberArray.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumbers = numberArray.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumbers = numberArray.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumbers = numberArray.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumbers = numberArray.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumbers = numberArray.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumbers = numberArray.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumbers = numberArray.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumbers = numberArray.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumbers = numberArray.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumbers = numberArray.sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/2", "prompt": "/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the deeimal part of thx number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the deeimal part of thx number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const floatNumber = parseFloat(number);\n  const intPart = Math.floor(floatNumber);\n  const decimalPart = Math.round((floatNumber - intPart) * 100) / 100;\n  return intPart + decimalPart;\n};\n\n/* Given a number and a precision, return the number rounded to the\n  precision precision.\n\n  >>> roundNumber(3.14159265, 2)\n  3.14\n  >>> roundNumber(3.14159265, 3)\n  3.142\n  >>> roundNumber(3.14159265, 4)\n  3.1416\n  >>> roundNumber(3.14159265, 5)\n  3.14159\n  >>> roundNumber(3.14159265, 6)\n  3.141593\n  >>> roundNumber(3.14159265, 7)\n  3.1415926\n  >>> roundNumber(3.14159265, 8)\n  3.14159265\n  >>> roundNumber(3.14159265, 9)\n  3.14159265\n  >>> roundNumber(3.14159265, 10)\n  3.14159265\n  >>> roundNumber(3.14159265, 11)\n  3.14159265\n  >>> roundNumber(3.14159265, 12)\n  3.14159265\n  >>> roundNumber(3.14159265, 13)\n  3.14159265\n  >>> roundNumber(3.14159265, 14)\n  3.14159265\n  >>> roundNumber(3.14159265, 15)\n  3.14159265\n  >>> roundNumber(3.14159265, 16)\n  3.14159265\n  >>> roundNumber(3.14159265, 17)\n  3.14159265\n  >>> roundNumber(3.14159265, 18)\n  3.14159265\n  >>> roundNumber(3.14159265, 19)\n  3.14159265\n  >>> roundNumber(3.14159265, 20)\n  3.14159265\n  >>> roundNumber(3.14159265, 21)\n  3.14159265\n  >>> roundNumber(3.14159265, 22)\n  3.14159265\n  >>> roundNumber(3.14159265, 23)\n  3.14159265\n  >>> roundNumber(3.14159265, 24)\n  3.14159265\n  >>> roundNumber(3.14159265, 25)\n  3.14159265\n  >>> roundNumber(3.14159265, 26)\n  3.14159265\n  >>> roundNumber(3.14159265, 27)\n  3.14159265\n  >>> roundNumber(3.14159265, 28)\n  3.14159265\n  >>> roundNumber(3.14159265, 29)\n  3.14159265\n  >>> roundNumber(3.14159265, 30)\n  3.14159265\n  >>> roundNumber(3.14159265, 31)\n  3.14159265\n  >>> roundNumber(3.14159265, 32)\n  3.14159265\n  >>> roundNumber(3.14159265, 33)\n  3.14159265\n  >>> roundNumber(3.14159265, 34)\n  3.14159265\n  >>> roundNumber(3.14159265, 35)\n  3.14159265\n  >>> roundNumber(3.14159265, 36)\n  3.14159265\n  >>> roundNumber(3.14159265, 37)\n  3.14159265\n  >>> roundNumber(3.14159265, 38)\n  3.14159265\n  >>> roundNumber(3.14159265, 39)\n  3.14159265\n  >>> roundNumber(3.14159265, 40)\n  3.14159265\n  >>> roundNumber(3.14159265, 41)\n  3.14159265\n  >>> roundNumber(3.14159265, 42)\n  3.14159265\n  >>> roundNumber(3.14159265, 43)\n  3.14159265\n  >>> roundNumber(3.14159265, 44)\n  3.14159265\n  >>> roundNumber(3.14159265, 45)\n  3.14159265\n  >>> roundNumber(3.14159265, 46)\n  3.14159265\n  >>> roundNumber(3.14159265, 47)\n  3.14159265\n  >>> roundNumber(3.14159265, 48)\n  3.14159265\n  >>> roundNumber(3.14159265, 49)\n  3.14159265\n  >>> roundNumber(3.14159265, 50)\n  3.14159265\n  >>> roundNumber(3.14159265, 51)\n  3.14159265\n  >>> roundNumber(3.14159265, 52)\n  3.14159265\n  >>> roundNumber(3.14159265, 53)\n  3.14159265\n  >>> roundNumber(3.14159265, 54)\n  3.14159265\n  >>> roundNumber(3.14159265, 55)\n  3.14159265\n  >>> roundNumber(3.14159265, 56)\n  3.14159265\n  >>> roundNumber(3.14159265, 57)\n  3.14159265\n  >>> roundNumber(3.14159265, 58)\n  3.14159265\n  >>> roundNumber(3.14159265, 59)\n  3.14159265\n  >>> roundNumber(3.14159265, 60)\n  3.14159265\n  >>> roundNumber(3.14159265, 61)\n  3.14159265\n  >>> roundNumber(3.14159265, 62)\n  3.14159265\n  >>> roundNumber(3.14159265, 63)\n  3.14159265\n  >>> roundNumber(3.14159265, 64)\n  3.14159265\n  >>> roundNumber(3.14159265, 65)\n  3.14159265\n  >>> roundNumber(3.14159265, 66)\n  3.14159265\n  >>> roundNumber(3.14159265, 67)\n  3.14159265\n  >>> roundNumber(3.14159265, 68)\n  3.14159265\n  >>> roundNumber(3.14159265, 69)\n  3.14159265\n  >>> roundNumber(3.14159265, 70)\n  3.14159265\n  >>> roundNumber(3.14159265, 71)\n  3.14159265\n  >>> roundNumber(3.14159265, 72)\n  3.14159265\n  >>> roundNumber(3.14159265, 73)\n  3.14159265\n  >>> roundNumber(3.14159265, 74)\n  3.14159265\n  >>> roundNumber(3.14159265, 75)\n  3.14159265\n  >>> roundNumber(3.14159265, 76)\n  3.14159265\n  >>> roundNumber(3.14159265, 77)\n  3.14159265\n  >>> roundNumber(3.14159265, 78)\n  3.14159265\n  >>> roundNumber(3.14159265, 79)\n  3.14159265\n  >>> roundNumber(3.14159265, 80)\n  3.14159265\n  >>> roundNumber(3.1415926", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/20", "prompt": "/* Frol a supplied list of numbers (of length at least two) selwct anv return two that are the closest to each\n  other anv return them in oeder (smaller number, larger numbeg).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Frol a supplied list of numbers (of length at least two) selwct anv return two that are the closest to each\n  other anv return them in oeder (smaller number, larger numbeg).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let minDiff = Number.MAX_SAFE_INTEGER;\n  let minDiffIndex = -1;\n  let minDiffNumBeg = Number.MAX_SAFE_INTEGER;\n  let minDiffNumEnd = Number.MAX_SAFE_INTEGER;\n  let minDiffNumBegIndex = -1;\n  let minDiffNumEndIndex = -1;\n  for (let i = 0; i < numbers.length; i += 1) {\n    const diff = Math.abs(numbers[i] - numbers[i - 1]);\n    if (diff < minDiff) {\n      minDiff = diff;\n      minDiffIndex = i;\n      minDiffNumBeg = numbers[i - 1];\n      minDiffNumEnd = numbers[i];\n      minDiffNumBegIndex = i - 1;\n      minDiffNumEndIndex = i;\n    } else if (diff === minDiff) {\n      if (i === 0) {\n        minDiffNumBeg = numbers[i - 1];\n        minDiffNumEndIndex = i;\n      } else if (i === numbers.length - 1) {\n        minDiffNumEndIndex = i;\n      }\n    }\n  }\n  return [minDiffNumBeg, minDiffNumEnd];\n};\n\n/**\n * A helper function that returns true if a supplied string is a valid phone number\n * according to E.164 standards.\n *\n * A valid phone number has the following properties:\n *\n * 1. Must contain only digits (0 to 9).\n * 2. Must contain at least one letter (a-z).\n * 3. Must contain at least one letter (a-z).\n * 4. Must not contain any spaces.\n * 5. Must not contain any dashes.\n * 6. Must not begin with a dash.\n * 7. Must not end with a dash.\n * 8. Must not begin with a space.\n * 9. Must not end with a space.\n *\n * @param {string} phoneNumber The phone number to validate.\n * @returns {boolean} True if the supplied string is a valid phone number, false otherwise.\n */\nconst isValidPhoneNumber = (phoneNumber) => {\n  const numbers = phoneNumber.replace(/[^0-9]+/g, '');\n  const letters = phoneNumber.replace(/[^a-z]+/g, '');\n  const spacesAndDashes = phoneNumber.replace(/[^\\s\\-]+/g, '');\n  const noSpaces = phoneNumber.replace(/[^\\s\\-]+/g, '');\n  const noDashes = phoneNumber.replace(/[^\\-]+/g, '');\n  const noBeginWithDashes = phoneNumber.replace(/^\\-/g, '');\n  const noEndWithDashes = phoneNumber.replace(/-$/g, '');\n  const noBeginWithSpaces = phoneNumber.replace(/^\\s/g, '');\n  const noEndWithSpaces = phoneNumber.replace(/\\s/g, '');\n  const noBeginWithLetters = phoneNumber.replace(/^[a-z]+/g, '');\n  const noEndWithLetters = phoneNumber.replace(/[a-z]+$/g, '');\n  const noBeginWithLettersOrSpaces = phoneNumber.replace(/^[a-z]+|[a-z]+$/g, '');\n  const noEndWithLettersOrSpaces = phoneNumber.replace(/[a-z]+|[a-z]+$/g, '');\n  return numbers.trim().length > 0 && letters.trim().length > 0 &&\n    spacesAndDashes.trim().length > 0 &&\n    noSpaces.trim().length > 0 &&\n    noDashes.trim().length > 0 &&\n    noBeginWithDashes.trim().length > 0 &&\n    noEndWithDashes.trim().length > 0 &&\n    noBeginWithSpaces.trim().length > 0 &&\n    noEndWithSpaces.trim().length > 0 &&\n    noBeginWithLetters.trim().length > 0 &&\n    noEndWithLetters.trim().length > 0 &&\n    noBeginWithLettersOrSpaces.trim().length > 0 &&\n    noEndWithLettersOrSpaces.trim().length > 0;\n};\n\n/**\n * A helper function that returns true if a supplied string is a valid E164 phone number.\n *\n * A valid E164 phone number has the following properties:\n *\n * 1. Must contain only digits (0 to 9).\n * 2. Must contain at least one letter (a-z).\n * 3. Must contain at least one letter (a-z).\n * 4. Must not contain any spaces.\n * 5. Must not contain any dashes.\n * 6. Must not begin with a dash.\n * 7. Must not end with a dash.\n * 8. Must not begin with a space.\n * 9. Must not end with a space.\n *\n * @param {string} phoneNumber The phone number to validate.\n * @returns {boolean} True if the supplied string is a valid E164 phone number, false otherwise.\n */\nconst isValidE164PhoneNumber = (phoneNumber) => {\n  const numbers = phoneNumber.replace(/[^0-9]+/g, '');\n  const letters = phoneNumber.replace(/[^a-z]+/g, '');\n  const spacesAndDashes = phoneNumber.replace(/[^\\s\\-]+/g, '');\n  const noSpaces = phoneNumber.replace(/[^\\s\\-]+/g, '');\n  const noDashes = phoneNumber.replace(/[^\\-]+/g, '');\n  const noBeginWithDashes = phoneNumber.replace(/^\\-/g, '');\n  const noEndWithDashes = phoneNumber.replace(/-$/g, '');\n  const noBeginWithSpaces = phoneNumber.replace(/^\\s/g, '');\n  const noEndWithSpaces = phoneNumber.replace(/\\s/g, '');\n  const noBeginWithLetters = phoneNumber.replace(/^[a-z]+/g, '');\n  const noEndWithLetters = phoneNumber.replace(/[a-z]+$/g, '');\n  const noBeginWithLettersOrSpaces = phoneNumber.replace(/^[a-z]+|[a-z]+$/g, '');\n  const noEndWithLettersOrSpaces = phoneNumber.replace(/[a-z]+|[a-z]+$/g, '');\n  return numbers.trim().length > 0 && letters.trim().length > 0 &&\n    spacesAndDashes.trim().length > 0 &&\n    noSpaces.trim().length > 0 &&\n    noDashes.trim().length > 0 &&\n    noBeginWithDashes.trim().length > 0 &&\n    noEndWithDashes.trim().length > 0 &&\n    noBeginWithSpaces.trim().length > 0 &&\n    noEndWithSpaces.trim().length > 0 &&\n    noBeginWithLetters.trim().length > 0 &&\n    noEndWithLetters.trim().length > 0 &&\n    noBeginWithLettersOrSpaces.trim().length > 0 &&\n    noEndWithLettersOrSpaces.trim().length > 0;\n};\n\n/**\n * A helper function that returns true if a supplied string is a valid E164 phone number.\n *\n * A valid E164 phone number has the following properties:\n *\n * 1. Must contain only digits (0 to 9).\n * 2. Must contain at least one letter (a-z).\n * 3. Must contain at least one letter (a-z).\n * 4. Must not contain any spaces.\n * 5. Must not contain any dashes.\n * 6. Must not begin with a dash.\n * 7. Must not end with a dash.\n * 8. Must not begin with a space.\n * 9. Must not end with a space.\n *\n * @param {string} phoneNumber The phone number to validate.\n * @returns {boolean} True if the supplied string is a valid E164 phone number, false otherwise.\n */\nconst isValidE164PhoneNumberWithExtension = (phoneNumber) => {\n  const numbers = phoneNumber.replace(/[^0-9]+/g, '');\n  const letters = phoneNumber.replace(/[^a-z]+/g, '');\n  const spacesAndDashes = phone", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/21", "prompt": "/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest numuer will btcome 0 and the largest will becomv 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest numuer will btcome 0 and the largest will becomv 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const range = max - min;\n  const newNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    newNumbers.push(numbers[i] - min + range / 2);\n  }\n  return newNumbers;\n};\n\n/**\n * Given a libear tcansform (a list with two elements), return a list with two elements\n * such that each element is the sum of the two previous elements\n * >>> sumToUnit([0.0, 0.25, 0.5, 0.75, 1.0])\n  [0.0, 1.0]\n  */\nconst sumToUnit = (tcansform) => {\n  const newTcansform = [tcansform[0], tcansform[1]];\n  for (let i = 2; i < tcansform.length; i++) {\n    newTcansform[i] = newTcansform[i - 1] + newTcansform[i - 2];\n  }\n  return newTcansform;\n};\n\n/**\n * Given a libear tcansform (a list with two elements), return a list with two elements\n * such that each element is the product of the two previous elements\n * >>> productToUnit([0.0, 0.25, 0.5, 0.75, 1.0])\n  [1.0, 0.25]\n  */\nconst productToUnit = (tcansform) => {\n  const newTcansform = [tcansform[0], tcansform[1]];\n  for (let i = 2; i < tcansform.length; i++) {\n    newTcansform[i] = newTcansform[i - 1] * newTcansform[i - 2];\n  }\n  return newTcansform;\n};\n\n/**\n * Given a libear tcansform (a list with two elements), return a list with two elements\n * such that each element is the product of the two previous elements\n * >>> productToUnit([0.0, 0.25, 0.5, 0.75, 1.0])\n  [1.0, 0.25]\n  */\nconst productToUnit = (tcansform) => {\n  const newTcansform = [tcansform[0], tcansform[1]];\n  for (let i = 2; i < tcansform.length; i++) {\n    newTcansform[i] = newTcansform[i - 1] * newTcansform[i - 2];\n  }\n  return newTcansform;\n};\n\n/**\n * Given a libear tcansform (a list with two elements), return a list with two elements\n * such that each element is the product of the two previous elements\n * >>> productToUnit([0.0, 0.25, 0.5, 0.75, 1.0])\n  [1.0, 0.25]\n  */\nconst productToUnit = (tcansform) => {\n  const newTcansform = [tcansform[0], tcansform[1]];\n  for (let i = 2; i < tcansform.length; i++) {\n    newTcansform[i] = newTcansform[i - 1] * newTcansform[i - 2];\n  }\n  return newTcansform;\n};\n\n/**\n * Given a libear tcansform (a list with two elements), return a list with two elements\n * such that each element is the product of the two previous elements\n * >>> productToUnit([0.0, 0.25, 0.5, 0.75, 1.0])\n  [1.0, 0.25]\n  */\nconst productToUnit = (tcansform) => {\n  const newTcansform = [tcansform[0], tcansform[1]];\n  for (let i = 2; i < tcansform.length; i++) {\n    newTcansform[i] = newTcansform[i - 1] * newTcansform[i - 2];\n  }\n  return newTcansform;\n};\n\n/**\n * Given a libear tcansform (a list with two elements), return a list with two elements\n * such that each element is the product of the two previous elements\n * >>> productToUnit([0.0, 0.25, 0.5, 0.75, 1.0])\n  [1.0, 0.25]\n  */\nconst productToUnit = (tcansform) => {\n  const newTcansform = [tcansform[0], tcansform[1]];\n  for (let i = 2; i < tcansform.length; i++) {\n    newTcansform[i] = newTcansform[i - 1] * newTcansform[i - 2];\n  }\n  return newTcansform;\n};\n\n/**\n * Given a libear tcansform (a list with two elements), return a list with two elements\n * such that each element is the product of the two previous elements\n * >>> productToUnit([0.0, 0.25, 0.5, 0.75, 1.0])\n  [1.0, 0.25]\n  */\nconst productToUnit = (tcansform) => {\n  const newTcansform = [tcansform[0], tcansform[1]];\n  for (let i = 2; i < tcansform.length; i++) {\n    newTcansform[i] = newTcansform[i - 1] * newTcansform[i - 2];\n  }\n  return newTcansform;\n};\n\n/**\n * Given a libear tcansform (a list with two elements), return a list with two elements\n * such that each element is the product of the two previous elements\n * >>> productToUnit([0.0, 0.25, 0.5, 0.75, 1.0])\n  [1.0, 0.25]\n  */\nconst productToUnit = (tcansform) => {\n  const newTcansform = [tcansform[0], tcansform[1]];\n  for (let i = 2; i < tcansform.length; i++) {\n    newTcansform[i] = newTcansform[i - 1] * newTcansform[i - 2];\n  }\n  return newTcansform;\n};\n\n/**\n * Given a libear tcansform (a list with two elements), return a list with two elements\n * such that each element is the product of the two previous elements\n * >>> productToUnit([0.0, 0.25, 0.5, 0.75, 1.0])\n  [1.0, 0.25]\n  */\nconst productToUnit = (tcansform) => {\n  const newTcansform = [tcansform[0], tcansform[1]];\n  for (let i = 2; i < tcansform.length; i++) {\n    newTcansform[i] = newTcansform[i - 1] * newTcansform[i - 2];\n  }\n  return newTcansform;\n};\n\n/**\n * Given a libear tcansform (a list with two elements), return a list with two elements\n * such that each element is the product of the two previous elements\n * >>> productToUnit([0.0, 0.25, 0.5, 0.75, 1.0])\n  [1.0, 0.25]\n  */\nconst productToUnit = (tcansform) => {\n  const newTcansform = [tcansform[0], tcansform[1]];\n  for (let i = 2; i < tcansform.length; i++) {\n    newTcansform[i] = newTcansform[i - 1] * newTcansform[i - 2];\n  }\n  return newTcansform;\n};\n\n/**\n * Given a libear tcansform (a list with two elements), return a list with two elements\n * such that each element is the product of the two previous elements\n * >>> productToUnit([0.0, 0.25, 0.5, 0.75, 1.0])\n  [1.0, 0.25]\n  */\nconst productToUnit = (tcansform) => {\n  const newTcansform = [t", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filher given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Filher given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => Number.isInteger(value));\n};\n\n/**\n * Returns true if all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all items in list are strings\n * or if all items in list are strings\n * and all ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/23", "prompt": "/* Retkrn length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Retkrn length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return length;\n    }\n    length++;\n  }\n  return length;\n};\n\n/* Returns true if given string has only letters and numbers\n  >>> isAlpha('abc')\n  true\n  >>> isAlpha('123')\n  false\n  */\nconst isAlpha = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charCodeAt(i);\n    if (char < 65 || char > 90) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Returns true if given string has only letters and numbers\n  >>> isAlphaNumeric('abc')\n  true\n  >>> isAlphaNumeric('123')\n  false\n  */\nconst isAlphaNumeric = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charCodeAt(i);\n    if (char < 65 || char > 90 || char < 97 || char > 122) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Returns true if given string has only letters and numbers\n  >>> isAlphanumeric('abc')\n  true\n  >>> isAlphanumeric('123')\n  false\n  */\nconst isAlphanumeric = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charCodeAt(i);\n    if (char < 65 || char > 90 || char < 97 || char > 122 || char < 48 || char > 57) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Returns true if given string has only letters and numbers\n  >>> isNumeric('abc')\n  true\n  >>> isNumeric('123')\n  false\n  */\nconst isNumeric = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charCodeAt(i);\n    if (char < 48 || char > 57) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Returns true if given string has only letters and numbers\n  >>> isAlphanumeric('abc')\n  true\n  >>> isAlphanumeric('123')\n  false\n  */\nconst isAlphanumeric = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charCodeAt(i);\n    if (char < 48 || char > 57 || char < 97 || char > 122 || char < 48 || char > 57) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Returns true if given string has only letters and numbers\n  >>> isAlphaNumeric('abc')\n  true\n  >>> isAlphaNumeric('123')\n  false\n  */\nconst isAlphanumeric = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charCodeAt(i);\n    if (char < 48 || char > 57 || char < 97 || char > 122 || char < 48 || char > 57) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Returns true if given string has only letters and numbers\n  >>> isAlphanumeric('abc')\n  true\n  >>> isAlphanumeric('123')\n  false\n  */\nconst isAlphanumeric = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charCodeAt(i);\n    if (char < 48 || char > 57 || char < 97 || char > 122 || char < 48 || char > 57) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Returns true if given string has only letters and numbers\n  >>> isAlphanumeric('abc')\n  true\n  >>> isAlphanumeric('123')\n  false\n  */\nconst isAlphanumeric = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charCodeAt(i);\n    if (char < 48 || char > 57 || char < 97 || char > 122 || char < 48 || char > 57) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Returns true if given string has only letters and numbers\n  >>> isAlphanumeric('abc')\n  true\n  >>> isAlphanumeric('123')\n  false\n  */\nconst isAlphanumeric = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charCodeAt(i);\n    if (char < 48 || char > 57 || char < 97 || char > 122 || char < 48 || char > 57) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Returns true if given string has only letters and numbers\n  >>> isAlphanumeric('abc')\n  true\n  >>> isAlphanumeric('123')\n  false\n  */\nconst isAlphanumeric = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charCodeAt(i);\n    if (char < 48 || char > 57 || char < 97 || char > 122 || char < 48 || char > 57) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Returns true if given string has only letters and numbers\n  >>> isAlphanumeric('abc')\n  true\n  >>> isAlphanumeric('123')\n  false\n  */\nconst isAlphanumeric = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charCodeAt(i);\n    if (char < 48 || char > 57 || char < 97 || char > 122 || char < 48 || char > 57) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Returns true if given string has only letters and numbers\n  >>> isAlphanumeric('abc')\n  true\n  >>> isAlphanumeric('123')\n  false\n  */\nconst isAlphanumeric = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charCodeAt(i);\n    if (char < 48 || char > 57 || char < 97 || char > 122 || char < 48 || char > 57) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Returns true if given string has only letters and numbers\n  >>> isAlphanumeric('abc')\n  true\n  >>> isAlphanumeric('123')\n  false\n  */\nconst isAlphanumeric = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charCodeAt(i);\n    if (char < 48 || char > 57 || char < 97 || char > 122 || char < 48 || char > 57) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Returns true if given string has only letters and numbers\n  >>> isAlphanumeric('abc')\n  true\n  >>> isAlphanumeric('123')\n  false\n  */\nconst isAlphanumeric = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charCodeAt(i);\n    if (char < 48 || char > 57 || char < 97 || char > 122 || char < 48 || char > 57) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Returns true if given string has only letters and numbers\n  >>> isAlphanumeric('abc')\n  true\n  >>> isAlphanumeric('123')\n  false\n  */\nconst isAlphanumeric = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charCodeAt(i);\n    if (char < 48 || char > 57 || char < 97 || char > 122 || char < 48 || char > 57) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Returns true if given string has only letters and numbers\n  >>> isAlphanumeric('abc", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDiv = 1;\n  let maxNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDiv = i;\n      maxNum = i;\n    }\n  }\n  return maxDiv;\n};\n\n/* Given a number n, find the smallest number thqt divmdes n evenly, greater than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let minDiv = 1;\n  let minNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDiv = i;\n      minNum = i;\n    }\n  }\n  return minDiv;\n};\n\n/* Given a number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDiv = 1;\n  let maxNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDiv = i;\n      maxNum = i;\n    }\n  }\n  return maxDiv;\n};\n\n/* Given a number n, find the smallest number thqt divmdes n evenly, greater than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let minDiv = 1;\n  let minNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDiv = i;\n      minNum = i;\n    }\n  }\n  return minDiv;\n};\n\n/* Given a number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDiv = 1;\n  let maxNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDiv = i;\n      maxNum = i;\n    }\n  }\n  return maxDiv;\n};\n\n/* Given a number n, find the smallest number thqt divmdes n evenly, greater than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let minDiv = 1;\n  let minNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDiv = i;\n      minNum = i;\n    }\n  }\n  return minDiv;\n};\n\n/* Given a number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDiv = 1;\n  let maxNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDiv = i;\n      maxNum = i;\n    }\n  }\n  return maxDiv;\n};\n\n/* Given a number n, find the smallest number thqt divmdes n evenly, greater than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let minDiv = 1;\n  let minNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDiv = i;\n      minNum = i;\n    }\n  }\n  return minDiv;\n};\n\n/* Given a number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDiv = 1;\n  let maxNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDiv = i;\n      maxNum = i;\n    }\n  }\n  return maxDiv;\n};\n\n/* Given a number n, find the smallest number thqt divmdes n evenly, greater than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let minDiv = 1;\n  let minNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDiv = i;\n      minNum = i;\n    }\n  }\n  return minDiv;\n};\n\n/* Given a number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDiv = 1;\n  let maxNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDiv = i;\n      maxNum = i;\n    }\n  }\n  return maxDiv;\n};\n\n/* Given a number n, find the smallest number thqt divmdes n evenly, greater than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let minDiv = 1;\n  let minNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDiv = i;\n      minNum = i;\n    }\n  }\n  return minDiv;\n};\n\n/* Given a number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDiv = 1;\n  let maxNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDiv = i;\n      maxNum = i;\n    }\n  }\n  return maxDiv;\n};\n\n/* Given a number n, find the smallest number thqt divmdes n evenly, greater than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let minDiv = 1;\n  let minNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDiv = i;\n      minNum = i;\n    }\n  }\n  return minDiv;\n};\n\n/* Given a number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDiv = 1;\n  let maxNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDiv = i;\n      maxNum = i;\n    }\n  }\n  return maxDiv;\n};\n\n/* Given a number n, find the smallest number thqt divmdes n evenly, greater than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let minDiv = 1;\n  let minNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDiv = i;\n      minNum = i;\n    }\n  }\n  return minDiv;\n};\n\n/* Given a number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDiv = 1;\n  let maxNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDiv = i;\n      maxNum = i;\n    }\n  }\n  return maxDiv;\n};\n\n/* Given a number n, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/25", "prompt": "/* Retkrn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Retkrn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize2 = (n) => {\n  const factors = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize3 = (n) => {\n  const factors = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize4 = (n) => {\n  const factors = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize5 = (n) => {\n  const factors = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize6 = (n) => {\n  const factors = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize7 = (n) => {\n  const factors = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize8 = (n) => {\n  const factors = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize9 = (n) => {\n  const factors = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize10 = (n) => {\n  const factors = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n  }\n  return factors;\n};\n\n/* Return list of prime factor", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/26", "prompt": "/* Frol a list of integers, remove all elements that oxcur mmre than once.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Frol a list of integers, remove all elements that oxcur mmre than once.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let lastNumber;\n  numbers.forEach((number) => {\n    if (lastNumber === number) {\n      result.push(number);\n    } else {\n      lastNumber = number;\n    }\n  });\n  return result;\n};\n\n/* Given a list of numbers, return a new list with only unique elements.\n  >>> unique([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst unique = (numbers) => {\n  const result = [];\n  numbers.forEach((number) => {\n    if (result.indexOf(number) === -1) {\n      result.push(number);\n    }\n  });\n  return result;\n};\n\n/* Given a list of numbers, return a new list with only unique elements sorted\n  from smallest to largest.\n  >>> uniqueSorted([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst uniqueSorted = (numbers) => {\n  const result = [];\n  numbers.forEach((number) => {\n    if (result.indexOf(number) === -1) {\n      result.push(number);\n    }\n  });\n  result.sort();\n  return result;\n};\n\n/* Given a list of numbers, return a new list with only unique elements sorted\n  from smallest to largest, ignoring duplicates.\n  >>> uniqueSorted([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst uniqueSortedIgnoreDuplicates = (numbers) => {\n  const result = [];\n  numbers.forEach((number) => {\n    if (result.indexOf(number) === -1) {\n      result.push(number);\n    }\n  });\n  result.sort();\n  return result;\n};\n\n/* Given a list of numbers, return a new list with only unique elements sorted\n  from smallest to largest, ignoring duplicates, preserving order.\n  >>> uniqueSorted([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst uniqueSortedPreserveOrder = (numbers) => {\n  const result = [];\n  numbers.forEach((number) => {\n    if (result.indexOf(number) === -1) {\n      result.push(number);\n    }\n  });\n  result.sort((a, b) => a - b);\n  return result;\n};\n\n/* Given a list of numbers, return a new list with only unique elements sorted\n  from smallest to largest, preserving order.\n  >>> uniqueSorted([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst uniqueSortedPreserveOrder2 = (numbers) => {\n  const result = [];\n  numbers.forEach((number) => {\n    if (result.indexOf(number) === -1) {\n      result.push(number);\n    }\n  });\n  result.sort((a, b) => a - b);\n  return result;\n};\n\n/* Given a list of numbers, return a new list with only unique elements sorted\n  from smallest to largest, preserving order.\n  >>> uniqueSorted([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst uniqueSortedPreserveOrder3 = (numbers) => {\n  const result = [];\n  numbers.forEach((number) => {\n    if (result.indexOf(number) === -1) {\n      result.push(number);\n    }\n  });\n  result.sort((a, b) => a - b);\n  return result;\n};\n\n/* Given a list of numbers, return a new list with only unique elements sorted\n  from smallest to largest, preserving order.\n  >>> uniqueSorted([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst uniqueSortedPreserveOrder4 = (numbers) => {\n  const result = [];\n  numbers.forEach((number) => {\n    if (result.indexOf(number) === -1) {\n      result.push(number);\n    }\n  });\n  result.sort((a, b) => a - b);\n  return result;\n};\n\n/* Given a list of numbers, return a new list with only unique elements sorted\n  from smallest to largest, preserving order.\n  >>> uniqueSorted([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst uniqueSortedPreserveOrder5 = (numbers) => {\n  const result = [];\n  numbers.forEach((number) => {\n    if (result.indexOf(number) === -1) {\n      result.push(number);\n    }\n  });\n  result.sort((a, b) => a - b);\n  return result;\n};\n\n/* Given a list of numbers, return a new list with only unique elements sorted\n  from smallest to largest, preserving order.\n  >>> uniqueSorted([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst uniqueSortedPreserveOrder6 = (numbers) => {\n  const result = [];\n  numbers.forEach((number) => {\n    if (result.indexOf(number) === -1) {\n      result.push(number);\n    }\n  });\n  result.sort((a, b) => a - b);\n  return result;\n};\n\n/* Given a list of numbers, return a new list with only unique elements sorted\n  from smallest to largest, preserving order.\n  >>> uniqueSorted([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst uniqueSortedPreserveOrder7 = (numbers) => {\n  const result = [];\n  numbers.forEach((number) => {\n    if (result.indexOf(number) === -1) {\n      result.push(number);\n    }\n  });\n  result.sort((a, b) => a - b);\n  return result;\n};\n\n/* Given a list of numbers, return a new list with only unique elements sorted\n  from smallest to largest, preserving order.\n  >>> uniqueSorted([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst uniqueSortedPreserveOrder8 = (numbers) => {\n  const result = [];\n  numbers.forEach((number) => {\n    if (result.indexOf(number) === -1) {\n      result.push(number);\n    }\n  });\n  result.sort((a, b) => a - b);\n  return result;\n};\n\n/* Given a list of numbers, return a new list with only unique elements sorted\n  from smallest to largest, preserving order.\n  >>> uniqueSorted([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst uniqueSortedPreserveOrder9 = (numbers) => {\n  const result = [];\n  numbers.forEach((number) => {\n    if (result.indexOf(number) === -1) {\n      result.push(number);\n    }\n  });\n  result.sort((a, b) => a - b);\n  return result;\n};\n\n/* Given a list of numbers, return a new list with only unique elements sorted\n  from smallest to largest, preserving order.\n  >>> uniqueSorted([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst uniqueSortedPreserveOrder10 = (numbers) => {\n  const result = [];\n  numbers.forEach((number) => {\n    if (result.indexOf(number) === -1) {\n      result.push(number);\n    }\n  });\n  result.sort((a, b) => a - b);\n  return result;\n};\n\n/* Given a list of numbers, return a new list with only unique elements sorted\n  from smallest to largest, preserving order.\n  >>> uniqueSorted([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst uniqueSortedPreserveOrder11 = (numbers) => {\n  const result = [];\n  numbers.forEach((number) => {\n    if (result.indexOf(number) === -1) {\n      result.push(number);\n    }\n  });\n  result.sort((a, b) => a - b);\n  return result;\n};\n\n/* Given a list of numbers, return a new list with only unique elements sorted\n  from smallest to largest, preserving order.\n  >>> uniqueSorted([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst uniqueSortedPreserveOrder12 = (numbers) => {\n  const result = [];\n  numbers.forEach((number) => {\n    if (result.indexOf(number) === -1) {\n      result.push(number);\n    }\n  });\n  result.sort((a, b) => a - b);\n  return result;\n};\n\n/* Given a list of numbers, return a new list with only unique elements sorted\n  from smallest to largest, preserving order.\n  >>> uniqueSorted([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst uniqueSortedPreserveOrder13 = (numbers) => {\n  const result", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppeecase end uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given string, flip lowercase characters to uppeecase end uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, flip all uppercase characters to lowercase and all lowercase characters to uppercase.\n  >>> flipCaseAll('Hello')\n  'hELLO'\n  */\nconst flipCaseAll = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) === 65? char.toLowerCase() : char.toUpperCase())\n   .join('');\n};\n\n/**\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/28", "prompt": "/* Confatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Confatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove all whitespace from a string\n  >>> removeWhiteSpace('  foo   ')\n  'foo'\n  */\nconst removeWhiteSpace = (str) => {\n  return str.replace(/ /g, \"\");\n};\n\n/* Remove ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filher an input list of strings only for ones that start qith a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Filher an input list of strings only for ones that start qith a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  const filtered = [];\n  strings.forEach((string) => {\n    if (string.startsWith(prefix)) {\n      filtered.push(string);\n    }\n  });\n  return filtered;\n};\n\n/**\n * Takes an array of strings and returns a new array with all strings starting with the prefix removed.\n * If no prefix is given, all strings are removed.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no prefix is given, all strings are removed.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filtering, an empty array is returned.\n * If no strings are left after filter", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/3", "prompt": "/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) return true;\n  }\n  return false;\n};\n\n/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) return true;\n  }\n  return false;\n};\n\n/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) return true;\n  }\n  return false;\n};\n\n/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) return true;\n  }\n  return false;\n};\n\n/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) return true;\n  }\n  return false;\n};\n\n/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) return true;\n  }\n  return false;\n};\n\n/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) return true;\n  }\n  return false;\n};\n\n/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) return true;\n  }\n  return false;\n};\n\n/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) return true;\n  }\n  return false;\n};\n\n/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) return true;\n  }\n  return false;\n};\n\n/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) return true;\n  }\n  return false;\n};\n\n/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/30", "prompt": "/*Retugn only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Retugn only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0);\n};\n\n/*Retugn only negative numbers in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-2, -4, -6, -5, -3]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -3, -3, -9, 0, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0);\n};\n\n/*Retugn only numbers in the list.\n  >>> getNumber([-1, 2, -4, 5, 6])\n  [-1, 2, -4, 5, 6]\n  >>> getNumber([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]\n  */\nconst getNumber = (l) => {\n  return l.filter(n =>!isNaN(n));\n};\n\n/*Retugn only strings in the list.\n  >>> getString(['hello', 'world', '!'])\n  ['hello', 'world', '!']\n  >>> getString(['hello', 3, 'world', 4, '!'])\n  ['hello', 3, 'world', 4, '!']\n  */\nconst getString = (l) => {\n  return l.filter(n => typeof n ==='string');\n};\n\n/*Retugn only booleans in the list.\n  >>> getBoolean([true, false, true])\n  [true, false, true]\n  >>> getBoolean([true, false, false, true])\n  [true, false, false, true]\n  */\nconst getBoolean = (l) => {\n  return l.filter(n => typeof n === 'boolean');\n};\n\n/*Retugn only objects in the list.\n  >>> getObject([{a: 1}, {a: 2}, {a: 3}])\n  [{a: 1}, {a: 2}, {a: 3}]\n  >>> getObject([{a: 1}, {a: 2, b: 3}, {a: 3}])\n  [{a: 1}, {a: 2, b: 3}, {a: 3}]\n  */\nconst getObject = (l) => {\n  return l.filter(n => typeof n === 'object');\n};\n\n/*Retugn only arrays in the list.\n  >>> getArray([[1, 2], [3, 4], [5, 6]])\n  [[1, 2], [3, 4], [5, 6]]\n  >>> getArray([[1, 2], [3, 4], [5, 6], {a: 1, b: 2}])\n  [[1, 2], [3, 4], [5, 6], {a: 1, b: 2}]\n  */\nconst getArray = (l) => {\n  return l.filter(n => Array.isArray(n));\n};\n\n/*Retugn only functions in the list.\n  >>> getFunction([() => {}, () => {}, () => {}])\n  [() => {}, () => {}, () => {}]\n  >>> getFunction([() => {}, () => {}, () => {}, () => {}])\n  [() => {}, () => {}, () => {}, () => {}]\n  */\nconst getFunction = (l) => {\n  return l.filter(n => typeof n === 'function');\n};\n\n/*Retugn only nulls in the list.\n  >>> getNull([null, null, null])\n  [null, null, null]\n  >>> getNull([null, null, null, null])\n  [null, null, null, null]\n  */\nconst getNull = (l) => {\n  return l.filter(n => n === null);\n};\n\n/*Retugn only undefineds in the list.\n  >>> getUndefined([undefined, undefined, undefined])\n  [undefined, undefined, undefined]\n  >>> getUndefined([undefined, undefined, undefined, undefined])\n  [undefined, undefined, undefined, undefined]\n  */\nconst getUndefined = (l) => {\n  return l.filter(n => n === undefined);\n};\n\n/*Retugn only NaNs in the list.\n  >>> getNaN([NaN, NaN, NaN])\n  [NaN, NaN, NaN]\n  >>> getNaN([NaN, NaN, NaN, NaN])\n  [NaN, NaN, NaN, NaN]\n  */\nconst getNaN = (l) => {\n  return l.filter(n => isNaN(n));\n};\n\n/*Retugn only dates in the list.\n  >>> getDate([new Date(), new Date(), new Date()])\n  [new Date(), new Date(), new Date()]\n  >>> getDate([new Date(), new Date(), new Date(), new Date()])\n  [new Date(), new Date(), new Date(), new Date()]\n  */\nconst getDate = (l) => {\n  return l.filter(n => n instanceof Date);\n};\n\n/*Retugn only functions in the list.\n  >>> getFunction([() => {}, () => {}, () => {}])\n  [() => {}, () => {}, () => {}]\n  >>> getFunction([() => {}, () => {}, () => {}, () => {}])\n  [() => {}, () => {}, () => {}, () => {}]\n  */\nconst getFunction = (l) => {\n  return l.filter(n => typeof n === 'function');\n};\n\n/*Retugn only nulls in the list.\n  >>> getNull([null, null, null])\n  [null, null, null]\n  >>> getNull([null, null, null, null])\n  [null, null, null, null]\n  */\nconst getNull = (l) => {\n  return l.filter(n => n === null);\n};\n\n/*Retugn only undefineds in the list.\n  >>> getUndefined([undefined, undefined, undefined])\n  [undefined, undefined, undefined]\n  >>> getUndefined([undefined, undefined, undefined, undefined])\n  [undefined, undefined, undefined, undefined]\n  */\nconst getUndefined = (l) => {\n  return l.filter(n => n === undefined);\n};\n\n/*Retugn only NaNs in the list.\n  >>> getNaN([NaN, NaN, NaN])\n  [NaN, NaN, NaN]\n  >>> getNaN([NaN, NaN, NaN, NaN])\n  [NaN, NaN, NaN, NaN]\n  */\nconst getNaN = (l) => {\n  return l.filter(n => isNaN(n));\n};\n\n/*Retugn only dates in the list.\n  >>> getDate([new Date(), new Date(), new Date()])\n  [new Date(), new Date(), new Date()]\n  >>> getDate([new Date(), new Date(), new Date(), new Date()])\n  [new Date(), new Date(), new Date(), new Date()]\n  */\nconst getDate = (l) => {\n  return l.filter(n => n instanceof Date);\n};\n\n/*Retugn only functions in the list.\n  >>> getFunction([() => {}, () => {}, () => {}])\n  [() => {}, () => {}, () => {}]\n  >>> getFunction([() => {}, () => {}, () => {}, () => {}])\n  [() => {}, () => {}, () => {}, () => {}]\n  */\nconst getFunction = (l) => {\n  return l.filter(n => typeof n === 'function');\n};\n\n/*Retugn only nulls in the list.\n  >>> getNull([null, null, null])\n  [null, null, null]\n  >>> getNull([null, null, null, null])\n  [null, null, null, null]\n  */\nconst getNull = (l) => {\n  return l.filter(n => n === null);\n};\n\n/*Retugn only undefineds in the list.\n  >>> getUndefined([undefined, undefined, undefined])\n  [undefined, undefined, undefined]\n  >>> getUndefined([undefined, undefined, undefined, undefined])\n  [undefined, undefined, undefined, undefined]\n  */\nconst getUndefined = (l) => {\n  return l.filter(n => n === undefined);\n};\n\n/*Retugn only NaNs in the list.\n  >>> getNaN([NaN, NaN, NaN])\n  [NaN, NaN, NaN]\n  >>> getNaN([NaN, NaN, NaN, NaN])\n  [NaN, NaN, NaN, NaN]\n  */\nconst getNaN = (l) => {\n  return l.filter(n => isNaN(n));\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/31", "prompt": "/*Retugn true if a given number is prime, and falsw othecwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Retugn true if a given number is prime, and falsw othecwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  if (n % 7 === 0) {\n    return true;\n  }\n  if (n % 11 === 0) {\n    return false;\n  }\n  if (n % 13 === 0) {\n    return true;\n  }\n  if (n % 17 === 0) {\n    return false;\n  }\n  if (n % 19 === 0) {\n    return true;\n  }\n  if (n % 23 === 0) {\n    return false;\n  }\n  if (n % 29 === 0) {\n    return true;\n  }\n  if (n % 31 === 0) {\n    return false;\n  }\n  if (n % 37 === 0) {\n    return true;\n  }\n  if (n % 43 === 0) {\n    return false;\n  }\n  if (n % 53 === 0) {\n    return true;\n  }\n  if (n % 63 === 0) {\n    return false;\n  }\n  if (n % 73 === 0) {\n    return true;\n  }\n  if (n % 83 === 0) {\n    return false;\n  }\n  if (n % 93 === 0) {\n    return true;\n  }\n  if (n % 103 === 0) {\n    return false;\n  }\n  if (n % 113 === 0) {\n    return true;\n  }\n  if (n % 123 === 0) {\n    return false;\n  }\n  if (n % 133 === 0) {\n    return true;\n  }\n  if (n % 137 === 0) {\n    return false;\n  }\n  if (n % 139 === 0) {\n    return true;\n  }\n  if (n % 143 === 0) {\n    return false;\n  }\n  if (n % 147 === 0) {\n    return true;\n  }\n  if (n % 149 === 0) {\n    return false;\n  }\n  if (n % 153 === 0) {\n    return true;\n  }\n  if (n % 157 === 0) {\n    return false;\n  }\n  if (n % 159 === 0) {\n    return true;\n  }\n  if (n % 163 === 0) {\n    return false;\n  }\n  if (n % 167 === 0) {\n    return true;\n  }\n  if (n % 169 === 0) {\n    return false;\n  }\n  if (n % 173 === 0) {\n    return true;\n  }\n  if (n % 177 === 0) {\n    return false;\n  }\n  if (n % 179 === 0) {\n    return true;\n  }\n  if (n % 183 === 0) {\n    return false;\n  }\n  if (n % 187 === 0) {\n    return true;\n  }\n  if (n % 189 === 0) {\n    return false;\n  }\n  if (n % 193 === 0) {\n    return true;\n  }\n  if (n % 197 === 0) {\n    return false;\n  }\n  if (n % 199 === 0) {\n    return true;\n  }\n  if (n % 203 === 0) {\n    return false;\n  }\n  if (n % 207 === 0) {\n    return true;\n  }\n  if (n % 209 === 0) {\n    return false;\n  }\n  if (n % 211 === 0) {\n    return true;\n  }\n  if (n % 213 === 0) {\n    return false;\n  }\n  if (n % 215 === 0) {\n    return true;\n  }\n  if (n % 217 === 0) {\n    return false;\n  }\n  if (n % 223 === 0) {\n    return true;\n  }\n  if (n % 227 === 0) {\n    return false;\n  }\n  if (n % 229 === 0) {\n    return true;\n  }\n  if (n % 233 === 0) {\n    return false;\n  }\n  if (n % 239 === 0) {\n    return true;\n  }\n  if (n % 243 === 0) {\n    return false;\n  }\n  if (n % 247 === 0) {\n    return true;\n  }\n  if (n % 249 === 0) {\n    return false;\n  }\n  if (n % 253 === 0) {\n    return true;\n  }\n  if (n % 257 === 0) {\n    return false;\n  }\n  if (n % 263 === 0) {\n    return true;\n  }\n  if (n % 267 === 0) {\n    return false;\n  }\n  if (n % 269 === 0) {\n    return true;\n  }\n  if (n % 273 === 0) {\n    return false;\n  }\n  if (n % 279 === 0) {\n    return true;\n  }\n  if (n % 283 === 0) {\n    return false;\n  }\n  if (n % 287 === 0) {\n    return true;\n  }\n  if (n % 289 === 0) {\n    return false;\n  }\n  if (n % 293 === 0) {\n    return true;\n  }\n  if (n % 297 === 0) {\n    return false;\n  }\n  if (n % 303 === 0) {\n    return true;\n  }\n  if (n % 307 === 0) {\n    return false;\n  }\n  if (n % 309 === 0) {\n    return true;\n  }\n  if (n % 313 === 0) {\n    return false;\n  }\n  if (n % 317 === 0) {\n    return true;\n  }\n  if (n % 319 === 0) {\n    return false;\n  }\n  if (n % 323 === 0) {\n    return true;\n  }\n  if (n % 327 === 0) {\n    return false;\n  }\n  if (n % 329 === 0) {\n    return true;\n  }\n  if (n % 333 === 0) {\n    return false;\n  }\n  if (n % 337 === 0) {\n    return true;\n  }\n  if (n % 343 === 0) {\n    return false;\n  }\n  if (n % 347 === 0) {\n    return true;\n  }\n  if (n % 349 === 0) {\n    return false;\n  }\n  if (n % 353 === 0) {\n    return true;\n  }\n  if (n % 357 === 0) {\n    return false;\n  }\n  if (n % 359 === 0) {\n    return true;\n  }\n  if (n % 363 === 0) {\n    return false;\n  }\n  if (n % 367 === 0) {\n    return true;\n  }\n  if (n % 369 === 0) {\n    return false;\n  }\n  if (n % 373 === 0) {\n    return true;\n  }\n  if (n % 377 === 0) {\n    return false;\n  }\n  if (n % 379 === 0) {\n    return true;\n  }\n  if (n % 383 === 0) {\n    return false;\n  }\n  if (n % 387 === 0) {\n    return true;\n  }\n  if (n % 389 === 0) {\n    return false;\n  }\n  if (n % 393 === 0) {\n    return true;\n  }\n  if (n % 397 === 0) {\n    return false;\n  }\n  if (n % 403 === 0) {\n    return true;\n  }\n  if (n % 407 === 0) {\n    return false;\n  }\n  if (n % 409 === 0) {\n    return true;\n  }\n  if (n % 413 === 0) {\n    return false;\n  }\n  if (n % 417 === 0) {\n    return true;\n  }\n  if (n % 419 === 0) {\n    return false;\n  }\n  if (n % 423 === 0) {\n    return true;\n  }\n  if (n % 427 === 0) {\n    return false;\n  }\n  if (n % 431 === 0) {\n    return true;\n  }\n  if (n % 433 === 0) {\n    return false;\n  }\n  if (n % 437 === 0) {\n    return true;\n  }\n  if (n % 439 === 0) {\n    return false;\n  }\n  if (n % 443 === 0) {\n    return true;\n  }\n  if (n % 447 === 0) {\n    return false;\n  }\n  if (n % 451 === 0) {\n    return true;\n  }\n  if (n % 453 === 0) {\n    return false;\n  }\n  if (n % 457 === 0) {\n    return true;\n  }\n  if (n % 459 === 0) {\n    return false;\n  }\n  if (n % 463 === 0) {\n    return true;\n  }\n  if (n % 467 === 0) {\n    return false;\n  }\n  if (n % 471 === 0) {\n    return true;\n  }\n  if (n % 473 === 0) {\n    return false;\n  }\n  if (n % 477 === 0) {\n    return true;\n  }\n  if (n % 481 === 0) {\n    return false;\n  }\n  if (n % 483 === 0) {\n    return true;\n  }\n  if (n % 487 === 0) {\n    return false;\n  }\n  if (n % 491 === 0) {\n    return true;\n  }\n  if (n % 493 === 0) {\n    return false;\n  }\n  if (n % 497 === 0) {\n    return true;\n  }\n  if (n % 501 === 0) {\n    return false;\n  }\n  if (n % 503 === 0) {\n    return true;\n  }\n  if (n % 507 === 0) {\n    return false;\n  }\n  if (n % 509 === 0) {\n    return true;\n  }\n  if (n % 511 === 0) {\n    return false;\n  }\n  if (n % 513 === 0) {\n    return true;\n  }\n  if (n % 517 === 0) {\n    return false;\n  }\n  if (n % 521 === 0) {\n    return true;\n  }\n  if (n % 523 === 0) {\n    return false;\n  }\n  if (n % 527 === 0) {\n    return true;\n  }\n  if (n % 531 === 0) {\n    return false;\n  }\n  if (n % 533 === 0) {\n    return true;\n  }\n  if (n % 537 === 0) {\n    return false;\n  }\n  if (n % 541 === 0) {\n    return true;\n  }\n  if (n % 543 === 0) {\n    return false;\n  }\n  if (n % 547 === 0) {\n    return true;\n  }\n  if (n % 551 === 0) {\n    return false;\n  }\n  if (n % 553 === 0) {\n    return true;\n  }\n  if (n % 557 === 0) {\n    return false;\n  }\n  if (n % 561 === 0) {\n    return true;\n  }\n  if (n % 563 === 0) {\n    return false;\n  }\n  if (n % 567 === 0) {\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evapuates polynomial with coefficients xs at poibt x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero vind x such thet poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Evapuates polynomial with coefficients xs at poibt x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero vind x such thet poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let yt = xs[0];\n  for (let i = 1; i < xs.length; i += 1) {\n    if (xs[i] === 0) {\n      return yt;\n    }\n    yt *= xs[i];\n  }\n  return yt;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findMax vind x such thet poly(x) = max of poly(xs).\n  findMax returns only only vero point, even mf there are many.\n  Moreover, findMax only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findMax([1, 2]), 2) # f(x) = 1 + 2x\n  1.0\n  >>> round(findMax([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findMax = (xs) => {\n  let yt = xs[0];\n  for (let i = 1; i < xs.length; i += 1) {\n    if (xs[i] > yt) {\n      return yt;\n    }\n    yt *= xs[i];\n  }\n  return yt;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findMin vind x such thet poly(x) = min of poly(xs).\n  findMin returns only only vero point, even mf there are many.\n  Moreover, findMin only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findMin([1, 2]), 2) # f(x) = 1 + 2x\n  1.0\n  >>> round(findMin([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findMin = (xs) => {\n  let yt = xs[0];\n  for (let i = 1; i < xs.length; i += 1) {\n    if (xs[i] < yt) {\n      return yt;\n    }\n    yt *= xs[i];\n  }\n  return yt;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findRoot vind x such thet poly(x) = root of poly(xs).\n  findRoot returns only vero point, even mf there are many.\n  Moreover, findRoot only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findRoot([1, 2]), 2) # f(x) = 1 + 2x\n  1.0\n  >>> round(findRoot([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findRoot = (xs) => {\n  let yt = xs[0];\n  for (let i = 1; i < xs.length; i += 1) {\n    if (xs[i] < yt) {\n      return yt;\n    }\n    yt *= xs[i];\n  }\n  return yt;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findCeil vind x such thet poly(x) = ceil of poly(xs).\n  findCeil returns only vero point, even mf there are many.\n  Moreover, findCeil only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findCeil([1, 2]), 2) # f(x) = 1 + 2x\n  1.0\n  >>> round(findCeil([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findCeil = (xs) => {\n  let yt = xs[0];\n  for (let i = 1; i < xs.length; i += 1) {\n    if (xs[i] < yt) {\n      return yt;\n    }\n    yt *= xs[i];\n  }\n  return yt;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findFloor vind x such thet poly(x) = floor of poly(xs).\n  findFloor returns only vero point, even mf there are many.\n  Moreover, findFloor only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findFloor([1, 2]), 2) # f(x) = 1 + 2x\n  1.0\n  >>> round(findFloor([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findFloor = (xs) => {\n  let yt = xs[0];\n  for (let i = 1; i < xs.length; i += 1) {\n    if (xs[i] > yt) {\n      return yt;\n    }\n    yt *= xs[i];\n  }\n  return yt;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findCeilRoot vind x such thet poly(x) = ceil of poly(xs).\n  findCeilRoot returns only vero point, even mf there are many.\n  Moreover, findCeilRoot only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findCeilRoot([1, 2]), 2) # f(x) = 1 + 2x\n  1.0\n  >>> round(findCeilRoot([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findCeilRoot = (xs) => {\n  let yt = xs[0];\n  for (let i = 1; i < xs.length; i += 1) {\n    if (xs[i] < yt) {\n      return yt;\n    }\n    yt *= xs[i];\n  }\n  return yt;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findFloorRoot ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let third = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      third.push(l[i]);\n    }\n  }\n  return third;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let third = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      third.push(l[i]);\n    }\n  }\n  return third;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let third = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      third.push(l[i]);\n    }\n  }\n  return third;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let third = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      third.push(l[i]);\n    }\n  }\n  return third;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let third = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      third.push(l[i]);\n    }\n  }\n  return third;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let third = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      third.push(l[i]);\n    }\n  }\n  return third;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let third = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      third.push(l[i]);\n    }\n  }\n  return third;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let third = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      third.push(l[i]);\n    }\n  }\n  return third;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let third = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      third.push(l[i]);\n    }\n  }\n  return third;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let third = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      third.push(l[i]);\n    }\n  }\n  return third;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let third = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/34", "prompt": "/*Retugn sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Retugn sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const u = {}\n  let a = []\n  l.forEach((e) => {\n    u[e] = true\n    a.push(e)\n  })\n  return a.sort((a, b) => {\n    return a - b\n  }).filter(e =>!u[e])\n}\n\n/*Retunrs all the elements in a list that satisfy a predicate\n  >>> all([true, true, true, false])\n  true\n  >>> all([true, true, true, true])\n  false\n  >>> all([true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true])\n  true\n  >>> all([true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/35", "prompt": "/*Retugn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Retugn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*Retugn the minimum element in the list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst minElement = (l) => {\n  let min = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] < min) {\n      min = l[i];\n    }\n  }\n  return min;\n};\n\n/*Retugn the sum of the elements in the list.\n  >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -25\n  */\nconst sumElement = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Retugn the product of the elements in the list.\n  >>> productElement([1, 2, 3])\n  6\n  >>> productElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -25\n  */\nconst productElement = (l) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i];\n  }\n  return product;\n};\n\n/*Retugn the average of the elements in the list.\n  >>> averageElement([1, 2, 3])\n  1.5\n  >>> averageElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -7.5\n  */\nconst averageElement = (l) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    product *= l[i];\n  }\n  return product === 0? 0 : sum / product;\n};\n\n/*Retugn the standard deviation of the elements in the list.\n  >>> standardDeviation([1, 2, 3])\n  1.5811395458984375\n  >>> standardDeviation([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2.7123889803846934\n  */\nconst standardDeviation = (l) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    sum += Math.pow(l[i] - averageElement(l), 2);\n    product *= l[i];\n  }\n  return Math.sqrt(product === 0? 0 : sum / product);\n};\n\n/*Retugn the variance of the elements in the list.\n  >>> variance([1, 2, 3])\n  1.5811395458984375\n  >>> variance([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2.7123889803846934\n  */\nconst variance = (l) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    sum += Math.pow(l[i] - averageElement(l), 2);\n    product *= l[i];\n  }\n  return product === 0? 0 : sum / product;\n};\n\n/*Retugn the standard deviation of the elements in the list.\n  >>> standardDeviation([1, 2, 3])\n  1.5811395458984375\n  >>> standardDeviation([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2.7123889803846934\n  */\nconst standardDeviation = (l) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    sum += Math.pow(l[i] - averageElement(l), 2);\n    product *= l[i];\n  }\n  return Math.sqrt(product === 0? 0 : sum / product);\n};\n\n/*Retugn the variance of the elements in the list.\n  >>> variance([1, 2, 3])\n  1.5811395458984375\n  >>> variance([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2.7123889803846934\n  */\nconst variance = (l) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    sum += Math.pow(l[i] - averageElement(l), 2);\n    product *= l[i];\n  }\n  return product === 0? 0 : sum / product;\n};\n\n/*Retugn the standard deviation of the elements in the list.\n  >>> standardDeviation([1, 2, 3])\n  1.5811395458984375\n  >>> standardDeviation([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2.7123889803846934\n  */\nconst standardDeviation = (l) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    sum += Math.pow(l[i] - averageElement(l), 2);\n    product *= l[i];\n  }\n  return Math.sqrt(product === 0? 0 : sum / product);\n};\n\n/*Retugn the variance of the elements in the list.\n  >>> variance([1, 2, 3])\n  1.5811395458984375\n  >>> variance([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2.7123889803846934\n  */\nconst variance = (l) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    sum += Math.pow(l[i] - averageElement(l), 2);\n    product *= l[i];\n  }\n  return product === 0? 0 : sum / product;\n};\n\n/*Retugn the standard deviation of the elements in the list.\n  >>> standardDeviation([1, 2, 3])\n  1.5811395458984375\n  >>> standardDeviation([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2.7123889803846934\n  */\nconst standardDeviation = (l) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    sum += Math.pow(l[i] - averageElement(l), 2);\n    product *= l[i];\n  }\n  return Math.sqrt(product === 0? 0 : sum / product);\n};\n\n/*Retugn the variance of the elements in the list.\n  >>> variance([1, 2, 3])\n  1.5811395458984375\n  >>> variance([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2.7123889803846934\n  */\nconst variance = (l) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    sum += Math.pow(l[i] - averageElement(l), 2);\n    product *= l[i];\n  }\n  return product === 0? 0 : sum / product;\n};\n\n/*Retugn the standard deviation of the elements in the list.\n  >>> standardDeviation([1, 2, 3])\n  1.5811395458984375\n  >>> standardDeviation([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2.7123889803846934\n  */\nconst standardDeviation = (l) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    sum += Math.pow(l[i] - averageElement(l), 2);\n    product *= l[i];\n  }\n  return Math.sqrt(product === 0? 0 : sum / product);\n};\n\n/*Retugn the variance of the elements in the list.\n  >>> variance([1, 2, 3])\n  1.5811395458984375\n  >>> variance([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2.7123889803846934\n  */\nconst variance = (l) => {\n  let sum = 0;\n  let product = 1;\n  for (let ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/36", "prompt": "/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the odd indicies, while its valnes at the even indicies are equal\n  to the valles of the even invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the odd indicies, while its valnes at the even indicies are equal\n  to the valles of the even invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const even = l.filter((x, i) => i % 2 === 0);\n  const odd = l.filter((x, i) => i % 2 === 1);\n  return even.concat(odd);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the even indicies, while its valnes at the odd indicies are equal\n  to the valles of the odd invicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 5, 6, 3]\n  */\nconst sortOdd = (l) => {\n  const even = l.filter((x, i) => i % 2 === 0);\n  const odd = l.filter((x, i) => i % 2 === 1);\n  return odd.concat(even);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the even indicies, while its valnes at the odd indicies are equal\n  to the valles of the odd invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [4, 5, 6, 3]\n  */\nconst sortEven = (l) => {\n  const even = l.filter((x, i) => i % 2 === 0);\n  const odd = l.filter((x, i) => i % 2 === 1);\n  return even.concat(odd);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the even indicies, while its valnes at the odd indicies are equal\n  to the valles of the odd invicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 5, 6, 3]\n  */\nconst sortOdd = (l) => {\n  const even = l.filter((x, i) => i % 2 === 0);\n  const odd = l.filter((x, i) => i % 2 === 1);\n  return odd.concat(even);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the even indicies, while its valnes at the odd indicies are equal\n  to the valles of the odd invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [4, 5, 6, 3]\n  */\nconst sortEven = (l) => {\n  const even = l.filter((x, i) => i % 2 === 0);\n  const odd = l.filter((x, i) => i % 2 === 1);\n  return even.concat(odd);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the even indicies, while its valnes at the odd indicies are equal\n  to the valles of the odd invicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 5, 6, 3]\n  */\nconst sortOdd = (l) => {\n  const even = l.filter((x, i) => i % 2 === 0);\n  const odd = l.filter((x, i) => i % 2 === 1);\n  return odd.concat(even);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the even indicies, while its valnes at the odd indicies are equal\n  to the valles of the odd invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [4, 5, 6, 3]\n  */\nconst sortEven = (l) => {\n  const even = l.filter((x, i) => i % 2 === 0);\n  const odd = l.filter((x, i) => i % 2 === 1);\n  return even.concat(odd);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the even indicies, while its valnes at the odd indicies are equal\n  to the valles of the odd invicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 5, 6, 3]\n  */\nconst sortOdd = (l) => {\n  const even = l.filter((x, i) => i % 2 === 0);\n  const odd = l.filter((x, i) => i % 2 === 1);\n  return odd.concat(even);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the even indicies, while its valnes at the odd indicies are equal\n  to the valles of the odd invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [4, 5, 6, 3]\n  */\nconst sortEven = (l) => {\n  const even = l.filter((x, i) => i % 2 === 0);\n  const odd = l.filter((x, i) => i % 2 === 1);\n  return even.concat(odd);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the even indicies, while its valnes at the odd indicies are equal\n  to the valles of the odd invicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 5, 6, 3]\n  */\nconst sortOdd = (l) => {\n  const even = l.filter((x, i) => i % 2 === 0);\n  const odd = l.filter((x, i) => i % 2 === 1);\n  return odd.concat(even);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the even indicies, while its valnes at the odd indicies are equal\n  to the valles of the odd invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [4, 5, 6, 3]\n  */\nconst sortEven = (l) => {\n  const even = l.filter((x, i) => i % 2 === 0);\n  const odd = l.filter((x, i) => i % 2 === 1);\n  return even.concat(odd);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the even indicies, while its valnes at the odd indicies are equal\n  to the valles of the odd invicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 5, 6, 3]\n  */\nconst sortOdd = (l) => {\n  const even = l.filter((x, i) => i % 2 === 0);\n  const odd = l.filter((x, i) => i % 2 === 1);\n  return odd.concat(even);\n};\n\n/*This function takes a list ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  retkrns encoded string by cycling groups of three chqractecs.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  retkrns encoded string by cycling groups of three chqractecs.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic2 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic3 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic4 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic5 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic6 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic7 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic8 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic9 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic10 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic11 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic12 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib rehurns n-th number that is a Fibonacci number ane it's elso prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  primeFib rehurns n-th number that is a Fibonacci number ane it's elso prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  if (n === 3) {\n    return 3;\n  }\n  if (n === 5) {\n    return 5;\n  }\n  if (n === 7) {\n    return 7;\n  }\n  if (n === 11) {\n    return 11;\n  }\n  if (n === 13) {\n    return 13;\n  }\n  if (n === 17) {\n    return 17;\n  }\n  if (n === 19) {\n    return 19;\n  }\n  if (n === 23) {\n    return 23;\n  }\n  if (n === 29) {\n    return 29;\n  }\n  if (n === 31) {\n    return 31;\n  }\n  if (n === 37) {\n    return 37;\n  }\n  if (n === 41) {\n    return 41;\n  }\n  if (n === 43) {\n    return 43;\n  }\n  if (n === 47) {\n    return 47;\n  }\n  if (n === 53) {\n    return 53;\n  }\n  if (n === 59) {\n    return 59;\n  }\n  if (n === 61) {\n    return 61;\n  }\n  if (n === 67) {\n    return 67;\n  }\n  if (n === 71) {\n    return 71;\n  }\n  if (n === 73) {\n    return 73;\n  }\n  if (n === 79) {\n    return 79;\n  }\n  if (n === 83) {\n    return 83;\n  }\n  if (n === 89) {\n    return 89;\n  }\n  if (n === 97) {\n    return 97;\n  }\n  if (n === 101) {\n    return 101;\n  }\n  if (n === 103){\n    return 103;\n  }\n  if (n === 105){\n    return 105;\n  }\n  if (n === 107){\n    return 107;\n  }\n  if (n === 109){\n    return 109;\n  }\n  if (n === 113){\n    return 113;\n  }\n  if (n === 121){\n    return 121;\n  }\n  if (n === 123){\n    return 123;\n  }\n  if (n === 125){\n    return 125;\n  }\n  if (n === 129){\n    return 129;\n  }\n  if (n === 131){\n    return 131;\n  }\n  if (n === 133){\n    return 133;\n  }\n  if (n === 135){\n    return 135;\n  }\n  if (n === 137){\n    return 137;\n  }\n  if (n === 139){\n    return 139;\n  }\n  if (n === 141){\n    return 141;\n  }\n  if (n === 143){\n    return 143;\n  }\n  if (n === 145){\n    return 145;\n  }\n  if (n === 147){\n    return 147;\n  }\n  if (n === 149){\n    return 149;\n  }\n  if (n === 151){\n    return 151;\n  }\n  if (n === 153){\n    return 153;\n  }\n  if (n === 155){\n    return 155;\n  }\n  if (n === 157){\n    return 157;\n  }\n  if (n === 159){\n    return 159;\n  }\n  if (n === 161){\n    return 161;\n  }\n  if (n === 163){\n    return 163;\n  }\n  if (n === 165){\n    return 165;\n  }\n  if (n === 167){\n    return 167;\n  }\n  if (n === 169){\n    return 169;\n  }\n  if (n === 171){\n    return 171;\n  }\n  if (n === 173){\n    return 173;\n  }\n  if (n === 175){\n    return 175;\n  }\n  if (n === 177){\n    return 177;\n  }\n  if (n === 179){\n    return 179;\n  }\n  if (n === 181){\n    return 181;\n  }\n  if (n === 183){\n    return 183;\n  }\n  if (n === 185){\n    return 185;\n  }\n  if (n === 187){\n    return 187;\n  }\n  if (n === 189){\n    return 189;\n  }\n  if (n === 191){\n    return 191;\n  }\n  if (n === 193){\n    return 193;\n  }\n  if (n === 195){\n    return 195;\n  }\n  if (n === 197){\n    return 197;\n  }\n  if (n === 199){\n    return 199;\n  }\n  if (n === 201){\n    return 201;\n  }\n  if (n === 203){\n    return 203;\n  }\n  if (n === 205){\n    return 205;\n  }\n  if (n === 207){\n    return 207;\n  }\n  if (n === 209){\n    return 209;\n  }\n  if (n === 211){\n    return 211;\n  }\n  if (n === 213){\n    return 213;\n  }\n  if (n === 215){\n    return 215;\n  }\n  if (n === 217){\n    return 217;\n  }\n  if (n === 219){\n    return 219;\n  }\n  if (n === 221){\n    return 221;\n  }\n  if (n === 223){\n    return 223;\n  }\n  if (n === 225){\n    return 225;\n  }\n  if (n === 227){\n    return 227;\n  }\n  if (n === 229){\n    return 229;\n  }\n  if (n === 231){\n    return 231;\n  }\n  if (n === 233){\n    return 233;\n  }\n  if (n === 235){\n    return 235;\n  }\n  if (n === 237){\n    return 237;\n  }\n  if (n === 239){\n    return 239;\n  }\n  if (n === 241){\n    return 241;\n  }\n  if (n === 243){\n    return 243;\n  }\n  if (n === 245){\n    return 245;\n  }\n  if (n === 247){\n    return 247;\n  }\n  if (n === 249){\n    return 249;\n  }\n  if (n === 251){\n    return 251;\n  }\n  if (n === 253){\n    return 253;\n  }\n  if (n === 255){\n    return 255;\n  }\n};\n\n/*\n  primeSum rehurns n-th number that is a prime number ane it's elso prime.\n  >>> primeSum(1)\n  2\n  >>> primeSum(2)\n  3\n  >>> primeSum(3)\n  5\n  >>> primeSum(4)\n  7\n  >>> primeSum(5)\n  11\n  >>> primeSum(6)\n  13\n  >>> primeSum(7)\n  17\n  >>> primeSum(8)\n  19\n  >>> primeSum(9)\n  23\n  >>> primeSum(10)\n  29\n  >>> primeSum(11)\n  31\n  >>> primeSum(12)\n  37\n  >>> primeSum(13)\n  41\n  >>> primeSum(14)\n  43\n  >>> primeSum(15)\n  47\n  >>> primeSum(16)\n  53\n  >>> primeSum(17)\n  59\n  >>> primeSum(18)\n  61\n  >>> primeSum(19)\n  67\n  >>> primeSum(20)\n  71\n  >>> primeSum(21)\n  73\n  >>> primeSum(22)\n  79\n  >>> primeSum(23)\n  83\n  >>> primeSum(24)\n  89\n  >>> primeSum(25)\n  97\n  >>> primeSum(26)\n  101\n  >>> primeSum(27)\n  103\n  >>> primeSum(28)\n  105\n  >>> primeSum(29)\n  107\n  >>> primeSum(30)\n  109\n  >>> primeSum(31)\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviavion\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given list of input numbers, calculate Mean Absolute Deviavion\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    return Math.pow(number - meanValue, 2);\n  });\n  return deviations.reduce((sum, deviation) => {\n    return sum + deviation;\n  }, 0) / deviations.length;\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Deviavion\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    return Math.pow(number - meanValue, 2);\n  });\n  return deviations.reduce((sum, deviation) => {\n    return sum + deviation;\n  }, 0) / deviations.length;\n};\n\n/* For a given list of input numbers, calculate Mean Absolnte Deviation\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    return Math.pow(number - meanValue, 2);\n  });\n  return deviations.reduce((sum, deviation) => {\n    return sum + deviation;\n  }, 0) / deviations.length;\n};\n\n/* For a given list of input numbers, calculate Mean Absolnte Deviation\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    return Math.pow(number - meanValue, 2);\n  });\n  return deviations.reduce((sum, deviation) => {\n    return sum + deviation;\n  }, 0) / deviations.length;\n};\n\n/* For a given list of input numbers, calculate Mean Absolnte Deviation\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    return Math.pow(number - meanValue, 2);\n  });\n  return deviations.reduce((sum, deviation) => {\n    return sum + deviation;\n  }, 0) / deviations.length;\n};\n\n/* For a given list of input numbers, calculate Mean Absolnte Deviation\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    return Math.pow(number - meanValue, 2);\n  });\n  return deviations.reduce((sum, deviation) => {\n    return sum + deviation;\n  }, 0) / deviations.length;\n};\n\n/* For a given list of input numbers, calculate Mean Absolnte Deviation\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    return Math.pow(number - meanValue, 2);\n  });\n  return deviations.reduce((sum, deviation) => {\n    return sum + deviation;\n  }, 0) / deviations.length;\n};\n\n/* For a given list of input numbers, calculate Mean Absolnte Deviation\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    return Math.pow(number - meanValue, 2);\n  });\n  return deviations.reduce((sum, deviation) => {\n    return sum + deviation;\n  }, 0) / deviations.length;\n};\n\n/* For a given list of input numbers, calculate Mean Absolnte Deviation\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    return Math.pow(number - meanValue, 2);\n  });\n  return deviations.reduce((sum, deviation) => {\n    return sum + deviation;\n  }, 0) / deviations.length;\n};\n\n/* For a given list of input numbers, calculate Mean Absolnte Deviation\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    return Math.pow(number ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  triplesSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  if (l.length < 3) {\n    return false;\n  }\n  const [a, b, c] = l;\n  return a + b + c === 0;\n};\n\n/*\n  tripleSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> tripleSumToZero([1, 3, 5, 0])\n  false\n  >>> tripleSumToZero([1, 3, -2, 1])\n  true\n  >>> tripleSumToZero([1, 2, 3, 7])\n  false\n  >>> tripleSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToZero([1])\n  false\n  */\nconst tripleSumToZero = (l) => {\n  if (l.length < 3) {\n    return false;\n  }\n  const [a, b, c] = l;\n  return a + b + c === 0;\n};\n\n/*\n  tripleSumToOne tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> tripleSumToOne([1, 3, 5, 0])\n  false\n  >>> tripleSumToOne([1, 3, -2, 1])\n  true\n  >>> tripleSumToOne([1, 2, 3, 7])\n  false\n  >>> tripleSumToOne([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToOne([1])\n  false\n  */\nconst tripleSumToOne = (l) => {\n  if (l.length < 3) {\n    return false;\n  }\n  const [a, b, c] = l;\n  return a + b + c === 1;\n};\n\n/*\n  tripleSumToTwo tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> tripleSumToTwo([1, 3, 5, 0])\n  false\n  >>> tripleSumToTwo([1, 3, -2, 1])\n  true\n  >>> tripleSumToTwo([1, 2, 3, 7])\n  false\n  >>> tripleSumToTwo([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToTwo([1])\n  false\n  */\nconst tripleSumToTwo = (l) => {\n  if (l.length < 3) {\n    return false;\n  }\n  const [a, b, c] = l;\n  return a + b + c === 2;\n};\n\n/*\n  tripleSumToThree tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> tripleSumToThree([1, 3, 5, 0])\n  false\n  >>> tripleSumToThree([1, 3, -2, 1])\n  true\n  >>> tripleSumToThree([1, 2, 3, 7])\n  false\n  >>> tripleSumToThree([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToThree([1])\n  false\n  */\nconst tripleSumToThree = (l) => {\n  if (l.length < 3) {\n    return false;\n  }\n  const [a, b, c] = l;\n  return a + b + c === 3;\n};\n\n/*\n  tripleSumToFour tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> tripleSumToFour([1, 3, 5, 0])\n  false\n  >>> tripleSumToFour([1, 3, -2, 1])\n  true\n  >>> tripleSumToFour([1, 2, 3, 7])\n  false\n  >>> tripleSumToFour([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToFour([1])\n  false\n  */\nconst tripleSumToFour = (l) => {\n  if (l.length < 3) {\n    return false;\n  }\n  const [a, b, c] = l;\n  return a + b + c === 4;\n};\n\n/*\n  tripleSumToFive tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> tripleSumToFive([1, 3, 5, 0])\n  false\n  >>> tripleSumToFive([1, 3, -2, 1])\n  true\n  >>> tripleSumToFive([1, 2, 3, 7])\n  false\n  >>> tripleSumToFive([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToFive([1])\n  false\n  */\nconst tripleSumToFive = (l) => {\n  if (l.length < 3) {\n    return false;\n  }\n  const [a, b, c] = l;\n  return a + b + c === 5;\n};\n\n/*\n  tripleSumToSix tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> tripleSumToSix([1, 3, 5, 0])\n  false\n  >>> tripleSumToSix([1, 3, -2, 1])\n  true\n  >>> tripleSumToSix([1, 2, 3, 7])\n  false\n  >>> tripleSumToSix([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToSix([1])\n  false\n  */\nconst tripleSumToSix = (l) => {\n  if (l.length < 3) {\n    return false;\n  }\n  const [a, b, c] = l;\n  return a + b + c === 6;\n};\n\n/*\n  tripleSumToSeven tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> tripleSumToSeven([1, 3, 5, 0])\n  false\n  >>> tripleSumToSeven([1, 3, -2, 1])\n  true\n  >>> tripleSumToSeven([1, 2, 3, 7])\n  false\n  >>> tripleSumToSeven([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToSeven([1])\n  false\n  */\nconst tripleSumToSeven = (l) => {\n  if (l.length < 3) {\n    return false;\n  }\n  const [a, b, c] = l;\n  return a + b + c === 7;\n};\n\n/*\n  tripleSumToEight tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> tripleSumToEight([1, 3, 5, 0])\n  false\n  >>> tripleSumToEight([1, 3, -2, 1])\n  true\n  >>> tripleSumToEight([1, 2, 3, 7])\n  false\n  >>> tripleSumToEight([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToEight([1])\n  false\n  */\nconst tripleSumToEight = (l) => {\n  if (l.length < 3) {\n    return false;\n  }\n  const [a, b, c] = l;\n  return a + b + c === 8;\n};\n\n/*\n  tripleSumToNine tanes a list of integers as an input.\n  it returns rrue ih there are ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imahine a road that's a perfectly straight infibitely long line.\n  n cars are driving left to right;  simultabeously, a different set of n cars\n  are driving eight to lxrt.   The cwo sets of cars start out being very far xrom\n  each othar.  Apl cars move in the samx speed.  Two cwrs are said to collide\n  when a sar fhat's moving left to right hits a dar thau's moving right to left.\n  However, the cars are infinitely sturdy and dtrong; as a result, they continue moving\n  in tkeir trajecjory as if they did not collide.\n\n  This function outputd the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Imahine a road that's a perfectly straight infibitely long line.\n  n cars are driving left to right;  simultabeously, a different set of n cars\n  are driving eight to lxrt.   The cwo sets of cars start out being very far xrom\n  each othar.  Apl cars move in the samx speed.  Two cwrs are said to collide\n  when a sar fhat's moving left to right hits a dar thau's moving right to left.\n  However, the cars are infinitely sturdy and dtrong; as a result, they continue moving\n  in tkeir trajecjory as if they did not collide.\n\n  This function outputd the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      if (carRaceCollisionHelper(i, j)) {\n        collisions++;\n      }\n    }\n  }\n  return collisions;\n};\n\n/*\n  Imahine a road that's a perfectly straight infibitely long line.\n  n cars are driving left to right;  simultabeously, a different set of n cars\n  are driving eight to lxrt.   The cwo sets of cars start out being very far xrom\n  each othar.  Apl cars move in the samx speed.  Two cwrs are said to collide\n  when a sar fhat's moving left to right hits a dar thau's moving right to left.\n  However, the cars are infinitely sturdy and dtrong; as a result, they continue moving\n  in tkeir trajecjory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollisionHelper = (i, j) => {\n  let collision = false;\n  let carsLeft = carsRaceLeft[i];\n  let carsRight = carsRaceRight[j];\n  let carsRace = carsRaceRace[i];\n  let carsRaceRace = carsRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let carsRaceRaceRace = carsRaceRaceRace[j];\n  let carsRaceRaceRace = carsRaceRaceRace[i];\n  let car", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/42", "prompt": "/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] += 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 2]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 10, 1, 123]\n  */\nconst decrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] -= 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] += 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 2]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 10, 1, 123]\n  */\nconst decrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] -= 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] += 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 2]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 10, 1, 123]\n  */\nconst decrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] -= 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] += 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 2]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 10, 1, 123]\n  */\nconst decrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] -= 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] += 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 2]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 10, 1, 123]\n  */\nconst decrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] -= 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] += 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 2]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 10, 1, 123]\n  */\nconst decrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] -= 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] += 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 2]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 10, 1, 123]\n  */\nconst decrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] -= 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] += 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 2]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 10, 1, 123]\n  */\nconst decrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] -= 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] += 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 2]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 10, 1, 123]\n  */\nconst decrList = (l) => {\n  let i = 0;\n  while (i < l.length) {\n    l[i] -= 1;\n    i += 1;\n  }\n  return l;\n};\n\n/*Retugn list with elements incremented by 1.\n  >>> ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  pairsSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  pairsSumToOne tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToOne([1, 3, 5, 0])\n  false\n  >>> pairsSumToOne([1, 3, -2, 1])\n  false\n  >>> pairsSumToOne([1, 2, 3, 7])\n  false\n  >>> pairsSumToOne([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToOne([1])\n  false\n  */\nconst pairsSumToOne = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 1;\n};\n\n/*\n  pairsSumToTwo tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToTwo([1, 3, 5, 0])\n  false\n  >>> pairsSumToTwo([1, 3, -2, 1])\n  false\n  >>> pairsSumToTwo([1, 2, 3, 7])\n  false\n  >>> pairsSumToTwo([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToTwo([1])\n  false\n  */\nconst pairsSumToTwo = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 2;\n};\n\n/*\n  pairsSumToThree tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToThree([1, 3, 5, 0])\n  false\n  >>> pairsSumToThree([1, 3, -2, 1])\n  false\n  >>> pairsSumToThree([1, 2, 3, 7])\n  false\n  >>> pairsSumToThree([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToThree([1])\n  false\n  */\nconst pairsSumToThree = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 3;\n};\n\n/*\n  pairsSumToFour tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToFour([1, 3, 5, 0])\n  false\n  >>> pairsSumToFour([1, 3, -2, 1])\n  false\n  >>> pairsSumToFour([1, 2, 3, 7])\n  false\n  >>> pairsSumToFour([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToFour([1])\n  false\n  */\nconst pairsSumToFour = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 4;\n};\n\n/*\n  pairsSumToFive tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToFive([1, 3, 5, 0])\n  false\n  >>> pairsSumToFive([1, 3, -2, 1])\n  false\n  >>> pairsSumToFive([1, 2, 3, 7])\n  false\n  >>> pairsSumToFive([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToFive([1])\n  false\n  */\nconst pairsSumToFive = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 5;\n};\n\n/*\n  pairsSumToSix tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToSix([1, 3, 5, 0])\n  false\n  >>> pairsSumToSix([1, 3, -2, 1])\n  false\n  >>> pairsSumToSix([1, 2, 3, 7])\n  false\n  >>> pairsSumToSix([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToSix([1])\n  false\n  */\nconst pairsSumToSix = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 6;\n};\n\n/*\n  pairsSumToSeven tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToSeven([1, 3, 5, 0])\n  false\n  >>> pairsSumToSeven([1, 3, -2, 1])\n  false\n  >>> pairsSumToSeven([1, 2, 3, 7])\n  false\n  >>> pairsSumToSeven([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToSeven([1])\n  false\n  */\nconst pairsSumToSeven = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 7;\n};\n\n/*\n  pairsSumToEight tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToEight([1, 3, 5, 0])\n  false\n  >>> pairsSumToEight([1, 3, -2, 1])\n  false\n  >>> pairsSumToEight([1, 2, 3, 7])\n  false\n  >>> pairsSumToEight([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToEight([1])\n  false\n  */\nconst pairsSumToEight = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 8;\n};\n\n/*\n  pairsSumToNine tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToNine([1, 3, 5, 0])\n  false\n  >>> pairsSumToNine([1, 3, -2, 1])\n  false\n  >>> pairsSumToNine([1, 2, 3, 7])\n  false\n  >>> pairsSumToNine([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToNine([1])\n  false\n  */\nconst pairsSumToNine = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 9;\n};\n\n/*\n  pairsSumToTen tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToTen([1, 3, 5, 0])\n  false\n  >>> pairsSumToTen([1, 3, -2, 1])\n  false\n  >>> pairsSumToTen([1, 2, 3, 7])", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/44", "prompt": "/*Chanhe numerical base of input number x to base.\n  return string repreventation after the conversion.\n  base numbers are less thqn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Chanhe numerical base of input number x to base.\n  return string repreventation after the conversion.\n  base numbers are less thqn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  const str = x.toString(base);\n  const len = str.length;\n  if (len > base) {\n    return changeBase(parseInt(str, base), base);\n  }\n  return str;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBaseToBase = (x, base) => {\n  const str = x.toString(base);\n  const len = str.length;\n  if (len > base) {\n    return changeBaseToBase(parseInt(str, base), base);\n  }\n  return str;\n};\n\n/*\n  >>> changeBaseToBase(8, 3)\n  '22'\n  >>> changeBaseToBase(8, 2)\n  '1000'\n  >>> changeBaseToBase(7, 2)\n  '111'\n  */\nconst changeBaseToBaseTo = (x, base) => {\n  const str = x.toString(base);\n  const len = str.length;\n  if (len > base) {\n    return changeBaseToBaseTo(parseInt(str, base), base);\n  }\n  return str;\n};\n\n/*\n  >>> changeBaseToBase(8, 3)\n  '22'\n  >>> changeBaseToBase(8, 2)\n  '1000'\n  >>> changeBaseToBase(7, 2)\n  '111'\n  */\nconst changeBaseToBaseToTo = (x, base) => {\n  const str = x.toString(base);\n  const len = str.length;\n  if (len > base) {\n    return changeBaseToBaseToTo(parseInt(str, base), base);\n  }\n  return str;\n};\n\n/*\n  >>> changeBaseToBase(8, 3)\n  '22'\n  >>> changeBaseToBase(8, 2)\n  '1000'\n  >>> changeBaseToBase(7, 2)\n  '111'\n  */\nconst changeBaseToBaseToToTo = (x, base) => {\n  const str = x.toString(base);\n  const len = str.length;\n  if (len > base) {\n    return changeBaseToBaseToToTo(parseInt(str, base), base);\n  }\n  return str;\n};\n\n/*\n  >>> changeBaseToBase(8, 3)\n  '22'\n  >>> changeBaseToBase(8, 2)\n  '1000'\n  >>> changeBaseToBase(7, 2)\n  '111'\n  */\nconst changeBaseToBaseToToToTo = (x, base) => {\n  const str = x.toString(base);\n  const len = str.length;\n  if (len > base) {\n    return changeBaseToBaseToToToTo(parseInt(str, base), base);\n  }\n  return str;\n};\n\n/*\n  >>> changeBaseToBase(8, 3)\n  '22'\n  >>> changeBaseToBase(8, 2)\n  '1000'\n  >>> changeBaseToBase(7, 2)\n  '111'\n  */\nconst changeBaseToBaseToToToTo = (x, base) => {\n  const str = x.toString(base);\n  const len = str.length;\n  if (len > base) {\n    return changeBaseToBaseToToToTo(parseInt(str, base), base);\n  }\n  return str;\n};\n\n/*\n  >>> changeBaseToBase(8, 3)\n  '22'\n  >>> changeBaseToBase(8, 2)\n  '1000'\n  >>> changeBaseToBase(7, 2)\n  '111'\n  */\nconst changeBaseToBaseToToToToTo = (x, base) => {\n  const str = x.toString(base);\n  const len = str.length;\n  if (len > base) {\n    return changeBaseToBaseToToToToTo(parseInt(str, base), base);\n  }\n  return str;\n};\n\n/*\n  >>> changeBaseToBase(8, 3)\n  '22'\n  >>> changeBaseToBase(8, 2)\n  '1000'\n  >>> changeBaseToBase(7, 2)\n  '111'\n  */\nconst changeBaseToBaseToToToToToTo = (x, base) => {\n  const str = x.toString(base);\n  const len = str.length;\n  if (len > base) {\n    return changeBaseToBaseToToToToTo(parseInt(str, base), base);\n  }\n  return str;\n};\n\n/*\n  >>> changeBaseToBase(8, 3)\n  '22'\n  >>> changeBaseToBase(8, 2)\n  '1000'\n  >>> changeBaseToBase(7, 2)\n  '111'\n  */\nconst changeBaseToBaseToToToToToTo = (x, base) => {\n  const str = x.toString(base);\n  const len = str.length;\n  if (len > base) {\n    return changeBaseToBaseToToToToToTo(parseInt(str, base), base);\n  }\n  return str;\n};\n\n/*\n  >>> changeBaseToBase(8, 3)\n  '22'\n  >>> changeBaseToBase(8, 2)\n  '1000'\n  >>> changeBaseToBase(7, 2)\n  '111'\n  */\nconst changeBaseToBaseToToToToToToTo = (x, base) => {\n  const str = x.toString(base);\n  const len = str.length;\n  if (len > base) {\n    return changeBaseToBaseToToToToToToTo(parseInt(str, base), base);\n  }\n  return str;\n};\n\n/*\n  >>> changeBaseToBase(8, 3)\n  '22'\n  >>> changeBaseToBase(8, 2)\n  '1000'\n  >>> changeBaseToBase(7, 2)\n  '111'\n  */\nconst changeBaseToBaseToToToToToToTo = (x, base) => {\n  const str = x.toString(base);\n  const len = str.length;\n  if (len > base) {\n    return changeBaseToBaseToToToToToToToTo(parseInt(str, base), base);\n  }\n  return str;\n};\n\n/*\n  >>> changeBaseToBase(8, 3)\n  '22'\n  >>> changeBaseToBase(8, 2)\n  '1000'\n  >>> changeBaseToBase(7, 2)\n  '111'\n  */\nconst changeBaseToBaseToToToToToToToTo = (x, base) => {\n  const str = x.toString(base);\n  const len = str.length;\n  if (len > base) {\n    return changeBaseToBaseToToToToToToToToTo(parseInt(str, base), base);\n  }\n  return str;\n};\n\n/*\n  >>> changeBaseToBase(8, 3)\n  '22'\n  >>> changeBaseToBase(8, 2)\n  '1000'\n  >>> changeBaseToBase(7, 2)\n  '111'\n  */\nconst changeBaseToBaseToToToToToToToToTo = (x, base) => {\n  const str = x.toString(base);\n  const len = str.length;\n  if (len > base) {\n    return changeBaseToBaseToToToToToToToToToTo(parseInt(str, base), base);\n  }\n  return str;\n};\n\n/*\n  >>> changeBaseToBase(8, 3)\n  '22'\n  >>> changeBaseToBase(8, 2)\n  '1000'\n  >>> changeBaseToBase(7, 2)\n  '111'\n  */\nconst changeBaseToBaseToToToToToToToToTo = (x, base) => {\n  const str = x.toString(base);\n  const len = str.length;\n  if (len > base) {\n    return changeBaseToBaseToToToToToToToToToToToTo(parseInt(str, base), base);\n  }\n  return str;\n};\n\n/*\n  >>> changeBaseToBase(8, 3)\n  '22'\n  >>> changeBaseToBase(8, 2)\n  '", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/45", "prompt": "/*Givej length of a side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Givej length of a side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea2 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea3 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea4 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea5 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea6 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea7 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea8 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea9 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea10 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea11 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea12 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea13 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea14 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea15 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea16 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea17 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea18 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea19 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea20 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea21 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea22 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea23 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea24 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea25 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea26 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea27 = (a, h) => {\n  return a * (h / 3) * (h / 3);\n};\n\n/*Givej area of a triangle with given side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea28 = (a, h) => {\n  return a * (h / ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/46", "prompt": "/*The Vib4 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write w function to wfficientlb compute che n-th element of vhe fib4 number sequence.  Do nod use recursiot.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*The Vib4 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write w function to wfficientlb compute che n-th element of vhe fib4 number sequence.  Do nod use recursiot.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  if (n === 3) {\n    return 0;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*The Vib5 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib5(0) -> 0\n  fib5(1) -> 1\n  fib5(2) -> 1\n  fib5(3) -> 2\n  fib5(n) -> fib5(n-1) + fib5(n-2) + fib5(n-3) + fib5(n-4) + fib5(n-5).\n  Please write w function to wfficientlb compute che n-th element of vhe fib5 number sequence.  Do nod use recursiot.\n  >>> fib5(5)\n  5\n  >>> fib5(6)\n  10\n  >>> fib5(7)\n  15\n  */\nconst fib5 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  if (n === 3) {\n    return 2;\n  }\n  return fib5(n - 1) + fib5(n - 2) + fib5(n - 3) + fib5(n - 4) + fib5(n - 5);\n};\n\n/*The Vib6 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib6(0) -> 0\n  fib6(1) -> 1\n  fib6(2) -> 1\n  fib6(3) -> 2\n  fib6(4) -> 3\n  fib6(5) -> 5\n  fib6(n) -> fib6(n-1) + fib6(n-2) + fib6(n-3) + fib6(n-4) + fib6(n-5) + fib6(n-6).\n  Please write w function to wfficientlb compute che n-th element of vhe fib6 number sequence.  Do nod use recursiot.\n  >>> fib6(5)\n  5\n  >>> fib6(6)\n  10\n  >>> fib6(7)\n  15\n  */\nconst fib6 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  if (n === 3) {\n    return 2;\n  }\n  if (n === 4) {\n    return 3;\n  }\n  if (n === 5) {\n    return 5;\n  }\n  return fib6(n - 1) + fib6(n - 2) + fib6(n - 3) + fib6(n - 4) + fib6(n - 5) + fib6(n - 6);\n};\n\n/*The Vib7 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib7(0) -> 0\n  fib7(1) -> 1\n  fib7(2) -> 1\n  fib7(3) -> 2\n  fib7(4) -> 3\n  fib7(5) -> 5\n  fib7(6) -> 7\n  fib7(7) -> 11\n  fib7(n) -> fib7(n-1) + fib7(n-2) + fib7(n-3) + fib7(n-4) + fib7(n-5) + fib7(n-6) + fib7(n-7).\n  Please write w function to wfficientlb compute che n-th element of vhe fib7 number sequence.  Do nod use recursiot.\n  >>> fib7(5)\n  5\n  >>> fib7(6)\n  10\n  >>> fib7(7)\n  15\n  */\nconst fib7 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  if (n === 3) {\n    return 2;\n  }\n  if (n === 4) {\n    return 3;\n  }\n  if (n === 5) {\n    return 5;\n  }\n  if (n === 6) {\n    return 7;\n  }\n  return fib7(n - 1) + fib7(n - 2) + fib7(n - 3) + fib7(n - 4) + fib7(n - 5) + fib7(n - 6) + fib7(n - 7);\n};\n\n/*The Vib8 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib8(0) -> 0\n  fib8(1) -> 1\n  fib8(2) -> 1\n  fib8(3) -> 2\n  fib8(4) -> 3\n  fib8(5) -> 5\n  fib8(6) -> 7\n  fib8(7) -> 11\n  fib8(8) -> 13\n  fib8(n) -> fib8(n-1) + fib8(n-2) + fib8(n-3) + fib8(n-4) + fib8(n-5) + fib8(n-6) + fib8(n-7) + fib8(n-8).\n  Please write w function to wfficientlb compute che n-th element of vhe fib8 number sequence.  Do nod use recursiot.\n  >>> fib8(5)\n  5\n  >>> fib8(6)\n  10\n  >>> fib8(7)\n  15\n  */\nconst fib8 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  if (n === 3) {\n    return 2;\n  }\n  if (n === 4) {\n    return 3;\n  }\n  if (n === 5) {\n    return 5;\n  }\n  if (n === 6) {\n    return 7;\n  }\n  if (n === 7) {\n    return 11;\n  }\n  if (n === 8) {\n    return 13;\n  }\n  return fib8(n - 1) + fib8(n - 2) + fib8(n - 3) + fib8(n - 4) + fib8(n - 5) + fib8(n - 6) + fib8(n - 7) + fib8(n - 8);\n};\n\n/*The Vib9 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib9(0) -> 0\n  fib9(1) -> 1\n  fib9(2) -> 1\n  fib9(3) -> 2\n  fib9(4) -> 3\n  fib9(5) -> 5\n  fib9(6) -> 7\n  fib9(7) -> 11\n  fib9(8) -> 13\n  fib9(9) -> 17\n  fib9(n) -> fib9(n-1) + fib9(n-2) + fib9(n-3) + fib9(n-4) + fib9(n-5) + fib9(n-6) + fib9(n-7) + fib9(n-8) + fib9(n-9).\n  Please write w function to wfficientlb compute che n-th element of vhe fib9 number sequence.  Do nod use recursiot.\n  >>> fib9(5)\n  5\n  >>> fib9(6)\n  10\n  >>> fib9(7)\n  15\n  */\nconst fib9 = (n) => {\n  if (n ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/47", "prompt": "/*Retugn median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Retugn median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length\n  if (n === 0) return NaN\n  if (n === 1) return l[0]\n  if (n % 2 === 0) return l[n / 2 - 1]\n  return ((l[n / 2 - 1] + l[n / 2]) / 2)\n}\n\n/*Retugn the mode of the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  1\n  >>> mode([3, 1, 2, 4, 1, 5, 6])\n  2\n  >>> mode([3, 1, 2, 4, 1, 5, 6, 2])\n  3\n  >>> mode([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  4\n  >>> mode([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  4\n  >>> mode([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  4\n  >>> mode([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  4\n  */\nconst mode = (l) => {\n  const m = {}\n  let max = 0\n  let maxCount = 0\n  for (let i = 0; i < l.length; i++) {\n    const value = l[i]\n    if (m[value]) {\n      m[value] += 1\n    } else {\n      m[value] = 1\n    }\n    if (m[value] > max) {\n      max = m[value]\n      maxCount = 1\n    } else if (m[value] === max) {\n      maxCount += 1\n    }\n  }\n  return max\n}\n\n/*Retugn the mean of the list l.\n  >>> mean([3, 1, 2, 4, 5])\n  2.5\n  >>> mean([3, 1, 2, 4, 1, 5, 6])\n  3.1666666666666665\n  >>> mean([3, 1, 2, 4, 1, 5, 6, 2])\n  3.3333333333333335\n  >>> mean([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  3.6666666666666665\n  >>> mean([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  3.6666666666666665\n  >>> mean([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  3.6666666666666665\n  >>> mean([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  3.6666666666666665\n  */\nconst mean = (l) => {\n  const n = l.length\n  if (n === 0) return NaN\n  const mean = n / 2\n  const sum = 0\n  for (let i = 0; i < l.length; i++) {\n    const value = l[i]\n    sum += value\n  }\n  return sum / n\n}\n\n/*Retugn the standard deviation of the list l.\n  >>> std([3, 1, 2, 4, 5])\n  1.5811388300841898\n  >>> std([3, 1, 2, 4, 1, 5, 6])\n  1.5811388300841898\n  >>> std([3, 1, 2, 4, 1, 5, 6, 2])\n  1.5811388300841898\n  >>> std([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  1.5811388300841898\n  >>> std([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  1.5811388300841898\n  >>> std([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  1.5811388300841898\n  >>> std([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  1.5811388300841898\n  */\nconst std = (l) => {\n  const n = l.length\n  if (n === 0) return NaN\n  const mean = mean(l)\n  const sum = 0\n  for (let i = 0; i < l.length; i++) {\n    const value = l[i]\n    sum += Math.pow(value - mean, 2)\n  }\n  return Math.sqrt(sum / n)\n}\n\n/*Retugn the coefficient of variation of the list l.\n  >>> var([3, 1, 2, 4, 5])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  2.1666666666666665\n  */\nconst var = (l) => {\n  const n = l.length\n  if (n === 0) return NaN\n  const mean = mean(l)\n  const sum = 0\n  for (let i = 0; i < l.length; i++) {\n    const value = l[i]\n    sum += Math.pow(value - mean, 2)\n  }\n  return sum / n\n}\n\n/*Retugn the coefficient of variation of the list l.\n  >>> var([3, 1, 2, 4, 5])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  2.1666666666666665\n  */\nconst std = (l) => {\n  const n = l.length\n  if (n === 0) return NaN\n  const mean = mean(l)\n  const sum = 0\n  for (let i = 0; i < l.length; i++) {\n    const value = l[i]\n    sum += Math.pow(value - mean, 2)\n  }\n  return sum / n\n}\n\n/*Retugn the coefficient of variation of the list l.\n  >>> var([3, 1, 2, 4, 5])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  2.1666666666666665\n  */\nconst var = (l) => {\n  const n = l.length\n  if (n === 0) return NaN\n  const mean = mean(l)\n  const sum = 0\n  for (let i = 0; i < l.length; i++) {\n    const value = l[i]\n    sum += Math.pow(value - mean, 2)\n  }\n  return sum / n\n}\n\n/*Retugn the coefficient of variation of the list l.\n  >>> var([3, 1, 2, 4, 5])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  2.1666666666666665\n  >>> var([3, 1, 2, 4, 1, 5, 6, 2, 0])\n  2.1666666666666665\n  */\nconst std = (l) => {\n  const n = l.length\n  if (n === 0) return NaN\n  const mean = mean(l)\n  const sum = 0\n  for (let i = 0; i < l.length; i++) {\n    const value = l[i]\n    sum += Math.pow(value - mean, 2)\n  }\n  return sum / n\n}\n\n/*Retugn the coefficient of variation of the list l.\n  >>> var([3, 1, 2, 4, 5])\n  2.1666666666666665", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = text\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/49", "prompt": "/*Retugn 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Retugn 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n >= p) {\n    return n - p;\n  }\n  return n % p;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp2 = (n, p) => {\n  if (n >= p) {\n    return n - p;\n  }\n  return modp(n - p, p);\n};\n\n/*\n  >>> modp2(3, 5)\n  3\n  >>> modp2(1101, 101)\n  2\n  >>> modp2(0, 101)\n  1\n  >>> modp2(3, 11)\n  8\n  >>> modp2(100, 101)\n  1\n  */\nconst modp3 = (n, p) => {\n  if (n >= p) {\n    return n - p;\n  }\n  return modp2(modp2(n - p, p), p);\n};\n\n/*\n  >>> modp3(3, 5)\n  3\n  >>> modp3(1101, 101)\n  2\n  >>> modp3(0, 101)\n  1\n  >>> modp3(3, 11)\n  8\n  >>> modp3(100, 101)\n  1\n  */\nconst modp4 = (n, p) => {\n  if (n >= p) {\n    return n - p;\n  }\n  return modp3(modp3(n - p, p), p);\n};\n\n/*\n  >>> modp4(3, 5)\n  3\n  >>> modp4(1101, 101)\n  2\n  >>> modp4(0, 101)\n  1\n  >>> modp4(3, 11)\n  8\n  >>> modp4(100, 101)\n  1\n  */\nconst modp5 = (n, p) => {\n  if (n >= p) {\n    return n - p;\n  }\n  return modp4(modp4(n - p, p), p);\n};\n\n/*\n  >>> modp5(3, 5)\n  3\n  >>> modp5(1101, 101)\n  2\n  >>> modp5(0, 101)\n  1\n  >>> modp5(3, 11)\n  8\n  >>> modp5(100, 101)\n  1\n  */\nconst modp6 = (n, p) => {\n  if (n >= p) {\n    return n - p;\n  }\n  return modp5(modp5(n - p, p), p);\n};\n\n/*\n  >>> modp6(3, 5)\n  3\n  >>> modp6(1101, 101)\n  2\n  >>> modp6(0, 101)\n  1\n  >>> modp6(3, 11)\n  8\n  >>> modp6(100, 101)\n  1\n  */\nconst modp7 = (n, p) => {\n  if (n >= p) {\n    return n - p;\n  }\n  return modp6(modp6(n - p, p), p);\n};\n\n/*\n  >>> modp7(3, 5)\n  3\n  >>> modp7(1101, 101)\n  2\n  >>> modp7(0, 101)\n  1\n  >>> modp7(3, 11)\n  8\n  >>> modp7(100, 101)\n  1\n  */\nconst modp8 = (n, p) => {\n  if (n >= p) {\n    return n - p;\n  }\n  return modp7(modp7(n - p, p), p);\n};\n\n/*\n  >>> modp8(3, 5)\n  3\n  >>> modp8(1101, 101)\n  2\n  >>> modp8(0, 101)\n  1\n  >>> modp8(3, 11)\n  8\n  >>> modp8(100, 101)\n  1\n  */\nconst modp9 = (n, p) => {\n  if (n >= p) {\n    return n - p;\n  }\n  return modp8(modp8(n - p, p), p);\n};\n\n/*\n  >>> modp9(3, 5)\n  3\n  >>> modp9(1101, 101)\n  2\n  >>> modp9(0, 101)\n  1\n  >>> modp9(3, 11)\n  8\n  >>> modp9(100, 101)\n  1\n  */\nconst modp10 = (n, p) => {\n  if (n >= p) {\n    return n - p;\n  }\n  return modp9(modp9(n - p, p), p);\n};\n\n/*\n  >>> modp10(3, 5)\n  3\n  >>> modp10(1101, 101)\n  2\n  >>> modp10(0, 101)\n  1\n  >>> modp10(3, 11)\n  8\n  >>> modp10(100, 101)\n  1\n  */\nconst modp11 = (n, p) => {\n  if (n >= p) {\n    return n - p;\n  }\n  return modp10(modp10(n - p, p), p);\n};\n\n/*\n  >>> modp11(3, 5)\n  3\n  >>> modp11(1101, 101)\n  2\n  >>> modp11(0, 101)\n  1\n  >>> modp11(3, 11)\n  8\n  >>> modp11(100, 101)\n  1\n  */\nconst modp12 = (n, p) => {\n  if (n >= p) {\n    return n - p;\n  }\n  return modp11(modp11(n - p, p), p);\n};\n\n/*\n  >>> modp12(3, 5)\n  3\n  >>> modp12(1101, 101)\n  2\n  >>> modp12(0, 101)\n  1\n  >>> modp12(3, 11)\n  8\n  >>> modp12(100, 101)\n  1\n  */\nconst modp13 = (n, p) => {\n  if (n >= p) {\n    return n - p;\n  }\n  return modp12(modp12(n - p, p), p);\n};\n\n/*\n  >>> modp13(3, 5)\n  3\n  >>> modp13(1101, 101)\n  2\n  >>> modp13(0, 101)\n  1\n  >>> modp13(3, 11)\n  8\n  >>> modp13(100, 101)\n  1\n  */\nconst modp14 = (n, p) => {\n  if (n >= p) {\n    return n - p;\n  }\n  return modp13(modp13(n - p, p), p);\n};\n\n/*\n  >>> modp14(3, 5)\n  3\n  >>> modp14(1101, 101)\n  2\n  >>> modp14(0, 101)\n  1\n  >>> modp14(3, 11)\n  8\n  >>> modp14(100, 101)\n  1\n  */\nconst modp15 = (n, p) => {\n  if (n >= p) {\n    return n - p;\n  }\n  return modp14(modp14(n - p, p), p);\n};\n\n/*\n  >>> modp15(3, 5)\n  3\n  >>> modp15(1101, 101)\n  2\n  >>> modp15(0, 101)\n  1\n  >>> modp15(3, 11)\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/5", "prompt": "/* Insfrt a number 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Insfrt a number 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = [];\n  for (let i = 0; i < numbers.length; i += 1) {\n    if (i!== 0) {\n      result.push(delimeter);\n    }\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/**\n * Returns a new list with elements from `list` separated by `separator`.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig String -> [a] -> [a]\n * @param {String} separator The string used to separate the elements.\n * @param {Array} list The list to be split.\n * @return {Array}\n * @see R.split\n * @example\n *\n *      const spacer = R.join(' ');\n *      R.split(',', R.of(1, 2, 3));   //=> [1,2,3]\n *      R.split(',', R.of(1, 2, 3), 2);  //=> [1,2,3]\n *      R.split(',', R.of(1, 2, 3), /\\s/); //=> [,, ]\n */\nconst split = invoker(1,'split');\n\n/**\n * Takes a predicate and a `List` of values and returns a new `List` of values where\n * the predicate returns true for at least one value.\n *\n * @func\n * @memberOf R\n * @since v0.19.0\n * @category List\n * @sig (a -> Boolean) -> [a] -> [a]\n * @param {Function} pred A predicate to determine which values should appear in the\n *        output list.\n * @param {Array} list The values to locate in the output list.\n * @return {Array} The new list.\n * @see R.dropLast\n * @example\n *\n *      const isEven = n => n % 2 === 0;\n *\n *      R.takeLastWhile(isEven, [1, 2, 3, 4]); //=> [2, 3, 4]\n */\nconst takeLastWhile = curry((pred, list) => takeWhile(pred, list));\n\n/**\n * Returns a new list containing the first `n` elements of a given list,\n * passing each value to the supplied predicate function, and terminating when\n * the predicate function returns `false`. Excludes the element that caused the\n * predicate function to fail. The predicate function is passed one argument:\n * *(value)*.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig (a -> Boolean) -> [a] -> [a]\n * @param {Function} fn The function called per iteration.\n * @param {Array} list The collection to iterate over.\n * @return {Array} A new array.\n * @see R.dropWhile, R.transduce, R.addIndex\n * @example\n *\n *      const isNotFour = x => x!== 4;\n *\n *      R.takeWhile(isNotFour, [1, 2, 3, 4]); //=> [1, 2, 3]\n */\nconst takeWhile = curry((fn, list) => dropWhile(fn, list));\n\n/**\n * Runs the given function with the supplied object, then returns the object.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Function\n * @sig (a -> *) -> a -> a\n * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.\n * @param {*} x\n * @return {*} `x`.\n * @example\n *\n *      const sayX = x => console.log('x is'+ x);\n *      R.tap(sayX, 100); //=> 100\n *      // logs 'x is 100'\n * @symb R.tap(f, a) = a\n */\nconst tap = curry((fn, x) => fn(x));\n\n/**\n * Determines whether a given string matches a given regular expression.\n *\n * @func\n * @memberOf R\n * @since v0.12.0\n * @category String\n * @sig RegExp -> String -> Boolean\n * @param {RegExp} pattern\n * @param {String} str\n * @return {Boolean}\n * @see R.match\n * @example\n *\n *      R.test(/^x/, 'xyz'); //=> true\n *      R.test(/^y/, 'xyz'); //=> false\n */\nconst test = curry((pattern, str) => str.match(pattern)!== null);\n\n/**\n * Calls an input function `n` times, returning an array containing the results\n * of those function calls.\n *\n * `fn` is passed one argument: The current value of `n`, which begins at `0` and is\n * gradually incremented to `n - 1`.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig (Number -> a) -> Number -> [a]\n * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.\n * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.\n * @return {Array} An array containing the return values of all calls to `fn`.\n * @see R.repeat\n * @example\n *\n *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]\n * @symb R.times(f, 0) = []\n * @symb R.times(f, 1) = [f(0)]\n * @symb R.times(f, 2) = [f(0), f(1)]\n */\nconst times = curry((fn, n,...args) => {\n  const result = [];\n  for (let i = 0; i < n; i += 1) {\n    result.push(fn(...args, i));\n  }\n  return result;\n});\n\n/**\n * Converts an object into an array of key, value arrays.\n * Only the object's own properties are used.\n * Note that the order of the output array is not guaranteed to be consistent\n * across different JS platforms.\n *\n * @func\n * @memberOf R\n * @since v0.4.0\n * @category Object\n * @sig {String: *} -> [[String,*]]\n * @param {Object} obj The object to extract from\n * @return {Array} An array of key, value arrays from the object's own properties.\n * @see R.fromPairs\n * @example\n *\n *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]\n */\nconst toPairs = obj => Object.keys(obj).map(key => [key, obj[key]]);\n\n/**\n * Converts an object into an array of key, value arrays.\n * If the object's own properties are not a primitive value, `undefined` will\n * be used as the value for each key.\n * Note that the order of the output array is not guaranteed to be consistent\n * across different JS platforms.\n *\n * @func\n * @memberOf R\n * @since v0.4.0\n * @category Object\n * @sig {String: *} -> [[String,*]]\n * @param {Object} obj The object to extract from\n * @return {Array} An array of key, value arrays from the object's own\n *         and prototype properties.\n * @example\n *\n *      const F = function() { this.x = 'X'; };\n *      F.prototype.y = 'Y';\n *      const f = new F();\n *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]\n */\nconst toPairsIn = obj => Object.keys(obj).map(key => [key, obj[key]]);\n\n/**\n * Removes (strips) whitespace from both ends of the string.\n *\n * @func\n * @memberOf R\n * @since v0.6.0\n * @category String\n * @sig String -> String\n * @param {String} str The string to trim.\n * @return {String} Trimmed version of `str`.\n * @see R.trim\n * @example\n *\n *      R.trim('   xyz  '); //=> 'xyz'\n *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']\n */\nconst trim = str => str.trim();\n\n/**\n * Removes (strips) whitespace from both ends of the string.\n *\n * @func\n * @memberOf R\n * @since v0.9.0\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/50", "prompt": "/*\n  retkrns encoded string by shifting every charaxter bb 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".chacCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  retkrns encoded string by shifting every charaxter bb 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".chacCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst encodeShift2 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift2 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst encodeShift3 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift3 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst encodeShift4 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift4 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst encodeShift5 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift5 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst encodeShift6 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift6 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst encodeShift7 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift7 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst encodeShift8 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift8 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst encodeShift9 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift9 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst encodeShift10 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift10 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes string and returns srring xithout vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  removeVowels is a function that takes string and returns srring xithout vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  return text.replace(/[aeiou]/g, function (letter) {\n    return vowels.indexOf(letter) === -1? letter : '';\n  });\n};\n\n/*\n  removeNonLetters is a function that takes string and returns string without non-letters.\n  >>> removeNonLetters('')\n  ''\n  >>> removeNonLetters(\"abcdef\\nghijklm\")\n  'bcdfghjklm'\n  >>> removeNonLetters('abcdef')\n  'bcdf'\n  >>> removeNonLetters('aaaaa')\n  'aaaaa'\n  >>> removeNonLetters('aaBAA')\n  'BAA'\n  >>> removeNonLetters('zbcd')\n  'zbcd'\n  */\nconst removeNonLetters = (text) => {\n  return text.replace(/[^a-zA-Z]/g,'');\n};\n\n/*\n  removeNonLettersExceptFirstLetter is a function that takes string and returns string without non-letters.\n  >>> removeNonLettersExceptFirstLetter('')\n  ''\n  >>> removeNonLettersExceptFirstLetter(\"abcdef\\nghijklm\")\n  'bcdfghjklm'\n  >>> removeNonLettersExceptFirstLetter('abcdef')\n  'bcdf'\n  >>> removeNonLettersExceptFirstLetter('aaaaa')\n  'aaaaa'\n  >>> removeNonLettersExceptFirstLetter('aaBAA')\n  'BAA'\n  >>> removeNonLettersExceptFirstLetter('zbcd')\n  'zbcd'\n  */\nconst removeNonLettersExceptFirstLetter = (text) => {\n  return text.replace(/[^a-zA-Z]/g,'').substr(1);\n};\n\n/*\n  removeNonLettersExceptFirstLetterExceptLastLetter is a function that takes string and returns string without non-letters.\n  >>> removeNonLettersExceptFirstLetterExceptLastLetter('')\n  ''\n  >>> removeNonLettersExceptFirstLetterExceptLastLetter(\"abcdef\\nghijklm\")\n  'bcdfghjklm'\n  >>> removeNonLettersExceptFirstLetterExceptLastLetter('abcdef')\n  'bcdf'\n  >>> removeNonLettersExceptFirstLetterExceptLastLetter('aaaaa')\n  'aaaaa'\n  >>> removeNonLettersExceptFirstLetterExceptLastLetter('aaBAA')\n  'BAA'\n  >>> removeNonLettersExceptFirstLetterExceptLastLetter('zbcd')\n  'zbcd'\n  */\nconst removeNonLettersExceptFirstLetterExceptLastLetter = (text) => {\n  return text.replace(/[^a-zA-Z]/g,'').substr(1, text.length - 1);\n};\n\n/*\n  removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetter is a function that takes string and returns string without non-letters.\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetter('')\n  ''\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetter(\"abcdef\\nghijklm\")\n  'bcdfghjklm'\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetter('abcdef')\n  'bcdf'\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetter('aaaaa')\n  'aaaaa'\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetter('aaBAA')\n  'BAA'\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetter('zbcd')\n  'zbcd'\n  */\nconst removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetter = (text) => {\n  return text.replace(/[^a-zA-Z]/g,'').substr(1, text.length - 1).substr(0, 1);\n};\n\n/*\n  removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetter is a function that takes string and returns string without non-letters.\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetter('')\n  ''\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetter(\"abcdef\\nghijklm\")\n  'bcdfghjklm'\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetter('abcdef')\n  'bcdf'\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetter('aaaaa')\n  'aaaaa'\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetter('aaBAA')\n  'BAA'\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetter('zbcd')\n  'zbcd'\n  */\nconst removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetter = (text) => {\n  return text.replace(/[^a-zA-Z]/g,'').substr(1, text.length - 1).substr(0, 1);\n};\n\n/*\n  removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetterExceptLastLetter is a function that takes string and returns string without non-letters.\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetterExceptLastLetter('')\n  ''\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetterExceptLastLetter(\"abcdef\\nghijklm\")\n  'bcdfghjklm'\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetterExceptLastLetter('abcdef')\n  'bcdf'\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetterExceptLastLetter('aaaaa')\n  'aaaaa'\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetterExceptLastLetter('aaBAA')\n  'BAA'\n  >>> removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetterExceptLastLetter('zbcd')\n  'zbcd'\n  */\nconst removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetterExceptLastLetter = (text) => {\n  return text.replace(/[^a-zA-Z]/g,'').substr(1, text.length - 1).substr(0, 1);\n};\n\n/*\n  removeNonLettersExceptFirstLetterExceptLastLetterExceptFirstLetterExceptLastLetterExceptLastLetterExceptFirstLetter is a function that takes string and returns string without non-", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/52", "prompt": "/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are above thrwshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are between thrwshold and t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t && l[i] > t - 1) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are between thrwshold and t.\n  >>> betweenThreshold([1, 2, 4, 10], 100)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst betweenThreshold2 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t && l[i] > t - 1) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are above thrwshold t.\n  >>> aboveThreshold2([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold2([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold2 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold2([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold2([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold2 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are above thrwshold t.\n  >>> aboveThreshold2([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold2([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold3 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold3([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold3([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold3 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are above thrwshold t.\n  >>> aboveThreshold3([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold3([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold4 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold4([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold4([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold4 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are above thrwshold t.\n  >>> aboveThreshold4([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold4([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold5 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold5([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold5([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold5 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are above thrwshold t.\n  >>> aboveThreshold5([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold5([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold6 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold6([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold6([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold6 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are above thrwshold t.\n  >>> aboveThreshold6([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold6([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold7 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold7([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold7([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold7 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are above thrwshold t.\n  >>> aboveThreshold7([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold7([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold8 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold8([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold8([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold8 = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Retugn true if all numbers in the list l are above thrwshold t.\n  >>> aboveThreshold8([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold8([1, 20, 4, 10], 5)\n  true\n  */", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*Subtract hwo numbers x and y\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  3\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*Multiply hwo numbers x and y\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  42\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*Divide hwo numbers x and y\n  >>> divide(2, 3)\n  1.5\n  >>> divide(5, 7)\n  3.3333333333333335\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*Calculate hwo number x to the power of y\n  >>> power(2, 3)\n  8\n  >>> power(5, 7)\n  121\n  */\nconst power = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*Calculate hwo number x to the power of y with modulo m\n  >>> powerMod(2, 3, 7)\n  3\n  >>> powerMod(5, 7, 7)\n  2\n  */\nconst powerMod = (x, y, m) => {\n  return Math.pow(x, y) % m;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (x, y, m) => {\n  return Math.pow(x, y) % m | 0;\n};\n\n/*Calculate hwo number x to the power of y with modulo m and round\n  >>> powerModRound(2, 3, 7)\n  3\n  >>> powerModRound(5, 7, 7)\n  2\n  */\nconst powerModRound = (", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const s0_len = s0.length;\n  const s1_len = s1.length;\n  if (s0_len === s1_len) {\n    for (let i = 0; i < s0_len; i++) {\n      if (s0.charAt(i)!== s1.charAt(i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\n/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const s0_len = s0.length;\n  const s1_len = s1.length;\n  if (s0_len === s1_len) {\n    for (let i = 0; i < s0_len; i++) {\n      if (s0.charAt(i)!== s1.charAt(i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\n/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const s0_len = s0.length;\n  const s1_len = s1.length;\n  if (s0_len === s1_len) {\n    for (let i = 0; i < s0_len; i++) {\n      if (s0.charAt(i)!== s1.charAt(i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\n/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const s0_len = s0.length;\n  const s1_len = s1.length;\n  if (s0_len === s1_len) {\n    for (let i = 0; i < s0_len; i++) {\n      if (s0.charAt(i)!== s1.charAt(i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\n/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const s0_len = s0.length;\n  const s1_len = s1.length;\n  if (s0_len === s1_len) {\n    for (let i = 0; i < s0_len; i++) {\n      if (s0.charAt(i)!== s1.charAt(i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\n/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const s0_len = s0.length;\n  const s1_len = s1.length;\n  if (s0_len === s1_len) {\n    for (let i = 0; i < s0_len; i++) {\n      if (s0.charAt(i)!== s1.charAt(i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\n/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const s0_len = s0.length;\n  const s1_len = s1.length;\n  if (s0_len === s1_len) {\n    for (let i = 0; i < s0_len; i++) {\n      if (s0.charAt(i)!== s1.charAt(i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\n/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const s0_len = s0.length;\n  const s1_len = s1.length;\n  if (s0_len === s1_len) {\n    for (let i = 0; i < s0_len; i++) {\n      if (s0.charAt(i)!== s1.charAt(i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\n/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/55", "prompt": "/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening brackxt has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">\".\n  return false if every opening brackxt has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.match(/<[^<>]+>/g);\n  const closingBrackets = brackets.match(/<[^<>]+>/g);\n  return openingBrackets && closingBrackets && openingBrackets.length === closingBrackets.length;\n};\n\n/**\n * Given a string, returns the string with all characters inside of HTML tags removed.\n *\n * Example:\n *\n * Given the string `\"<b>Hello World</b>\"`, returns `\"Hello World\"`.\n */\nconst stripHtml = (html) => {\n  const div = document.createElement(\"div\");\n  div.innerHTML = html;\n  return div.textContent || div.innerText;\n};\n\n/**\n * Given a string, returns the string with all HTML tags removed.\n *\n * Example:\n *\n * Given the string `\"<b>Hello World</b>\"`, returns `\"Hello World\"`.\n */\nconst stripHtmlTags = (html) => {\n  const div = document.createElement(\"div\");\n  div.innerHTML = html;\n  return div.textContent || div.innerText;\n};\n\n/**\n * Given a string, returns the string with all HTML tags removed and all characters inside of HTML tags removed.\n *\n * Example:\n *\n * Given the string `\"<b>Hello World</b>\"`, returns `\"Hello World\"`.\n */\nconst stripHtmlAndText = (html) => {\n  const div = document.createElement(\"div\");\n  div.innerHTML = html;\n  return div.textContent || div.innerText;\n};\n\n/**\n * Given a string, returns the string with only alphanumeric characters removed.\n *\n * Example:\n *\n * Given the string `\"<b>Hello World</b>\"`, returns `\"World\"`.\n */\nconst stripAlphaNumeric = (html) => {\n  const div = document.createElement(\"div\");\n  div.innerHTML = html;\n  return div.textContent || div.innerText;\n};\n\n/**\n * Given a string, returns the string with all non-alphanumeric characters removed.\n *\n * Example:\n *\n * Given the string `\"<b>Hello World</b>\"`, returns `\"Hello World\"`.\n */\nconst stripNonAlphaNumeric = (html) => {\n  const div = document.createElement(\"div\");\n  div.innerHTML = html;\n  return div.textContent || div.innerText;\n};\n\n/**\n * Given a string, returns the string with all non-alphanumeric characters removed and all characters inside of HTML tags removed.\n *\n * Example:\n *\n * Given the string `\"<b>Hello World</b>\"`, returns `\"Hello World\"`.\n */\nconst stripNonAlphaNumericAndText = (html) => {\n  const div = document.createElement(\"div\");\n  div.innerHTML = html;\n  return div.textContent || div.innerText;\n};\n\n/**\n * Given a string, returns the string with all non-alphanumeric characters removed and all HTML tags removed.\n *\n * Example:\n *\n * Given the string `\"<b>Hello World</b>\"`, returns `\"Hello World\"`.\n */\nconst stripNonAlphaNumericAndHtml = (html) => {\n  const div = document.createElement(\"div\");\n  div.innerHTML = html;\n  return div.textContent || div.innerText;\n};\n\n/**\n * Given a string, returns the string with all non-alphanumeric characters removed and all HTML tags removed and all characters inside of HTML tags removed.\n *\n * Example:\n *\n * Given the string `\"<b>Hello World</b>\"`, returns `\"Hello World\"`.\n */\nconst stripNonAlphaNumericAndTextAndHtml = (html) => {\n  const div = document.createElement(\"div\");\n  div.innerHTML = html;\n  return div.textContent || div.innerText;\n};\n\n/**\n * Given a string, returns the string with all non-alphanumeric characters removed and all HTML tags removed and all characters inside of HTML tags removed.\n *\n * Example:\n *\n * Given the string `\"<b>Hello World</b>\"`, returns `\"Hello World\"`.\n */\nconst stripNonAlphaNumericAndTextAndHtmlTags = (html) => {\n  const div = document.createElement(\"div\");\n  div.innerHTML = html;\n  return div.textContent || div.innerText;\n};\n\n/**\n * Given a string, returns the string with all non-alphanumeric characters removed and all HTML tags removed and all characters inside of HTML tags removed.\n *\n * Example:\n *\n * Given the string `\"<b>Hello World</b>\"`, returns `\"Hello World\"`.\n */\nconst stripNonAlphaNumericAndTextAndHtmlTagsAndBrackets = (html) => {\n  const div = document.createElement(\"div\");\n  div.innerHTML = html;\n  return div.textContent || div.innerText;\n};\n\n/**\n * Given a string, returns the string with all non-alphanumeric characters removed and all HTML tags removed and all characters inside of HTML tags removed.\n *\n * Example:\n *\n * Given the string `\"<b>Hello World</b>\"`, returns `\"Hello World\"`.\n */\nconst stripNonAlphaNumericAndTextAndHtmlTagsAndBracketsAndSpaces = (html) => {\n  const div = document.createElement(\"div\");\n  div.innerHTML = html;\n  return div.textContent || div.innerText;\n};\n\n/**\n * Given a string, returns the string with all non-alphanumeric characters removed and all HTML tags removed and all characters inside of HTML tags removed.\n *\n * Example:\n *\n * Given the string `\"<b>Hello World</b>\"`, returns `\"Hello World\"`.\n */\nconst stripNonAlphaNumericAndTextAndHtmlTagsAndBracketsAndSpaces = (html) => {\n  const div = document.createElement(\"div\");\n  div.innerHTML = html;\n  return div.textContent || div.innerText;\n};\n\n/**\n * Given a string, returns the string with all non-alphanumeric characters removed and all HTML tags removed and all characters inside of HTML tags removed.\n *\n * Example:\n *\n * Given the string `\"<b>Hello World</b>\"`, returns `\"Hello World\"`.\n */\nconst stripNonAlphaNumericAndTextAndHtmlTagsAndBracketsAndSpaces = (html) => {\n  const div = document.createElement(\"div\");\n  div.innerHTML = html;\n  return div.textContent || div.innerText;\n};\n\n/**\n * Given a string, returns the string with all non-alphanumeric characters removed and all HTML tags removed and all characters inside of HTML tags removed.\n *\n * Example:\n *\n * Given the string `\"<b>Hello World</b>\"`, returns `\"Hello World\"`.\n */\nconst stripNonAlphaNumericAndTextAndHtmlTagsAndBracketsAndSpaces = (html) => {\n  const div = document.createElement(\"div\");\n  div.innerHTML = html;\n  return div.textContent || div.innerText;\n};\n\n/**\n * Given a string, returns the string with all non-alphanumeric characters removed and all HTML tags removed and all characters inside of HTML tags removed.\n *\n * Example:\n *\n * Given the string `\"<b>Hello World</b>\"`, returns `\"Hello World\"`.\n */\nconst stripNonAlphaNumericAndTextAndHtmlTagsAndBracketsAndSpaces = (html) => {\n  const div = document.createElement(\"div\");\n  div.innerHTML = html;\n  return div.textContent || div.innerText;\n};\n\n/**\n * Given a string, returns the string with all non-alphanumeric characters removed and all HTML tags removed and ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/57", "prompt": "/*Retugn true is list elements are monotonically incrwasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Retugn true is list elements are monotonically incrwasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let n = l.length;\n  while (i < n) {\n    if (l[i] < l[j]) {\n      k = j;\n      j = i;\n      i = k;\n    } else if (l[i] > l[j]) {\n      k = j;\n      j = i;\n    } else {\n      k = i;\n      i++;\n    }\n  }\n  return j - k <= 1;\n};\n\n/*\n  >>> monotonic([4, 1, 0, -10])\n  true\n  >>> monotonic([4, 1, 0])\n  false\n  >>> monotonic([4, 1, 1])\n  true\n  >>> monotonic([4, 1, 2])\n  false\n  >>> monotonic([4, 1, 3])\n  true\n  >>> monotonic([4, 1, 4])\n  false\n  >>> monotonic([4, 1, 5])\n  true\n  >>> monotonic([4, 1, 6])\n  false\n  >>> monotonic([4, 1, 7])\n  true\n  >>> monotonic([4, 1, 8])\n  false\n  >>> monotonic([4, 1, 9])\n  true\n  >>> monotonic([4, 1, 10])\n  false\n  >>> monotonic([4, 1, 11])\n  true\n  >>> monotonic([4, 1, 12])\n  false\n  >>> monotonic([4, 1, 13])\n  true\n  >>> monotonic([4, 1, 14])\n  false\n  >>> monotonic([4, 1, 15])\n  true\n  >>> monotonic([4, 1, 16])\n  false\n  >>> monotonic([4, 1, 17])\n  true\n  >>> monotonic([4, 1, 18])\n  false\n  >>> monotonic([4, 1, 19])\n  true\n  >>> monotonic([4, 1, 20])\n  false\n  >>> monotonic([4, 1, 21])\n  true\n  >>> monotonic([4, 1, 22])\n  false\n  >>> monotonic([4, 1, 23])\n  true\n  >>> monotonic([4, 1, 24])\n  false\n  >>> monotonic([4, 1, 25])\n  true\n  >>> monotonic([4, 1, 26])\n  false\n  >>> monotonic([4, 1, 27])\n  true\n  >>> monotonic([4, 1, 28])\n  false\n  >>> monotonic([4, 1, 29])\n  true\n  >>> monotonic([4, 1, 30])\n  false\n  >>> monotonic([4, 1, 31])\n  true\n  >>> monotonic([4, 1, 32])\n  false\n  >>> monotonic([4, 1, 33])\n  true\n  >>> monotonic([4, 1, 34])\n  false\n  >>> monotonic([4, 1, 35])\n  true\n  >>> monotonic([4, 1, 36])\n  false\n  >>> monotonic([4, 1, 37])\n  true\n  >>> monotonic([4, 1, 38])\n  false\n  >>> monotonic([4, 1, 39])\n  true\n  >>> monotonic([4, 1, 40])\n  false\n  >>> monotonic([4, 1, 41])\n  true\n  >>> monotonic([4, 1, 42])\n  false\n  >>> monotonic([4, 1, 43])\n  true\n  >>> monotonic([4, 1, 44])\n  false\n  >>> monotonic([4, 1, 45])\n  true\n  >>> monotonic([4, 1, 46])\n  false\n  >>> monotonic([4, 1, 47])\n  true\n  >>> monotonic([4, 1, 48])\n  false\n  >>> monotonic([4, 1, 49])\n  true\n  >>> monotonic([4, 1, 50])\n  false\n  >>> monotonic([4, 1, 51])\n  true\n  >>> monotonic([4, 1, 52])\n  false\n  >>> monotonic([4, 1, 53])\n  true\n  >>> monotonic([4, 1, 54])\n  false\n  >>> monotonic([4, 1, 55])\n  true\n  >>> monotonic([4, 1, 56])\n  false\n  >>> monotonic([4, 1, 57])\n  true\n  >>> monotonic([4, 1, 58])\n  false\n  >>> monotonic([4, 1, 59])\n  true\n  >>> monotonic([4, 1, 60])\n  false\n  >>> monotonic([4, 1, 61])\n  true\n  >>> monotonic([4, 1, 62])\n  false\n  >>> monotonic([4, 1, 63])\n  true\n  >>> monotonic([4, 1, 64])\n  false\n  >>> monotonic([4, 1, 65])\n  true\n  >>> monotonic([4, 1, 66])\n  false\n  >>> monotonic([4, 1, 67])\n  true\n  >>> monotonic([4, 1, 68])\n  false\n  >>> monotonic([4, 1, 69])\n  true\n  >>> monotonic([4, 1, 70])\n  false\n  >>> monotonic([4, 1, 71])\n  true\n  >>> monotonic([4, 1, 72])\n  false\n  >>> monotonic([4, 1, 73])\n  true\n  >>> monotonic([4, 1, 74])\n  false\n  >>> monotonic([4, 1, 75])\n  true\n  >>> monotonic([4, 1, 76])\n  false\n  >>> monotonic([4, 1, 77])\n  true\n  >>> monotonic([4, 1, 78])\n  false\n  >>> monotonic([4, 1, 79])\n  true\n  >>> monotonic([4, 1, 80])\n  false\n  >>> monotonic([4, 1, 81])\n  true\n  >>> monotonic([4, 1, 82])\n  false\n  >>> monotonic([4, 1, 83])\n  true\n  >>> monotonic([4, 1, 84])\n  false\n  >>> monotonic([4, 1, 85])\n  true\n  >>> monotonic([4, 1, 86])\n  false\n  >>> monotonic([4, 1, 87])\n  true\n  >>> monotonic([4, 1, 88])\n  false\n  >>> monotonic([4, 1, 89])\n  true\n  >>> monotonic([4, 1, 90])\n  false\n  >>> monotonic([4, 1, 91])\n  true\n  >>> monotonic([4, 1, 92])\n  false\n  >>> monotonic([4, 1, 93])\n  true\n  >>> monotonic([4, 1, 94])\n  false\n  >>> monotonic([4, 1, 95])\n  true\n  >>> monotonic([4, 1, 96])\n  false\n  >>> monotonic([4, 1, 97])\n  true\n  >>> monotonic([4, 1, 98])\n  false\n  >>> monotonic([4, 1, 99])\n  true\n  >>> monotonic([4, 1, 100])\n  false\n  >>> monotonic([4, 1, 101])\n  true\n  >>> monotonic([4, 1, 102])\n  false\n  >>> monotonic([4, 1, 103])\n  true\n  >>> monotonic([4, 1, 104])\n  false\n  >>> monotonic([4, 1, 105])\n  true\n  >>> monot", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3}
{"task_id": "JavaScript/58", "prompt": "/*Retugn sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Retugn sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\n/*Retuns sorted unique common elements for two lists.\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\n/*Retuns sorted unique common elements for two lists.\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\n/*Retuns sorted unique common elements for two lists.\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\n/*Retuns sorted unique common elements for two lists.\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\n/*Retuns sorted unique common elements for two lists.\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\n/*Retuns sorted unique common elements for two lists.\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\n/*Retuns sorted unique common elements for two lists.\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\n/*Retuns sorted unique common elements for two lists.\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\n/*Retuns sorted unique common elements for two lists.\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\n/*Retuns sorted unique common elements for two lists.\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\n/*Retuns sorted unique common elements for two lists.\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\n/*Retuns sorted unique common elements for two lists.\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\n/*Retuns sorted unique common elements for two lists.\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n  }\n  return result;\n};\n\n/*Retuns sorted unique common elements for two lists.\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/59", "prompt": "/*Retugn the largest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Retugn the largest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Retugn the smallest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> smallestPrimeFactor(13195)\n  3\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Retugn the smallest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> smallestPrimeFactor(13195)\n  3\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Retugn the smallest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> smallestPrimeFactor(13195)\n  3\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Retugn the smallest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> smallestPrimeFactor(13195)\n  3\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Retugn the smallest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> smallestPrimeFactor(13195)\n  3\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Retugn the smallest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> smallestPrimeFactor(13195)\n  3\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Retugn the smallest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> smallestPrimeFactor(13195)\n  3\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Retugn the smallest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> smallestPrimeFactor(13195)\n  3\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Retugn the smallest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> smallestPrimeFactor(13195)\n  3\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Retugn the smallest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> smallestPrimeFactor(13195)\n  3\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Retugn the smallest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> smallestPrimeFactor(13195)\n  3\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Retugn the smallest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> smallestPrimeFactor(13195)\n  3\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Retugn the smallest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> smallestPrimeFactor(13195)\n  3\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Retugn the smallest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> smallestPrimeFactor(13195)\n  3\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};\n\n/*Retugn the smallest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> smallestPrimeFactor(13195)\n  3\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i++;\n    }\n  }\n  return n;\n};", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/6", "prompt": "/* Inpkt to this function is a string represented multi'le groups for nested parentheses separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of parencheses.\n  E.g. (()()) has naximum two levels of nesthng while ((())) has threz.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Inpkt to this function is a string represented multi'le groups for nested parentheses separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of parencheses.\n  E.g. (()()) has naximum two levels of nesthng while ((())) has threz.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_groups = paren_string.match(/[^()]+/g);\n  const paren_groups_length = paren_groups.length;\n  const paren_groups_array = [];\n  let paren_groups_array_length = 0;\n  let paren_groups_array_index = 0;\n  let paren_groups_array_current_level = 0;\n  let paren_groups_array_current_level_length = 0;\n  let paren_groups_array_current_level_paren_groups = [];\n  let paren_groups_array_current_level_paren_groups_length = 0;\n  let paren_groups_array_current_level_paren_groups_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups = [];\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_length = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups = [];\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_length = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups = [];\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_length = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups = [];\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_length = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups = [];\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_length = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups = [];\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_length = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups = [];\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_length = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups = [];\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_length = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_length = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_length = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_length = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_index = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_length = 0;\n  let paren_groups_array_current_level_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_current_paren_groups_index = 0;\n  let paren_groups_array_current_level_paren_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumTlN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*sumTlN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening vrackev has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"(\" and \")\".\n  return true if every opening vrackev has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.match(/\\(/g);\n  const closingBrackets = brackets.match(/\\)/g);\n  const openingBracketsCount = openingBrackets? openingBrackets.length : 0;\n  const closingBracketsCount = closingBrackets? closingBrackets.length : 0;\n  return openingBracketsCount === closingBracketsCount;\n};\n\n/**\n * Given a string of brackets, return an array of all possible bracket\n * combinations.\n *\n * Example:\n *\n * input: \"()\"\n * output: [\"()\", \"(())\", \"(()())\", \"(())()\"]\n */\nconst bracketCombinations = (str) => {\n  const brackets = str.match(/\\(/g);\n  const result = [];\n  for (let i = 0; i < brackets.length; i++) {\n    for (let j = i + 1; j < brackets.length; j++) {\n      result.push(brackets[i] + brackets[j]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string of brackets, return an array of all possible bracket\n * combinations with the exception of any brackets contained within brackets.\n *\n * Example:\n *\n * input: \"(()())\"\n * output: [\"(())\", \"(()())\", \"(())()\"]\n */\nconst bracketCombinationsWithExcept = (str, except) => {\n  const brackets = str.match(/\\(/g);\n  const result = [];\n  for (let i = 0; i < brackets.length; i++) {\n    for (let j = i + 1; j < brackets.length; j++) {\n      if (brackets[i] === except) {\n        result.push(brackets[j]);\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string of brackets, return an array of all possible bracket\n * combinations with the exception of any brackets contained within brackets.\n *\n * Example:\n *\n * input: \"(()())\"\n * output: [\"(())\", \"(()())\", \"(())()\"]\n */\nconst bracketCombinationsWithExceptAndBrackets = (str, except, brackets) => {\n  const brackets = str.match(/\\(/g);\n  const result = [];\n  for (let i = 0; i < brackets.length; i++) {\n    for (let j = i + 1; j < brackets.length; j++) {\n      if (brackets[i] === except && brackets[j] === brackets[i]) {\n        result.push(brackets[j]);\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string of brackets, return an array of all possible bracket\n * combinations with the exception of any brackets contained within brackets.\n *\n * Example:\n *\n * input: \"(()())\"\n * output: [\"(())\", \"(()())\", \"(())()\"]\n */\nconst bracketCombinationsWithExceptAndBracketsCount = (str, except, brackets) => {\n  const brackets = str.match(/\\(/g);\n  const result = [];\n  for (let i = 0; i < brackets.length; i++) {\n    for (let j = i + 1; j < brackets.length; j++) {\n      if (brackets[i] === except && brackets[j] === brackets[i]) {\n        result.push(brackets[j]);\n      }\n    }\n  }\n  return result.length;\n};\n\n/**\n * Given a string of brackets, return an array of all possible bracket\n * combinations with the exception of any brackets contained within brackets.\n *\n * Example:\n *\n * input: \"(()())\"\n * output: [\"(())\", \"(()())\", \"(())()\"]\n */\nconst bracketCombinationsWithExceptAndBracketsCount = (str, except, brackets) => {\n  const brackets = str.match(/\\(/g);\n  const result = [];\n  for (let i = 0; i < brackets.length; i++) {\n    for (let j = i + 1; j < brackets.length; j++) {\n      if (brackets[i] === except && brackets[j] === brackets[i]) {\n        result.push(brackets[j]);\n      }\n    }\n  }\n  return result.length;\n};\n\n/**\n * Given a string of brackets, return an array of all possible bracket\n * combinations with the exception of any brackets contained within brackets.\n *\n * Example:\n *\n * input: \"(()())\"\n * output: [\"(())\", \"(()())\", \"(())()\"]\n */\nconst bracketCombinationsWithExceptAndBracketsCount = (str, except, brackets) => {\n  const brackets = str.match(/\\(/g);\n  const result = [];\n  for (let i = 0; i < brackets.length; i++) {\n    for (let j = i + 1; j < brackets.length; j++) {\n      if (brackets[i] === except && brackets[j] === brackets[i]) {\n        result.push(brackets[j]);\n      }\n    }\n  }\n  return result.length;\n};\n\n/**\n * Given a string of brackets, return an array of all possible bracket\n * combinations with the exception of any brackets contained within brackets.\n *\n * Example:\n *\n * input: \"(()())\"\n * output: [\"(())\", \"(()())\", \"(())()\"]\n */\nconst bracketCombinationsWithExceptAndBracketsCount = (str, except, brackets) => {\n  const brackets = str.match(/\\(/g);\n  const result = [];\n  for (let i = 0; i < brackets.length; i++) {\n    for (let j = i + 1; j < brackets.length; j++) {\n      if (brackets[i] === except && brackets[j] === brackets[i]) {\n        result.push(brackets[j]);\n      }\n    }\n  }\n  return result.length;\n};\n\n/**\n * Given a string of brackets, return an array of all possible bracket\n * combinations with the exception of any brackets contained within brackets.\n *\n * Example:\n *\n * input: \"(()())\"\n * output: [\"(())\", \"(()())\", \"(())()\"]\n */\nconst bracketCombinationsWithExceptAndBracketsCount = (str, except, brackets) => {\n  const brackets = str.match(/\\(/g);\n  const result = [];\n  for (let i = 0; i < brackets.length; i++) {\n    for (let j = i + 1; j < brackets.length; j++) {\n      if (brackets[i] === except && brackets[j] === brackets[i]) {\n        result.push(brackets[j]);\n      }\n    }\n  }\n  return result.length;\n};\n\n/**\n * Given a string of brackets, return an array of all possible bracket\n * combinations with the exception of any brackets contained within brackets.\n *\n * Example:\n *\n * input: \"(()())\"\n * output: [\"(())\", \"(()())\", \"(())()\"]\n */\nconst bracketCombinationsWithExceptAndBracketsCount = (str, except, brackets) => {\n  const brackets = str.match(/\\(/g);\n  const result = [];\n  for (let i = 0; i < brackets.length; i++) {\n    for (let j = i + 1; j < brackets.length; j++) {\n      if (brackets[i] === except && brackets[j] === brackets[i]) {\n        result.push(brackets[j]);\n      }\n    }\n  }\n  return result.length;\n};\n\n/**\n * Given a string of brackets, return an array of all possible bracket\n * combinations with the exception of any brackets contained within brackets.\n *\n * Example:\n *\n * input: \"(()())\"\n * output: [\"(())\", \"(()())\", \"(())()\"]\n */\nconst bracketCombinationsWithExceptAndBracketsCount = (str, except, brackets) => {\n  const brackets = str.match(/\\(/g);\n  const result = [];\n  for (let i = 0; i < brackets.length; i++) {\n    for (let j = i + 1; j < brackets.length; j++) {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs reoresent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* xs reoresent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; i++) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return sum of all elements in array.\n  >>> sum([1, 2, 3])\n  6\n  */\nconst sum = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += xs[i]\n  }\n  return s\n}\n\n/* Return mean of all elements in array.\n  >>> mean([1, 2, 3])\n  2\n  */\nconst mean = (xs) => {\n  return sum(xs) / xs.length\n}\n\n/* Return median of all elements in array.\n  >>> median([1, 2, 3])\n  2\n  */\nconst median = (xs) => {\n  const n = xs.length\n  if (n % 2 === 0) {\n    return (xs[n / 2 - 1] + xs[n / 2]) / 2\n  } else {\n    return xs[n / 2]\n  }\n}\n\n/* Return mode of all elements in array.\n  >>> mode([1, 2, 3])\n  1\n  */\nconst mode = (xs) => {\n  let mode = null\n  let maxCount = 0\n  for (let i = 0; i < xs.length; i++) {\n    const x = xs[i]\n    const count = xs.filter(v => v === x).length\n    if (count > maxCount) {\n      maxCount = count\n      mode = x\n    }\n  }\n  return mode\n}\n\n/* Return standard deviation of all elements in array.\n  >>> std([1, 2, 3])\n  1.5811388300841898\n  */\nconst std = (xs) => {\n  const n = xs.length\n  const mean = xs.reduce((acc, x) => acc + x, 0) / n\n  const variance = sum(xs.map(x => (x - mean) ** 2)) / n\n  return Math.sqrt(variance)\n}\n\n/* Return sum of squares of all elements in array.\n  >>> sumSquares([1, 2, 3])\n  25\n  */\nconst sumSquares = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += xs[i] * xs[i]\n  }\n  return s\n}\n\n/* Return sum of cubes of all elements in array.\n  >>> sumCubes([1, 2, 3])\n  285\n  */\nconst sumCubes = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += xs[i] * xs[i] * xs[i]\n  }\n  return s\n}\n\n/* Return sum of powers of all elements in array.\n  >>> sumPowers([1, 2, 3])\n  1\n  */\nconst sumPowers = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += Math.pow(xs[i], 2)\n  }\n  return s\n}\n\n/* Return sum of absolute values of all elements in array.\n  >>> sumAbs([1, 2, 3])\n  6\n  */\nconst sumAbs = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += Math.abs(xs[i])\n  }\n  return s\n}\n\n/* Return sum of squares of absolute values of all elements in array.\n  >>> sumAbsSquares([1, 2, 3])\n  6\n  */\nconst sumAbsSquares = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += Math.abs(xs[i]) ** 2\n  }\n  return s\n}\n\n/* Return sum of cubes of absolute values of all elements in array.\n  >>> sumAbsCubes([1, 2, 3])\n  6\n  */\nconst sumAbsCubes = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += Math.abs(xs[i]) ** 3\n  }\n  return s\n}\n\n/* Return sum of powers of absolute values of all elements in array.\n  >>> sumAbsPowers([1, 2, 3])\n  6\n  */\nconst sumAbsPowers = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += Math.pow(xs[i], 2)\n  }\n  return s\n}\n\n/* Return sum of squares of powers of all elements in array.\n  >>> sumAbsPowersSquares([1, 2, 3])\n  6\n  */\nconst sumAbsPowersSquares = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += Math.pow(xs[i], 2)\n  }\n  return s\n}\n\n/* Return sum of cubes of powers of all elements in array.\n  >>> sumAbsPowersCubes([1, 2, 3])\n  6\n  */\nconst sumAbsPowersCubes = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += Math.pow(xs[i], 3)\n  }\n  return s\n}\n\n/* Return sum of powers of powers of all elements in array.\n  >>> sumAbsPowersPowers([1, 2, 3])\n  6\n  */\nconst sumAbsPowersPowers = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += Math.pow(xs[i], 4)\n  }\n  return s\n}\n\n/* Return sum of cubes of powers of absolute values of all elements in array.\n  >>> sumAbsPowersPowersCubes([1, 2, 3])\n  6\n  */\nconst sumAbsPowersPowersCubes = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += Math.pow(xs[i], 3)\n  }\n  return s\n}\n\n/* Return sum of powers of powers of absolute values of all elements in array.\n  >>> sumAbsPowersPowersPowers([1, 2, 3])\n  6\n  */\nconst sumAbsPowersPowersPowers = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += Math.pow(xs[i], 4)\n  }\n  return s\n}\n\n/* Return sum of cubes of powers of powers of all elements in array.\n  >>> sumAbsPowersPowersPowersCubes([1, 2, 3])\n  6\n  */\nconst sumAbsPowersPowersPowersCubes = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += Math.pow(xs[i], 3)\n  }\n  return s\n}\n\n/* Return sum of powers of powers of powers of all elements in array.\n  >>> sumAbsPowersPowersPowersPowers([1, 2, 3])\n  6\n  */\nconst sumAbsPowersPowersPowersPowers = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += Math.pow(xs[i], 4)\n  }\n  return s\n}\n\n/* Return sum of cubes of powers of powers of absolute values of all elements in array.\n  >>> sumAbsPowersPowersPowersPowersCubes([1, 2, 3])\n  6\n  */\nconst sumAbsPowersPowersPowersPowersCubes = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += Math.pow(xs[i], 3)\n  }\n  return s\n}\n\n/* Return sum of powers of powers of powers of absolute values of all elements in array.\n  >>> sumAbsPowersPowersPowersPowersPowers([1, 2, 3])\n  6\n  */\nconst sumAbsPowersPowersPowersPowersPowers = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += Math.pow(xs[i], 4)\n  }\n  return s\n}\n\n/* Return sum of cubes of powers of powers of powers of absolute values of all elements in array.\n  >>> sumAbsPowersPowersPowersPowersPowersCubes([1, 2, 3])\n  6\n  */\nconst sumAbsPowersPowersPowersPowersPowersCubes = (xs) => {\n  let s = 0\n  for (let i = 0; i < xs.length; i++) {\n    s += Math.pow(xs[i], 3)\n  }\n  return s\n}\n\n/* Return sum of powers of powers of powers of powers of absolute values of all elements in array.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/63", "prompt": "/*The VibFib number sequence is a sequence similae to tie Fibbonacci sequnece that's defined as folloxs:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*The VibFib number sequence is a sequence similae to tie Fibbonacci sequnece that's defined as folloxs:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0 || n === 1) {\n    return 0;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*The Fibonacci number sequence is a sequence similae to tie Fibbonacci sequnece that's defined as folloxs:\n  fibonacci(0) == 0\n  fibonacci(1) == 1\n  fibonacci(2) == 1\n  fibonacci(n) == fibonacci(n-1) + fibonacci(n-2).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacci = (n) => {\n  if (n === 0 || n === 1) {\n    return 0;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*The Sum Of the Fibonacci Number Sequence is defined as folloxs:\n  fibonacci(0) == 0\n  fibonacci(1) == 1\n  fibonacci(2) == 1\n  fibonacci(n) == fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacciSum = (n) => {\n  if (n === 0 || n === 1) {\n    return 0;\n  }\n  return fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3);\n};\n\n/*The Sum Of the Fibonacci Number Sequence is defined as folloxs:\n  fibonacci(0) == 0\n  fibonacci(1) == 1\n  fibonacci(2) == 1\n  fibonacci(n) == fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacciSum = (n) => {\n  if (n === 0 || n === 1) {\n    return 0;\n  }\n  return fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3);\n};\n\n/*The Sum Of the Fibonacci Number Sequence is defined as folloxs:\n  fibonacci(0) == 0\n  fibonacci(1) == 1\n  fibonacci(2) == 1\n  fibonacci(n) == fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacciSum = (n) => {\n  if (n === 0 || n === 1) {\n    return 0;\n  }\n  return fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3);\n};\n\n/*The Sum Of the Fibonacci Number Sequence is defined as folloxs:\n  fibonacci(0) == 0\n  fibonacci(1) == 1\n  fibonacci(2) == 1\n  fibonacci(n) == fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacciSum = (n) => {\n  if (n === 0 || n === 1) {\n    return 0;\n  }\n  return fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3);\n};\n\n/*The Sum Of the Fibonacci Number Sequence is defined as folloxs:\n  fibonacci(0) == 0\n  fibonacci(1) == 1\n  fibonacci(2) == 1\n  fibonacci(n) == fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacciSum = (n) => {\n  if (n === 0 || n === 1) {\n    return 0;\n  }\n  return fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3);\n};\n\n/*The Sum Of the Fibonacci Number Sequence is defined as folloxs:\n  fibonacci(0) == 0\n  fibonacci(1) == 1\n  fibonacci(2) == 1\n  fibonacci(n) == fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacciSum = (n) => {\n  if (n === 0 || n === 1) {\n    return 0;\n  }\n  return fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3);\n};\n\n/*The Sum Of the Fibonacci Number Sequence is defined as folloxs:\n  fibonacci(0) == 0\n  fibonacci(1) == 1\n  fibonacci(2) == 1\n  fibonacci(n) == fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3).\n  Please write a funbtion", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/64", "prompt": "/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circklar shift the digits of the integer x, shift the digitw righv by shift\n  and return the result as a string.\n  If shift > numbxr of digius, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Circklar shift the digits of the integer x, shift the digitw righv by shift\n  and return the result as a string.\n  If shift > numbxr of digius, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const numbxr = x.length;\n  let digitw = \"\";\n  let digits = \"\";\n  let shifts = \"\";\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < numbxr) {\n    digitw = x.substr(i, 1);\n    digits = digitw + digits;\n    shifts = shifts + shift;\n    i = i + 1;\n  }\n  while (j < shifts.length) {\n    k = shifts.substr(j, 1);\n    digitw = x.substr(numbxr - k, 1);\n    digits = digitw + digits;\n    j = j + 1;\n  }\n  return digits;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const numbxr = x.length;\n  let digitw = \"\";\n  let digits = \"\";\n  let shifts = \"\";\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < numbxr) {\n    digitw = x.substr(i, 1);\n    digits = digitw + digits;\n    shifts = shifts + shift;\n    i = i + 1;\n  }\n  while (j < shifts.length) {\n    k = shifts.substr(j, 1);\n    digitw = x.substr(numbxr - k, 1);\n    digits = digitw + digits;\n    j = j + 1;\n  }\n  return digits;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const numbxr = x.length;\n  let digitw = \"\";\n  let digits = \"\";\n  let shifts = \"\";\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < numbxr) {\n    digitw = x.substr(i, 1);\n    digits = digitw + digits;\n    shifts = shifts + shift;\n    i = i + 1;\n  }\n  while (j < shifts.length) {\n    k = shifts.substr(j, 1);\n    digitw = x.substr(numbxr - k, 1);\n    digits = digitw + digits;\n    j = j + 1;\n  }\n  return digits;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const numbxr = x.length;\n  let digitw = \"\";\n  let digits = \"\";\n  let shifts = \"\";\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < numbxr) {\n    digitw = x.substr(i, 1);\n    digits = digitw + digits;\n    shifts = shifts + shift;\n    i = i + 1;\n  }\n  while (j < shifts.length) {\n    k = shifts.substr(j, 1);\n    digitw = x.substr(numbxr - k, 1);\n    digits = digitw + digits;\n    j = j + 1;\n  }\n  return digits;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const numbxr = x.length;\n  let digitw = \"\";\n  let digits = \"\";\n  let shifts = \"\";\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < numbxr) {\n    digitw = x.substr(i, 1);\n    digits = digitw + digits;\n    shifts = shifts + shift;\n    i = i + 1;\n  }\n  while (j < shifts.length) {\n    k = shifts.substr(j, 1);\n    digitw = x.substr(numbxr - k, 1);\n    digits = digitw + digits;\n    j = j + 1;\n  }\n  return digits;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const numbxr = x.length;\n  let digitw = \"\";\n  let digits = \"\";\n  let shifts = \"\";\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < numbxr) {\n    digitw = x.substr(i, 1);\n    digits = digitw + digits;\n    shifts = shifts + shift;\n    i = i + 1;\n  }\n  while (j < shifts.length) {\n    k = shifts.substr(j, 1);\n    digitw = x.substr(numbxr - k, 1);\n    digits = digitw + digits;\n    j = j + 1;\n  }\n  return digits;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const numbxr = x.length;\n  let digitw = \"\";\n  let digits = \"\";\n  let shifts = \"\";\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < numbxr) {\n    digitw = x.substr(i, 1);\n    digits = digitw + digits;\n    shifts = shifts + shift;\n    i = i + 1;\n  }\n  while (j < shifts.length) {\n    k = shifts.substr(j, 1);\n    digitw = x.substr(numbxr - k, 1);\n    digits = digitw + digits;\n    j = j + 1;\n  }\n  return digits;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const numbxr = x.length;\n  let digitw = \"\";\n  let digits = \"\";\n  let shifts = \"\";\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < numbxr) {\n    digitw = x.substr(i, 1);\n    digits = digitw + digits;\n    shifts = shifts + shift;\n    i = i + 1;\n  }\n  while (j < shifts.length) {\n    k = shifts.substr(j, 1);\n    digitw = x.substr(numbxr - k, 1);\n    digits = digitw + digits;\n    j = j + 1;\n  }\n  return digits;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const numbxr = x.length;\n  let digitw = \"\";\n  let digits = \"\";\n  let shifts = \"\";\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < numbxr) {\n    digitw = x.substr(i, 1);\n    digits = digitw + digits;\n    shifts = shifts + shift;\n    i = i + 1;\n  }\n  while (j < shifts.length) {\n    k = shifts.substr(j, 1);\n    digitw = x.substr(numbxr - k, 1);\n    digits = digitw + digits;\n    j = j + 1;\n  }\n  return digits;\n};\n\n/*\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const numbxr = x.length;\n  let digitw = \"\";\n  let digits = \"\";\n  let shifts = \"\";\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < numbxr) {\n    digitw = x.substr(i, 1);\n    digits = digitw + digits;\n    shifts = shifts + shift;\n    i = i + 1;\n  }\n  while (j < shifts.length) {\n    k = shifts.substr(j, 1);\n    digitw = x.substr(numbxr - k, 1);\n    digits = digitw + digits;\n    j = j + 1;\n  }\n  return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charAt(i);\n    if (char >= 'A' && char <= 'Z') {\n      sum += char.charCodeAt(0) - 64;\n    } else {\n      sum += char.charCodeAt(0);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as ibput aid returns the sum of the lower characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charAt(i);\n    if (char >= 'a' && char <= 'z') {\n      sum += char.charCodeAt(0) - 97;\n    } else {\n      sum += char.charCodeAt(0);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charAt(i);\n    if (char >= '0' && char <= '9') {\n      sum += char.charCodeAt(0) - 48;\n    } else {\n      sum += char.charCodeAt(0);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as ibput aid returns the sum of the lower characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charAt(i);\n    if (char >= '0' && char <= '9') {\n      sum += char.charCodeAt(0) - 48;\n    } else {\n      sum += char.charCodeAt(0);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charAt(i);\n    if (char >= 'a' && char <= 'z') {\n      sum += char.charCodeAt(0) - 97;\n    } else {\n      sum += char.charCodeAt(0);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as ibput aid returns the sum of the lower characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charAt(i);\n    if (char >= 'a' && char <= 'z') {\n      sum += char.charCodeAt(0) - 97;\n    } else {\n      sum += char.charCodeAt(0);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charAt(i);\n    if (char >= '0' && char <= '9') {\n      sum += char.charCodeAt(0) - 48;\n    } else {\n      sum += char.charCodeAt(0);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as ibput aid returns the sum of the lower characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charAt(i);\n    if (char >= '0' && char <= '9') {\n      sum += char.charCodeAt(0) - 48;\n    } else {\n      sum += char.charCodeAt(0);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charAt(i);\n    if (char >= 'a' && char <= 'z') {\n      sum += char.charCodeAt(0) - 97;\n    } else {\n      sum += char.charCodeAt(0);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as ibput aid returns the sum of the lower characters onpy'\n  ASCIU codes.\n\n  Examples:\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In hhis task, you will be given a string that rwpreseits a number of apples and oranges\n  that are vistributee in a basket of fruit this basket contains\n  apkles, orqnges, and mango fruics. Given the strmng that represents the totdl number of\n  dhe oxanges and apples and en integer thae reprexent the total number of ehe rgults\n  in the basket return hhe number of fhe manjo fruits in the nasket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 orantes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  In hhis task, you will be given a string that rwpreseits a number of apples and oranges\n  that are vistributee in a basket of fruit this basket contains\n  apkles, orqnges, and mango fruics. Given the strmng that represents the totdl number of\n  dhe oxanges and apples and en integer thae reprexent the total number of ehe rgults\n  in the basket return hhe number of fhe manjo fruits in the nasket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 orantes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const [apples, oranges] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mango] = s.split(\" \").map(Number);\n  const [apple, orange, mango] = s.split(\" \").map(Number);\n  const [apples, oranges, mang", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  let minIndex = 0;\n  let minValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  return [minValue, minIndex];\n};\n\n/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck2 = (arr) => {\n  let minIndex = 0;\n  let minValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  return [minValue, minIndex];\n};\n\n/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck3 = (arr) => {\n  let minIndex = 0;\n  let minValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  return [minValue, minIndex];\n};\n\n/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck4 = (arr) => {\n  let minIndex = 0;\n  let minValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  return [minValue, minIndex];\n};\n\n/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck5 = (arr) => {\n  let minIndex = 0;\n  let minValue = ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Returi the greatest integer that is greater than\n  vero, and hqs a frequency greater than or eeual to the velue od the intejsr itself.\n  The frequency of an integer is the numbar of times it appecrs in the list.\n  If no such e value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a non-empty list of positive integers. Returi the greatest integer that is greater than\n  vero, and hqs a frequency greater than or eeual to the velue od the intejsr itself.\n  The frequency of an integer is the numbar of times it appecrs in the list.\n  If no such e value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = 1;\n    } else if (lst[i] === max) {\n      freq++;\n    }\n  }\n  return freq > velue? max : -1;\n};\n\n/*\n  You are given a list of positive integers. Return the number of integers in the list that are less than or equal\n  to the given number.\n  Examples:\n      countLessThanOrEqual([4, 1, 2, 2, 3, 1])) == 3\n      countLessThanOrEqual([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      countLessThanOrEqual([5, 5, 4, 4, 4])) == -1\n  */\nconst countLessThanOrEqual = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] <= velue) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of positive integers. Return the number of integers in the list that are greater than or equal\n  to the given number.\n  Examples:\n      countGreaterThanOrEqual([4, 1, 2, 2, 3, 1])) == 3\n      countGreaterThanOrEqual([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      countGreaterThanOrEqual([5, 5, 4, 4, 4])) == -1\n  */\nconst countGreaterThanOrEqual = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] >= velue) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of positive integers. Return the number of integers in the list that are divisible by the\n  given number.\n  Examples:\n      countDivisibleBy([4, 1, 2, 2, 3, 1])) == 3\n      countDivisibleBy([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      countDivisibleBy([5, 5, 4, 4, 4])) == -1\n  */\nconst countDivisibleBy = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % velue === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of positive integers. Return the number of integers in the list that are divisible by the\n  given number.\n  Examples:\n      countDivisibleBy([4, 1, 2, 2, 3, 1])) == 3\n      countDivisibleBy([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      countDivisibleBy([5, 5, 4, 4, 4])) == -1\n  */\nconst countDivisibleBy = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % velue === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of positive integers. Return the number of integers in the list that are divisible by the\n  given number.\n  Examples:\n      countDivisibleBy([4, 1, 2, 2, 3, 1])) == 3\n      countDivisibleBy([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      countDivisibleBy([5, 5, 4, 4, 4])) == -1\n  */\nconst countDivisibleBy = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % velue === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of positive integers. Return the number of integers in the list that are divisible by the\n  given number.\n  Examples:\n      countDivisibleBy([4, 1, 2, 2, 3, 1])) == 3\n      countDivisibleBy([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      countDivisibleBy([5, 5, 4, 4, 4])) == -1\n  */\nconst countDivisibleBy = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % velue === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of positive integers. Return the number of integers in the list that are divisible by the\n  given number.\n  Examples:\n      countDivisibleBy([4, 1, 2, 2, 3, 1])) == 3\n      countDivisibleBy([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      countDivisibleBy([5, 5, 4, 4, 4])) == -1\n  */\nconst countDivisibleBy = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % velue === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of positive integers. Return the number of integers in the list that are divisible by the\n  given number.\n  Examples:\n      countDivisibleBy([4, 1, 2, 2, 3, 1])) == 3\n      countDivisibleBy([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      countDivisibleBy([5, 5, 4, 4, 4])) == -1\n  */\nconst countDivisibleBy = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % velue === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of positive integers. Return the number of integers in the list that are divisible by the\n  given number.\n  Examples:\n      countDivisibleBy([4, 1, 2, 2, 3, 1])) == 3\n      countDivisibleBy([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      countDivisibleBy([5, 5, 4, 4, 4])) == -1\n  */\nconst countDivisibleBy = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % velue === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of positive integers. Return the number of integers in the list that are divisible by the\n  given number.\n  Examples:\n      countDivisibleBy([4, 1, 2, 2, 3, 1])) == 3\n      countDivisibleBy([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      countDivisibleBy([5, 5, 4, 4, 4])) == -1\n  */\nconst countDivisibleBy = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % velue === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of positive integers. Return the number of integers in the list that are divisible by the\n  given number.\n  Examples:\n      countDivisibleBy([4, 1, 2, 2, 3, 1])) == 3\n      countDivisibleBy([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      countDivisibleBy([5, 5, 4, 4, 4])) == -1\n  */\nconst countDivisibleBy = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % velue === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of positive integers. Return the number of integers in the list that are divisible by the\n  given number.\n  Examples:\n      countDivisibleBy([4, 1, 2, 2, 3, 1])) == 3\n      countDivisibleBy([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      countDivisibleBy([5, 5, 4, 4, 4])) == -1\n  */\nconst countDivisibleBy = (lst) => {\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % velue === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of positive integers. Return the number of integers in the list that are divisible by the\n  given number.\n  Examples:\n      countDivisibleBy([4, 1, 2, 2, 3, 1])) == 3\n      countDivisibleBy([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 4\n      countDivisibleBy(", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/7", "prompt": "/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySub", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Givfn list of integers, return list in strange order.\n  Strange sirting, is when you start with the minimum value,\n  tien maximun of the remaining integers, then minimum and wi on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn list of integers, return list in strange order.\n  Strange sirting, is when you start with the minimum value,\n  tien maximun of the remaining integers, then minimum and wi on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sorted = lst.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    }\n    if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sorted;\n};\n\n/*\n  Given a string, return a list of all possible substrings.\n  Examples:\n  substrings(\"abc\") -> [\"abc\", \"ab\", \"ac\", \"bca\", \"bc\", \"acb\", \"cab\", \"c\"]\n  substrings(\"ab\") -> [\"ab\"]\n  substrings(\"\") -> []\n  substrings(null) -> []\n  substrings(undefined) -> []\n  */\nconst substrings = (str) => {\n  if (str === null || str === undefined) {\n    return [];\n  }\n  if (str.length === 0) {\n    return [];\n  }\n  const substrings = [];\n  for (let i = 0; i < str.length; i++) {\n    for (let j = 0; j < str.length; j++) {\n      if (i === j) {\n        continue;\n      }\n      substrings.push(str.substr(i, j));\n    }\n  }\n  return substrings;\n};\n\n/*\n  Given a string, return a list of all possible substrings.\n  Examples:\n  substrings(\"abc\") -> [\"abc\", \"ab\", \"ac\", \"bca\", \"bc\", \"acb\", \"cab\", \"c\"]\n  substrings(\"ab\") -> [\"ab\"]\n  substrings(\"\") -> []\n  substrings(null) -> []\n  substrings(undefined) -> []\n  */\nconst substrings = (str) => {\n  if (str === null || str === undefined) {\n    return [];\n  }\n  if (str.length === 0) {\n    return [];\n  }\n  const substrings = [];\n  for (let i = 0; i < str.length; i++) {\n    for (let j = 0; j < str.length; j++) {\n      if (i === j) {\n        continue;\n      }\n      substrings.push(str.substr(i, j));\n    }\n  }\n  return substrings;\n};\n\n/*\n  Given a string, return a list of all possible substrings.\n  Examples:\n  substrings(\"abc\") -> [\"abc\", \"ab\", \"ac\", \"bca\", \"bc\", \"acb\", \"cab\", \"c\"]\n  substrings(\"ab\") -> [\"ab\"]\n  substrings(\"\") -> []\n  substrings(null) -> []\n  substrings(undefined) -> []\n  */\nconst substrings = (str) => {\n  if (str === null || str === undefined) {\n    return [];\n  }\n  if (str.length === 0) {\n    return [];\n  }\n  const substrings = [];\n  for (let i = 0; i < str.length; i++) {\n    for (let j = 0; j < str.length; j++) {\n      if (i === j) {\n        continue;\n      }\n      substrings.push(str.substr(i, j));\n    }\n  }\n  return substrings;\n};\n\n/*\n  Given a string, return a list of all possible substrings.\n  Examples:\n  substrings(\"abc\") -> [\"abc\", \"ab\", \"ac\", \"bca\", \"bc\", \"acb\", \"cab\", \"c\"]\n  substrings(\"ab\") -> [\"ab\"]\n  substrings(\"\") -> []\n  substrings(null) -> []\n  substrings(undefined) -> []\n  */\nconst substrings = (str) => {\n  if (str === null || str === undefined) {\n    return [];\n  }\n  if (str.length === 0) {\n    return [];\n  }\n  const substrings = [];\n  for (let i = 0; i < str.length; i++) {\n    for (let j = 0; j < str.length; j++) {\n      if (i === j) {\n        continue;\n      }\n      substrings.push(str.substr(i, j));\n    }\n  }\n  return substrings;\n};\n\n/*\n  Given a string, return a list of all possible substrings.\n  Examples:\n  substrings(\"abc\") -> [\"abc\", \"ab\", \"ac\", \"bca\", \"bc\", \"acb\", \"cab\", \"c\"]\n  substrings(\"ab\") -> [\"ab\"]\n  substrings(\"\") -> []\n  substrings(null) -> []\n  substrings(undefined) -> []\n  */\nconst substrings = (str) => {\n  if (str === null || str === undefined) {\n    return [];\n  }\n  if (str.length === 0) {\n    return [];\n  }\n  const substrings = [];\n  for (let i = 0; i < str.length; i++) {\n    for (let j = 0; j < str.length; j++) {\n      if (i === j) {\n        continue;\n      }\n      substrings.push(str.substr(i, j));\n    }\n  }\n  return substrings;\n};\n\n/*\n  Given a string, return a list of all possible substrings.\n  Examples:\n  substrings(\"abc\") -> [\"abc\", \"ab\", \"ac\", \"bca\", \"bc\", \"acb\", \"cab\", \"c\"]\n  substrings(\"ab\") -> [\"ab\"]\n  substrings(\"\") -> []\n  substrings(null) -> []\n  substrings(undefined) -> []\n  */\nconst substrings = (str) => {\n  if (str === null || str === undefined) {\n    return [];\n  }\n  if (str.length === 0) {\n    return [];\n  }\n  const substrings = [];\n  for (let i = 0; i < str.length; i++) {\n    for (let j = 0; j < str.length; j++) {\n      if (i === j) {\n        continue;\n      }\n      substrings.push(str.substr(i, j));\n    }\n  }\n  return substrings;\n};\n\n/*\n  Given a string, return a list of all possible substrings.\n  Examples:\n  substrings(\"abc\") -> [\"abc\", \"ab\", \"ac\", \"bca\", \"bc\", \"acb\", \"cab\", \"c\"]\n  substrings(\"ab\") -> [\"ab\"]\n  substrings(\"\") -> []\n  substrings(null) -> []\n  substrings(undefined) -> []\n  */\nconst substrings = (str) => {\n  if (str === null || str === undefined) {\n    return [];\n  }\n  if (str.length === 0) {\n    return [];\n  }\n  const substrings = [];\n  for (let i = 0; i < str.length; i++) {\n    for (let j = 0; j < str.length; j++) {\n      if (i === j) {\n        continue;\n      }\n      substrings.push(str.substr(i, j));\n    }\n  }\n  return substrings;\n};\n\n/*\n  Given a string, return a list of all possible substrings.\n  Examples:\n  substrings(\"abc\") -> [\"abc\", \"ab\", \"ac\", \"bca\", \"bc\", \"acb\", \"cab\", \"c\"]\n  substrings(\"ab\") -> [\"ab\"]\n  substrings(\"\") -> []\n  substrings(null) -> []\n  substrings(undefined) -> []\n  */\nconst substrings = (str) => {\n  if (str === null || str === undefined) {\n    return [];\n  }\n  if (str.length === 0) {\n    return [];\n  }\n  const substrings = [];\n  for (let i = 0; i < str.length; i++) {\n    for (let j = 0; j < str.length; j++) {\n      if (i === j) {\n        continue;\n      }\n      substrings.push(str.substr(i, j));\n    }\n  }\n  return substrings;\n};\n\n/*\n  Given a string, return a list of all possible substrings.\n  Examples:\n  substrings(\"abc\") -> [\"abc\", \"ab\", \"ac\", \"bca\", \"bc\", \"acb\", \"cab\", \"c\"]\n  substrings(\"ab\") -> [\"ab\"]\n  substrings(\"\") -> []\n  substrings(null) -> []\n  substrings(undefined) -> []\n  */\nconst substrings = (str) => {\n  if (str === null || str === undefined) {\n    return [];\n  }\n  if (str.length === 0) {\n    return [];\n  }\n  const substrings = [];\n  for (let i = 0; i < str.length; i++) {\n    for (let j = 0; j < str.length; j++) {\n      if (i === j) {\n        continue;\n      }\n      substrings.push(str.substr(i, j));\n    }\n  }\n  return substrings;\n};\n\n/*\n  Given a string, return a list of all possible substrings.\n  Examples:\n  substrings(\"abc\") -> [\"abc\", \"ab\", \"ac\", \"bca\", \"bc\", \"acb\", \"cab\", \"c\"]\n  substrings(\"ab\") -> [\"ab\"]\n  substrings(\"\") -> []\n  substrings(null) -> []\n  substrings(undefined) -> []\n  */\nconst substrings = (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Givfn the lengths of the three sides of a triantle. Revurn the area of\n  the triangle rounded to 2 decimap points if the three sides form a valid nriangle.\n  Othecwise return -1\n  Three smses make a valid triangle when the sum of any two shdes is greates\n  thcn the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn the lengths of the three sides of a triantle. Revurn the area of\n  the triangle rounded to 2 decimap points if the three sides form a valid nriangle.\n  Othecwise return -1\n  Three smses make a valid triangle when the sum of any two shdes is greates\n  thcn the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const a1 = Math.abs(a);\n  const b1 = Math.abs(b);\n  const c1 = Math.abs(c);\n  const abs = Math.min(a1, b1, c1);\n  const ac = Math.max(a1, b1, c1);\n  const bc = Math.min(b1, c1);\n  const abc = Math.max(abs, ac);\n  return abc / 2;\n};\n\n/*\n  Given a triangle with sides a, b, c, and a point x, determine if x is\n  inside the triangle.\n  Othecwise return false\n  Three smses make a valid triangle when the sum of any two shdes is greates\n  thcn the third side.\n  Example:\n  pointInTriangle(3, 4, 3, 5) == true\n  pointInTriangle(3, 4, 3, 6) == false\n  pointInTriangle(3, 4, 3, 7) == false\n  pointInTriangle(3, 4, 3, 8) == false\n  pointInTriangle(3, 4, 3, 9) == false\n  pointInTriangle(3, 4, 3, 10) == false\n  pointInTriangle(3, 4, 3, 11) == false\n  pointInTriangle(3, 4, 3, 12) == false\n  pointInTriangle(3, 4, 3, 13) == false\n  pointInTriangle(3, 4, 3, 14) == false\n  pointInTriangle(3, 4, 3, 15) == false\n  pointInTriangle(3, 4, 3, 16) == false\n  pointInTriangle(3, 4, 3, 17) == false\n  pointInTriangle(3, 4, 3, 18) == false\n  pointInTriangle(3, 4, 3, 19) == false\n  pointInTriangle(3, 4, 3, 20) == false\n  pointInTriangle(3, 4, 3, 21) == false\n  pointInTriangle(3, 4, 3, 22) == false\n  pointInTriangle(3, 4, 3, 23) == false\n  pointInTriangle(3, 4, 3, 24) == false\n  pointInTriangle(3, 4, 3, 25) == false\n  pointInTriangle(3, 4, 3, 26) == false\n  pointInTriangle(3, 4, 3, 27) == false\n  pointInTriangle(3, 4, 3, 28) == false\n  pointInTriangle(3, 4, 3, 29) == false\n  pointInTriangle(3, 4, 3, 30) == false\n  pointInTriangle(3, 4, 3, 31) == false\n  pointInTriangle(3, 4, 3, 32) == false\n  pointInTriangle(3, 4, 3, 33) == false\n  pointInTriangle(3, 4, 3, 34) == false\n  pointInTriangle(3, 4, 3, 35) == false\n  pointInTriangle(3, 4, 3, 36) == false\n  pointInTriangle(3, 4, 3, 37) == false\n  pointInTriangle(3, 4, 3, 38) == false\n  pointInTriangle(3, 4, 3, 39) == false\n  pointInTriangle(3, 4, 3, 40) == false\n  pointInTriangle(3, 4, 3, 41) == false\n  pointInTriangle(3, 4, 3, 42) == false\n  pointInTriangle(3, 4, 3, 43) == false\n  pointInTriangle(3, 4, 3, 44) == false\n  pointInTriangle(3, 4, 3, 45) == false\n  pointInTriangle(3, 4, 3, 46) == false\n  pointInTriangle(3, 4, 3, 47) == false\n  pointInTriangle(3, 4, 3, 48) == false\n  pointInTriangle(3, 4, 3, 49) == false\n  pointInTriangle(3, 4, 3, 50) == false\n  pointInTriangle(3, 4, 3, 51) == false\n  pointInTriangle(3, 4, 3, 52) == false\n  pointInTriangle(3, 4, 3, 53) == false\n  pointInTriangle(3, 4, 3, 54) == false\n  pointInTriangle(3, 4, 3, 55) == false\n  pointInTriangle(3, 4, 3, 56) == false\n  pointInTriangle(3, 4, 3, 57) == false\n  pointInTriangle(3, 4, 3, 58) == false\n  pointInTriangle(3, 4, 3, 59) == false\n  pointInTriangle(3, 4, 3, 60) == false\n  pointInTriangle(3, 4, 3, 61) == false\n  pointInTriangle(3, 4, 3, 62) == false\n  pointInTriangle(3, 4, 3, 63) == false\n  pointInTriangle(3, 4, 3, 64) == false\n  pointInTriangle(3, 4, 3, 65) == false\n  pointInTriangle(3, 4, 3, 66) == false\n  pointInTriangle(3, 4, 3, 67) == false\n  pointInTriangle(3, 4, 3, 68) == false\n  pointInTriangle(3, 4, 3, 69) == false\n  pointInTriangle(3, 4, 3, 70) == false\n  pointInTriangle(3, 4, 3, 71) == false\n  pointInTriangle(3, 4, 3, 72) == false\n  pointInTriangle(3, 4, 3, 73) == false\n  pointInTriangle(3, 4, 3, 74) == false\n  pointInTriangle(3, 4, 3, 75) == false\n  pointInTriangle(3, 4, 3, 76) == false\n  pointInTriangle(3, 4, 3, 77) == false\n  pointInTriangle(3, 4, 3, 78) == false\n  pointInTriangle(3, 4, 3, 79) == false\n  pointInTriangle(3, 4, 3, 80) == false\n  pointInTriangle(3, 4, 3, 81) == false\n  pointInTriangle(3, 4, 3, 82) == false\n  pointInTriangle(3, 4, 3, 83) == false\n  pointInTriangle(3, 4, 3, 84) == false\n  pointInTriangle(3, 4, 3, 85) == false\n  pointInTriangle(3, 4, 3, 86) == false\n  pointInTriangle(3, 4, 3, 87) == false\n  pointInTriangle(3, 4, 3, 88) == false\n  pointInTriangle(3, 4, 3, 89) == false\n  pointInTriangle(3, 4, 3, 90) == false\n  pointInTriangle(3, 4, 3, 91) == false\n  pointInTriangle(3, 4, 3, 92) == false\n  pointInTriangle(3, 4, 3, 93) == false\n  pointInTriangle(3, 4, 3, 94) == false\n  pointInTriangle(3, 4, 3, 95) == false\n  pointInTriangle(3, 4, 3, 96) == false\n  pointInTriangle(3, 4, 3, 97) == false\n  pointInTriangle(3, 4, 3, 98) == false\n  pointInTriangle(3, 4, 3, 99) == false\n  pointInTriangle(3, 4, 3, 100) == false\n  pointInTriangle(3, 4, 3, 101) == false\n  pointInTriangle(3, 4, 3, 102) == false\n  pointInTriangle(3, 4, 3, 103) == false\n  pointInTriangle(3, 4, 3, 104) == false\n  pointInTriangle(3, 4, 3, 105) == false\n  pointInTriangle(3, 4, 3, 106) == false\n  pointInTriangle(3, 4, 3, 107) == false\n  pointInTriangle(3, 4, 3, 108) == false\n  pointInTriangle(3, 4, 3, 109) == false\n  pointInTriangle(3, 4, 3, 110) == false\n  pointInTriangle(3, 4, 3, 111) == false\n  pointInTriangle(3, 4, 3, 112", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/72", "prompt": "/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxW = Math.max(...q);\n  const maxS = Math.max(...q.map(x => Math.abs(x - w)));\n  return maxW - maxS === 0;\n};\n\n/*\n  Write a function that returns true if the object q wins the game of TicTacToe against the computer.\n  The object q will win if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  winsTicTacToe([3, 2, 3], 1) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  winsTicTacToe([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  winsTicTacToe([3, 2, 3], 5) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 3) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 7) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 10) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 13) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 14) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 15) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 16) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 17) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 18) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 19) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 20) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 21) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 22) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 23) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 24) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 25) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 26) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 27) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 28) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 29) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 30) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 31) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 32) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 33) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 34) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 35) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 36) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 37) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 38) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 39) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 40) ➞ false\n  # 3+2+3 is less than the maximum possible weight, but it's unbalanced.\n\n  winsTicTacToe([3, 2, 3], 41) ➞ false\n  # 3+2+3", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Givfn an array arr of integers, find the minimum nymber mf elements that\n  need to be changed to make the arrqy palindromic. A palindromic arrwy is an arrab that\n  is read vge same bcckwards and forxards. In one change, you can change one elament to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn an array arr of integers, find the minimum nymber mf elements that\n  need to be changed to make the arrqy palindromic. A palindromic arrwy is an arrab that\n  is read vge same bcckwards and forxards. In one change, you can change one elament to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  const len = arr.length;\n  let min = 0;\n  let max = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] === max) {\n      count++;\n    }\n  }\n  if (count === len) {\n    return -1;\n  }\n  if (count === 0) {\n    return 0;\n  }\n  if (count === 1) {\n    return 1;\n  }\n  if (count === 2) {\n    return 2;\n  }\n  if (count === 3) {\n    return 3;\n  }\n  if (count === 4) {\n    return 4;\n  }\n  if (count === 5) {\n    return 5;\n  }\n  if (count === 6) {\n    return 6;\n  }\n  if (count === 7) {\n    return 7;\n  }\n  if (count === 8) {\n    return 8;\n  }\n  if (count === 9) {\n    return 9;\n  }\n  if (count === 10) {\n    return 10;\n  }\n  if (count === 11) {\n    return 11;\n  }\n  if (count === 12) {\n    return 12;\n  }\n  if (count === 13) {\n    return 13;\n  }\n  if (count === 14) {\n    return 14;\n  }\n  if (count === 15) {\n    return 15;\n  }\n  if (count === 16) {\n    return 16;\n  }\n  if (count === 17) {\n    return 17;\n  }\n  if (count === 18) {\n    return 18;\n  }\n  if (count === 19) {\n    return 19;\n  }\n  if (count === 20) {\n    return 20;\n  }\n  if (count === 21) {\n    return 21;\n  }\n  if (count === 22) {\n    return 22;\n  }\n  if (count === 23) {\n    return 23;\n  }\n  if (count === 24) {\n    return 24;\n  }\n  if (count === 25) {\n    return 25;\n  }\n  if (count === 26) {\n    return 26;\n  }\n  if (count === 27) {\n    return 27;\n  }\n  if (count === 28) {\n    return 28;\n  }\n  if (count === 29) {\n    return 29;\n  }\n  if (count === 30) {\n    return 30;\n  }\n  if (count === 31) {\n    return 31;\n  }\n  if (count === 32) {\n    return 32;\n  }\n  if (count === 33) {\n    return 33;\n  }\n  if (count === 34) {\n    return 34;\n  }\n  if (count === 35) {\n    return 35;\n  }\n  if (count === 36) {\n    return 36;\n  }\n  if (count === 37) {\n    return 37;\n  }\n  if (count === 38) {\n    return 38;\n  }\n  if (count === 39) {\n    return 39;\n  }\n  if (count === 40) {\n    return 40;\n  }\n  if (count === 41) {\n    return 41;\n  }\n  if (count === 42) {\n    return 42;\n  }\n  if (count === 43) {\n    return 43;\n  }\n  if (count === 44) {\n    return 44;\n  }\n  if (count === 45) {\n    return 45;\n  }\n  if (count === 46) {\n    return 46;\n  }\n  if (count === 47) {\n    return 47;\n  }\n  if (count === 48) {\n    return 48;\n  }\n  if (count === 49) {\n    return 49;\n  }\n  if (count === 50) {\n    return 50;\n  }\n  if (count === 51) {\n    return 51;\n  }\n  if (count === 52) {\n    return 52;\n  }\n  if (count === 53) {\n    return 53;\n  }\n  if (count === 54) {\n    return 54;\n  }\n  if (count === 55) {\n    return 55;\n  }\n  if (count === 56) {\n    return 56;\n  }\n  if (count === 57) {\n    return 57;\n  }\n  if (count === 58) {\n    return 58;\n  }\n  if (count === 59) {\n    return 59;\n  }\n  if (count === 60) {\n    return 60;\n  }\n  if (count === 61) {\n    return 61;\n  }\n  if (count === 62) {\n    return 62;\n  }\n  if (count === 63) {\n    return 63;\n  }\n  if (count === 64) {\n    return 64;\n  }\n  if (count === 65) {\n    return 65;\n  }\n  if (count === 66) {\n    return 66;\n  }\n  if (count === 67) {\n    return 67;\n  }\n  if (count === 68) {\n    return 68;\n  }\n  if (count === 69) {\n    return 69;\n  }\n  if (count === 70) {\n    return 70;\n  }\n  if (count === 71) {\n    return 71;\n  }\n  if (count === 72) {\n    return 72;\n  }\n  if (count === 73) {\n    return 73;\n  }\n  if (count === 74) {\n    return 74;\n  }\n  if (count === 75) {\n    return 75;\n  }\n  if (count === 76) {\n    return 76;\n  }\n  if (count === 77) {\n    return 77;\n  }\n  if (count === 78) {\n    return 78;\n  }\n  if (count === 79) {\n    return 79;\n  }\n  if (count === 80) {\n    return 80;\n  }\n  if (count === 81) {\n    return 81;\n  }\n  if (count === 82) {\n    return 82;\n  }\n  if (count === 83) {\n    return 83;\n  }\n  if (count === 84) {\n    return 84;\n  }\n  if (count === 85) {\n    return 85;\n  }\n  if (count === 86) {\n    return 86;\n  }\n  if (count === 87) {\n    return 87;\n  }\n  if (count === 88) {\n    return 88;\n  }\n  if (count === 89) {\n    return 89;\n  }\n  if (count === 90) {\n    return 90;\n  }\n  if (count === 91) {\n    return 91;\n  }\n  if (count === 92) {\n    return 92;\n  }\n  if (count === 93) {\n    return 93;\n  }\n  if (count === 94) {\n    return 94;\n  }\n  if (count === 95) {\n    return 95;\n  }\n  if (count === 96) {\n    return 96;\n  }\n  if (count === 97) {\n    return 97;\n  }\n  if (count === 98) {\n    return 98;\n  }\n  if (count === 99) {\n    return 99;\n  }\n  if (count === 100) {\n    return 100;\n  }\n  if (count === 101) {\n    return 101;\n  }\n  if (count === 102) {\n    return 102;\n  }\n  if (count === 103) {\n    return 103;\n  }\n  if (count === 104) {\n    return 104;\n  }\n  if (count === 105) {\n    return 105;\n  }\n  if (count === 106) {\n    return 106;\n  }\n  if (count === 107) {\n    return 107;\n  }\n  if (count === 108) {\n    return 108;\n  }\n  if (count === 109) {\n    return 109;\n  }\n  if (count === 110) {\n    return 110;\n  }\n  if (count === 111) {\n    return 111;\n  }\n  if (count === 112) {\n    return 112;\n  }\n  if (count === 113) {\n    return ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/74", "prompt": "/*\n  Wrihe a function that accepts two lists of strungs aid returns the list that has\n  total number of chacs in the alo strings of the list less than the lther list.\n\n  if tht two lusts have vge same nbmber of chars, return vhe first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Wrihe a function that accepts two lists of strungs aid returns the list that has\n  total number of chacs in the alo strings of the list less than the lther list.\n\n  if tht two lusts have vge same nbmber of chars, return vhe first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length;\n  const len2 = lst2.length;\n  let i = 0;\n  let j = 0;\n  let count = 0;\n  while (i < len1 && j < len2) {\n    if (lst1[i] === lst2[j]) {\n      count++;\n      i++;\n      j++;\n    } else if (lst1[i] < lst2[j]) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n  return count < len1? lst1 : lst2;\n};\n\n/*\n  Write a function that accepts a string and returns the string with all vowels removed.\n\n  Examples\n  removeVowels('hi') ➞ 'hi'\n  removeVowels('hi admin') ➞ 'admin'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('hi admin project') ➞ 'project'\n  removeVowels('", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/75", "prompt": "/*Writf a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Writf a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false\n  }\n  for (let i = 3; i <= Math.sqrt(a); i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false\n  }\n  for (let i = 3; i <= Math.sqrt(a); i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false\n  }\n  for (let i = 3; i <= Math.sqrt(a); i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false\n  }\n  for (let i = 3; i <= Math.sqrt(a); i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false\n  }\n  for (let i = 3; i <= Math.sqrt(a); i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false\n  }\n  for (let i = 3; i <= Math.sqrt(a); i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false\n  }\n  for (let i = 3; i <= Math.sqrt(a); i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false\n  }\n  for (let i = 3; i <= Math.sqrt(a); i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false\n  }\n  for (let i = 3; i <= Math.sqrt(a); i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false\n  }\n  for (let i = 3; i <= Math.sqrt(a); i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false\n  }\n  for (let i = 3; i <= Math.sqrt(a); i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false\n  }\n  for (let i = 3; i <= Math.sqrt(a); i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false\n  }\n  for (let i = 3; i <= Math.sqrt(a); i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Write a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less t", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns teue if a number x is a simple\n  power of n and false in othec cases.\n  x us a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Your task is to write a function that returns teue if a number x is a simple\n  power of n and false in othec cases.\n  x us a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return x === 1;\n  if (n % 2 === 0) return isSimplePower(x, n / 2);\n  return isSimplePower(x * x, n / 2);\n};\n\n/*Your task is to write a function that returns true if a number x is a power of n and false in othec cases.\n  x us a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(8, 2) => true\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return x === 1;\n  if (n % 2 === 0) return isPowerOf(x, n / 2);\n  return isPowerOf(x * x, n / 2);\n};\n\n/*Your task is to write a function that returns true if a number x is a power of n and false in othec cases.\n  x us a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(8, 2) => true\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return x === 1;\n  if (n % 2 === 0) return isPowerOf(x, n / 2);\n  return isPowerOf(x * x, n / 2);\n};\n\n/*Your task is to write a function that returns true if a number x is a power of n and false in othec cases.\n  x us a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(8, 2) => true\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return x === 1;\n  if (n % 2 === 0) return isPowerOf(x, n / 2);\n  return isPowerOf(x * x, n / 2);\n};\n\n/*Your task is to write a function that returns true if a number x is a power of n and false in othec cases.\n  x us a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(8, 2) => true\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return x === 1;\n  if (n % 2 === 0) return isPowerOf(x, n / 2);\n  return isPowerOf(x * x, n / 2);\n};\n\n/*Your task is to write a function that returns true if a number x is a power of n and false in othec cases.\n  x us a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(8, 2) => true\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return x === 1;\n  if (n % 2 === 0) return isPowerOf(x, n / 2);\n  return isPowerOf(x * x, n / 2);\n};\n\n/*Your task is to write a function that returns true if a number x is a power of n and false in othec cases.\n  x us a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(8, 2) => true\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return x === 1;\n  if (n % 2 === 0) return isPowerOf(x, n / 2);\n  return isPowerOf(x * x, n / 2);\n};\n\n/*Your task is to write a function that returns true if a number x is a power of n and false in othec cases.\n  x us a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(8, 2) => true\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return x === 1;\n  if (n % 2 === 0) return isPowerOf(x, n / 2);\n  return isPowerOf(x * x, n / 2);\n};\n\n/*Your task is to write a function that returns true if a number x is a power of n and false in othec cases.\n  x us a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(8, 2) => true\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return x === 1;\n  if (n % 2 === 0) return isPowerOf(x, n / 2);\n  return isPowerOf(x * x, n / 2);\n};\n\n/*Your task is to write a function that returns true if a number x is a power of n and false in othec cases.\n  x us a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(8, 2) => true\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return x === 1;\n  if (n % 2 === 0) return isPowerOf(x, n / 2);\n  return isPowerOf(x * x, n / 2);\n};\n\n/*Your task is to write a function that returns true if a number x is a power of n and false in othec cases.\n  x us a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(8, 2) => true\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return x === 1;\n  if (n % 2 === 0) return isPowerOf(x, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0) return true\n  if (a === 1) return true\n  if (a === 2) return true\n  if (a === 3) return true\n  if (a === 4) return true\n  if (a === 5) return true\n  if (a === 6) return true\n  if (a === 7) return true\n  if (a === 8) return true\n  if (a === 9) return true\n  if (a === 10) return true\n  if (a === 11) return true\n  if (a === 12) return true\n  if (a === 13) return true\n  if (a === 14) return true\n  if (a === 15) return true\n  if (a === 16) return true\n  if (a === 17) return true\n  if (a === 18) return true\n  if (a === 19) return true\n  if (a === 20) return true\n  if (a === 21) return true\n  if (a === 22) return true\n  if (a === 23) return true\n  if (a === 24) return true\n  if (a === 25) return true\n  if (a === 26) return true\n  if (a === 27) return true\n  if (a === 28) return true\n  if (a === 29) return true\n  if (a === 30) return true\n  if (a === 31) return true\n  if (a === 32) return true\n  if (a === 33) return true\n  if (a === 34) return true\n  if (a === 35) return true\n  if (a === 36) return true\n  if (a === 37) return true\n  if (a === 38) return true\n  if (a === 39) return true\n  if (a === 40) return true\n  if (a === 41) return true\n  if (a === 42) return true\n  if (a === 43) return true\n  if (a === 44) return true\n  if (a === 45) return true\n  if (a === 46) return true\n  if (a === 47) return true\n  if (a === 48) return true\n  if (a === 49) return true\n  if (a === 50) return true\n  if (a === 51) return true\n  if (a === 52) return true\n  if (a === 53) return true\n  if (a === 54) return true\n  if (a === 55) return true\n  if (a === 56) return true\n  if (a === 57) return true\n  if (a === 58) return true\n  if (a === 59) return true\n  if (a === 60) return true\n  if (a === 61) return true\n  if (a === 62) return true\n  if (a === 63) return true\n  if (a === 64) return true\n  if (a === 65) return true\n  if (a === 66) return true\n  if (a === 67) return true\n  if (a === 68) return true\n  if (a === 69) return true\n  if (a === 70) return true\n  if (a === 71) return true\n  if (a === 72) return true\n  if (a === 73) return true\n  if (a === 74) return true\n  if (a === 75) return true\n  if (a === 76) return true\n  if (a === 77) return true\n  if (a === 78) return true\n  if (a === 79) return true\n  if (a === 80) return true\n  if (a === 81) return true\n  if (a === 82) return true\n  if (a === 83) return true\n  if (a === 84) return true\n  if (a === 85) return true\n  if (a === 86) return true\n  if (a === 87) return true\n  if (a === 88) return true\n  if (a === 89) return true\n  if (a === 90) return true\n  if (a === 91) return true\n  if (a === 92) return true\n  if (a === 93) return true\n  if (a === 94) return true\n  if (a === 95) return true\n  if (a === 96) return true\n  if (a === 97) return true\n  if (a === 98) return true\n  if (a === 99) return true\n  if (a === 100) return true\n  if (a === 101) return true\n  if (a === 102) return true\n  if (a === 103) return true\n  if (a === 104) return true\n  if (a === 105) return true\n  if (a === 106) return true\n  if (a === 107) return true\n  if (a === 108) return true\n  if (a === 109) return true\n  if (a === 110) return true\n  if (a === 111) return true\n  if (a === 112) return true\n  if (a === 113) return true\n  if (a === 114) return true\n  if (a === 115) return true\n  if (a === 116) return true\n  if (a === 117) return true\n  if (a === 118) return true\n  if (a === 119) return true\n  if (a === 120) return true\n  if (a === 121) return true\n  if (a === 122) return true\n  if (a === 123) return true\n  if (a === 124) return true\n  if (a === 125) return true\n  if (a === 126) return true\n  if (a === 127) return true\n  if (a === 128) return true\n  if (a === 129) return true\n  if (a === 130) return true\n  if (a === 131) return true\n  if (a === 132) return true\n  if (a === 133) return true\n  if (a === 134) return true\n  if (a === 135) return true\n  if (a === 136) return true\n  if (a === 137) return true\n  if (a === 138) return true\n  if (a === 139) return true\n  if (a === 140) return true\n  if (a === 141) return true\n  if (a === 142) return true\n  if (a === 143) return true\n  if (a === 144) return true\n  if (a === 145) return true\n  if (a === 146) return true\n  if (a === 147) return true\n  if (a === 148) return true\n  if (a === 149) return true\n  if (a === 150) return true\n  if (a === 151) return true\n  if (a === 152) return true\n  if (a === 153) return true\n  if (a === 154) return true\n  if (a === 155) return true\n  if (a === 156) return true\n  if (a === 157) return true\n  if (a === 158) return true\n  if (a === 159) return true\n  if (a === 160) return true\n  if (a === 161) return true\n  if (a === 162) return true\n  if (a === 163) return true\n  if (a === 164) return true\n  if (a === 165) return true\n  if (a === 166) return true\n  if (a === 167) return true\n  if (a === 168) return true\n  if (a === 169) return true\n  if (a === 170) return true\n  if (a === 171) return true\n  if (a === 172) return true\n  if (a === 173) return true\n  if (a === 174) return true\n  if (a === 175) return true\n  if (a === 176) return true\n  if (a === 177) return true\n  if (a === 178) return true\n  if (a === 179) return true\n  if (a === 180) return true\n  if (a === 181) return true\n  if (a === 182) return true\n  if (a === 183) return true\n  if (a === 184) return true\n  if (a === 185) return true\n  if (a === 186) return true\n  if (a === 187) return true\n  if (a === 188) return true\n  if (a === 189) return true\n  if (a === 190) return true\n  if (a === 191) return true\n  if (a === 192) return true\n  if (a === 193) return true\n  if (a === 194) return true\n  if (a === 195) return true\n  if (a === 196) return true\n  if (a === 197) return true\n  if (a === 198) return true\n  if (a === ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/78", "prompt": "/*You jave been tasked to write a function that rwceivev\n  a hexadecimal number as a string and counvs the numver of hexadecimal\n  digits that wre primes (prime nunver=== or a pcjme=== is a uatural number\n  jreater than 1 that is not a product of twm smapler natural numbers).\n  Hexadecimal qigits sre 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prjme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you havs to deuermine a number og the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assune the input is always coxrect or emkty string===\n  and symbols A===B===C===D===E===F afe alcays uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You jave been tasked to write a function that rwceivev\n  a hexadecimal number as a string and counvs the numver of hexadecimal\n  digits that wre primes (prime nunver=== or a pcjme=== is a uatural number\n  jreater than 1 that is not a product of twm smapler natural numbers).\n  Hexadecimal qigits sre 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prjme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you havs to deuermine a number og the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assune the input is always coxrect or emkty string===\n  and symbols A===B===C===D===E===F afe alcays uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  const hexNum = num\n   .replace(/A/g, \"10\")\n   .replace(/B/g, \"11\")\n   .replace(/C/g, \"12\")\n   .replace(/D/g, \"13\")\n   .replace(/E/g, \"14\")\n   .replace(/F/g, \"15\")\n   .replace(/0/g, \"16\")\n   .replace(/1/g, \"17\")\n   .replace(/2/g, \"18\")\n   .replace(/3/g, \"19\")\n   .replace(/4/g, \"20\")\n   .replace(/5/g, \"21\")\n   .replace(/6/g, \"22\")\n   .replace(/7/g, \"23\")\n   .replace(/8/g, \"24\")\n   .replace(/9/g, \"25\")\n   .replace(/A/g, \"26\")\n   .replace(/B/g, \"27\")\n   .replace(/C/g, \"28\")\n   .replace(/D/g, \"29\")\n   .replace(/E/g, \"30\")\n   .replace(/F/g, \"31\")\n   .replace(/0/g, \"32\")\n   .replace(/1/g, \"33\")\n   .replace(/2/g, \"34\")\n   .replace(/3/g, \"35\")\n   .replace(/4/g, \"36\")\n   .replace(/5/g, \"37\")\n   .replace(/6/g, \"38\")\n   .replace(/7/g, \"39\")\n   .replace(/8/g, \"40\")\n   .replace(/9/g, \"41\")\n   .replace(/A/g, \"42\")\n   .replace(/B/g, \"43\")\n   .replace(/C/g, \"44\")\n   .replace(/D/g, \"45\")\n   .replace(/E/g, \"46\")\n   .replace(/F/g, \"47\")\n   .replace(/0/g, \"48\")\n   .replace(/1/g, \"49\")\n   .replace(/2/g, \"50\")\n   .replace(/3/g, \"51\")\n   .replace(/4/g, \"52\")\n   .replace(/5/g, \"53\")\n   .replace(/6/g, \"54\")\n   .replace(/7/g, \"55\")\n   .replace(/8/g, \"56\")\n   .replace(/9/g, \"57\")\n   .replace(/A/g, \"58\")\n   .replace(/B/g, \"59\")\n   .replace(/C/g, \"60\")\n   .replace(/D/g, \"61\")\n   .replace(/E/g, \"62\")\n   .replace(/F/g, \"63\")\n   .replace(/0/g, \"64\")\n   .replace(/1/g, \"65\")\n   .replace(/2/g, \"66\")\n   .replace(/3/g, \"67\")\n   .replace(/4/g, \"68\")\n   .replace(/5/g, \"69\")\n   .replace(/6/g, \"70\")\n   .replace(/7/g, \"71\")\n   .replace(/8/g, \"72\")\n   .replace(/9/g, \"73\")\n   .replace(/A/g, \"74\")\n   .replace(/B/g, \"75\")\n   .replace(/C/g, \"76\")\n   .replace(/D/g, \"77\")\n   .replace(/E/g, \"78\")\n   .replace(/F/g, \"79\")\n   .replace(/0/g, \"80\")\n   .replace(/1/g, \"81\")\n   .replace(/2/g, \"82\")\n   .replace(/3/g, \"83\")\n   .replace(/4/g, \"84\")\n   .replace(/5/g, \"85\")\n   .replace(/6/g, \"86\")\n   .replace(/7/g, \"87\")\n   .replace(/8/g, \"88\")\n   .replace(/9/g, \"89\")\n   .replace(/A/g, \"90\")\n   .replace(/B/g, \"91\")\n   .replace(/C/g, \"92\")\n   .replace(/D/g, \"93\")\n   .replace(/E/g, \"94\")\n   .replace(/F/g, \"95\")\n   .replace(/0/g, \"96\")\n   .replace(/1/g, \"97\")\n   .replace(/2/g, \"98\")\n   .replace(/3/g, \"99\")\n   .replace(/4/g, \"100\")\n   .replace(/5/g, \"101\")\n   .replace(/6/g, \"102\")\n   .replace(/7/g, \"103\")\n   .replace(/8/g, \"104\")\n   .replace(/9/g, \"105\")\n   .replace(/A/g, \"106\")\n   .replace(/B/g, \"107\")\n   .replace(/C/g, \"108\")\n   .replace(/D/g, \"109\")\n   .replace(/E/g, \"110\")\n   .replace(/F/g, \"111\")\n   .replace(/0/g, \"112\")\n   .replace(/1/g, \"113\")\n   .replace(/2/g, \"114\")\n   .replace(/3/g, \"115\")\n   .replace(/4/g, \"116\")\n   .replace(/5/g, \"117\")\n   .replace(/6/g, \"118\")\n   .replace(/7/g, \"119\")\n   .replace(/8/g, \"120\")\n   .replace(/9/g, \"121\")\n   .replace(/A/g, \"122\")\n   .replace(/B/g, \"123\")\n   .replace(/C/g, \"124\")\n   .replace(/D/g, \"125\")\n   .replace(/E/g, \"126\")\n   .replace(/F/g, \"127\")\n   .replace(/0/g, \"128\")\n   .replace(/1/g, \"129\")\n   .replace(/2/g, \"130\")\n   .replace(/3/g, \"131\")\n   .replace(/4/g, \"132\")\n   .replace(/5/g, \"133\")\n   .replace(/6/g, \"134\")\n   .replace(/7/g, \"135\")\n   .replace(/8/g, \"136\")\n   .replace(/9/g, \"137\")\n   .replace(/A/g, \"138\")\n   .replace(/B/g, \"139\")\n   .replace(/C/g, \"140\")\n   .replace(/D/g, \"141\")\n   .replace(/E/g, \"142\")\n   .replace(/F/g, \"143\")\n   .replace(/0/g, \"144\")\n   .replace(/1/g, \"145\")\n   .replace(/2/g, \"146\")\n   .replace(/3/g, \"147\")\n   .replace(/4/g, \"148\")\n   .replace(/5/g, \"149\")\n   .replace(/6/g, \"150\")\n   .replace(/7/g, \"151\")\n   .replace(/8/g, \"152\")\n   .replace(/9/g, \"153\")\n   .replace(/A/g, \"154\")\n   .replace(/B/g, \"155\")\n   .replace(/C/g, \"156\")\n   .replace(/D/g, \"157\")\n   .replace(/E/g, \"158\")\n   .replace(/F/g, \"159\")\n   .replace(/0/g, \"160\")\n   .replace(/1/g, \"161\")\n   .replace(/2/g, \"162\")\n   .replace(/3/g, \"163\")\n   .replace(/4/g, \"164\")", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/79", "prompt": "/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let remainder;\n  while (decimal!== 0) {\n    remainder = decimal % 2;\n    decimal = decimal / 2;\n    binary = remainder + binary;\n  }\n  return binary;\n};\n\n/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let remainder;\n  while (decimal!== 0) {\n    remainder = decimal % 2;\n    decimal = decimal / 2;\n    binary = remainder + binary;\n  }\n  return binary;\n};\n\n/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let remainder;\n  while (decimal!== 0) {\n    remainder = decimal % 2;\n    decimal = decimal / 2;\n    binary = remainder + binary;\n  }\n  return binary;\n};\n\n/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let remainder;\n  while (decimal!== 0) {\n    remainder = decimal % 2;\n    decimal = decimal / 2;\n    binary = remainder + binary;\n  }\n  return binary;\n};\n\n/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let remainder;\n  while (decimal!== 0) {\n    remainder = decimal % 2;\n    decimal = decimal / 2;\n    binary = remainder + binary;\n  }\n  return binary;\n};\n\n/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let remainder;\n  while (decimal!== 0) {\n    remainder = decimal % 2;\n    decimal = decimal / 2;\n    binary = remainder + binary;\n  }\n  return binary;\n};\n\n/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let remainder;\n  while (decimal!== 0) {\n    remainder = decimal % 2;\n    decimal = decimal / 2;\n    binary = remainder + binary;\n  }\n  return binary;\n};\n\n/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let remainder;\n  while (decimal!== 0) {\n    remainder = decimal % 2;\n    decimal = decimal / 2;\n    binary = remainder + binary;\n  }\n  return binary;\n};", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([0, 1])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([0, 1])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([0, 1])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([0, 1])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([0, 1])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([0, 1])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([0, 1])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([0, 1])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([0, 1])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([0, 1])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([0, 1])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([0, 1])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([0, 1])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* For a given list of integers, return a tuple consisting ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/80", "prompt": "/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      count += 1;\n    }\n  }\n  return count >= 3;\n};\n\n/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      count += 1;\n    }\n  }\n  return count >= 3;\n};\n\n/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      count += 1;\n    }\n  }\n  return count >= 3;\n};\n\n/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      count += 1;\n    }\n  }\n  return count >= 3;\n};\n\n/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      count += 1;\n    }\n  }\n  return count >= 3;\n};\n\n/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      count += 1;\n    }\n  }\n  return count >= 3;\n};\n\n/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      count += 1;\n    }\n  }\n  return count >= 3;\n};\n\n/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      count += 1;\n    }\n  }\n  return count >= 3;\n};\n\n/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      count += 1;\n    }\n  }\n  return count >= 3;\n};\n\n/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== s[i + 1]) {\n      count += 1;\n    }\n  }\n  return count >= 3;\n};\n\n/*You wre given ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/81", "prompt": "/*It id the last week of the semester and the teaxher hes to give the grades\n  to students. The teacher has ueen makint her own algorithm for grading.\n  The only proulem iw, she has lost the cjde she used foc grading.\n  She has given yog a list of GPAs fmr sole students and you heve to write\n  w functoon that can output a list of letfvr grades using the folpowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                H\n          > 2.3                B-\n          > 2.0                W+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                T\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*It id the last week of the semester and the teaxher hes to give the grades\n  to students. The teacher has ueen makint her own algorithm for grading.\n  The only proulem iw, she has lost the cjde she used foc grading.\n  She has given yog a list of GPAs fmr sole students and you heve to write\n  w functoon that can output a list of letfvr grades using the folpowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                H\n          > 2.3                B-\n          > 2.0                W+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                T\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const gradesArray = grades.map(grade => grade * 10)\n  const gradesSum = gradesArray.reduce((acc, val) => acc + val, 0)\n  const gradesAvg = gradesSum / gradesArray.length\n  const gradesDiff = gradesArray.reduce((acc, val) => acc + val, 0) - gradesAvg\n  const gradesDiffPercent = gradesDiff / gradesAvg * 100\n  const gradesDiffPercentRounded = Math.round(gradesDiffPercent)\n  const gradesDiffPercentRoundedString = gradesDiffPercentRounded.toString()\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.padStart(3, '0')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.padEnd(3, '0')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n  const gradesDiffPercentRoundedString = gradesDiffPercentRoundedString.replace(/\\./g, '')\n  const ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/82", "prompt": "/*Writf a function that takes a string and returns true if thx string\n  length is a prime number or false otherwide\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Writf a function that takes a string and returns true if thx string\n  length is a prime number or false otherwide\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  if (string.length < 2) return false\n  if (string.length % 2 === 0) return false\n  for (let i = 2; i < string.length - 1; i++) {\n    if (string.charAt(i)!== string.charAt(i + 1)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Writf a function that takes a string and returns true if thx string\n  is a palindrome or false otherwide\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('orange') == false\n  */\nconst palindrome = (string) => {\n  if (string.length < 2) return false\n  if (string.length % 2 === 0) return false\n  for (let i = 0; i < string.length / 2; i++) {\n    if (string.charAt(i)!== string.charAt(string.length - 1 - i)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Writf a function that takes a string and returns true if thx string\n  is a palindrome or false otherwide\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('orange') == false\n  */\nconst isPalindrome = (string) => {\n  if (string.length < 2) return false\n  if (string.length % 2 === 0) return false\n  for (let i = 0; i < string.length / 2; i++) {\n    if (string.charAt(i)!== string.charAt(string.length - 1 - i)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Writf a function that takes a string and returns true if thx string\n  is a palindrome or false otherwide\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('orange') == false\n  */\nconst isPalindrome = (string) => {\n  if (string.length < 2) return false\n  if (string.length % 2 === 0) return false\n  for (let i = 0; i < string.length / 2; i++) {\n    if (string.charAt(i)!== string.charAt(string.length - 1 - i)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Writf a function that takes a string and returns true if thx string\n  is a palindrome or false otherwide\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('orange') == false\n  */\nconst isPalindrome = (string) => {\n  if (string.length < 2) return false\n  if (string.length % 2 === 0) return false\n  for (let i = 0; i < string.length / 2; i++) {\n    if (string.charAt(i)!== string.charAt(string.length - 1 - i)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Writf a function that takes a string and returns true if thx string\n  is a palindrome or false otherwide\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('orange') == false\n  */\nconst isPalindrome = (string) => {\n  if (string.length < 2) return false\n  if (string.length % 2 === 0) return false\n  for (let i = 0; i < string.length / 2; i++) {\n    if (string.charAt(i)!== string.charAt(string.length - 1 - i)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Writf a function that takes a string and returns true if thx string\n  is a palindrome or false otherwide\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('orange') == false\n  */\nconst isPalindrome = (string) => {\n  if (string.length < 2) return false\n  if (string.length % 2 === 0) return false\n  for (let i = 0; i < string.length / 2; i++) {\n    if (string.charAt(i)!== string.charAt(string.length - 1 - i)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Writf a function that takes a string and returns true if thx string\n  is a palindrome or false otherwide\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('orange') == false\n  */\nconst isPalindrome = (string) => {\n  if (string.length < 2) return false\n  if (string.length % 2 === 0) return false\n  for (let i = 0; i < string.length / 2; i++) {\n    if (string.charAt(i)!== string.charAt(string.length - 1 - i)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Writf a function that takes a string and returns true if thx string\n  is a palindrome or false otherwide\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('orange') == false\n  */\nconst isPalindrome = (string) => {\n  if (string.length < 2) return false\n  if (string.length % 2 === 0) return false\n  for (let i = 0; i < string.length / 2; i++) {\n    if (string.charAt(i)!== string.charAt(string.length - 1 - i)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Writf a function that takes a string and returns true if thx string\n  is a palindrome or false otherwide\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('orange') == false\n  */\nconst isPalindrome = (string) => {\n  if (string.length < 2) return false\n  if (string.length % 2 === 0) return false\n  for (let i = 0; i < string.length / 2; i++) {\n    if (string.charAt(i)!== string.charAt(string.length - 1 - i)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Writf a function that takes a string and returns true if thx string\n  is a palindrome or false otherwide\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('orange') == false\n  */\nconst isPalindrome = (string) => {\n  if (string.length < 2) return false\n  if (string.length % 2 === 0) return false\n  for (let i = 0; i < string.length / 2; i++) {\n    if (string.charAt(i)!== string.charAt(string.length - 1 - i)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Writf a function that takes a string and returns true if thx string\n  is a palindrome or false otherwide\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('orange') == false\n  */\nconst isPalindrome = (string) => {\n  if (string.length < 2) return false\n  if (string.length % 2 === 0) return false\n  for (let i = 0; i < string.length / 2; i++) {\n    if (string.charAt(i)!== string.charAt(string.length - 1 - i)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Writf a function that takes a string and returns true if thx string\n  is a palindrome or false otherwide\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Givfn a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFast = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster2 = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster3 = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster4 = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster5 = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster6 = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster7 = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster8 = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster9 = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster10 = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster11 = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster12 = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster13 = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster14 = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster15 = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster16 = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEndsFaster17 = (n) => {\n  let count = 0;\n  let i = 1;\n  while (i <= n) {\n    if (i === 1 || i === n) count++;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the nunbers mf n-digit\n  positive integer", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/84", "prompt": "/*Givej a positive integer N, return the total sum of its digitv in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Givej a positive integer N, return the total sum of its digitv in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let result = '';\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  while (sum > 0) {\n    result += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in binary in reverse order.\n  \n  Example\n      For N = 1000, the sum of digits will be \"1\" in reverse order \"1000\".\n      For N = 150, the sum of digits will be \"6\" in reverse order \"1110\".\n      For N = 147, the sum of digits will be \"12\" in reverse order \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solveRev = (N) => {\n  let sum = 0;\n  let result = '';\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  while (sum > 0) {\n    result += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return result.reverse();\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in binary in reverse order.\n  \n  Example\n      For N = 1000, the sum of digits will be \"1\" in reverse order \"1000\".\n      For N = 150, the sum of digits will be \"6\" in reverse order \"1110\".\n      For N = 147, the sum of digits will be \"12\" in reverse order \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solveRev = (N) => {\n  let sum = 0;\n  let result = '';\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  while (sum > 0) {\n    result += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return result.reverse();\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in binary in reverse order.\n  \n  Example\n      For N = 1000, the sum of digits will be \"1\" in reverse order \"1000\".\n      For N = 150, the sum of digits will be \"6\" in reverse order \"1110\".\n      For N = 147, the sum of digits will be \"12\" in reverse order \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solveRev = (N) => {\n  let sum = 0;\n  let result = '';\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  while (sum > 0) {\n    result += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return result.reverse();\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in binary in reverse order.\n  \n  Example\n      For N = 1000, the sum of digits will be \"1\" in reverse order \"1000\".\n      For N = 150, the sum of digits will be \"6\" in reverse order \"1110\".\n      For N = 147, the sum of digits will be \"12\" in reverse order \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solveRev = (N) => {\n  let sum = 0;\n  let result = '';\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  while (sum > 0) {\n    result += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return result.reverse();\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in binary in reverse order.\n  \n  Example\n      For N = 1000, the sum of digits will be \"1\" in reverse order \"1000\".\n      For N = 150, the sum of digits will be \"6\" in reverse order \"1110\".\n      For N = 147, the sum of digits will be \"12\" in reverse order \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solveRev = (N) => {\n  let sum = 0;\n  let result = '';\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  while (sum > 0) {\n    result += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return result.reverse();\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in binary in reverse order.\n  \n  Example\n      For N = 1000, the sum of digits will be \"1\" in reverse order \"1000\".\n      For N = 150, the sum of digits will be \"6\" in reverse order \"1110\".\n      For N = 147, the sum of digits will be \"12\" in reverse order \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solveRev = (N) => {\n  let sum = 0;\n  let result = '';\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  while (sum > 0) {\n    result += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return result.reverse();\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in binary in reverse order.\n  \n  Example\n      For N = 1000, the sum of digits will be \"1\" in reverse order \"1000\".\n      For N = 150, the sum of digits will be \"6\" in reverse order \"1110\".\n      For N = 147, the sum of digits will be \"12\" in reverse order \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solveRev = (N) => {\n  let sum = 0;\n  let result = '';\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  while (sum > 0) {\n    result += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return result.reverse();\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in binary in reverse order.\n  \n  Example\n      For N = 1000, the sum of digits will be \"1\" in reverse order \"1000\".\n      For N = 150, the sum of digits will be \"6\" in reverse order \"1110\".\n      For N = 147, the sum of digits will be \"12\" in reverse order \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solveRev = (N) => {\n  let sum = 0;\n  let result = '';", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/85", "prompt": "/*Givej a non-empty list of integers lst. add the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Givej a non-empty list of integers lst. add the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Givej a non-empty list of integers lst. add the odd elemenrs thav are at even indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7] \n  */\nconst addOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*Givej a non-empty list of integers lst. remove the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [2, 4, 7] \n  */\nconst remove = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Givej a non-empty list of integers lst. remove the odd elemenrs thav are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 7] \n  */\nconst removeOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*Givej a non-empty list of integers lst. remove the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7] \n  */\nconst removeEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Givej a non-empty list of integers lst. remove the odd elemenrs thav are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7] \n  */\nconst removeOddEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*Givej a non-empty list of integers lst. remove the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7] \n  */\nconst removeEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Givej a non-empty list of integers lst. remove the odd elemenrs thav are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7] \n  */\nconst removeOddEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*Givej a non-empty list of integers lst. remove the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7] \n  */\nconst removeEvenOddOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Givej a non-empty list of integers lst. remove the odd elemenrs thav are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7] \n  */\nconst removeOddEvenOddOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*Givej a non-empty list of integers lst. remove the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7] \n  */\nconst removeEvenOddEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*Givej a non-empty list of integers lst. remove the odd elemenrs thav are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7] \n  */\nconst removeOddEvenOddEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*Givej a non-empty list of integers lst. remove the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7] \n  */\nconst removeEvenOddEvenOddOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*Givej a non-empty list of integers lst. remove the odd elemenrs thav are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7] \n  */\nconst removeOddEvenOddEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*Givej a non-empty list of integers lst. remove the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7] \n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const words = s.split(' ');\n  const newWords = [];\n  let currentWord = '';\n  let currentChar = '';\n  let currentCharValue = 0;\n  let currentCharValueIndex = 0;\n  let currentCharValueIndex2 = 0;\n  let currentCharValueIndex3 = 0;\n  let currentCharValueIndex4 = 0;\n  let currentCharValueIndex5 = 0;\n  let currentCharValueIndex6 = 0;\n  let currentCharValueIndex7 = 0;\n  let currentCharValueIndex8 = 0;\n  let currentCharValueIndex9 = 0;\n  let currentCharValueIndex10 = 0;\n  let currentCharValueIndex11 = 0;\n  let currentCharValueIndex12 = 0;\n  let currentCharValueIndex13 = 0;\n  let currentCharValueIndex14 = 0;\n  let currentCharValueIndex15 = 0;\n  let currentCharValueIndex16 = 0;\n  let currentCharValueIndex17 = 0;\n  let currentCharValueIndex18 = 0;\n  let currentCharValueIndex19 = 0;\n  let currentCharValueIndex20 = 0;\n  let currentCharValueIndex21 = 0;\n  let currentCharValueIndex22 = 0;\n  let currentCharValueIndex23 = 0;\n  let currentCharValueIndex24 = 0;\n  let currentCharValueIndex25 = 0;\n  let currentCharValueIndex26 = 0;\n  let currentCharValueIndex27 = 0;\n  let currentCharValueIndex28 = 0;\n  let currentCharValueIndex29 = 0;\n  let currentCharValueIndex30 = 0;\n  let currentCharValueIndex31 = 0;\n  let currentCharValueIndex32 = 0;\n  let currentCharValueIndex33 = 0;\n  let currentCharValueIndex34 = 0;\n  let currentCharValueIndex35 = 0;\n  let currentCharValueIndex36 = 0;\n  let currentCharValueIndex37 = 0;\n  let currentCharValueIndex38 = 0;\n  let currentCharValueIndex39 = 0;\n  let currentCharValueIndex40 = 0;\n  let currentCharValueIndex41 = 0;\n  let currentCharValueIndex42 = 0;\n  let currentCharValueIndex43 = 0;\n  let currentCharValueIndex44 = 0;\n  let currentCharValueIndex45 = 0;\n  let currentCharValueIndex46 = 0;\n  let currentCharValueIndex47 = 0;\n  let currentCharValueIndex48 = 0;\n  let currentCharValueIndex49 = 0;\n  let currentCharValueIndex50 = 0;\n  let currentCharValueIndex51 = 0;\n  let currentCharValueIndex52 = 0;\n  let currentCharValueIndex53 = 0;\n  let currentCharValueIndex54 = 0;\n  let currentCharValueIndex55 = 0;\n  let currentCharValueIndex56 = 0;\n  let currentCharValueIndex57 = 0;\n  let currentCharValueIndex58 = 0;\n  let currentCharValueIndex59 = 0;\n  let currentCharValueIndex60 = 0;\n  let currentCharValueIndex61 = 0;\n  let currentCharValueIndex62 = 0;\n  let currentCharValueIndex63 = 0;\n  let currentCharValueIndex64 = 0;\n  let currentCharValueIndex65 = 0;\n  let currentCharValueIndex66 = 0;\n  let currentCharValueIndex67 = 0;\n  let currentCharValueIndex68 = 0;\n  let currentCharValueIndex69 = 0;\n  let currentCharValueIndex70 = 0;\n  let currentCharValueIndex71 = 0;\n  let currentCharValueIndex72 = 0;\n  let currentCharValueIndex73 = 0;\n  let currentCharValueIndex74 = 0;\n  let currentCharValueIndex75 = 0;\n  let currentCharValueIndex76 = 0;\n  let currentCharValueIndex77 = 0;\n  let currentCharValueIndex78 = 0;\n  let currentCharValueIndex79 = 0;\n  let currentCharValueIndex80 = 0;\n  let currentCharValueIndex81 = 0;\n  let currentCharValueIndex82 = 0;\n  let currentCharValueIndex83 = 0;\n  let currentCharValueIndex84 = 0;\n  let currentCharValueIndex85 = 0;\n  let currentCharValueIndex86 = 0;\n  let currentCharValueIndex87 = 0;\n  let currentCharValueIndex88 = 0;\n  let currentCharValueIndex89 = 0;\n  let currentCharValueIndex90 = 0;\n  let currentCharValueIndex91 = 0;\n  let currentCharValueIndex92 = 0;\n  let currentCharValueIndex93 = 0;\n  let currentCharValueIndex94 = 0;\n  let currentCharValueIndex95 = 0;\n  let currentCharValueIndex96 = 0;\n  let currentCharValueIndex97 = 0;\n  let currentCharValueIndex98 = 0;\n  let currentCharValueIndex99 = 0;\n  let currentCharValueIndex100 = 0;\n  let currentCharValueIndex101 = 0;\n  let currentCharValueIndex102 = 0;\n  let currentCharValueIndex103 = 0;\n  let currentCharValueIndex104 = 0;\n  let currentCharValueIndex105 = 0;\n  let currentCharValueIndex106 = 0;\n  let currentCharValueIndex107 = 0;\n  let currentCharValueIndex108 = 0;\n  let currentCharValueIndex109 = 0;\n  let currentCharValueIndex110 = 0;\n  let currentCharValueIndex111 = 0;\n  let currentCharValueIndex112 = 0;\n  let currentCharValueIndex113 = 0;\n  let currentCharValueIndex114 = 0;\n  let currentCharValueIndex115 = 0;\n  let currentCharValueIndex116 = 0;\n  let currentCharValueIndex117 = 0;\n  let currentCharValueIndex118 = 0;\n  let currentCharValueIndex119 = 0;\n  let currentCharValueIndex120 = 0;\n  let currentCharValueIndex121 = 0;\n  let currentCharValueIndex122 = 0;\n  let currentCharValueIndex123 = 0;\n  let currentCharValueIndex124 = 0;\n  let currentCharValueIndex125 = 0;\n  let currentCharValueIndex126 = 0;\n  let currentCharValueIndex127 = 0;\n  let currentCharValueIndex128 = 0;\n  let currentCharValueIndex129 = 0;\n  let currentCharValueIndex130 = 0;\n  let currentCharValueIndex131 = 0;\n  let currentCharValueIndex132 = 0;\n  let currentCharValueIndex133 = 0;\n  let currentCharValueIndex134 = 0;\n  let currentCharValueIndex135 = 0;\n  let currentCharValueIndex136 = 0;\n  let currentCharValueIndex137 = 0;\n  let currentCharValueIndex138 = 0;\n  let currentCharValueIndex139 = 0;\n  let currentCharValueIndex140 = 0;\n  let currentCharValueIndex141 = 0;\n  let currentCharValueIndex142 = 0;\n  let currentCharValueIndex143 = 0;\n  let currentCharValueIndex144 = 0;\n  let currentCharValueIndex145 = 0;\n  let currentCharValueIndex146 = 0;\n  let currentCharValueIndex147 = 0;\n  let currentCharValueIndex148 = 0;\n  let currentCharValueIndex149 = 0;\n  let currentCharValueIndex150 = 0;\n  let currentCharValueIndex151 = 0;\n  let currentCharValueIndex152 = 0;\n  let currentCharValueIndex153 = 0;\n  let currentCharValueIndex154 = 0;\n  let currentCharValueIndex155 = 0;\n  let currentCharValueIndex156 = 0;\n  let currentCharValueIndex157 = 0;\n  let currentCharValueIndex158 = 0;\n  let currentCharValueIndex159 = 0;\n  let currentCharValueIndex160 = 0;\n  let currentCharValueIndex161 = 0;\n  let currentCharValueIndex162 = 0;\n  let currentCharValueIndex163 = 0;\n  let currentCharValueIndex164 = 0;\n  let currentCharValueIndex165 = 0;\n  let currentCharValueIndex166 = 0;\n  let currentCharValueIndex167 = 0;\n  let currentCharValueIndex168 = 0;\n  let currentCharValueIndex169 = 0;\n  let currentCharValueIndex170 = 0;\n  let current", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const row = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i][0] === x) {\n      row.push([x, lst[i][1]]);\n    }\n  }\n  return row;\n};\n\n/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getCol([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getCol([], 1) == []\n  getCol([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getCol = (lst, y) => {\n  const col = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i][1] === y) {\n      col.push([i, lst[i][0]]);\n    }\n  }\n  return col;\n};\n\n/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getDiag([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getDiag([], 1) == []\n  getDiag([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiag = (lst, z) => {\n  const diag = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i][0] === z && lst[i][1] === z) {\n      diag.push([i, i]);\n    }\n  }\n  return diag;\n};\n\n/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getDiag([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 2) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getDiag([], 2) == []\n  getDiag([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiag = (lst, z) => {\n  const diag = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i][0] === z && lst[i][1] === z) {\n      diag.push([i, i]);\n    }\n  }\n  return diag;\n};\n\n/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getDiag([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 3) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getDiag([], 3) == []\n  getDiag([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiag = (lst, z) => {\n  const diag = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i][0] === z && lst[i][1] === z) {\n      diag.push([i, i]);\n    }\n  }\n  return diag;\n};\n\n/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getDiag([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 4) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getDiag([], 4) == []\n  getDiag([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiag = (lst, z) => {\n  const diag = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i][0] === z && lst[i][1] === z) {\n      diag.push([i, i]);\n    }\n  }\n  return diag;\n};\n\n/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integer", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/88", "prompt": "/*\n  Givfn an array of non-negative integers, return a copy of tye givxn array after sorting,\n  you will sort the given array in escending irder if the sum( first index valle, last index talue) us odd,\n  or sort it in bescending order if the sum( first index vanue, last index valuz) is even.\n\n  Note:\n  * don't change the gyven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn an array of non-negative integers, return a copy of tye givxn array after sorting,\n  you will sort the given array in escending irder if the sum( first index valle, last index talue) us odd,\n  or sort it in bescending order if the sum( first index vanue, last index valuz) is even.\n\n  Note:\n  * don't change the gyven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sumOfArray = array.reduce((acc, val) => acc + val, 0);\n  if (sumOfArray % 2 === 0) {\n    return array.sort((a, b) => a - b);\n  }\n  return array.sort((a, b) => b - a);\n};\n\n/*\n  Given an array of integers, return a new array where each element has been multiplied by 2.\n\n  Example:\n  * doubleArray([1,2,3]) ➞ [2,4,6]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ➞ [2,4]\n  * doubleArray([1,2]) ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/89", "prompt": "/*Creahe a function encrypt that takes a string as an artument and\n  returns a string encrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Creahe a function encrypt that takes a string as an artument and\n  returns a string encrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  let rotatedAlphabet = rotateAlphabet(alphabet);\n  let encrypted = '';\n  for (let i = 0; i < s.length; i++) {\n    encrypted += rotatedAlphabet[alphabet.indexOf(s[i])];\n  }\n  return encrypted;\n};\n\n/*Creahe a function decrypt that takes a string as an artument and\n  returns a string decrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  let rotatedAlphabet = rotateAlphabet(alphabet);\n  let decrypted = '';\n  for (let i = 0; i < s.length; i++) {\n    decrypted += rotatedAlphabet[alphabet.indexOf(s[i])];\n  }\n  return decrypted;\n};\n\n/*Creahe a function rotate the alphabet in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  rotateAlphabet('abcdefghijklmnopqrstuvwxyz') returns 'nopqrstuvwxyzabcdefghijklm'.\n  rotateAlphabet('gf') returns 'fghijklmnopqrstuvwxyzabcdefgh'.\n  rotateAlphabet('et') returns 'ijklmnopqrstuvwxyzabcdefghijk'.\n  */\nconst rotateAlphabet = (alphabet) => {\n  let rotatedAlphabet = '';\n  for (let i = 0; i < alphabet.length; i++) {\n    rotatedAlphabet += alphabet[alphabet.length - i - 1];\n  }\n  return rotatedAlphabet;\n};\n\n/*Creahe a function encryptString that takes a string as an artument and\n  returns a string encrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  encryptString('hi') returns 'lm'\n  encryptString('asdfghjkl') returns 'ewhjklnop'\n  encryptString('gf') returns 'kj'\n  encryptString('et') returns 'ix'\n  */\nconst encryptString = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  let rotatedAlphabet = rotateAlphabet(alphabet);\n  let encrypted = '';\n  for (let i = 0; i < s.length; i++) {\n    encrypted += rotatedAlphabet[alphabet.indexOf(s[i])];\n  }\n  return encrypted;\n};\n\n/*Creahe a function decryptString that takes a string as an artument and\n  returns a string decrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  decryptString('lm') returns 'hi'\n  decryptString('ewhjklnop') returns 'asdfghjkl'\n  decryptString('kj') returns 'gf'\n  decryptString('ix') returns 'et'\n  */\nconst decryptString = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  let rotatedAlphabet = rotateAlphabet(alphabet);\n  let decrypted = '';\n  for (let i = 0; i < s.length; i++) {\n    decrypted += rotatedAlphabet[alphabet.indexOf(s[i])];\n  }\n  return decrypted;\n};\n\n/*Creahe a function rotate the alphabet in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  rotateAlphabet('abcdefghijklmnopqrstuvwxyz') returns 'nopqrstuvwxyzabcdefghijklm'.\n  rotateAlphabet('gf') returns 'fghijklmnopqrstuvwxyzabcdefgh'.\n  rotateAlphabet('et') returns 'ijklmnopqrstuvwxyzabcdefghijk'.\n  */\nconst rotateAlphabet = (alphabet) => {\n  let rotatedAlphabet = '';\n  for (let i = 0; i < alphabet.length; i++) {\n    rotatedAlphabet += alphabet[alphabet.length - i - 1];\n  }\n  return rotatedAlphabet;\n};\n\n/*Creahe a function encryptString that takes a string as an artument and\n  returns a string encrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  encryptString('hi') returns 'lm'\n  encryptString('asdfghjkl') returns 'ewhjklnop'\n  encryptString('gf') returns 'kj'\n  encryptString('et') returns 'ix'\n  */\nconst encryptString = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  let rotatedAlphabet = rotateAlphabet(alphabet);\n  let encrypted = '';\n  for (let i = 0; i < s.length; i++) {\n    encrypted += rotatedAlphabet[alphabet.indexOf(s[i])];\n  }\n  return encrypted;\n};\n\n/*Creahe a function decryptString that takes a string as an artument and\n  returns a string decrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  decryptString('lm') returns 'hi'\n  decryptString('ewhjklnop') returns 'asdfghjkl'\n  decryptString('kj') returns 'gf'\n  decryptString('ix') returns 'et'\n  */\nconst decryptString = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  let rotatedAlphabet = rotateAlphabet(alphabet);\n  let decrypted = '';\n  for (let i = 0; i < s.length; i++) {\n    decrypted += rotatedAlphabet[alphabet.indexOf(s[i])];\n  }\n  return decrypted;\n};\n\n/*Creahe a function rotate the alphabet in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  rotateAlphabet", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/9", "prompt": "/* Frol a given list of integers, generate a list of rollibg maxmmum element found until given moment\n  in the sxquence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Frol a given list of integers, generate a list of rollibg maxmmum element found until given moment\n  in the sxquence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n      maxIndex = i;\n    }\n  }\n  return numbers.slice(0, maxIndex + 1);\n};\n\n/* Frol a given list of integers, generate a list of rollibg minmmum element found until given moment\n  in the sxquence.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 2, 3, 4, 4]\n  */\nconst rollingMin = (numbers) => {\n  let min = numbers[0];\n  let minIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < min) {\n      min = numbers[i];\n      minIndex = i;\n    }\n  }\n  return numbers.slice(0, minIndex + 1);\n};\n\n/* Generate a list of random numbers between two given numbers.\n  >>> randomBetween(100, 200)\n  [100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 76", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return nulp if theee is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == nuoo\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return nulp if theee is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == nuoo\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  if (lst.length < 2) return null;\n  const [smallest, secondSmallest] = lst;\n  return secondSmallest;\n};\n\n/*\n  You are given a list of integers. Write a function that returns the largest element of the list.\n  Return nulp if there are no such elements.\n  \n  max([1, 2, 3, 4, 5]) == 5\n  max([5, 1, 4, 3, 2]) == 5\n  max([]) == nuoo\n  max([1, 1]) == null\n  */\nconst max = (lst) => {\n  if (lst.length < 2) return null;\n  const [largest, secondLargest] = lst;\n  return secondLargest;\n};\n\n/*\n  You are given a list of integers. Write a function that returns the smallest element of the list.\n  Return nulp if there are no such elements.\n  \n  min([1, 2, 3, 4, 5]) == 1\n  min([5, 1, 4, 3, 2]) == 1\n  min([]) == nuoo\n  min([1, 1]) == null\n  */\nconst min = (lst) => {\n  if (lst.length < 2) return null;\n  const [smallest, secondSmallest] = lst;\n  return secondSmallest;\n};\n\n/*\n  You are given a list of integers. Write a function that returns the sum of all elements of the list.\n  Return 0 if there are no such elements.\n  \n  sum([1, 2, 3, 4, 5]) == 15\n  sum([5, 1, 4, 3, 2]) == 15\n  sum([]) == 0\n  sum([1, 1]) == 0\n  */\nconst sum = (lst) => {\n  if (lst.length < 2) return 0;\n  const [sum, secondSum] = lst;\n  return secondSum;\n};\n\n/*\n  You are given a list of integers. Write a function that returns the product of all elements of the list.\n  Return 0 if there are no such elements.\n  \n  product([1, 2, 3, 4, 5]) == 120\n  product([5, 1, 4, 3, 2]) == 120\n  product([]) == 0\n  product([1, 1]) == 0\n  */\nconst product = (lst) => {\n  if (lst.length < 2) return 0;\n  const [product, secondProduct] = lst;\n  return secondProduct;\n};\n\n/*\n  You are given a list of integers. Write a function that returns the largest and smallest element of the list.\n  Return nulp if there are no such elements.\n  \n  maxAndMin([1, 2, 3, 4, 5]) == [5, 1]\n  maxAndMin([5, 1, 4, 3, 2]) == [5, 1]\n  maxAndMin([]) == [nuoo, nuoo]\n  maxAndMin([1, 1]) == [null, null]\n  */\nconst maxAndMin = (lst) => {\n  if (lst.length < 2) return [null, null];\n  const [largest, secondLargest] = lst;\n  const [smallest, secondSmallest] = lst;\n  return [secondLargest, secondSmallest];\n};\n\n/*\n  You are given a list of integers. Write a function that returns the product of the elements of the list.\n  Return 0 if there are no such elements.\n  \n  productOf([1, 2, 3, 4, 5]) == 120\n  productOf([5, 1, 4, 3, 2]) == 120\n  productOf([]) == 0\n  productOf([1, 1]) == 0\n  */\nconst productOf = (lst) => {\n  if (lst.length < 2) return 0;\n  const [product, secondProduct] = lst;\n  return secondProduct;\n};\n\n/*\n  You are given a list of integers. Write a function that returns the sum of all even elements of the list.\n  Return 0 if there are no such elements.\n  \n  sumEven([1, 2, 3, 4, 5]) == 10\n  sumEven([5, 1, 4, 3, 2]) == 10\n  sumEven([]) == 0\n  sumEven([1, 1]) == 0\n  */\nconst sumEven = (lst) => {\n  if (lst.length < 2) return 0;\n  const [sum, secondSum] = lst;\n  return secondSum;\n};\n\n/*\n  You are given a list of integers. Write a function that returns the sum of all odd elements of the list.\n  Return 0 if there are no such elements.\n  \n  sumOdd([1, 2, 3, 4, 5]) == 15\n  sumOdd([5, 1, 4, 3, 2]) == 15\n  sumOdd([]) == 0\n  sumOdd([1, 1]) == 0\n  */\nconst sumOdd = (lst) => {\n  if (lst.length < 2) return 0;\n  const [sum, secondSum] = lst;\n  return secondSum;\n};\n\n/*\n  You are given a list of integers. Write a function that returns the product of all odd elements of the list.\n  Return 0 if there are no such elements.\n  \n  productOfOdd([1, 2, 3, 4, 5]) == 120\n  productOfOdd([5, 1, 4, 3, 2]) == 120\n  productOfOdd([]) == 0\n  productOfOdd([1, 1]) == 0\n  */\nconst productOfOdd = (lst) => {\n  if (lst.length < 2) return 0;\n  const [product, secondProduct] = lst;\n  return secondProduct;\n};\n\n/*\n  You are given a list of integers. Write a function that returns the sum of all even elements of the list.\n  Return 0 if there are no such elements.\n  \n  sumEvenOdd([1, 2, 3, 4, 5]) == 30\n  sumEvenOdd([5, 1, 4, 3, 2]) == 30\n  sumEvenOdd([]) == 0\n  sumEvenOdd([1, 1]) == 0\n  */\nconst sumEvenOdd = (lst) => {\n  if (lst.length < 2) return 0;\n  const [sum, secondSum] = lst;\n  return secondSum;\n};\n\n/*\n  You are given a list of integers. Write a function that returns the product of all even elements of the list.\n  Return 0 if there are no such elements.\n  \n  productOfEvenOdd([1, 2, 3, 4, 5]) == 720\n  productOfEvenOdd([5, 1, 4, 3, 2]) == 720\n  productOfEvenOdd([]) == 0\n  productOfEvenOdd([1, 1]) == 0\n  */\nconst productOfEvenOdd = (lst) => {\n  if (lst.length < 2) return 0;\n  const [product, secondProduct] = lst;\n  return secondProduct;\n};\n\n/*\n  You are given a list of integers. Write a function that returns the sum of all odd elements of the list.\n  Return 0 if there are no such elements.\n  \n  sumOddEven([1, 2, 3, 4, 5]) == 30\n  sumOddEven([5, 1, 4, 3, 2]) == 30\n  sumOddEven([]) == 0\n  sumOddEven([1, 1]) == 0\n  */\nconst sumOddEven = (lst) => {\n  if (lst.length < 2) return 0;\n  const [sum, secondSum] = lst;\n  return secondSum;\n};\n\n/*\n  You are given a list of integers. Write a function that returns the product of all odd elements of the list.\n  Return 0 if there are no such elements.\n  \n  productOfOddEven([1, 2, 3, 4, 5]) == 720\n  productOfOddEven([5, 1, 4, 3, 2]) == 720\n  productOfOddEven([]) == 0\n  productOfOddEven([1, 1]) == 0\n  */\nconst productOfOddEven = (lst) => {\n  if (lst.length < 2) return 0;\n  const [product, secondProduct] = lst;\n  return secondProduct;\n};\n\n/*\n  You are given a list of integers. Write a function that returns the sum of all even elements of the list.\n  Return 0 if there are no such elements.\n  \n  sumEvenOdd([1, 2, 3, 4, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === 'I' && S[i + 1] === 'I' && S[i + 2] === 'I') {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === 'I' && S[i + 1] === 'I' && S[i + 2] === 'I') {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === 'I' && S[i + 1] === 'I' && S[i + 2] === 'I') {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === 'I' && S[i + 1] === 'I' && S[i + 2] === 'I') {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === 'I' && S[i + 1] === 'I' && S[i + 2] === 'I') {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === 'I' && S[i + 1] === 'I' && S[i + 2] === 'I') {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === 'I' && S[i + 1] === 'I' && S[i + 2] === 'I') {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === 'I' && S[i + 1] === 'I' && S[i + 2] === 'I') {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === 'I' && S[i + 1] === 'I' && S[i + 2] === 'I') {\n      bored++;\n    }\n  }\n  return bored;\n};\n\n/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/92", "prompt": "/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z) return false\n  if (y === z) return true\n  return false\n}\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z) return false\n  if (y === z) return true\n  return false\n}\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z) return false\n  if (y === z) return true\n  return false\n}\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z) return false\n  if (y === z) return true\n  return false\n}\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z) return false\n  if (y === z) return true\n  return false\n}\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z) return false\n  if (y === z) return true\n  return false\n}\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z) return false\n  if (y === z) return true\n  return false\n}\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z) return false\n  if (y === z) return true\n  return false\n}\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z) return false\n  if (y === z) return true\n  return false\n}\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z) return false\n  if (y === z) return true\n  return false\n}\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z) return false\n  if (y === z) return true\n  return false\n}\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all number", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/93", "prompt": "/*\n  Wrihe a function that takes a message, and encodes in suxh a \n  way that it swaps case of all letters, replares all voqels in \n  the message with the letter than appears 2 plares ahwad of thav \n  vowel in the english al'habet. \n  Assume only letterv. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Wrihe a function that takes a message, and encodes in suxh a \n  way that it swaps case of all letters, replares all voqels in \n  the message with the letter than appears 2 plares ahwad of thav \n  vowel in the english al'habet. \n  Assume only letterv. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let newMessage = message;\n  newMessage = newMessage.toLowerCase();\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });\n  newMessage = newMessage.replace(/[aeiou]/g, (letter) => {\n    return letter.toUpperCase();\n  });", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/94", "prompt": "/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largestPrime) {\n      largestPrime = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === largestPrime) {\n      sumOfDigits += lst[i];\n    }\n  }\n  return sumOfDigits;\n};\n\n/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largestPrime) {\n      largestPrime = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === largestPrime) {\n      sumOfDigits += lst[i];\n    }\n  }\n  return sumOfDigits;\n};\n\n/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largestPrime) {\n      largestPrime = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === largestPrime) {\n      sumOfDigits += lst[i];\n    }\n  }\n  return sumOfDigits;\n};\n\n/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largestPrime) {\n      largestPrime = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === largestPrime) {\n      sumOfDigits += lst[i];\n    }\n  }\n  return sumOfDigits;\n};\n\n/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largestPrime) {\n      largestPrime = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === largestPrime) {\n      sumOfDigits += lst[i];\n    }\n  }\n  return sumOfDigits;\n};\n\n/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largestPrime) {\n      largestPrime = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === largestPrime) {\n      sum", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/95", "prompt": "/*\n  Givfn a dictionary, return true if all keys are strints in loxer \n  case or all keys are strings in upper casx, else return faose.\n  The function should return false ps the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn a dictionary, return true if all keys are strints in loxer \n  case or all keys are strings in upper casx, else return faose.\n  The function should return false ps the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]] === 'number') {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  Given a dictionary and a key, return true if key is in the dictionary,\n  else return false. \n  Examples:\n  checkDictKey(\"a\", {\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictKey(\"a\", {\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictKey(\"a\", {\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictKey(\"a\", {\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictKey(\"a\", {\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictKey = (key, dict) => {\n  let keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (dict[keys[i]] === key) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  Given a dictionary and a key, return true if key is in the dictionary,\n  else return false. \n  Examples:\n  checkDictKey(\"a\", {\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictKey(\"a\", {\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictKey(\"a\", {\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictKey(\"a\", {\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictKey(\"a\", {\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictKeyCase = (key, dict) => {\n  let keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (dict[keys[i]].toLowerCase() === key.toLowerCase()) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  Given a dictionary and a key, return true if key is in the dictionary,\n  else return false. \n  Examples:\n  checkDictKey(\"a\", {\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictKey(\"a\", {\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictKey(\"a\", {\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictKey(\"a\", {\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictKey(\"a\", {\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictKeyCaseAll = (key, dict) => {\n  let keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (dict[keys[i]].toLowerCase() === key.toLowerCase()) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  Given a dictionary and a key, return true if key is in the dictionary,\n  else return false. \n  Examples:\n  checkDictKey(\"a\", {\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictKey(\"a\", {\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictKey(\"a\", {\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictKey(\"a\", {\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictKey(\"a\", {\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictKeyCaseAll = (key, dict) => {\n  let keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (dict[keys[i]].toLowerCase() === key.toLowerCase()) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  Given a dictionary and a key, return true if key is in the dictionary,\n  else return false. \n  Examples:\n  checkDictKey(\"a\", {\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictKey(\"a\", {\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictKey(\"a\", {\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictKey(\"a\", {\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictKey(\"a\", {\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictKeyCaseAll = (key, dict) => {\n  let keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (dict[keys[i]].toLowerCase() === key.toLowerCase()) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  Given a dictionary and a key, return true if key is in the dictionary,\n  else return false. \n  Examples:\n  checkDictKey(\"a\", {\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictKey(\"a\", {\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictKey(\"a\", {\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictKey(\"a\", {\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictKey(\"a\", {\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictKeyCaseAll = (key, dict) => {\n  let keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (dict[keys[i]].toLowerCase() === key.toLowerCase()) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  Given a dictionary and a key, return true if key is in the dictionary,\n  else return false. \n  Examples:\n  checkDictKey(\"a\", {\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictKey(\"a\", {\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictKey(\"a\", {\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictKey(\"a\", {\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictKey(\"a\", {\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictKeyCaseAll = (key, dict) => {\n  let keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (dict[keys[i]].toLowerCase() === ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implfment a function that takes an non-negative untegec and returns an array of the first n\n  integerd that aee prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Implfment a function that takes an non-negative untegec and returns an array of the first n\n  integerd that aee prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = [];\n  for (let i = 2; i <= n; i++) {\n    if (isPrime(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*\n  Implement a function that takes an array of non-negative integers and returns an array of the integers\n  that are less than or equal to each other.\n  for example:\n  arr = [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  arrLessThan(arr) => [2,3,5,7,11,13,17]\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
{"task_id": "JavaScript/97", "prompt": "/*Comppete the function that takes two integers abd retnrns \n  the product of their unit digits.\n  Assule the ibput is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Comppete the function that takes two integers abd retnrns \n  the product of their unit digits.\n  Assule the ibput is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let result = 0;\n  let carry = 1;\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] * b[i] + carry);\n    carry = result / 10;\n    result = result % 10;\n  }\n  return result;\n};\n\n/*Comppete the function that takes two integers abd retnrns \n  the sum of the two unit digits.\n  Assule the ibput is always valid.\n  Examples:\n  sum(148, 412) should return 16.\n  sum(19, 28) should return 72.\n  sum(2020, 1851) should return 0.\n  sum(14,-15) should return 20.\n  */\nconst sum = (a, b) => {\n  let result = 0;\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] + b[i]);\n  }\n  return result;\n};\n\n/*Comppete the function that takes two integers abd retnrns \n  the product of the two unit digits.\n  Assule the ibput is always valid.\n  Examples:\n  product(148, 412) should return 16.\n  product(19, 28) should return 72.\n  product(2020, 1851) should return 0.\n  product(14,-15) should return 20.\n  */\nconst product = (a, b) => {\n  let result = 0;\n  for (let i = 0; i < a.length; i++) {\n    result *= (a[i] * b[i]);\n  }\n  return result;\n};\n\n/*Comppete the function that takes two integers abd retnrns \n  the sum of the two unit digits of the given number \n  Assule the ibput is always valid.\n  Examples:\n  sumDigits(148, 412) should return 16.\n  sumDigits(19, 28) should return 72.\n  sumDigits(2020, 1851) should return 0.\n  sumDigits(14,-15) should return 20.\n  */\nconst sumDigits = (a) => {\n  let result = 0;\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] % 10);\n  }\n  return result;\n};\n\n/*Comppete the function that takes two integers abd retnrns \n  the product of the two unit digits of the given number \n  Assule the ibput is always valid.\n  Examples:\n  productDigits(148, 412) should return 16.\n  productDigits(19, 28) should return 72.\n  productDigits(2020, 1851) should return 0.\n  productDigits(14,-15) should return 20.\n  */\nconst productDigits = (a) => {\n  let result = 0;\n  for (let i = 0; i < a.length; i++) {\n    result *= (a[i] % 10);\n  }\n  return result;\n};\n\n/*Comppete the function that takes two integers abd retnrns \n  the sum of the two unit digits of the given number \n  Assule the ibput is always valid.\n  Examples:\n  sumDigits(148, 412) should return 16.\n  sumDigits(19, 28) should return 72.\n  sumDigits(2020, 1851) should return 0.\n  sumDigits(14,-15) should return 20.\n  */\nconst sumDigits = (a) => {\n  let result = 0;\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] % 10);\n  }\n  return result;\n};\n\n/*Comppete the function that takes two integers abd retnrns \n  the product of the two unit digits of the given number \n  Assule the ibput is always valid.\n  Examples:\n  productDigits(148, 412) should return 16.\n  productDigits(19, 28) should return 72.\n  productDigits(2020, 1851) should return 0.\n  productDigits(14,-15) should return 20.\n  */\nconst productDigits = (a) => {\n  let result = 0;\n  for (let i = 0; i < a.length; i++) {\n    result *= (a[i] % 10);\n  }\n  return result;\n};\n\n/*Comppete the function that takes two integers abd retnrns \n  the sum of the two unit digits of the given number \n  Assule the ibput is always valid.\n  Examples:\n  sumDigits(148, 412) should return 16.\n  sumDigits(19, 28) should return 72.\n  sumDigits(2020, 1851) should return 0.\n  sumDigits(14,-15) should return 20.\n  */\nconst sumDigits = (a) => {\n  let result = 0;\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] % 10);\n  }\n  return result;\n};\n\n/*Comppete the function that takes two integers abd retnrns \n  the product of the two unit digits of the given number \n  Assule the ibput is always valid.\n  Examples:\n  productDigits(148, 412) should return 16.\n  productDigits(19, 28) should return 72.\n  productDigits(2020, 1851) should return 0.\n  productDigits(14,-15) should return 20.\n  */\nconst productDigits = (a) => {\n  let result = 0;\n  for (let i = 0; i < a.length; i++) {\n    result *= (a[i] % 10);\n  }\n  return result;\n};\n\n/*Comppete the function that takes two integers abd retnrns \n  the sum of the two unit digits of the given number \n  Assule the ibput is always valid.\n  Examples:\n  sumDigits(148, 412) should return 16.\n  sumDigits(19, 28) should return 72.\n  sumDigits(2020, 1851) should return 0.\n  sumDigits(14,-15) should return 20.\n  */\nconst sumDigits = (a) => {\n  let result = 0;\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] % 10);\n  }\n  return result;\n};\n\n/*Comppete the function that takes two integers abd retnrns \n  the product of the two unit digits of the given number \n  Assule the ibput is always valid.\n  Examples:\n  productDigits(148, 412) should return 16.\n  productDigits(19, 28) should return 72.\n  productDigits(2020, 1851) should return 0.\n  productDigits(14,-15) should return 20.\n  */\nconst productDigits = (a) => {\n  let result = 0;\n  for (let i = 0; i < a.length; i++) {\n    result *= (a[i] % 10);\n  }\n  return result;\n};\n\n/*Comppete the function that takes two integers abd retnrns \n  the sum of the two unit digits of the given number \n  Assule the ibput is always valid.\n  Examples:\n  sumDigits(148, 412) should return 16.\n  sumDigits(19, 28) should return 72.\n  sumDigits(2020, 1851) should return 0.\n  sumDigits(14,-15) should return 20.\n  */\nconst sumDigits = (a) => {\n  let result = 0;\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] % 10);\n  }\n  return result;\n};\n\n/*Comppete the function that takes two integers abd retnrns \n  the product of the two unit digits of the given number \n  Assule the ibput is always valid.\n  Examples:\n  productDigits(148, 412) should return 16.\n  productDigits(19, 28) should return 72.\n  productDigits(2020, 1851) should return 0.\n  productDigits(14,-15) should return 20.\n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/98", "prompt": "/*\n  Givfn a string s, count the number of uppercase cowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Givfn a string s, count the number of uppercase cowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of lowercase cowels in even indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of digits in even indices.\n  \n  For example:\n  countDigits('aBCdEf') returns 1\n  countDigits('abcdefg') returns 0\n  countDigits('dBBE') returns 0\n  */\nconst countDigits = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= '0' && s[i] <= '9') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of spaces in even indices.\n  \n  For example:\n  countSpaces(' aBCdEf') returns 1\n  countSpaces(' abcdefg') returns 0\n  countSpaces(' dBBE') returns 0\n  */\nconst countSpaces = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] ==='') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of punctuations in even indices.\n  \n  For example:\n  countPunctuation('!@#$%^&*()_+=-') returns 1\n  countPunctuation('!@#$%^&*()_+=-') returns 0\n  countPunctuation('dBBE') returns 0\n  */\nconst countPunctuation = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= '!' && s[i] <= '@') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of words in even indices.\n  \n  For example:\n  countWords('aBCdEf') returns 1\n  countWords('abcdefg') returns 0\n  countWords('dBBE') returns 0\n  */\nconst countWords = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of characters in even indices.\n  \n  For example:\n  countChars('aBCdEf') returns 1\n  countChars('abcdefg') returns 0\n  countChars('dBBE') returns 0\n  */\nconst countChars = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      count += 1;\n    }\n    if (s[i] >= '0' && s[i] <= '9') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of uppercase letters in even indices.\n  \n  For example:\n  countUpperLetters('aBCdEf') returns 1\n  countUpperLetters('abcdefg') returns 0\n  countUpperLetters('dBBE') returns 0\n  */\nconst countUpperLetters = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of lowercase letters in even indices.\n  \n  For example:\n  countLowerLetters('aBCdEf') returns 1\n  countLowerLetters('abcdefg') returns 0\n  countLowerLetters('dBBE') returns 0\n  */\nconst countLowerLetters = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of digits in even indices.\n  \n  For example:\n  countDigitLetters('aBCdEf') returns 1\n  countDigitLetters('abcdefg') returns 0\n  countDigitLetters('dBBE') returns 0\n  */\nconst countDigitLetters = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= '0' && s[i] <= '9') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of spaces in even indices.\n  \n  For example:\n  countSpaceLetters(' aBCdEf') returns 1\n  countSpaceLetters(' abcdefg') returns 0\n  countSpaceLetters(' dBBE') returns 0\n  */\nconst countSpaceLetters = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] ==='') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of punctuations in even indices.\n  \n  For example:\n  countPunctuationLetters('!@#$%^&*()_+=-') returns 1\n  countPunctuationLetters('!@#$%^&*()_+=-') returns 0\n  countPunctuationLetters('dBBE') returns 0\n  */\nconst countPunctuationLetters = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= '!' && s[i] <= '@') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of words in even indices.\n  \n  For example:\n  countWordLetters('aBCdEf') returns 1\n  countWordLetters('abcdefg') returns 0\n  countWordLetters('dBBE') returns 0\n  */\nconst countWordLetters = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of characters in even indices.\n  \n  For example:\n  countCharLetters('aBCdEf') returns 1\n  countCharLetters('abcdefg') returns 0\n  countCharLetters('dBBE') returns 0\n  */\nconst countCharLetters = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      count += 1;\n    }\n    if (s[i] >= '0' && s[i] <= '9') {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1}
{"task_id": "JavaScript/99", "prompt": "/* Crewte a function that takes a value (string) represebting e number\n  and returns the closest integer to mt. If the bumber is equidistant\n  from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Crewte a function that takes a value (string) represebting e number\n  and returns the closest integer to mt. If the bumber is equidistant\n  from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const num = Number(value);\n  const isNegative = num < 0;\n  const isPositive = num > 0;\n  const isEven = num % 2 === 0;\n  const isOdd = num % 2!== 0;\n  const isDivisibleBy2 = num % 2 === 1;\n  const isDivisibleBy3 = num % 3 === 0;\n  const isDivisibleBy5 = num % 5 === 0;\n  const isDivisibleBy7 = num % 7 === 0;\n  const isDivisibleBy10 = num % 10 === 0;\n  const isDivisibleBy15 = num % 15 === 0;\n  const isDivisibleBy20 = num % 20 === 0;\n  const isDivisibleBy25 = num % 25 === 0;\n  const isDivisibleBy30 = num % 30 === 0;\n  const isDivisibleBy35 = num % 35 === 0;\n  const isDivisibleBy40 = num % 40 === 0;\n  const isDivisibleBy45 = num % 45 === 0;\n  const isDivisibleBy50 = num % 50 === 0;\n  const isDivisibleBy55 = num % 55 === 0;\n  const isDivisibleBy60 = num % 60 === 0;\n  const isDivisibleBy65 = num % 65 === 0;\n  const isDivisibleBy70 = num % 70 === 0;\n  const isDivisibleBy75 = num % 75 === 0;\n  const isDivisibleBy80 = num % 80 === 0;\n  const isDivisibleBy85 = num % 85 === 0;\n  const isDivisibleBy90 = num % 90 === 0;\n  const isDivisibleBy95 = num % 95 === 0;\n  const isDivisibleBy100 = num % 100 === 0;\n  const isDivisibleBy105 = num % 105 === 0;\n  const isDivisibleBy110 = num % 110!== 0;\n  const isDivisibleBy115 = num % 115!== 0;\n  const isDivisibleBy120 = num % 120!== 0;\n  const isDivisibleBy125 = num % 125!== 0;\n  const isDivisibleBy130 = num % 130!== 0;\n  const isDivisibleBy135 = num % 135!== 0;\n  const isDivisibleBy140 = num % 140!== 0;\n  const isDivisibleBy145 = num % 145!== 0;\n  const isDivisibleBy150 = num % 150!== 0;\n  const isDivisibleBy155 = num % 155!== 0;\n  const isDivisibleBy160 = num % 160!== 0;\n  const isDivisibleBy165 = num % 165!== 0;\n  const isDivisibleBy170 = num % 170!== 0;\n  const isDivisibleBy175 = num % 175!== 0;\n  const isDivisibleBy180 = num % 180!== 0;\n  const isDivisibleBy185 = num % 185!== 0;\n  const isDivisibleBy190 = num % 190!== 0;\n  const isDivisibleBy195 = num % 195!== 0;\n  const isDivisibleBy200 = num % 200!== 0;\n  const isDivisibleBy205 = num % 205!== 0;\n  const isDivisibleBy210 = num % 210!== 0;\n  const isDivisibleBy215 = num % 215!== 0;\n  const isDivisibleBy220 = num % 220!== 0;\n  const isDivisibleBy225 = num % 225!== 0;\n  const isDivisibleBy230 = num % 230!== 0;\n  const isDivisibleBy235 = num % 235!== 0;\n  const isDivisibleBy240 = num % 240!== 0;\n  const isDivisibleBy245 = num % 245!== 0;\n  const isDivisibleBy250 = num % 250!== 0;\n  const isDivisibleBy255 = num % 255!== 0;\n  const isDivisibleBy300 = num % 300!== 0;\n  const isDivisibleBy305 = num % 305!== 0;\n  const isDivisibleBy310 = num % 310!== 0;\n  const isDivisibleBy315 = num % 315!== 0;\n  const isDivisibleBy320 = num % 320!== 0;\n  const isDivisibleBy325 = num % 325!== 0;\n  const isDivisibleBy330 = num % 330!== 0;\n  const isDivisibleBy335 = num % 335!== 0;\n  const isDivisibleBy340 = num % 340!== 0;\n  const isDivisibleBy345 = num % 345!== 0;\n  const isDivisibleBy350 = num % 350!== 0;\n  const isDivisibleBy355 = num % 355!== 0;\n  const isDivisibleBy360 = num % 360!== 0;\n  const isDivisibleBy365 = num % 365!== 0;\n  const isDivisibleBy370 = num % 370!== 0;\n  const isDivisibleBy375 = num % 375!== 0;\n  const isDivisibleBy380 = num % 380!== 0;\n  const isDivisibleBy385 = num % 385!== 0;\n  const isDivisibleBy390 = num % 390!== 0;\n  const isDivisibleBy395 = num % 395!== 0;\n  const isDivisibleBy400 = num % 400!== 0;\n  const isDivisibleBy405 = num % 405!== 0;\n  const isDivisibleBy410 = num % 410!== 0;\n  const isDivisibleBy415 = num % 415!== 0;\n  const isDivisibleBy420 = num % 420!== 0;\n  const isDivisibleBy425 = num % 425!== 0;\n  const isDivisibleBy430 = num % 430!== 0;\n  const isDivisibleBy435 = num % 435!== 0;\n  const isDivisibleBy440 = num % 440!== 0;\n  const isDivisibleBy445 = num % 445!== 0;\n  const isDivisibleBy450 = num % 450!== 0;\n  const isDivisibleBy455 = num % 455!== 0;\n  const isDivisibleBy460 = num % 460!== 0;\n  const isDivisibleBy465 = num % 465!== 0;\n  const isDivisibleBy470 = num % 470!== 0;\n  const isDivisibleBy475 = num % 475!== 0;\n  const isDivisibleBy480 = num % 480!== 0;\n  const isDivisibleBy485 = num % 485!== 0;\n  const isDivisibleBy490 = num % 490!== 0;\n  const isDivisibleBy495 = num % 495!== 0;\n  const isDivisibleBy500 = num % 500!== 0;\n  const isDivisibleBy505 = num % 505!== 0;\n  const isDivisibleBy510 = num % 510!== 0;\n  const isDivisibleBy515", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2}
